1
00:00:00,080 --> 00:00:05,520
欢迎来到这个 CUDA 编程课程

2
00:00:02,840 --> 00:00:08,200
在那里你将学习如何利用图形处理器（GPU）

3
00:00:05,520 --> 00:00:10,599
对于高性能计算，那个（这里“the”单独使用表意不明确，需结合完整语境理解）

4
00:00:08,200 --> 00:00:13,639
课程从对……的概述开始

5
00:00:10,599 --> 00:00:16,160
深度学习生态系统并为你提供指导

6
00:00:13,639 --> 00:00:19,039
通过设置CUDA并回顾

7
00:00:16,160 --> 00:00:21,439
你将学习的重要 C 和 C++ 概念

8
00:00:19,039 --> 00:00:24,279
探索GPU架构并写下你的（内容） 

9
00:00:21,439 --> 00:00:27,359
首个CUDA内核
高级主题

10
00:00:24,279 --> 00:00:30,439
包括优化矩阵乘法

11
00:00:27,359 --> 00:00:32,360
并以实用的方式扩展派火炬（这里“pie torch”可能有误，推测可能是“PyTorch” ，如果是 “PyTorch” 则可翻译为“并以实用的方式扩展 PyTorch”）

12
00:00:30,439 --> 00:00:35,680
像实现一个……这样的应用程序

13
00:00:32,360 --> 00:00:39,239
针对 mest 数据的多层感知器

14
00:00:35,680 --> 00:00:41,920
埃利奥特·阿里德创建了这门课程，所以

15
00:00:39,239 --> 00:00:44,360
什么是CUDA或计算统一设备？

16
00:00:41,920 --> 00:00:46,480
英伟达的架构 呃，我叫

17
00:00:44,360 --> 00:00:48,520
我叫埃利奥特，我是一名免费课程的讲师。

（原英文表述不太准确，正常可能想说“I'm Elliot and I'm an instructor for free courses” 之类的，这里按合理推测进行意译了） 

18
00:00:46,480 --> 00:00:50,920
代码训练营以及一名正在学习的学生

19
00:00:48,520 --> 00:00:54,480
为了我的计算机科学学位，所以在

20
00:00:50,920 --> 00:00:56,480
在这门课程中，我将为你带来用于深度学习的CUDA

21
00:00:54,480 --> 00:00:57,760
学习，但如果……不要让这吓退你

22
00:00:56,480 --> 00:00:58,719
你没有深入学习是因为

23
00:00:57,760 --> 00:01:01,039
我们还有很多事情要去做

24
00:00:58,719 --> 00:01:03,280
能够涵盖呃许多其他领域的

25
00:01:01,039 --> 00:01:05,360
并行编程，所以这更多是…… 

26
00:01:03,280 --> 00:01:08,240
面向深度学习，但并非

27
00:01:05,360 --> 00:01:10,759
专门针对它嗯，有…… 

28
00:01:08,240 --> 00:01:12,600
这里会涵盖很多内容，所以，呃

29
00:01:10,759 --> 00:01:15,400
这句话存在语法错误，可能想表达 “I'll show what the final project is.”

翻译如下：
我将展示最终项目是什么。

30
00:01:12,600 --> 00:01:16,759
最终项目首先是，嗯，所以说

31
00:01:15,400 --> 00:01:17,840
你可以提前感受一下，看看情况如何 

32
00:01:16,759 --> 00:01:20,119
关于我们最终要建造的东西

33
00:01:17,840 --> 00:01:21,600
到最后，嗯，然后我们就只是那种……

34
00:01:20,119 --> 00:01:23,200
从那里继续前行，所以在我们开始之前 

35
00:01:21,600 --> 00:01:26,280
我本应从任何疯狂的事情开始

36
00:01:23,200 --> 00:01:27,880
包含一份免责声明，嗯，本课程可能

37
00:01:26,280 --> 00:01:29,320
到那个时候可能不会完全是最新的情况

38
00:01:27,880 --> 00:01:30,680
如果你正在观看，那你正在看着这个。

39
00:01:29,320 --> 00:01:32,479
从现在起往后的这十年

40
00:01:30,680 --> 00:01:33,840
当我发布它的时候，可能不会是全部内容

41
00:01:32,479 --> 00:01:36,360
情况会一样，可能会有一些事情，那些……（这里原文不完整，翻译可能表意不明确） 

42
00:01:33,840 --> 00:01:38,560
新的呃计算设备已更新（这里原英文表述不太符合常规语法，只能根据大致意思翻译） 

43
00:01:36,360 --> 00:01:39,680
能力或许是你知道的方式

44
00:01:38,560 --> 00:01:41,520
或许那里会有一群……

45
00:01:39,680 --> 00:01:43,200
不同的事情在发生，所以我也不是太……

46
00:01:41,520 --> 00:01:47,240
当然，看看生态系统未来会处于怎样的状态

47
00:01:43,200 --> 00:01:49,159
10年，但截至2024年，这相当…… 

48
00:01:47,240 --> 00:01:50,960
这差不多是你能得到的最好结果了，所以

49
00:01:49,159 --> 00:01:52,920
只是想把那个包含进去，而且我

50
00:01:50,960 --> 00:01:55,280
本想着我要试着把一切都……呃

51
00:01:52,920 --> 00:01:57,600
并非完全围绕时间，所以你

52
00:01:55,280 --> 00:01:59,960
可以回到这个版本，呃，或者，或者

53
00:01:57,600 --> 00:02:01,719
特定的CUDA版本并全部重现

54
00:01:59,960 --> 00:02:03,399
同样的东西，只是可能会稍微……

55
00:02:01,719 --> 00:02:05,240
如果你的情况有所不同，之后会有点不一样。 

56
00:02:03,399 --> 00:02:08,280
晚点再看这个，那我为什么……

57
00:02:05,240 --> 00:02:10,520
把这门课程打造得非常出色 大量的 

58
00:02:08,280 --> 00:02:12,920
这些性能和内核工程

59
00:02:10,520 --> 00:02:14,360
工作需要大量的知识，它们

60
00:02:12,920 --> 00:02:16,560
需要在……方面有丰富的经验

61
00:02:14,360 --> 00:02:18,280
行业呃，而且真的很难去

62
00:02:16,560 --> 00:02:20,760
达到你能够做到的那个程度

63
00:02:18,280 --> 00:02:23,040
与顶尖的和最优秀的（对手）竞争

64
00:02:20,760 --> 00:02:24,160
最优秀的性能工程师，所以这些

65
00:02:23,040 --> 00:02:27,000
正在撰写……的人是那些……

（注：原英文句子不完整，这里的翻译根据现有内容进行，可能语义不够清晰明确。） 

66
00:02:24,160 --> 00:02:30,400
针对像 GPT 4、GPT 5 等的训练运行 

67
00:02:27,000 --> 00:02:32,280
关于这个，嗯，你需要很多技巧来…… 

68
00:02:30,400 --> 00:02:34,840
优化一个大型神经网络

69
00:02:32,280 --> 00:02:37,879
在一个大型数据集上进行训练运行和推理

注：原英文“a larg”可能有误，推测正确的是“a large” 。 

70
00:02:34,840 --> 00:02:40,280
数据中心或计算集群，所以这个

71
00:02:37,879 --> 00:02:42,519
旨在防止其中一些手动操作

72
00:02:40,280 --> 00:02:45,280
你这边的编织工作仍令人鼓舞

73
00:02:42,519 --> 00:02:47,200
你这样做是你自己的事，但要防止……

注：你提供的原文似乎并不完整或存在一定表述问题，此翻译是基于现有内容尽量通顺表达。 

74
00:02:45,280 --> 00:02:49,239
其中一些艰苦的劳作是关于前行的 

75
00:02:47,200 --> 00:02:51,440
深入探究并真正把事情弄清楚

76
00:02:49,239 --> 00:02:53,159
靠你自己从头开始 呃，那是一种情况

77
00:02:51,440 --> 00:02:56,080
我创建这个的原因之一
（注：原英文文本 “of the reasons why I created this” 表述不完整，可能原文前面还有 “One” 之类的词，这里按可能的常见语境补充理解翻译） 

78
00:02:53,159 --> 00:02:58,400
另一个就像是，一般来说

79
00:02:56,080 --> 00:03:00,080
编写 GPU 内核的意义，或者

80
00:02:58,400 --> 00:03:02,480
在图形处理器（GPU）上完全用代码进行编程是 

81
00:03:00,080 --> 00:03:05,760
让某物运行得更快，所以如果你有一个

82
00:03:02,480 --> 00:03:08,879
嵌套循环，嗯，你知道的，就像对于变量 i 在……（此处原英文句子不完整） 

83
00:03:05,760 --> 00:03:11,040
4J 射程 在四号射程内
4K 射程 在射程内

84
00:03:08,879 --> 00:03:12,400
不管怎样，无论你想放多少，呃

85
00:03:11,040 --> 00:03:15,599
本质上，什么是并行编程

86
00:03:12,400 --> 00:03:17,799
而CUDA能让我们做的就是展开那些

87
00:03:15,599 --> 00:03:19,680
所以，比如说，如果你选取四个离子

88
00:03:17,799 --> 00:03:22,760
在一定范围内，你可以处理每一件小事

89
00:03:19,680 --> 00:03:25,040
在那里面并在一个（设备/系统等，需结合上下文确定）上运行那条指令

90
00:03:22,760 --> 00:03:27,599
不同的认证机构（CA）所以如果你有一万…… 

91
00:03:25,040 --> 00:03:29,400
你提供的内容“cacor”可能有误，推测可能是拼写错误。若不考虑这个错误，大致翻译为：
卡科尔（假设“cacor”是人名），而你有一万种不同之处 

92
00:03:27,599 --> 00:03:32,519
在你的循环中进行迭代，然后你可以

93
00:03:29,400 --> 00:03:35,840
影响 我在单次操作中进行每次迭代

94
00:03:32,519 --> 00:03:37,480
指令或者关于……的单一线程（此处“on on the”表述有误，可能存在输入错误） 

95
00:03:35,840 --> 00:03:39,879
GPU 所以这就是其中的一些事情，那些…… 

96
00:03:37,480 --> 00:03:42,280
允许我们做 你要用你的

97
00:03:39,879 --> 00:03:44,000
呃，你的工作是要运用你的……你的……

98
00:03:42,280 --> 00:03:45,519
GPU架构内核知识

99
00:03:44,000 --> 00:03:46,879
启动配置以及一堆的……

100
00:03:45,519 --> 00:03:48,879
我们最终会学到的其他很酷的东西

101
00:03:46,879 --> 00:03:51,360
这门课程是为了让那段代码能够像这样运行 

102
00:03:48,879 --> 00:03:54,000
尽可能快 呃 然后是最后一个

103
00:03:51,360 --> 00:03:56,000
一是真的有太多数据了

104
00:03:54,000 --> 00:03:58,640
如今，他们说我们拥有的太多了

105
00:03:56,000 --> 00:04:00,560
数据，但我拥有的经过清理的数据却很少。

106
00:03:58,640 --> 00:04:03,400
从所有其他的事物中拿走了一切

107
00:04:00,560 --> 00:04:06,000
视频课程
互联网上的一切内容

108
00:04:03,400 --> 00:04:08,879
还有YouTube，呃，然后我把它们放进了一个

109
00:04:06,000 --> 00:04:10,879
单一课程，所以我筛选掉了一堆

110
00:04:08,879 --> 00:04:12,879
很多你们所知道的那些无稽之谈

111
00:04:10,879 --> 00:04:14,840
旧的东西 很多新的东西，那些

112
00:04:12,879 --> 00:04:17,600
也许没有被很好地覆盖，而且有点

113
00:04:14,840 --> 00:04:19,680
只是投射到了这一部杰作之中

114
00:04:17,600 --> 00:04:21,400
所以这包括付费涵盖的主题

115
00:04:19,680 --> 00:04:23,120
课程也是，实际上我还没付款呢。

116
00:04:21,400 --> 00:04:24,360
为了他们，但我只是有点看着

117
00:04:23,120 --> 00:04:25,800
你知道他们所说的章节是哪些吗

注：原英文句子似乎不完整，以上是根据现有内容尽量通顺翻译。 

118
00:04:24,360 --> 00:04:28,600
覆盖，然后包含其中一些

119
00:04:25,800 --> 00:04:30,199
本课程的重要概念 嗯 我

120
00:04:28,600 --> 00:04:31,680
确实有YouTube视频之类的链接。

121
00:04:30,199 --> 00:04:33,440
在我所接触过的这些资源当中

122
00:04:31,680 --> 00:04:34,759
但只通过那些高质量的（内容） 

123
00:04:33,440 --> 00:04:36,840
我已经看过很多这类视频了

124
00:04:34,759 --> 00:04:39,600
以及资源，而所有这些都将

125
00:04:36,840 --> 00:04:41,240
呃，在那个里面插入链接

126
00:04:39,600 --> 00:04:43,080
描述中有 GitHub 链接，所以

127
00:04:41,240 --> 00:04:45,199
你所需要的一切都会在那里。

128
00:04:43,080 --> 00:04:48,560
嗯，我把所有那些链接都放上去了

129
00:04:45,199 --> 00:04:51,479
在那个，嗯，在那个链接里，那么有哪些……

130
00:04:48,560 --> 00:04:52,759
CUDA并行GPU的用例

131
00:04:51,479 --> 00:04:55,160
编程 它有哪些用途呢

132
00:04:52,759 --> 00:04:57,120
关于这个的情况，你有图表资料。

133
00:04:55,160 --> 00:04:58,400
以及速率追踪，这样计算机

134
00:04:57,120 --> 00:05:01,160
你在视频中看到的画面

135
00:04:58,400 --> 00:05:03,560
游戏 嗯 你知道的 用户界面 所有的

136
00:05:01,160 --> 00:05:06,280
你这里有类似的流体模拟

注：原英文句子不太完整通顺，以上是根据现有内容给出的翻译。 

137
00:05:03,560 --> 00:05:09,479
物理学，嗯，还有建模，你知道的，引擎

138
00:05:06,280 --> 00:05:10,960
动态方面，你有视频编辑功能，所以……

139
00:05:09,479 --> 00:05:13,800
我现在正在为这个编辑的视频

140
00:05:10,960 --> 00:05:16,600
现在正在使用呃并行计算来

141
00:05:13,800 --> 00:05:18,280
使，呃，加密货币挖矿（变得怎么样），很多（情况会涉及到它）

注：由于原文表述不完整，只能进行相对合理的初步翻译。 

142
00:05:16,600 --> 00:05:20,800
你可能已经在做了，那就继续吧（注：原英文句子可能表述不太完整或地道，这里结合可能语义给出大致翻译）

143
00:05:18,280 --> 00:05:22,759
要使用，呃，你知道的，你的显卡

144
00:05:20,800 --> 00:05:25,080
硬件以及……的一些优势

145
00:05:22,759 --> 00:05:27,280
那是像我通过加密货币那样的（这里原句表述不太符合正常语法逻辑） 

146
00:05:25,080 --> 00:05:29,800
挖掘问题，然后你会有三维（的内容） 

147
00:05:27,280 --> 00:05:30,800
建模以及像Blender这样的软件，所以

148
00:05:29,800 --> 00:05:32,280
当你有一堆不同的

149
00:05:30,800 --> 00:05:33,600
要点持续存在，而且你必须进行渲染。

150
00:05:32,280 --> 00:05:36,080
从本质上来说，它和……是一样的（原句“things”表述不太符合语境逻辑，此处按常规理解补充语义） 

151
00:05:33,600 --> 00:05:40,080
视频编辑，但只是，呃，用 3D 而不是 

152
00:05:36,080 --> 00:05:42,400
二维，所以最后一个，你可能……

153
00:05:40,080 --> 00:05:44,440
已经猜到是深度学习了，所以

154
00:05:42,400 --> 00:05:46,240
目前，CUDA的首要应用场景

155
00:05:44,440 --> 00:05:49,080
现在我主要要讲的就是这些内容。

156
00:05:46,240 --> 00:05:50,639
在这门深度学习课程中，所以

157
00:05:49,080 --> 00:05:54,120
我们不会深入探讨到……的程度

注：原文 “as as” 可能有误，推测正确形式也许是 “as deep as”  ，但按照提供内容进行了翻译。 

158
00:05:50,639 --> 00:05:56,120
就像说卷积，但呃，某种程度上

159
00:05:54,120 --> 00:05:58,120
理解如何优化算法

160
00:05:56,120 --> 00:06:00,520
就像矩阵乘法，呃，我们在……

161
00:05:58,120 --> 00:06:02,639
接下来将对此进行相当深入的探讨

162
00:06:00,520 --> 00:06:04,560
那么现在你可能会问，埃利奥特，那些……是什么呢（原句不完整，翻译按现有内容处理） 

163
00:06:02,639 --> 00:06:06,800
……的要求或先决条件

164
00:06:04,560 --> 00:06:08,560
这门课程，所以有一些是

165
00:06:06,800 --> 00:06:11,560
更具知识性和学术性，而且在那里

166
00:06:08,560 --> 00:06:13,440
有些不是这样的，所以这严格来说

167
00:06:11,560 --> 00:06:15,240
针对英伟达显卡，以防你没注意到

168
00:06:13,440 --> 00:06:17,479
回到之前说的，如果你们没有……

169
00:06:15,240 --> 00:06:19,919
其一，你始终可以考虑租……嗯

170
00:06:17,479 --> 00:06:21,639
云端最便宜的那些 嗯 我

171
00:06:19,919 --> 00:06:23,759
建议你调查一下定价情况

172
00:06:21,639 --> 00:06:26,360
在对……明确说“不”之前

173
00:06:23,759 --> 00:06:28,039
其中一些云 GPU 的定价，嗯

174
00:06:26,360 --> 00:06:30,919
起初，我实际上很惊讶于如何……

175
00:06:28,039 --> 00:06:33,639
对于一些云服务来说成本很低

注：原英文句子表述不太准确地道，更符合语法的可能是 “The cost was low for some cloud (services)”  。 

176
00:06:30,919 --> 00:06:35,639
实例，嗯，尤其是非竞赛类的实例

177
00:06:33,639 --> 00:06:38,120
计算要求高的任务，所以如果你有

178
00:06:35,639 --> 00:06:39,880
比如只是一个中央处理器（CPU），或者是像内存密集型的（设备或程序） 

179
00:06:38,120 --> 00:06:42,039
机器，它实际上可能会花费（成本）

180
00:06:39,880 --> 00:06:44,800
明显低于开启GPU的情况

181
00:06:42,039 --> 00:06:46,880
嗯，那些显卡仍然很便宜。

182
00:06:44,800 --> 00:06:49,039
你可以使用像Vast AI这样的工具，它……（此处英文句子不完整，“which”引导的从句缺失内容） 

183
00:06:46,880 --> 00:06:50,520
我会再讲多一点，嗯，你可以

184
00:06:49,039 --> 00:06:52,840
用这个来真正地达成非常（此处原英文表述不完整）

185
00:06:50,520 --> 00:06:55,759
便宜的，呃，消费级硬件，那

186
00:06:52,840 --> 00:06:57,360
你可以通过 SSH 连接到云端，嗯，然后

187
00:06:55,759 --> 00:07:00,319
然后就去做你所有的实验，并且

188
00:06:57,360 --> 00:07:02,360
完成关于那个的课程

189
00:07:00,319 --> 00:07:05,800
你可以继续 呃 你可以继续

190
00:07:02,360 --> 00:07:07,960
与任何你所知的英伟达GTX、RTX显卡搭配运行

191
00:07:05,800 --> 00:07:09,599
或者数据中心级别的图形处理器，所以所有的

192
00:07:07,960 --> 00:07:11,520
英伟达显卡基本上都能得到支持。

193
00:07:09,599 --> 00:07:13,759
对于这个，呃，也许像下面这些（东西、人等，需结合语境）

194
00:07:11,520 --> 00:07:16,160
那些大概有15年历史了，那些可能

195
00:07:13,759 --> 00:07:18,520
不行，嗯，但一般来说，如果你有

196
00:07:16,160 --> 00:07:21,440
像 GTX 显卡，比如 1660 之类的

197
00:07:18,520 --> 00:07:24,800
感觉一切都会好起来的

198
00:07:21,440 --> 00:07:26,840
嗯，至于课程先决条件，是Python

199
00:07:24,800 --> 00:07:28,080
编程将有助于理解

200
00:07:26,840 --> 00:07:30,319
当我们在较低层面实施时

201
00:07:28,080 --> 00:07:32,280
语言 如此

202
00:07:30,319 --> 00:07:34,720
嗯，只是在理解整个（事情/情况等，需结合语境确定）

203
00:07:32,280 --> 00:07:36,960
编程，呃，概念才是真正重要的东西（由于原文不完整通顺，只能按字面大致翻译） 

204
00:07:34,720 --> 00:07:38,280
所有这些东西在这里又会被需要了

205
00:07:36,960 --> 00:07:42,039
不同的语言就像一种

206
00:07:38,280 --> 00:07:43,919
语法上的变化，对，所以，嗯，你知道的

207
00:07:42,039 --> 00:07:46,319
我们将使用基本的求导方法

208
00:07:43,919 --> 00:07:48,800
还有向量微积分，呃，那会让

209
00:07:46,319 --> 00:07:50,319
如果你已经了解了，学习会更容易

210
00:07:48,800 --> 00:07:52,639
嗯，这实际上只对……有要求。（注：原句不完整，这里按表达逻辑添加了省略内容） 

211
00:07:50,319 --> 00:07:53,840
反向传播背后的直觉以及

212
00:07:52,639 --> 00:07:56,280
我们打算用的一些东西是用来…… （原句不完整，这里按照常规理解做了表述） 

213
00:07:53,840 --> 00:07:58,319
从头开始构建神经网络 嗯

214
00:07:56,280 --> 00:08:00,599
线性代数绝对会让你的

215
00:07:58,319 --> 00:08:02,960
不用学习让生活更轻松

216
00:08:00,599 --> 00:08:05,639
从头开始学习基础算法，所以

217
00:08:02,960 --> 00:08:07,800
就好像如果你不是真的凭直觉……嗯

218
00:08:05,639 --> 00:08:10,280
你现在了解矩阵乘法了吗

219
00:08:07,800 --> 00:08:12,560
如果你真的……呃，你懂的，没去过

220
00:08:10,280 --> 00:08:14,520
深入探讨它的话，这可能是一个

221
00:08:12,560 --> 00:08:16,680
你要赶上有点难呃 但是

222
00:08:14,520 --> 00:08:18,520
矩阵乘法非常简单，它是

223
00:08:16,680 --> 00:08:20,639
回想起来相当微不足道，这非常……

224
00:08:18,520 --> 00:08:22,720
这很容易理解，嗯，但只是

225
00:08:20,639 --> 00:08:24,000
那里的直觉以及对其进行优化

226
00:08:22,720 --> 00:08:26,720
如果你没做过的话，可能会有点难。

227
00:08:24,000 --> 00:08:28,879
已经和它合作过很多次了

228
00:08:26,720 --> 00:08:31,159
嗯，那么如果你真的在意，我会……

229
00:08:28,879 --> 00:08:34,240
建议你去重温一下，你懂的，《黑客帝国》

230
00:08:31,159 --> 00:08:36,680
呃，转置矩阵乘法链

231
00:08:34,240 --> 00:08:38,959
微积分中的法则，然后求差

232
00:08:36,680 --> 00:08:40,279
在梯度和导数之间，嗯

233
00:08:38,959 --> 00:08:42,200
可能还有一些我漏掉了。

234
00:08:40,279 --> 00:08:43,640
但那些只是大致的想法

235
00:08:42,200 --> 00:08:46,720
你进入时将会需要的

236
00:08:43,640 --> 00:08:48,440
这个，嗯，然后提前提醒一下，呃，如果

237
00:08:46,720 --> 00:08:50,760
你正在使用一台 Windows 机器，这可能

238
00:08:48,440 --> 00:08:54,360
对你来说会有点难，所以我确实有

239
00:08:50,760 --> 00:08:56,240
一份关于 Windows 硬件的简易设置指南

240
00:08:54,360 --> 00:08:58,760
嗯，但是我……我在这里什么事情都做。 

241
00:08:56,240 --> 00:09:00,519
乌班图 Linux，所以这就是我正在使用的系统

242
00:08:58,760 --> 00:09:01,560
呃，就在我这台本地机器上，并且

243
00:09:00,519 --> 00:09:05,160
这就是我们即将要经历的

244
00:09:01,560 --> 00:09:08,760
这门课程嘛，你随时都可以用呃

245
00:09:05,160 --> 00:09:11,800
在 Windows 上使用 WSL 来模拟一个 Linux 系统

246
00:09:08,760 --> 00:09:13,399
系统，或者你也可以使用呃，Docker，所以

247
00:09:11,800 --> 00:09:15,920
Docker 是一个很棒的工具，它能让

248
00:09:13,399 --> 00:09:18,399
你基本上要启动呃一小…… 

249
00:09:15,920 --> 00:09:20,760
模拟的 Linux 机器，呃，就在你的……（原文表述似乎不完整） 

250
00:09:18,399 --> 00:09:22,920
在 Windows 系统的终端里，你可以直接进行（以下操作）

251
00:09:20,760 --> 00:09:24,880
通过那件事的一切，呃，我觉得它…… 

252
00:09:22,920 --> 00:09:26,839
通过……直接支持英伟达显卡

253
00:09:24,880 --> 00:09:28,839
Windows 我还不完全确定我

254
00:09:26,839 --> 00:09:30,279
还没测试过那个，不过，嗯，如果你处于……（此处原文未完整）

255
00:09:28,839 --> 00:09:32,800
一台Windows机器，我会

256
00:09:30,279 --> 00:09:35,240
推荐呃，Windows 子系统（WSL）或者

257
00:09:32,800 --> 00:09:37,720
如果你在使用 Docker 时确实遇到了错误或

258
00:09:35,240 --> 00:09:40,120
在这整个过程中存在的问题，呃，我确实建议

259
00:09:37,720 --> 00:09:43,279
你可以查看 GitHub、Stack Overflow

260
00:09:40,120 --> 00:09:45,000
英伟达开发者论坛  PyTorch文档 呃

261
00:09:43,279 --> 00:09:47,040
如果你的问题与其中任何一项有关

262
00:09:45,000 --> 00:09:48,760
课程资料，这样你就知道你有一份（课程资料）了。

263
00:09:47,040 --> 00:09:50,120
如果你有很多资源可供支配

264
00:09:48,760 --> 00:09:51,920
需要解决一个并不……的错误

265
00:09:50,120 --> 00:09:53,360
在课程材料中出现，呃，你

266
00:09:51,920 --> 00:09:55,160
也拥有非常强大的语言能力

267
00:09:53,360 --> 00:09:56,880
可供使用的模型，有很多种语言相关的（模型） 

268
00:09:55,160 --> 00:09:58,279
近期发布的模型

269
00:09:56,880 --> 00:10:00,320
那些在解决……方面真的非常厉害的

270
00:09:58,279 --> 00:10:02,880
以及解决编码问题，所以我确实（在做这些）

271
00:10:00,320 --> 00:10:06,640
建议你试试那些 嗯 如果……如果所有的……

272
00:10:02,880 --> 00:10:08,399
一切都搞砸了，嗯，所有的，所有的

273
00:10:06,640 --> 00:10:10,320
此部分的代码和注释保存在……中 

274
00:10:08,399 --> 00:10:11,800
描述中的 GitHub 仓库

275
00:10:10,320 --> 00:10:13,680
生态系统将彻底改变

276
00:10:11,800 --> 00:10:16,240
时间，所以万一这个视频达不到…… 

277
00:10:13,680 --> 00:10:17,720
日期 呃，GitHub 仓库将是因为

278
00:10:16,240 --> 00:10:20,240
我能够推动那件事并且切实做到

279
00:10:17,720 --> 00:10:22,279
有变化，所以如果有什么地方有点不对劲

280
00:10:20,240 --> 00:10:24,079
在这里你可能想去办理入住手续

281
00:10:22,279 --> 00:10:25,560
这个仓库，然后看看它实际上是什么样子

282
00:10:24,079 --> 00:10:27,160
看起来这样你实际上可以

283
00:10:25,560 --> 00:10:28,839
把它写规范点，也许会有一个

284
00:10:27,160 --> 00:10:32,120
更优化版本的东西会 

285
00:10:28,839 --> 00:10:34,720
有所变化，但你明白我的意思，呃，我确实（是这个意思）。

286
00:10:32,120 --> 00:10:36,000
建议关注呃该仓库以获取

287
00:10:34,720 --> 00:10:39,839
保持有组织的学习

288
00:10:36,000 --> 00:10:41,800
在这种方法中，我会加入 Excalidraw 图表

注：原句“approach I include...”表述不太符合常见语法结构，推测前面可能省略了“In this” 之类的，这里按照推测意思进行了翻译。 

289
00:10:39,839 --> 00:10:43,320
所以这将有助于说明，就像

290
00:10:41,800 --> 00:10:45,639
高层次的想法，我们打算如何去……

291
00:10:43,320 --> 00:10:47,440
处理事情，呃，以及如何去做

292
00:10:45,639 --> 00:10:50,959
内核层面的事物

293
00:10:47,440 --> 00:10:52,399
优化，所以自顶向下一直都是…… 

294
00:10:50,959 --> 00:10:53,880
其中，Excalidraw 对于……来说太棒了

295
00:10:52,399 --> 00:10:55,839
描绘事物，而且这完全是

296
00:10:53,880 --> 00:10:58,240
免费的，所以那里所有的图表都会…… 

297
00:10:55,839 --> 00:11:00,399
包含在 GitHub 仓库里 呃

298
00:10:58,240 --> 00:11:03,000
而且在这门课程里也是如此

299
00:11:00,399 --> 00:11:04,399
嗯，你知道的，你随时都可以……联系我。 

300
00:11:03,000 --> 00:11:07,000
通过我的 Discord 服务器传达给我，这…… 

301
00:11:04,399 --> 00:11:08,480
也会在 GitHub 仓库里，嗯，并且

302
00:11:07,000 --> 00:11:10,040
你可以通过那里联系我。

303
00:11:08,480 --> 00:11:11,680
并且和那里的社区交流，有…… 

304
00:11:10,040 --> 00:11:13,560
将会有很多其他的学生

305
00:11:11,680 --> 00:11:16,079
得知将会有一个专门的……（这里文本不完整，感觉句子没说完） 

306
00:11:13,560 --> 00:11:18,079
为此准备了一系列频道，所以万一你……

307
00:11:16,079 --> 00:11:20,320
遇到困难或者想讨论某事

308
00:11:18,079 --> 00:11:22,480
或者只是在服务器里进行一场愉快的聊天

309
00:11:20,320 --> 00:11:24,519
呃，你完全可以加入，我确实希望（你加入）。

310
00:11:22,480 --> 00:11:27,000
需要尽早注意到这门课程并非

311
00:11:24,519 --> 00:11:29,320
仅适用于CUDA，所以有几件事

312
00:11:27,000 --> 00:11:31,800
我在其之外所涵盖的内容，包括

313
00:11:29,320 --> 00:11:34,880
PyTorch引用，呃，进入类似的（情况）

314
00:11:31,800 --> 00:11:37,480
特里顿以及C和C++，与……类似 

315
00:11:34,880 --> 00:11:39,720
在外部，不包括 CUDA，仅仅是为了

316
00:11:37,480 --> 00:11:41,360
你知道如何举例说明事情的情况

317
00:11:39,720 --> 00:11:44,040
表明一个的幼稚版本是怎样的 

318
00:11:41,360 --> 00:11:45,399
算法可行，但是，呃，所以说……

319
00:11:44,040 --> 00:11:47,839
有代码这方面，然后还有

320
00:11:45,399 --> 00:11:49,959
另外，嗯，我打算提供一些

321
00:11:47,839 --> 00:11:52,519
先决条件，或者甚至称不上是先决条件

322
00:11:49,959 --> 00:11:54,639
而是仅仅呃，一种良好的理解

323
00:11:52,519 --> 00:11:57,399
关于整个深度学习生态系统

324
00:11:54,639 --> 00:11:59,440
所以实际上这就是接下来其中一个的样子

325
00:11:57,399 --> 00:12:01,240
各章节将要探讨的内容是如何……

326
00:11:59,440 --> 00:12:03,200
整个生态系统是如何运作的，又在哪里运作呢 

327
00:12:01,240 --> 00:12:05,160
我可以应用CUDA吗？这会有点…… 

328
00:12:03,200 --> 00:12:06,880
我真傻，还说什么“这就是你……的方法”

329
00:12:05,160 --> 00:12:09,360
优化一个内核并让它真正运行起来

330
00:12:06,880 --> 00:12:11,519
在你的硬件上运行真的很快，但并非如此

331
00:12:09,360 --> 00:12:14,000
实际上会给你一些切实可行的使用案例

332
00:12:11,519 --> 00:12:15,440
为此，所以你可能已经知道是什么了

333
00:12:14,000 --> 00:12:16,959
用例是，但万一你只是

334
00:12:15,440 --> 00:12:19,320
尝试学习CUDA，你可能会去查看

335
00:12:16,959 --> 00:12:22,399
在一些你可以应用它的方法上，我……

注：原英文句子可能存在表述不完整或有误的情况，翻译根据现有内容尽量处理。 

336
00:12:19,320 --> 00:12:24,199
同时也提供那个资源，所以这是剧透哦

337
00:12:22,399 --> 00:12:26,040
注意，但你可能会有一些收获

338
00:12:24,199 --> 00:12:28,519
从这门课程中学到的是，通过

339
00:12:26,040 --> 00:12:30,120
实验、试验与研究

340
00:12:28,519 --> 00:12:32,399
你会了解到主 GPU

341
00:12:30,120 --> 00:12:34,560
性能瓶颈在于内存

342
00:12:32,399 --> 00:12:36,920
带宽，所以在深度学习中我们有

343
00:12:34,560 --> 00:12:39,079
这些巨大而神秘的矩阵，它们…… （这里句子不完整，“that”后面应该还有内容） 

344
00:12:36,920 --> 00:12:41,760
无法在……时装入片上存储器

345
00:12:39,079 --> 00:12:44,440
那么，想一想，如果你有一个…… 

346
00:12:41,760 --> 00:12:46,560
一大群图形处理器，并且它们每一个

347
00:12:44,440 --> 00:12:48,519
拥有非常非常快速的张量核心

348
00:12:46,560 --> 00:12:50,519
这些就像是为执行（某事）进行了超级优化的。

349
00:12:48,519 --> 00:12:52,959
你知道深度学习中的张量运算

350
00:12:50,519 --> 00:12:55,800
学习，嗯，但如果你正在做这些

351
00:12:52,959 --> 00:12:58,320
在多个 GPU 上，你真的必须要

352
00:12:55,800 --> 00:13:00,560
交换、并且、并且、并且混合以及管理

353
00:12:58,320 --> 00:13:03,360
它们之间的信息，所以你最终

354
00:13:00,560 --> 00:13:05,760
发射电子，呃，你知道的，从这个（位置/装置等，需结合前文）发射

355
00:13:03,360 --> 00:13:07,240
从这个节点到这个节点再到右边的这个节点

356
00:13:05,760 --> 00:13:10,199
并且有很多这样的交流。

357
00:13:07,240 --> 00:13:12,399
那正在发生，所以你真的会得到很多

358
00:13:10,199 --> 00:13:14,800
来自内部计算的速度

注：你提供的文本似乎并不完整，但我按照要求进行了逐字翻译。 

359
00:13:12,399 --> 00:13:16,360
芯片，但当涉及到交流时

360
00:13:14,800 --> 00:13:18,800
实际上有一个相当大的

361
00:13:16,360 --> 00:13:22,160
那里存在瓶颈，而且你知道的，那是一个（瓶颈）

362
00:13:18,800 --> 00:13:25,120
你可能会从这件事中学到的东西

363
00:13:22,160 --> 00:13:27,720
嗯，芯片上也存在一些限制因素。

364
00:13:25,120 --> 00:13:31,079
所以你有像显存这样正在（变化/发展等，需结合上下文确定准确含义）的东西

注：原句表意不太完整，“which is going”这里没有明确表达出“正在怎么样”的意思。 

365
00:13:27,720 --> 00:13:33,279
呃，你知道的，相对来说比较慢以至于…… 

366
00:13:31,079 --> 00:13:35,360
芯片上的东西是什么，所以显存是…… 

367
00:13:33,279 --> 00:13:37,560
就像从实际的，你知道的核心部分脱离出来，然后…… 

368
00:13:35,360 --> 00:13:39,720
所有这些，然后它还得进行交流

369
00:13:37,560 --> 00:13:41,760
带着果核以及所有的那些那些那些

370
00:13:39,720 --> 00:13:43,839
芯片上的共享内存以及所有的……

371
00:13:41,760 --> 00:13:45,519
登记，结果成了一场狂欢

372
00:13:43,839 --> 00:13:49,079
脖子也是，所以不只是……那……

373
00:13:45,519 --> 00:13:51,240
大量的，呃，大量的矩阵

374
00:13:49,079 --> 00:13:53,079
在很多GPU之间进行通信，这是

375
00:13:51,240 --> 00:13:54,519
实际上，很多片上的……

这里文本不完整，推测可能还有后续内容。如果有完整文本可以继续让我翻译。 

376
00:13:53,079 --> 00:13:56,759
交流也是如此，所以有多种（情况/方式等，需结合上下文确定“multiple”指代内容）

377
00:13:54,519 --> 00:13:59,279
出现的瓶颈，那个……那个……或者那个

378
00:13:56,759 --> 00:14:01,199
那些产生的嗯，但这些都只是些事情

379
00:13:59,279 --> 00:14:03,399
你最终会遇到并且……并且

380
00:14:01,199 --> 00:14:06,519
能够在之后通过……来解决

注：由于文本不完整，这里只能根据现有的内容进行大致翻译。 

381
00:14:03,399 --> 00:14:07,839
优化，另一个关键要点是

382
00:14:06,519 --> 00:14:10,199
将是采用一个现有的

383
00:14:07,839 --> 00:14:11,480
实施并让它更快，这样一个

384
00:14:10,199 --> 00:14:13,480
很多时候你会看到一个新的

385
00:14:11,480 --> 00:14:15,160
研究论文发表后，你就会看到一个

386
00:14:13,480 --> 00:14:18,079
真是个很酷的算法，但你可能不会

387
00:14:15,160 --> 00:14:19,480
确切地知道它是如何运作的，然后呢，或者……或者……

388
00:14:18,079 --> 00:14:21,519
你也许知道，也许你知道它是怎样的

389
00:14:19,480 --> 00:14:23,199
工作着，而你只想让它快点完成

390
00:14:21,519 --> 00:14:25,079
并且你想把它集成到Pi中

391
00:14:23,199 --> 00:14:26,160
例如，火炬，所以这是某种东西

392
00:14:25,079 --> 00:14:28,040
实际上我们要在这当中做的是

393
00:14:26,160 --> 00:14:29,920
当然啦，我们打算，呃，我们要去……

394
00:14:28,040 --> 00:14:31,759
来构建一个算法，而且我们正在

395
00:14:29,920 --> 00:14:33,880
打算对它进行优化，然后我们会……

396
00:14:31,759 --> 00:14:35,560
实际上，将它移植到 PyTorch 中

397
00:14:33,880 --> 00:14:38,920
扩展，这样你就可以在……中调用它

398
00:14:35,560 --> 00:14:40,720
Python，它超酷的，嗯，但只是

399
00:14:38,920 --> 00:14:42,519
学习如何融入你自己的（环境、群体等，这里表述不完整，需结合上下文理解“own”的具体所指） 

400
00:14:40,720 --> 00:14:45,320
对使事物变得更快的方法进行研究

401
00:14:42,519 --> 00:14:46,720
让它在生产规模上运行

402
00:14:45,320 --> 00:14:48,160
嗯，这些真的很重要

403
00:14:46,720 --> 00:14:50,399
当你……的时候你必须要做的事情

404
00:14:48,160 --> 00:14:55,079
开始深入地工作，你非常清楚地了解与…… 

405
00:14:50,399 --> 00:14:57,000
还有一件事是卡帕西的大语言模型（LLM）。 

406
00:14:55,079 --> 00:14:59,759
你们很多人可能都听说过这个

407
00:14:57,000 --> 00:15:04,120
嗯，如果你去搜索大语言模型（LLM）……（注：这里M.C不太明确表意，可能原文有误，常见是大语言模型LLM ，Large Language Model ）

408
00:14:59,759 --> 00:15:06,399
呃，大语言模型能力（LLM.C）在……呃，在你身上，不是……不是在……（注：原文表述不太清晰，翻译可能不太准确达意） 

409
00:15:04,120 --> 00:15:08,120
谷歌上的YouTube 嗯 你会遇到

410
00:15:06,399 --> 00:15:12,240
一个叫安德烈·科波伊的人，而且他基本上

411
00:15:08,120 --> 00:15:15,880
用 C 语言搭建了一个大型的 GBT2 训练运行环境

412
00:15:12,240 --> 00:15:18,199
从头开始，所以它使用 C 和 CUDA 以及

413
00:15:15,880 --> 00:15:20,279
所有的东西
里面有好多东西呢

414
00:15:18,199 --> 00:15:22,720
而且我真的觉得很难去

415
00:15:20,279 --> 00:15:24,639
明白一开始，嗯，你知道，就像

416
00:15:22,720 --> 00:15:27,079
某个并非超级超级（厉害之类，需结合语境）的人

417
00:15:24,639 --> 00:15:30,160
丰富了，呃，并且已经完成了CUDA相关工作 

418
00:15:27,079 --> 00:15:31,560
大概20年了，嗯

419
00:15:30,160 --> 00:15:34,079
在那时有点难以理解那件事。 

420
00:15:31,560 --> 00:15:35,720
首先，所以要有一个非常好的基础，比如

421
00:15:34,079 --> 00:15:38,360
这是你真正能理解的地方

422
00:15:35,720 --> 00:15:40,639
如何使用CUDA，以及在哪里……在哪里……

423
00:15:38,360 --> 00:15:42,680
真正的，呃，从中获得的好处以及如何……

424
00:15:40,639 --> 00:15:45,480
使用它，这将使你能够阅读并

425
00:15:42,680 --> 00:15:46,600
接近KPOE LM。这样能看得更清楚一点

注：“KPOE”可能是特定的名称、缩写等，由于缺乏更多背景信息，这里直接保留英文。 

426
00:15:45,480 --> 00:15:48,920
那是我……的原因之一

427
00:15:46,600 --> 00:15:51,839
实际上做这个是为了让事情更简单

428
00:15:48,920 --> 00:15:54,759
供人们进入大语言模型文档以及

429
00:15:51,839 --> 00:15:56,920
了解正在发生的事情，所以在这个…… （此处原文不完整）

430
00:15:54,759 --> 00:15:59,399
GitHub链接和Notion文档

431
00:15:56,920 --> 00:16:01,800
在我的 GitHub 仓库里，呃，你会看到

432
00:15:59,399 --> 00:16:04,480
这在引言部分，所以只是一个

433
00:16:01,800 --> 00:16:06,639
关于呃，CUDA（统一计算设备架构）的一系列很酷的视频

434
00:16:04,480 --> 00:16:09,000
了解Transformer的工作原理有很多方面

435
00:16:06,639 --> 00:16:11,600
就是那种真的超酷超有趣的视频，你懂的

436
00:16:09,000 --> 00:16:14,079
真的能让你充满动力，情绪高涨地面对 

437
00:16:11,600 --> 00:16:17,399
呃，所有这些，所以有些技术方面的（问题） 

438
00:16:14,079 --> 00:16:19,440
我们有一些来自Fireship的有趣视频

439
00:16:17,399 --> 00:16:21,800
嗯，但一般来说，这些仅仅是

440
00:16:19,440 --> 00:16:23,720
你可以查看一些很棒的资源，呃

441
00:16:21,800 --> 00:16:25,399
CUDA编程库达姆模式是一种真正的……

注：“kudam”可能是拼写错误，推测正确的可能是“CUDA”相关的正确术语，可根据准确信息进一步修正译文。 

442
00:16:23,720 --> 00:16:27,160
不错的服务器，实际上我强烈推荐

443
00:16:25,399 --> 00:16:29,319
你加入这个，这只是一个 Discord（社交平台）。

444
00:16:27,160 --> 00:16:32,040
一群这样的人的群体

445
00:16:29,319 --> 00:16:34,759
真的很喜欢CUDA，所以我相信安德烈·戈波伊。 

446
00:16:32,040 --> 00:16:36,399
在这儿有一堆超酷的呃 你

447
00:16:34,759 --> 00:16:38,680
认识一些程序员，一群工程师在里面

448
00:16:36,399 --> 00:16:40,399
在这里只是为了讨论如何，呃，如何

449
00:16:38,680 --> 00:16:42,720
让某些内核正常运行，并且……（原句似乎不完整）

450
00:16:40,399 --> 00:16:45,920
一般来说只是 CUDA 相关的内容，嗯，这就是为什么……

451
00:16:42,720 --> 00:16:47,920
它被称为 CUDA 模式，对吧，所以，呃，真的

452
00:16:45,920 --> 00:16:49,720
很棒的服务器，我强烈推荐你加入。

453
00:16:47,920 --> 00:16:53,759
那以及我的服务器，它也……

454
00:16:49,720 --> 00:16:56,279
在 GitHub 仓库里，但那是

455
00:16:53,759 --> 00:16:57,480
那么现在我们要进入一个

456
00:16:56,279 --> 00:17:00,279
关于深度学习的一些介绍

457
00:16:57,480 --> 00:17:01,680
目前的生态系统，所以很明显这

458
00:17:00,279 --> 00:17:03,959
这不会是最新的情况了。 

459
00:17:01,680 --> 00:17:06,400
五年后，所以你知道的，收下这个

460
00:17:03,959 --> 00:17:08,959
半信半疑地看待，这可不是，呃，这

461
00:17:06,400 --> 00:17:10,720
并非一切，这只是我……（原文句子不太完整通顺，只能大致翻译） 

462
00:17:08,959 --> 00:17:12,039
发现看起来很有趣并值得专注

463
00:17:10,720 --> 00:17:13,360
关于以及要在……中留意的

464
00:17:12,039 --> 00:17:14,600
生态系统以及你可以怎样去（做某种事，这里原句不完整） 

465
00:17:13,360 --> 00:17:17,559
连接万物并理解

466
00:17:14,600 --> 00:17:19,640
怎么回事，所以实际上这并没有……（这里原句不完整，翻译可能不太准确）

467
00:17:17,559 --> 00:17:21,760
与……详细讨论任何专业性很强的技术问题

468
00:17:19,640 --> 00:17:23,600
CUDA，但我觉得展示出来会更好

469
00:17:21,760 --> 00:17:25,360
你关注的是生态系统，而不仅仅是

470
00:17:23,600 --> 00:17:26,679
盲目地输入技术细节，比如

471
00:17:25,360 --> 00:17:29,080
如果我们直接把数据倒入CUDA中

472
00:17:26,679 --> 00:17:33,120
内核，嗯，你不会知道如何连接的

473
00:17:29,080 --> 00:17:34,320
之后的那些点，所以当我们，呃，当

474
00:17:33,120 --> 00:17:35,840
实际上我们正在顺利推进建设。

475
00:17:34,320 --> 00:17:37,679
算法，就好像，好吧，现在你有

476
00:17:35,840 --> 00:17:40,200
做这件事的技能，你会在哪里应用呢

477
00:17:37,679 --> 00:17:42,919
所以，这就是其目标所在。

478
00:17:40,200 --> 00:17:44,360
给你稍微介绍一下背景情况，嗯

479
00:17:42,919 --> 00:17:46,520
了解生态系统将有所帮助

480
00:17:44,360 --> 00:17:47,840
你把一切都妥善规划好了，然后它

481
00:17:46,520 --> 00:17:49,799
为……提供最初的动力

注：由于原文“provides that initial motivation to”并不是完整句子，“to”后缺少内容，这里按照固定表达给出了“为……提供最初的动力”，如果能补充完整句子会翻译得更准确。 

482
00:17:47,840 --> 00:17:51,160
了解一下，所以有些部分将会变得……

483
00:17:49,799 --> 00:17:53,000
真的很难，当你有那种（情况）的时候

484
00:17:51,160 --> 00:17:54,720
更高层次的动力，去看待事情，就像，好吧

485
00:17:53,000 --> 00:17:56,880
这就是一旦我……实际上能够建造出来的东西

486
00:17:54,720 --> 00:17:59,559
学习如何去做这件事，而不是仅仅……

487
00:17:56,880 --> 00:18:04,000
让我们盲目地学习 CUDA 吧，看起来似乎…… 

488
00:17:59,559 --> 00:18:05,960
有点天真，嗯，所以带着（某种状态或想法）进入它 

489
00:18:04,000 --> 00:18:07,919
就像明白之后要做什么一样

490
00:18:05,960 --> 00:18:11,720
或者我认为你真正能做的是

491
00:18:07,919 --> 00:18:15,240
重要的是，嗯，再次强调，别随意……

492
00:18:11,720 --> 00:18:16,919
别……别觉得只能干坐着看啊

493
00:18:15,240 --> 00:18:19,080
看我谈论一个话题20（这里“20”后面应该还有内容，信息不完整）

494
00:18:16,919 --> 00:18:21,280
几个小时 嗯 如果你……可能会限制你的学习

495
00:18:19,080 --> 00:18:23,080
你只是强迫自己坐下来，然后

496
00:18:21,280 --> 00:18:25,400
然后就只是看着、听着关于什么的内容

注：原英文句子不完整，此翻译基于现有内容进行。 

497
00:18:23,080 --> 00:18:26,559
我想说，嗯，我确实鼓励你去。

498
00:18:25,400 --> 00:18:27,760
深入探究各种问题，所以如果你发现

499
00:18:26,559 --> 00:18:30,159
这件事中让你感兴趣的东西

500
00:18:27,760 --> 00:18:31,120
部分或者其他部分，就完全只是…… 

501
00:18:30,159 --> 00:18:34,080
到那边去，那就是你该去的地方。

注：原英文句子似乎不太完整或表述不太规范，以上翻译是基于常见表达逻辑进行的推测。 

502
00:18:31,120 --> 00:18:36,159
学到了很多，对，嗯，但不管怎样，我已经

503
00:18:34,080 --> 00:18:39,200
我已将其整理成了几个（部分/类别等，需结合上下文确定更合适表述）

504
00:18:36,159 --> 00:18:42,400
部分，所以进行研究

505
00:18:39,200 --> 00:18:43,559
生产，嗯，低水平推理用于

506
00:18:42,400 --> 00:18:45,640
边缘；边缘地带；优势；刀刃；边线；棱；边缘部分
（这里“Edge”是个多义词，需结合具体语境选择合适的释义） 

507
00:18:43,559 --> 00:18:48,559
计算……的便利性

508
00:18:45,640 --> 00:18:51,559
使用编译器以及

509
00:18:48,559 --> 00:18:54,280
杂项
所以我们从顶部开始

510
00:18:51,559 --> 00:18:57,280
这些是简单的，我们有 PyTorch

511
00:18:54,280 --> 00:18:58,960
我们有粒子流
我们有Jacks和Fireship

512
00:18:57,280 --> 00:19:01,280
有关于所有这些内容的视频 这些非常……

（原英文句子似乎不完整）

513
00:18:58,960 --> 00:19:02,440
有充分记录的 嗯 我会让你知道的

514
00:19:01,280 --> 00:19:03,720
你差不多可以直接通读一遍

515
00:19:02,440 --> 00:19:05,240
这些 我不会逐一详细讲解每一个

516
00:19:03,720 --> 00:19:09,960
单个项目符号，因为它已经

517
00:19:05,240 --> 00:19:12,919
这里，嗯，但没错，你有，你有MLX。

518
00:19:09,960 --> 00:19:15,240
由苹果公司为苹果硅芯片开发

519
00:19:12,919 --> 00:19:17,679
开源，呃，针对苹果公司的

520
00:19:15,240 --> 00:19:20,000
设备 P，火炬闪电就像 P

521
00:19:17,679 --> 00:19:21,280
火炬（这里推测“torch”可能指深度学习框架PyTorch），但减少了样板代码，因此

522
00:19:20,000 --> 00:19:23,120
这里有一篇Reddit上的帖子，它是

523
00:19:21,280 --> 00:19:25,640
有意思，嗯，当你做……就像当你……

524
00:19:23,120 --> 00:19:28,520
设置为你想要的TF32精度来操作

525
00:19:25,640 --> 00:19:30,720
PyTorch 中的张量核心计算

526
00:19:28,520 --> 00:19:31,720
嗯，就像那是样板代码，所以小菜一碟

527
00:19:30,720 --> 00:19:32,919
实际上，PyTorch Lightning 将会

528
00:19:31,720 --> 00:19:34,880
减少那个，它就会被移除

529
00:19:32,919 --> 00:19:36,159
那些样板内容，这样你就不用自己弄了

530
00:19:34,880 --> 00:19:38,840
担心，比如包括所有那些

531
00:19:36,159 --> 00:19:42,320
小的优化以及以及以及呃还有

532
00:19:38,840 --> 00:19:43,960
技巧，所以谈到制作方面

533
00:19:42,320 --> 00:19:46,000
通常有两件事是这样的

534
00:19:43,960 --> 00:19:48,039
那些落在这儿的，这样你就有训练了

535
00:19:46,000 --> 00:19:49,799
以及推理，其中一些将会

536
00:19:48,039 --> 00:19:52,200
一起支持他们当中的两个，其中一些

537
00:19:49,799 --> 00:19:56,280
他们中有些人只会支持其中一方

538
00:19:52,200 --> 00:19:58,799
嗯，所以在这里我们有虚拟机（VM），它相当…… 

539
00:19:56,280 --> 00:20:01,360
有意思，嗯

540
00:19:58,799 --> 00:20:06,440
在……上搜索“黑人的命也是命”运动

注：“BLM”是“Black Lives Matter”的缩写，即“黑人的命也是命”运动，是一场于2013年在美国兴起的黑人民权运动。由于原句“search a BLM on”表述不太完整，这里按照一般的理解进行了翻译。 

541
00:20:01,360 --> 00:20:06,440
GitHub 实际上宕机了，而且我们能看到

542
00:20:06,520 --> 00:20:13,720
嗯，它去哪儿了？对，LM印记和

543
00:20:10,200 --> 00:20:16,559
上菜之后，然后它去了哪里

544
00:20:13,720 --> 00:20:19,039
性能 是啊，所以是性能

545
00:20:16,559 --> 00:20:20,320
与Tensor RT进行基准测试，其中Tensor RT是

546
00:20:19,039 --> 00:20:22,280
接下来我要实际谈论的那个

547
00:20:20,320 --> 00:20:24,600
大概就在这儿，嗯，但他们……他们实施了一个

548
00:20:22,280 --> 00:20:26,919
一堆类似的，非常类似的，本质上类似的

549
00:20:24,600 --> 00:20:29,400
我们可能会进行的硬件 GPU 优化

550
00:20:26,919 --> 00:20:32,640
稍后再谈 嗯

551
00:20:29,400 --> 00:20:36,240
但是“黑人的命也是命”运动很棒，嗯，Tensor RT相当…… 

552
00:20:32,640 --> 00:20:38,480
英伟达的大量张量运行时，并且他们

553
00:20:36,240 --> 00:20:40,400
有一个张量RT语言模型，所以它是用于像……这样的情况 

554
00:20:38,480 --> 00:20:42,159
用所有的（方式/工具等，需结合上下文明确）来对语言模型进行推理

555
00:20:40,400 --> 00:20:45,679
这些，你知道所有这些不同的（事物）

556
00:20:42,159 --> 00:20:47,440
针对大语言模型（LLM）的优化，嗯，具体而言

557
00:20:45,679 --> 00:20:51,159
推理；推断；推论

558
00:20:47,440 --> 00:20:53,159
现在，海卫一，海卫一是我们所……的东西 

559
00:20:51,159 --> 00:20:55,320
实际上要多讲一些《创：战纪》（或《电子世界争霸战》相关内容，具体需结合语境确定）的内容了

560
00:20:53,159 --> 00:20:56,960
由开放之眼（Open Eye）开发 我们到这儿了

561
00:20:55,320 --> 00:20:59,360
你可以看到

562
00:20:56,960 --> 00:21:01,039
这个，呃，它会告诉你关于……比如……什么的……

563
00:20:59,360 --> 00:21:03,520
哎呀，海卫一（特里同）就像是，动机是什么呢

564
00:21:01,039 --> 00:21:05,320
是它的来源之处 嗯 但如果我们看看

565
00:21:03,520 --> 00:21:08,559
在这篇来自哈佛的论文里，这是

566
00:21:05,320 --> 00:21:09,960
实际上，海卫一究竟起源于何处呢

567
00:21:08,559 --> 00:21:11,600
尝试一种中间语言，并且

568
00:21:09,960 --> 00:21:13,480
儿童神经网络编译器

569
00:21:11,600 --> 00:21:15,400
计算 儿童神经网络

570
00:21:13,480 --> 00:21:16,840
计算在这里是关键，这是

571
00:21:15,400 --> 00:21:18,120
很多性能由此而来

572
00:21:16,840 --> 00:21:21,000
从 稍后当……的时候你会看到这个

573
00:21:18,120 --> 00:21:23,039
我们构建快速算法，平铺算法的关键在于…… 

574
00:21:21,000 --> 00:21:25,120
你有一个类似巨大的问题，在……的情况下（这里“where”后面内容缺失，翻译只能处理到现有文本） 

575
00:21:23,039 --> 00:21:27,600
你得去学线性代数。

576
00:21:25,120 --> 00:21:31,360
像对张量进行的操作，而且你有

577
00:21:27,600 --> 00:21:33,840
快速地并行完成它们，呃，并行地完成

578
00:21:31,360 --> 00:21:35,840
像GPU这样的处理器，那么你可以

579
00:21:33,840 --> 00:21:37,279
你要做的是你可以将矩阵平铺成一个

580
00:21:35,840 --> 00:21:40,520
一堆小方块似的东西

581
00:21:37,279 --> 00:21:42,640
子方块，而且你可以，你可以进行乘法运算

582
00:21:40,520 --> 00:21:44,720
把它们放在一起，这样你就不会有

583
00:21:42,640 --> 00:21:46,400
一次性做完一整件事，并且

584
00:21:44,720 --> 00:21:48,000
然后预订它，并且担心所有的事情

585
00:21:46,400 --> 00:21:50,760
你实际上可以直接选中那些东西

586
00:21:48,000 --> 00:21:53,760
块以及并行处理器在

587
00:21:50,760 --> 00:21:55,320
CUDA在处理方面极其出色

588
00:21:53,760 --> 00:21:56,720
那些因CUDA而产生的模块（此处“blocks”可根据具体语境灵活翻译，如“块、区块”等）

589
00:21:55,320 --> 00:22:00,120
我们将讨论的建筑

590
00:21:56,720 --> 00:22:01,480
稍后 嗯 但是 但是尝试一下 这很有趣

591
00:22:00,120 --> 00:22:03,400
是一整篇论文，而我不打算（看/处理等，需结合上下文确定具体语义）

592
00:22:01,480 --> 00:22:07,480
在这门课程中深入探究，但有很多

593
00:22:03,400 --> 00:22:09,760
有意思，呃，编译器和你都挺有意思的（注：原英文表述不太常规和完整，此为结合大概语义的翻译） 

594
00:22:07,480 --> 00:22:12,120
了解你从……中获得的速度提升

595
00:22:09,760 --> 00:22:13,960
以一种倾斜的方式处理事情

注：原文 “a with a” 可能有误，推测正确表述可能是 “a tilted”  。 

596
00:22:12,120 --> 00:22:15,520
嗯

597
00:22:13,960 --> 00:22:18,120
哲学

598
00:22:15,520 --> 00:22:20,679
现在只是一些其他的优化

599
00:22:18,120 --> 00:22:23,520
我们会参与演出，表演项目是火炬秀（此句原文可能存在表述不清晰或错误之处，这样翻译是基于大致语义猜测）

600
00:22:20,679 --> 00:22:26,640
编译，所以你要进行 PyTorch 编译，并且

601
00:22:23,520 --> 00:22:28,600
然后 （模型）

602
00:22:26,640 --> 00:22:31,120
而这实际上只会增加

603
00:22:28,600 --> 00:22:32,880
开箱即用性能提升 30%，它会……

604
00:22:31,120 --> 00:22:34,960
拿着那个由P torch生成的动态图

605
00:22:32,880 --> 00:22:36,760
构建，并且它会静态地进行，它会卡住 

606
00:22:34,960 --> 00:22:38,360
将它转化为一种静态的呈现形式用于

607
00:22:36,760 --> 00:22:40,480
生产，因为我们正将其用于

608
00:22:38,360 --> 00:22:43,240
生产，呃，而且它会起作用的

609
00:22:40,480 --> 00:22:44,760
全方位的优化，嗯，这些我们……

610
00:22:43,240 --> 00:22:46,559
会更深入地钻研这门课程，就像一个…… 

611
00:22:44,760 --> 00:22:48,200
例子可以是像内核融合这样的情况。

612
00:22:46,559 --> 00:22:50,400
在那里，而不是你知道的去做一件

613
00:22:48,200 --> 00:22:51,720
为每一步分别设置一个函数

614
00:22:50,400 --> 00:22:53,960
你就像是把两三个（事物）融合在了一起

615
00:22:51,720 --> 00:22:55,760
将多个操作整合为一个单一的函数，呃

616
00:22:53,960 --> 00:22:58,159
并且那样能减少一些开销……（这里“comp”可能不完整，推测可能是某个特定术语，但由于信息不足，无法准确完整翻译）

617
00:22:55,760 --> 00:22:59,440
你必须在那里进行的计算，所以

618
00:22:58,159 --> 00:23:00,960
呃，就一堆这些小的……

619
00:22:59,440 --> 00:23:02,640
torch talk编译的优化

620
00:23:00,960 --> 00:23:05,159
呃，极力推荐用于…… 

621
00:23:02,640 --> 00:23:07,159
在生产环境中，呃，Torch Script有点…… 

622
00:23:05,159 --> 00:23:09,679
年代久一些，但这里有一篇关于……的文章

623
00:23:07,159 --> 00:23:11,799
Torch脚本

624
00:23:09,679 --> 00:23:15,120
那么，手电筒

625
00:23:11,799 --> 00:23:16,559
脚本，呃，实际上我还没使用过，不过

626
00:23:15,120 --> 00:23:18,480
这里还有一些更多的讨论。

627
00:23:16,559 --> 00:23:20,240
你可以跟着做 嗯 我知道这是个

628
00:23:18,480 --> 00:23:22,120
年纪稍大一些，所以我通常就只能依靠

629
00:23:20,240 --> 00:23:23,880
对于大多数事情来说，进行托尔冲击编译

注：“Tor shock comp pile”可能并不是准确的英文表达，“comp pile”可能是“compile”拼写错误，推测是结合特定专业领域的表述，此翻译仅基于字面内容处理。 

630
00:23:22,120 --> 00:23:26,240
嗯，但它在这儿，以防你需要。

631
00:23:23,880 --> 00:23:27,520
那之后，玛瑙运行时也是

632
00:23:26,240 --> 00:23:29,640
有意思，我或许应该…… 

633
00:23:27,520 --> 00:23:32,400
在 Onyx 运行时之前放置了 Onyx，但它

634
00:23:29,640 --> 00:23:35,080
事情就是这样 嗯 玛瑙运行时相当…… 

635
00:23:32,400 --> 00:23:37,120
很多东西在玛瑙石上面，所以你有这个

636
00:23:35,080 --> 00:23:39,000
这个叫做玛瑙（Onyx）的东西，它导出一个

637
00:23:37,120 --> 00:23:40,279
来自 PyTorch 或 Tensor 的模型

638
00:23:39,000 --> 00:23:44,520
把你想要的任何东西都归结到这一点上

639
00:23:40,279 --> 00:23:44,520
玛瑙石格式，具有互操作性

640
00:23:58,600 --> 00:24:02,919
呃，它就像是一种奥尼克斯文件扩展名，那个……

641
00:24:00,480 --> 00:24:06,600
你用来存储神经网络，呃……

642
00:24:02,919 --> 00:24:08,799
权重和张量，所以，呃，ONNX运行时

643
00:24:06,600 --> 00:24:12,360
本质上是利用那个并让你能够

644
00:24:08,799 --> 00:24:14,400
让它运行得更快些
所以那是由……建造的

645
00:24:12,360 --> 00:24:16,400
微软，呃，然后还有个挺酷的小……

646
00:24:14,400 --> 00:24:18,960
我偶然遇到的项目，还有那个聊天机器人（这里“chat jbt”推测可能是“chat bot”拼写有误）

647
00:24:16,400 --> 00:24:21,679
我推荐投入到这门课程中的是

648
00:24:18,960 --> 00:24:25,080
Detectron 2 
所以呢，这挺有趣的

649
00:24:21,679 --> 00:24:27,159
你可能会觉得它有用，但嗯

650
00:24:25,080 --> 00:24:30,159
由脸书开发，而且它是

651
00:24:27,159 --> 00:24:33,080
本质上是一个计算机视觉库

652
00:24:30,159 --> 00:24:35,520
它使用，呃，图像检测以及

653
00:24:33,080 --> 00:24:37,720
分割算法

654
00:24:35,520 --> 00:24:39,320
所以只是一堆非常酷的东西

655
00:24:37,720 --> 00:24:41,799
它有很多计算机视觉方面的东西

656
00:24:39,320 --> 00:24:44,559
不同的神经网络架构

657
00:24:41,799 --> 00:24:45,640
以及它所使用的帽子，而且仅仅是

658
00:24:44,559 --> 00:24:48,679
那些你可能会觉得有趣的事情之一

659
00:24:45,640 --> 00:24:50,320
想和嗯……随便玩玩，然后我们就走

660
00:24:48,679 --> 00:24:53,480
到低水平，这就是这门课程（的情况） 

661
00:24:50,320 --> 00:24:55,080
基于 以防你还没读过那（部分内容） 

662
00:24:53,480 --> 00:24:58,039
标题显示出来了

663
00:24:55,080 --> 00:25:01,039
CUDA 呃，CUDA 是计算统一设备

664
00:24:58,039 --> 00:25:03,159
建筑师 厄尔 呃 编程语言 呃

665
00:25:01,039 --> 00:25:05,039
更适合英伟达的编程平台

666
00:25:03,159 --> 00:25:07,600
显卡，嗯，还有一堆东西

667
00:25:05,039 --> 00:25:11,600
我们稍后会深入探讨这个问题。

668
00:25:07,600 --> 00:25:13,360
嗯，对于 AMD 显卡而言，相当于（UM Rock M）的产品以及

669
00:25:11,600 --> 00:25:17,399
然后你有了OpenCL，所以这更……

670
00:25:13,360 --> 00:25:19,360
通用的，呃，为中央处理器（CPUs）、图形处理器（GPUs），呃，数字信号处理器（DSPs）而构建

671
00:25:17,399 --> 00:25:21,399
其他类型的硬件，所以就像一个

672
00:25:19,360 --> 00:25:24,960
通用计算语言 开放

673
00:25:21,399 --> 00:25:27,000
开源，嗯，然后我们有Edge（浏览器）。

674
00:25:24,960 --> 00:25:28,919
计算与嵌入式系统，那么……什么呢

675
00:25:27,000 --> 00:25:32,159
边缘计算到底是什么意思呢？

676
00:25:28,919 --> 00:25:35,240
边缘计算，嗯，想想特斯拉

677
00:25:32,159 --> 00:25:38,080
特斯拉拥有的车队，所以有很多 

678
00:25:35,240 --> 00:25:39,399
那些可能会撞上……的汽车

679
00:25:38,080 --> 00:25:42,320
偶尔会发生事故，所以他们想要

680
00:25:39,399 --> 00:25:43,840
将此情况反馈给特斯拉数据部门

681
00:25:42,320 --> 00:25:46,640
集中精力进行训练并提升……

（这里文本似乎不完整，“the”后面应该还有内容） 

682
00:25:43,840 --> 00:25:48,240
模型，所以你会有很多这样的模型

683
00:25:46,640 --> 00:25:49,640
本质上，这支舰队以及

684
00:25:48,240 --> 00:25:51,480
边缘计算的目的是拥有

685
00:25:49,640 --> 00:25:52,799
他们每个人都在做自己的事 

686
00:25:51,480 --> 00:25:55,000
他们自己的当地的

687
00:25:52,799 --> 00:25:56,360
计算，然后无论什么时候你在做……

注：原英文文本似乎不完整。 

688
00:25:55,000 --> 00:25:58,480
一条更新内容，你就打算就这么发出去？ 

689
00:25:56,360 --> 00:26:01,240
回来，而且你能够拥有像……这样的东西 

690
00:25:58,480 --> 00:26:02,840
一个中心化的实体，我猜这个……

691
00:26:01,240 --> 00:26:04,360
集中式数据中心是我们的实体

692
00:26:02,840 --> 00:26:06,039
在这里，它只是要做一些

693
00:26:04,360 --> 00:26:09,200
对所有那些、所有那些新的内容进行训练

694
00:26:06,039 --> 00:26:10,799
数据，呃，差不多就是这些了

695
00:26:09,200 --> 00:26:14,520
这，这就像一个去中心化的（东西） 

696
00:26:10,799 --> 00:26:16,760
如果你愿意的话，来谈谈计算方面的内容，嗯，所以你知道，你

697
00:26:14,520 --> 00:26:18,919
呃，你有类似 TensorFlow Lite 这样的东西吗

698
00:26:16,760 --> 00:26:20,320
这就像是一个精简版的…… 

699
00:26:18,919 --> 00:26:23,679
TensorFlow的轻量级版本以及

700
00:26:20,320 --> 00:26:25,159
那么 PyTorch Mobile 是一回事儿，嗯

701
00:26:23,679 --> 00:26:27,320
我的意思是，总会有优化的办法。

702
00:26:25,159 --> 00:26:29,159
你可以在CUDA里完成，就像普通的那样

703
00:26:27,320 --> 00:26:31,440
派火炬（此处“pie torch”可能表意不明，结合语境理解），那只会让事情运转起来

704
00:26:29,159 --> 00:26:34,240
不管怎样都很快，但有 Py 移动版（注：这里“Py”表意不明，可能是某个特定的名称）

705
00:26:31,440 --> 00:26:37,600
嗯，然后你有科勒（这里“corl”可能有误，推测是某个特定名称，若有正确信息可替换），它是

706
00:26:34,240 --> 00:26:40,279
适用于苹果产品，比如 macOS 系统

707
00:26:37,600 --> 00:26:43,679
一直看电视

注：原文“watch TV all this”表述不太准确，推测可能想说“watch TV all this time” 之类的表达，但按照要求仅给出字面直翻。 

708
00:26:40,279 --> 00:26:45,480
嗯，然后你会考虑到易用性，但实际上它并不具备（这里原文“which isn't”表意不太完整，可结合上下文理解，暂时按此翻译） 

709
00:26:43,679 --> 00:26:46,919
完全和CUDA相关，但我当时想

710
00:26:45,480 --> 00:26:49,520
我还是会提及此事，因为有些

711
00:26:46,919 --> 00:26:51,559
这些真的太棒了，所以你有呃

712
00:26:49,520 --> 00:26:53,799
你有快速的人工智能，而我不会（拥有/使用，需结合上下文确定） 

713
00:26:51,559 --> 00:26:56,559
说了很多，但你可以，你能行

714
00:26:53,799 --> 00:26:59,559
听着，也许你可以调查一下这个。 

715
00:26:56,559 --> 00:27:03,960
分开来说，嗯，所以他们有他们自己的

716
00:26:59,559 --> 00:27:03,960
他们在这里有自己的一套做法，但是

717
00:27:04,720 --> 00:27:10,080
嗯，是的，我不会去的，我不会去的。

718
00:27:06,799 --> 00:27:12,120
快速浏览一下快速人工智能，但他们，呃，他们有

719
00:27:10,080 --> 00:27:15,080
一些有趣的

720
00:27:12,120 --> 00:27:17,840
我们之前聊过的玛瑙相关的东西

721
00:27:15,080 --> 00:27:19,480
代表开放神经网络交换

722
00:27:17,840 --> 00:27:21,720
所以这个“x”是大写的，而那就是……的地方 

723
00:27:19,480 --> 00:27:26,880
X 来自于，呃，实际上你只要去做就行了

724
00:27:21,720 --> 00:27:28,720
托尔萨玛瑙。导出模型，嗯，然后

725
00:27:26,880 --> 00:27:30,399
虚假输入，然后随便怎样都行

726
00:27:28,720 --> 00:27:32,399
文件名是这样的，这样你可以多看看。

727
00:27:30,399 --> 00:27:34,279
进入火炬码头以及玛瑙号该如何（此处语义不太完整，原文可能表述不完整）

728
00:27:32,399 --> 00:27:36,320
在 PyTorch （推测你想表达的是 PyTorch，这里原文本“P torch”可能有误）上都要这样做以及 

729
00:27:34,279 --> 00:27:38,840
TensorFlow以及其他你想要的任何东西

730
00:27:36,320 --> 00:27:41,159
但这就是你导出玛瑙文件（这里“onyx”具体含义需结合语境，它常见有“玛瑙”之意，也可能是特定软件、设备等的名称）的方法。 

731
00:27:38,840 --> 00:27:43,440
格式

732
00:27:41,159 --> 00:27:45,960
嗯，然后这就是张量 FL

733
00:27:43,440 --> 00:27:47,880
等同的，所以本质上就是这个

734
00:27:45,960 --> 00:27:49,519
就像我拿到的那张不错的小图片，它在……

735
00:27:47,880 --> 00:27:53,159
就好像它能和所有东西都结合起来，所以

736
00:27:49,519 --> 00:27:55,360
这似乎并不是一个有实际意义的英文句子，可能存在拼写错误，勉强翻译如下：
P 到托尔 流动 鲫鱼 嗯 C 咖啡馆 哪个

737
00:27:53,159 --> 00:27:58,559
最初P火炬是什么样的 

738
00:27:55,360 --> 00:28:01,799
使用嗯，咖啡馆是其中一家，咖啡馆是其中一家

739
00:27:58,559 --> 00:28:05,360
那些呃，PyTorch里的原始部分

740
00:28:01,799 --> 00:28:06,640
生态系统 嗯，是之前一段时间的 嗯，所以

741
00:28:05,360 --> 00:28:08,559
那那在某种程度上正好表明了他们是怎样的

742
00:28:06,640 --> 00:28:11,200
可以相互连接，只要你愿意

743
00:28:08,559 --> 00:28:13,240
以其中一种格式导出，然后你就可以

744
00:28:11,200 --> 00:28:15,760
将其重新导入到这些中的任意一个里，呃

745
00:28:13,240 --> 00:28:17,880
再加上可运行的玛瑙（Onyx）运行时环境

746
00:28:15,760 --> 00:28:20,720
更快一些，然后你还有哑铃，并且……（注：原文似乎不完整，“and”后面可能还有内容） 

747
00:28:17,880 --> 00:28:22,159
偏见 所以我从……截取了一小段内容 

748
00:28:20,720 --> 00:28:24,600
互联网就像这看起来的样子

749
00:28:22,159 --> 00:28:25,799
但基本上可以让你进行追踪

750
00:28:24,600 --> 00:28:27,519
你的训练跑步以及一堆

751
00:28:25,799 --> 00:28:30,360
关于……的不同图表和统计数据

752
00:28:27,519 --> 00:28:32,360
你的模型表现如何呢，呃……

753
00:28:30,360 --> 00:28:35,399
当我在做……比如当我想训练的时候

754
00:28:32,360 --> 00:28:37,480
就像一种服装识别

755
00:28:35,399 --> 00:28:39,919
模特 说真的，这些我都能拥有

756
00:28:37,480 --> 00:28:42,480
不同的款式，所以凉鞋的精准度（方面）

注：由于原文“accuracy on sandals”表述不太清晰，这样的翻译只是基于字面意思，可能需要结合更多上下文来准确理解其含义。 

757
00:28:39,919 --> 00:28:43,840
衬衫 裤子 套头衫 靴子 对

758
00:28:42,480 --> 00:28:47,600
布茨有点混乱，而且

759
00:28:43,840 --> 00:28:49,279
套头衫之类的做起来还挺快的，嗯

760
00:28:47,600 --> 00:28:50,799
然后这个也是，这样你就可以有点……

761
00:28:49,279 --> 00:28:52,279
只需追踪一堆事情，并且

762
00:28:50,799 --> 00:28:53,679
理解你的模型是什么样的以及如何运作

763
00:28:52,279 --> 00:28:55,679
进行表演，然后向……展示那种喜欢的感觉 

764
00:28:53,679 --> 00:28:57,200
也许你的……也许你的呃雇主

765
00:28:55,679 --> 00:29:00,159
无论是什么或者是谁，也许是你的

766
00:28:57,200 --> 00:29:02,159
经理，然后把事情处理好

767
00:29:00,159 --> 00:29:04,159
通过那种方式可以轻松地记录事情

768
00:29:02,159 --> 00:29:06,799
无需使用相同的 Matplotlib 绘图工具（注：这里“matap”可能是“matplotlib”拼写错误）

769
00:29:04,159 --> 00:29:10,279
呃，这一切差不多都被记录下来了，而且

770
00:29:06,799 --> 00:29:11,880
为你导入并处理好了，嗯

771
00:29:10,279 --> 00:29:13,360
然后是云服务提供商，这些是

772
00:29:11,880 --> 00:29:15,120
实际上，知道……并非相当重要

773
00:29:13,360 --> 00:29:16,720
必然是在类似……的低层次部分上

774
00:29:15,120 --> 00:29:18,200
Cuda 但了解这些仍然是有好处的

775
00:29:16,720 --> 00:29:22,159
因为它们在……中起着重要作用

776
00:29:18,200 --> 00:29:24,720
生态系统 嗯，你有亚马逊云服务（AWS），所以AWS是一个

777
00:29:22,159 --> 00:29:26,159
主要的一个，我个人使用亚马逊网络服务（AWS）的…… 

778
00:29:24,720 --> 00:29:28,960
产品并更喜欢它们 我不是

779
00:29:26,159 --> 00:29:31,640
支持，不是赞助他们，而是

780
00:29:28,960 --> 00:29:34,840
嗯，他们没有给我赞助，但我确实在用广告。 

781
00:29:31,640 --> 00:29:37,799
美国产品，呃，主要有两样东西

782
00:29:34,840 --> 00:29:39,440
这里用于机器学习相关事务的是EC2实例，所以

783
00:29:37,799 --> 00:29:41,720
这些几乎是通用的，你只要

784
00:29:39,440 --> 00:29:43,600
就像启动一台远程机器一样，你可以做到

785
00:29:41,720 --> 00:29:45,240
通过 SSH 连接到它，然后做你想做的任何事

786
00:29:43,600 --> 00:29:47,360
想要，并且你可以使用所有像这样的规格。 

787
00:29:45,240 --> 00:29:49,480
这实际上是，呃，命令行访问权限

788
00:29:47,360 --> 00:29:51,399
而且你可以做任何你想做的事，嗯

789
00:29:49,480 --> 00:29:53,679
然后你有了 SageMaker，所以它是一个

790
00:29:51,399 --> 00:29:55,399
稍微容易一些，并且更聚焦于机器学习

791
00:29:53,679 --> 00:29:57,159
但你可以在一个（设备/平台等，此处原文未完整给出）上运行 Jupyter 笔记本

792
00:29:55,399 --> 00:29:58,640
集群，所以与其担心一个

793
00:29:57,159 --> 00:30:01,760
命令行，还得去启动（这里“having having”可能有误，推测可能是“having”重复了） 

794
00:29:58,640 --> 00:30:02,519
在像……呃，在 VS Code 里，就像在 VSS 里那样把事情搞定

795
00:30:01,760 --> 00:30:05,519
代码

796
00:30:02,519 --> 00:30:08,039
SSH 你只要，呃，运行一个 Jupyter 笔记本

797
00:30:05,519 --> 00:30:10,600
真的就像在浏览器里那样，或者你可以

798
00:30:08,039 --> 00:30:14,600
呃，只需通过 SSH 连接到呃 亚马逊 SageMaker 服务

799
00:30:10,600 --> 00:30:16,960
笔记本，我想，嗯，然后你有……

800
00:30:14,600 --> 00:30:19,159
呃，数据标注部分，这是

801
00:30:16,960 --> 00:30:20,360
在当今世界非常庞大，那么在哪里

802
00:30:19,159 --> 00:30:22,440
所有的数据都来自于我们所在的……吗？

（原句似乎不完整，这样的翻译是基于现有内容尽量通顺表达） 

803
00:30:20,360 --> 00:30:25,679
在……上训练模型 嗯，这恰恰是

804
00:30:22,440 --> 00:30:27,159
它在哪里，嗯，如果你使用亚马逊云科技（AWS）的 SageMaker 服务

805
00:30:25,679 --> 00:30:29,720
然后你会找到类似那种标签标注的东西

806
00:30:27,159 --> 00:30:31,919
我相信是土耳其人，部分原因或者是出于某种机制（此处原英文表意不太清晰） 

807
00:30:29,720 --> 00:30:34,880
这就叫信念，那就是……（此处原文表述不太完整，译文根据大致语义呈现）

808
00:30:31,919 --> 00:30:37,919
所有在亚马逊云科技（AWS）上的标记操作都会发生

809
00:30:34,880 --> 00:30:39,440
所以，呃，你知道那里有重要的事情呢，呃

810
00:30:37,919 --> 00:30:41,679
通常要花相当多的（钱）。 

811
00:30:39,440 --> 00:30:43,559
花钱雇人给你的东西贴标签，但是

812
00:30:41,679 --> 00:30:45,640
那……那就是你找到它的地方，嗯，还有

813
00:30:43,559 --> 00:30:47,279
然后是模型训练和部署，你

814
00:30:45,640 --> 00:30:48,760
那 那也得到了塞奇的支持

815
00:30:47,279 --> 00:30:50,559
制作者，所以你想部署你的

816
00:30:48,760 --> 00:30:53,799
拥有 llama 3 变体，就像去那里一样

817
00:30:50,559 --> 00:30:56,159
你使用 SageMaker（亚马逊云科技的机器学习服务）嗯，然后是谷歌云 我

818
00:30:53,799 --> 00:30:58,679
不要像他们那样使用那么多，他们有顶点 Ai

819
00:30:56,159 --> 00:31:01,080
还有他们那大概两台虚拟机

820
00:30:58,679 --> 00:31:02,480
等同的话，那么你有微软 Azure

821
00:31:01,080 --> 00:31:05,039
实际上我并没有怎么用过它

822
00:31:02,480 --> 00:31:06,279
所以，嗯，这就跟另外一次前三名的情况一样

823
00:31:05,039 --> 00:31:07,919
就像这些是……中的前三名选手

824
00:31:06,279 --> 00:31:10,799
生态系统，然后你就有点破坏了 

825
00:31:07,919 --> 00:31:12,559
向下到OpenAI、Fast AI和Lambda Labs

826
00:31:10,799 --> 00:31:14,200
所以OpenAI提供了他们自己类似的（东西） 

827
00:31:12,559 --> 00:31:15,679
微调服务，并且你可以，你（此翻译感觉原英文表述较奇怪，可能有表述不完整或有误的情况） 

828
00:31:14,200 --> 00:31:17,000
要知道，每个人都知道OpenAI，你可以

829
00:31:15,679 --> 00:31:18,760
直接登录那个网站，然后就

（这里句子似乎没说完，如果有完整内容可以继续提供以便更准确翻译） 

830
00:31:17,000 --> 00:31:22,080
在那里四处走走并弄清楚

831
00:31:18,760 --> 00:31:24,960
你想对模型快速做些什么呢



832
00:31:22,080 --> 00:31:28,519
人工智能 所以我还没有完全搞到一个

833
00:31:24,960 --> 00:31:29,639
这里还没有图片，但如果我去……

834
00:31:28,519 --> 00:31:32,080
在……处的贝斯；在……处的低音

（由于“bass at”这样的表述较简略，具体准确含义需结合更多语境来确定） 

835
00:31:29,639 --> 00:31:34,120
人工智能 嗯 我去……

836
00:31:32,080 --> 00:31:37,440
控制台 希望它不会暴露

837
00:31:34,120 --> 00:31:40,080
任何糟糕的事情 嗯 但就像 是的 我可以

838
00:31:37,440 --> 00:31:42,200
选择任意一个

注：“select any of” 表述并不完整，通常后面还会接具体内容，如 “select any of the options”（选择任意一个选项） 。若你能提供更完整的文本，我可以给出更贴合语境的翻译。 

839
00:31:40,080 --> 00:31:44,159
这些就像一堆装备。

840
00:31:42,200 --> 00:31:46,440
我可以按小时租用的（东西），对吧，明白（了）

841
00:31:44,159 --> 00:31:51,159
关于它们的所有规格，所有的一切，嗯，还有

842
00:31:46,440 --> 00:31:53,080
太棒了，所以你知道我装了 RTX 370 显卡。

843
00:31:51,159 --> 00:31:55,799
这就像我的显卡和我的（某个东西，结合前文此处“mine”指代不明） 

844
00:31:53,080 --> 00:31:58,120
大约每小时一美分，你懂的。

845
00:31:55,799 --> 00:32:01,360
这真的是便宜得让人不好意思了

846
00:31:58,120 --> 00:32:04,279
但是，呃，对，就是这个，哦，这个更……

847
00:32:01,360 --> 00:32:06,519
贵是贵，但没错，所以说，瓦斯蒂亚是……

848
00:32:04,279 --> 00:32:07,720
太棒了，你可以像使用任何 GPU 一样使用这些。

849
00:32:06,519 --> 00:32:09,559
你几乎可以直接选中它，然后

850
00:32:07,720 --> 00:32:10,960
在飞行中使用它，感觉就像有托管服务一样。

851
00:32:09,559 --> 00:32:14,080
被世界上某个其他人，而那个人是你

852
00:32:10,960 --> 00:32:17,240
通过 SSH 登录并执行操作自……（这里“from”后面缺少内容，所以翻译可能表意不太完整）

853
00:32:14,080 --> 00:32:19,760
嗯，然后你有兰姆达实验室，我……

854
00:32:17,240 --> 00:32:19,760
双曲正割集

855
00:32:22,200 --> 00:32:28,760
实际上在这里找到了 Lambda ，Lambda

856
00:32:25,360 --> 00:32:32,559
阴天如此

857
00:32:28,760 --> 00:32:35,399
呃，像这样的数据中心DGX系统

858
00:32:32,559 --> 00:32:37,080
实际上，你拥有布莱克威尔架构的GPU。

859
00:32:35,399 --> 00:32:41,399
你有……（由于文本不完整，此翻译可能不完全达意）

860
00:32:37,080 --> 00:32:44,120
H100系列 嗯，没错，基本上就是图形处理器

861
00:32:41,399 --> 00:32:46,440
特别是基础设施，嗯，而且它是

862
00:32:44,120 --> 00:32:48,960
我觉得比那个稍微便宜一点

（这里原英文句子似乎不完整，“the”后面应该还有内容） 

863
00:32:46,440 --> 00:32:51,720
像亚马逊网络服务（AWS）、谷歌这样的三大主要供应商以及 

864
00:32:48,960 --> 00:32:53,519
微软，呃，兰布达实验室通常

865
00:32:51,720 --> 00:32:55,480
用过的，但通常你会选择租赁物品。

866
00:32:53,519 --> 00:32:57,360
在一个集群里，所以你要支付像……这样的费用 

867
00:32:55,480 --> 00:32:59,000
成百、成千或几十

868
00:32:57,360 --> 00:33:00,919
每小时数千美元用于

869
00:32:59,000 --> 00:33:02,360
那么，如果你在一家公司里，并且

870
00:33:00,919 --> 00:33:04,480
你想尽量买得超级便宜。

871
00:33:02,360 --> 00:33:07,480
达到数据中心级别的 GPU，你

872
00:33:04,480 --> 00:33:10,159
也许可以考虑看看 Lambda

873
00:33:07,480 --> 00:33:13,559
嗯，然后是编译器，所以我并不像一个……

874
00:33:10,159 --> 00:33:15,960
编译器专家，但主要是你要去……（此处英文句子不完整，翻译仅供参考其已有部分） 

875
00:33:13,559 --> 00:33:18,639
有像xlaa这样的东西，所以这就是……

876
00:33:15,960 --> 00:33:21,799
正在为杰克供电，嗯，你打算……

877
00:33:18,639 --> 00:33:25,039
有逻辑卷管理器（LVM），但我不是这方面的专家，我没有（深入了解相关知识）

878
00:33:21,799 --> 00:33:26,679
构建编译器，所以嗯，我让你看看

879
00:33:25,039 --> 00:33:28,200
关于那方面有大量的资源。

880
00:33:26,679 --> 00:33:31,679
逻辑卷管理器（通常情况下“lvm”是“Logical Volume Manager”的缩写，若有其他特定语境，请根据实际情况理解） 

881
00:33:28,200 --> 00:33:35,240
嗯，它代表低级虚拟

882
00:33:31,679 --> 00:33:35,240
我相信机器

883
00:33:37,720 --> 00:33:43,080
嗯，去LVM（不太明确“LVM”具体所指，可能是某个特定的名称、缩写等）

884
00:33:40,880 --> 00:33:45,519
项目；计划；工程；课题；方案；事业；企业；专题研究；设计；规划；投掷；抛射；投射；放映；使突出；表现；体现；设想；预计；推算；让（观众）看到（自己的形象、情感等）；使呈现为；使看起来好像；把（自己的想法、情感等）加诸别人；将（自己的特点、情感等）投射到（别人身上）；发射；射出；投出；伸出；凸出

885
00:33:43,080 --> 00:33:47,480
嗯，一个用于构建……的工具包

886
00:33:45,519 --> 00:33:50,080
高度优化的编译器优化器

887
00:33:47,480 --> 00:33:53,840
以及运行时环境

888
00:33:50,080 --> 00:33:56,919
嗯，多个组件，嗯，组件

889
00:33:53,840 --> 00:34:00,760
编译 C、C++、Objective - C 和目标代码（这里原文“objective”表意不太明确，推测可能结合语境是想说目标代码之类的，若有更准确信息可进一步修正） 

890
00:33:56,919 --> 00:34:02,880
将 C++ 代码转换为 LVM 位码，嗯，然后

891
00:34:00,760 --> 00:34:05,120
转换为目标文件，所以从本质上来说

892
00:34:02,880 --> 00:34:07,799
用于用C/C++开发相关内容以及

893
00:34:05,120 --> 00:34:07,799
编译器和

894
00:34:07,839 --> 00:34:16,119
一般来说，然后你有磁量子数（ml），ml 是……

895
00:34:12,040 --> 00:34:16,119
什么是机器学习（这里ml一般指machine learning，按最常见含义翻译），看看这个

896
00:34:17,359 --> 00:34:26,320
再次，多层次中级水平

897
00:34:19,480 --> 00:34:28,440
表述，所以这是，呃，机器学习（ML）和潜在变量模型（LVM）

898
00:34:26,320 --> 00:34:31,960
主要由克里斯·弗拉特开发

899
00:34:28,440 --> 00:34:33,919
呃，我还有一门关于……的课程

900
00:34:31,960 --> 00:34:36,000
关于他所使用的编程语言（原句不太完整通顺，可能存在信息缺失）

901
00:34:33,919 --> 00:34:37,720
一家名为“模块化”的公司成立了（这里原英文可能语序不太准确，推测大致意思翻译） 

902
00:34:36,000 --> 00:34:39,399
这种编程语言叫做Mojo，你

903
00:34:37,720 --> 00:34:42,159
可以在免费代码营（Free Code Camp）上搜索那个。

904
00:34:39,399 --> 00:34:44,440
你也去学Mojo吧，但它就像一种……

905
00:34:42,159 --> 00:34:46,839
几乎只是一个人工智能编程

906
00:34:44,440 --> 00:34:48,839
用于处理类似快速张量的语言

907
00:34:46,839 --> 00:34:53,320
操作；手术；业务；作战行动

908
00:34:48,839 --> 00:34:56,320
嗯，所以这个被移动了，嗯，它是……的一部分

909
00:34:53,320 --> 00:34:58,520
LVM项目，呃，还有一些……

910
00:34:56,320 --> 00:35:01,440
那里有有趣的东西，它是，它是

911
00:34:58,520 --> 00:35:04,079
稍微新一些，所以有你

912
00:35:01,440 --> 00:35:06,800
了解有趣的、有趣的变化

913
00:35:04,079 --> 00:35:10,320
这也不是那种超级古老的东西

914
00:35:06,800 --> 00:35:12,440
嗯，但是，呃，我要说的主要的那些……

915
00:35:10,320 --> 00:35:14,359
能够谈论的就像 nvcc 那样

916
00:35:12,440 --> 00:35:17,480
那就像奥达（Auda）编译器，英伟达（Nvidia）的那种

917
00:35:14,359 --> 00:35:20,079
CUDA编译器

918
00:35:17,480 --> 00:35:21,359
嗯，你知道有一种建筑风格。

919
00:35:20,079 --> 00:35:23,960
这里，我还没有完全…… 

920
00:35:21,359 --> 00:35:25,800
还没记住呢，不过，呃，英伟达的CUDA

921
00:35:23,960 --> 00:35:27,800
编译器就是我们正在做的、我们要去做的（东西）。

922
00:35:25,800 --> 00:35:29,839
用于从本质上编译我们的

923
00:35:27,800 --> 00:35:31,560
CUDA脚本和内核，并且拥有它们

924
00:35:29,839 --> 00:35:34,839
你知道将其转换为二进制，这样我们就可以运行了

925
00:35:31,560 --> 00:35:36,440
它们很快，所以，呃，你知道这些是

926
00:35:34,839 --> 00:35:38,160
有趣 有趣的编译器

927
00:35:36,440 --> 00:35:39,680
基础设施 我可能会在此基础上再补充一些内容

928
00:35:38,160 --> 00:35:42,079
有一些关于……的更好的描述，比如

929
00:35:39,680 --> 00:35:44,200
这些是什么，但呃，这就像那个

930
00:35:42,079 --> 00:35:45,960
总体概述，然后针对……

931
00:35:44,200 --> 00:35:48,920
杂七杂八的事情 我有 我无法离开

932
00:35:45,960 --> 00:35:51,560
走出Hugging Face
所以最后但同样重要的是

933
00:35:48,920 --> 00:35:53,480
这就像抱抱脸一样，对吧，嗯，你

934
00:35:51,560 --> 00:35:56,480
可能已经知道它是什么了

935
00:35:53,480 --> 00:35:58,400
但以防万一，我还是会查一下的，所以

936
00:35:56,480 --> 00:36:02,760
在Hugging Face上你有一堆…… 

937
00:35:58,400 --> 00:36:04,720
嗯，你有模型、数据集之类的东西。 

938
00:36:02,760 --> 00:36:06,640
然后是空格，那还挺……

939
00:36:04,720 --> 00:36:08,839
你几乎需要了解的所有内容，所以如果你去的话

940
00:36:06,640 --> 00:36:12,920
给你模型


941
00:36:08,839 --> 00:36:15,119
可以，哦，也许加载需要几秒钟时间。

942
00:36:12,920 --> 00:36:18,520
嗯

943
00:36:15,119 --> 00:36:21,440
在这里，我们有跨模态计算机视觉。

944
00:36:18,520 --> 00:36:23,079
多层感知器音频表格强化学习

945
00:36:21,440 --> 00:36:24,440
然后是图机器学习，所以

946
00:36:23,079 --> 00:36:26,079
你能做很多很酷的事情

947
00:36:24,440 --> 00:36:28,119
这里，但其中大部分是语言模型

948
00:36:26,079 --> 00:36:30,359
现在，嗯，我知道，就像最近那样

949
00:36:28,119 --> 00:36:33,000
发布了一些

950
00:36:30,359 --> 00:36:35,000
我认为那是他们的形象，也许吧。

951
00:36:33,000 --> 00:36:36,520
视频生成相关的东西，我记不起来了

952
00:36:35,000 --> 00:36:38,880
具体来说，但这就是你会……的地方

953
00:36:36,520 --> 00:36:39,880
查看所有，就像新的开源模型一样

954
00:36:38,880 --> 00:36:41,839
呃，你几乎可以

955
00:36:39,880 --> 00:36:43,800
下载并运行
像在 PyTorch 中一样运行

956
00:36:41,839 --> 00:36:44,960
呃，你只需要足够的硬件

957
00:36:43,800 --> 00:36:47,359
你只需要足够好的硬件来

958
00:36:44,960 --> 00:36:48,960
运行这些，它就会正常运行的。

959
00:36:47,359 --> 00:36:50,800
嗯，然后你就有了实际的数据

960
00:36:48,960 --> 00:36:53,960
你提供的内容“sets for these models that that you” 似乎存在表述不完整或有误的情况，但按照字面翻译为：
这些模型的套装 那个 你

961
00:36:50,800 --> 00:36:57,200
对他们进行训练，所以，嗯，你知道的，你可以走了

962
00:36:53,960 --> 00:37:01,440
像三维数据集，这很有趣

963
00:36:57,200 --> 00:37:01,440
嗯，其中很多都只是文本内容

964
00:37:01,480 --> 00:37:05,599
那么，嗯，如果我移除

965
00:37:08,119 --> 00:37:13,800
是的，视觉数据很棒，自动计算功能也很棒。 

966
00:37:12,200 --> 00:37:14,920
文本 所以，所有这些 所有这些数据

967
00:37:13,800 --> 00:37:17,599
这里是那些模型所在的集合。

968
00:37:14,920 --> 00:37:19,440
在嗯上面进行训练，然后你会有空格

969
00:37:17,599 --> 00:37:21,319
这就是你实际可以使用的地方

970
00:37:19,440 --> 00:37:23,520
模特们 嗯，这就是人们会喜欢的地方

971
00:37:21,319 --> 00:37:25,640
举办活动或根据客户需求获得赞助商

972
00:37:23,520 --> 00:37:27,800
硬件设置，呃，而且他们将能够

973
00:37:25,640 --> 00:37:30,480
本质上只是托管这些模型

974
00:37:27,800 --> 00:37:32,440
你可以试用它们，然后使用它们。

975
00:37:30,480 --> 00:37:34,119
抱抱脸公司（Hugging Face）太棒了，它是一个重要的……

注：“hogging face”推测你想说的是“Hugging Face” ，这是一家人工智能技术公司。原英文句子不太完整，“it's a major”后面可能还有内容。 

976
00:37:32,440 --> 00:37:36,119
整个生态系统中的参与者，而我

977
00:37:34,119 --> 00:37:39,920
不能把它遗漏

978
00:37:36,119 --> 00:37:41,800
但是，呃，是的，差不多就是这样了。

979
00:37:39,920 --> 00:37:43,800
对于深度学习生态系统，我会关注看看

980
00:37:41,800 --> 00:37:46,920
下一个是你

981
00:37:43,800 --> 00:37:48,640
部分来说，在 Windows 系统上进行设置时，我们

982
00:37:46,920 --> 00:37:50,800
只需要打开我们的终端，然后

983
00:37:48,640 --> 00:37:53,880
以管理员身份运行 我从……开始

984
00:37:50,800 --> 00:37:56,880
Windows 呃，我们刚刚启用了权限。

985
00:37:53,880 --> 00:37:58,960
确保它是系统 32 目录

986
00:37:56,880 --> 00:38:02,520
准备导航，开到那个转弯处

987
00:37:58,960 --> 00:38:05,000
启用或关闭 Windows 功能，嗯，我们正在…… 

988
00:38:02,520 --> 00:38:08,359
打算往上滚动然后寻找

989
00:38:05,000 --> 00:38:10,079
Hyper-V 确保该框已勾选

990
00:38:08,359 --> 00:38:13,040
然后我们要去寻找虚拟的东西

991
00:38:10,079 --> 00:38:16,560
机器平台确保已检查

992
00:38:13,040 --> 00:38:18,880
关闭，然后，或者说，更确切地说是查看了，然后

993
00:38:16,560 --> 00:38:21,680
然后你就有了一个适用于……的 Windows 子系统

994
00:38:18,880 --> 00:38:24,280
Linux 要确保也勾选了那个选项

995
00:38:21,680 --> 00:38:26,839
嗯，为了让这个运行起来，你将

996
00:38:24,280 --> 00:38:28,359
需要你在你的（设备）上启用虚拟化功能

997
00:38:26,839 --> 00:38:30,160
机器；机械；机械装置；机动车；飞机；机动车辆；工具；仪器

998
00:38:28,359 --> 00:38:33,920
所以，呃，你知道一旦窗户……

999
00:38:30,160 --> 00:38:35,640
子系统已开启，你可以运行 wl.exe 并且

1000
00:38:33,920 --> 00:38:38,520
你会发现你有很多选择

1001
00:38:35,640 --> 00:38:41,520
那么安装发行版，然后我们会看到一个

1002
00:38:38,520 --> 00:38:46,119
例如，在WSL中安装发行版

1003
00:38:41,520 --> 00:38:48,280
你可以直接输入“enable”然后继续操作。

注：原英文“Yu”可能是拼写错误，推测想表达“you” 。若按原文逐字翻译，是“于我们可以继续并输入‘enable’以及”，但这样语义不通顺。上述翻译是基于合理推测给出的更符合语境的内容。 

1004
00:38:46,119 --> 00:38:50,319
我们只需等待那项工作完成。

1005
00:38:48,280 --> 00:38:53,160
我把这个稍微加快了一点速度，因为

1006
00:38:50,319 --> 00:38:54,880
这需要一些时间 呃 实际上它

1007
00:38:53,160 --> 00:38:56,720
这比你想象的几秒要花费更多时间

1008
00:38:54,880 --> 00:38:58,160
为了做到这一点，所以我会加快其中一些步骤的速度 

1009
00:38:56,720 --> 00:39:00,800
把事情搞定；整理；解决问题等（需结合具体语境准确理解，“things up”单独不是完整常见表达，一般是“sort things up”“clear things up”这类搭配） 

1010
00:38:58,160 --> 00:39:03,079
嗯，你已经被安装好了。

1011
00:39:00,800 --> 00:39:07,640
了不起的改变不会生效。

1012
00:39:03,079 --> 00:39:10,240
直到系统重启，嗯，是的，所以我们

1013
00:39:07,640 --> 00:39:14,240
再运行一次，嗯，我们有这个命令

1014
00:39:10,240 --> 00:39:16,760
它要求我们运行 WSL 可执行文件

1015
00:39:14,240 --> 00:39:18,800
安装没有进行安装操作的发行版

1016
00:39:16,760 --> 00:39:20,599
没错，嗯，而且我们得到了相同的结果。

1017
00:39:18,800 --> 00:39:23,760
再次强调，所以我们只是进行一个系统操作

1018
00:39:20,599 --> 00:39:25,319
在我们重启你之后，现在重启

1019
00:39:23,760 --> 00:39:28,839
可能会受到这样的迎接

1020
00:39:25,319 --> 00:39:31,200
终端，呃，你的英热单位（BTU），然后，呃，那个

1021
00:39:28,839 --> 00:39:32,920
另一个命令提示符，所以当你……的时候

1022
00:39:31,200 --> 00:39:34,800
如果只是有人跟你打招呼，（你会）得到那样的回应

注：原英文句子表意不太完整清晰，此翻译是尽量根据字面意思连贯表达。 

1023
00:39:32,920 --> 00:39:37,119
有了命令提示符，你就可以

1024
00:39:34,800 --> 00:39:38,800
WSL 呃，你可以进入这里，然后

1025
00:39:37,119 --> 00:39:40,440
只需输入一个用户名和一个密码

1026
00:39:38,800 --> 00:39:43,359
你现在要使用的东西，你应该（此处原英文表述不太完整通顺）

1027
00:39:40,440 --> 00:39:46,560
登录到你的那个小模拟世界里

注：原英文表述“uh”在正常书面表达中通常不会这样使用，推测是口语中的语气词，此处未做专门处理。整体句子意思可能需要结合更多上下文来更精准理解。 

1028
00:39:43,359 --> 00:39:48,160
呃，Linux 环境，所以一旦我们进入（这个环境）

1029
00:39:46,560 --> 00:39:50,760
这里有几个我们需要用到的命令

1030
00:39:48,160 --> 00:39:53,160
运行，所以我们要进行更新，并且我们

1031
00:39:50,760 --> 00:39:55,040
打算升级所有东西，所以只管输入

1032
00:39:53,160 --> 00:39:56,280
在这些命令中，正如你所看到的，有…… 

1033
00:39:55,040 --> 00:39:58,040
有些是我们能够复制的

1034
00:39:56,280 --> 00:40:00,680
然后粘贴进去，所以就结束输入那个密码

1035
00:39:58,040 --> 00:40:02,040
你之前设定了，我已经对这个进行了延时处理。 

1036
00:40:00,680 --> 00:40:04,520
没有进行延时处理，但我加快了这段（视频）的速度

1037
00:40:02,040 --> 00:40:07,480
又起来了，所以那只是一堆……

1038
00:40:04,520 --> 00:40:08,960
事情，呃，更新情况，嗯，如果我们去并且

1039
00:40:07,480 --> 00:40:11,880
安装一些其他我们会用到的软件包

1040
00:40:08,960 --> 00:40:13,560
之后需要像 WG 卷曲工具和 Git 那样的工具，我们会…… 

1041
00:40:11,880 --> 00:40:15,400
确保那些也作为一个（部分）被安装

1042
00:40:13,560 --> 00:40:18,359
更新和升级的一部分

1043
00:40:15,400 --> 00:40:20,839
命令，嗯，然后我们就进行安装

1044
00:40:18,359 --> 00:40:24,520
Python 3 pip 呃，这将只是…… 

1045
00:40:20,839 --> 00:40:28,400
本质上，Python 是为我们的机器而设计的，并且

1046
00:40:24,520 --> 00:40:30,880
呃，那个也能运行，所以那个不行 

1047
00:40:28,400 --> 00:40:33,280
显然默认就会出现，嗯，所以我们就

1048
00:40:30,880 --> 00:40:36,119
需要手动安装那个，但那是

1049
00:40:33,280 --> 00:40:37,800
好的，我们切换到 Chrome 浏览器，然后我们

1050
00:40:36,119 --> 00:40:40,000
搜索 CUDA 工具包，这是什么

1051
00:40:37,800 --> 00:40:41,680
我们正在寻找CUDA工具包下载。

1052
00:40:40,000 --> 00:40:43,800
所以你只需导航到最新的那个

1053
00:40:41,680 --> 00:40:46,560
可能是12.5
可能是12.6

1054
00:40:43,800 --> 00:40:49,640
无论对你来说是什么，去选择 Linux

1055
00:40:46,560 --> 00:40:52,160
你提供的英文文本“your architecture and use WSL you to”存在语法错误，无法准确翻译。请检查并提供正确的文本。 

1056
00:40:49,640 --> 00:40:53,839
记住，我们正在使用，呃，WSL，然后

1057
00:40:52,160 --> 00:40:55,319
直接运行文件，这是最简单的方法。

1058
00:40:53,839 --> 00:40:58,480
你最少数量的指令

不过这句话表述不太符合常见的英语表达习惯，可能存在一定的语病。 

1059
00:40:55,319 --> 00:41:01,400
不得不做 嗯 所以 所以打算去做这个

1060
00:40:58,480 --> 00:41:03,520
第一个，所以我们得到，呃，你就可以直接对了 

1061
00:41:01,400 --> 00:41:07,000
如果是普通粘贴，请在终端中点击

1062
00:41:03,520 --> 00:41:07,000
不起作用
无法正常工作 （注：“不起作用”较简洁，“无法正常工作”更详细，可按需选用） 

1063
00:41:07,720 --> 00:41:13,680
嗯，我们也许把整个部分都高亮显示一下

1064
00:41:11,400 --> 00:41:18,040
超棒的事情，所以这将会花费…… 

1065
00:41:13,680 --> 00:41:21,040
有一段时间来升级，呃，回头见

1066
00:41:18,040 --> 00:41:24,119
另一边的伙计们，好啦，现在我们要…… 

1067
00:41:21,040 --> 00:41:25,920
在那个小小的接受部分，所以仅仅只是

1068
00:41:24,119 --> 00:41:28,240
在那里勾选Cuda工具包，然后

1069
00:41:25,920 --> 00:41:31,640
那么你应该就可以顺利安装了。

1070
00:41:28,240 --> 00:41:34,280
现在我们已经完成了 runsh 文件，它是

1071
00:41:31,640 --> 00:41:35,880
命令的第二部分以及它

1072
00:41:34,280 --> 00:41:37,520
在总结中告诉我们，我们需要

1073
00:41:35,880 --> 00:41:40,960
往我们的路径里添加一些东西，所以我刚刚

1074
00:41:37,520 --> 00:41:42,800
把这个弄过来了，嗯，但这不是…… 

1075
00:41:40,960 --> 00:41:45,839
真的工作太多了，所以我离开了

1076
00:41:42,800 --> 00:41:48,960
并且生成了一些其他的，呃，你懂的

1077
00:41:45,839 --> 00:41:51,560
使用Chat GPT获取更多最新命令，呃

1078
00:41:48,960 --> 00:41:53,560
然后弄明白了，呃，那个行为，那个……

1079
00:41:51,560 --> 00:41:55,720
合适的那些；恰当的那些

1080
00:41:53,560 --> 00:41:57,079
那么你马上就会在这里看到那些东西了。

1081
00:41:55,720 --> 00:41:59,480
有一次我把它们拉了起来，但这仅仅是

1082
00:41:57,079 --> 00:42:02,359
这只是一个参考，所以这是

1083
00:41:59,480 --> 00:42:05,720
我们必须要做的事情之一就是，这样我们…… 

1084
00:42:02,359 --> 00:42:07,400
可以直接用 Vim 打开我们的 bash RC 文件，嗯

1085
00:42:05,720 --> 00:42:09,240
然后我差不多就只是打字了

1086
00:42:07,400 --> 00:42:11,680
和我一起到这儿，然后我们就……我们就……

1087
00:42:09,240 --> 00:42:13,680
保存这个文件，所以可以随意使用 Nano。

1088
00:42:11,680 --> 00:42:16,960
或者用 Vim，随便，用你想用的就行

1089
00:42:13,680 --> 00:42:19,400
我用 Vim 用得挺顺手，但

1090
00:42:16,960 --> 00:42:22,760
呃，你知道的，纳诺也不算太难搞。

1091
00:42:19,400 --> 00:42:24,680
那么要设置一个 CUDA 主目录 嗯 用户

1092
00:42:22,760 --> 00:42:29,680
本地CUDA，然后我们将

1093
00:42:24,680 --> 00:42:32,480
导出另一个，呃，叫做“path”的，并且作为

1094
00:42:29,680 --> 00:42:35,160
那段旅程的一部分 嗯 我们只是

1095
00:42:32,480 --> 00:42:37,160
本质上要包含 Cuda 主目录

1096
00:42:35,160 --> 00:42:40,760
然后是……的二进制表示

1097
00:42:37,160 --> 00:42:43,960
那个，然后最后但同样重要的是，嗯

1098
00:42:40,760 --> 00:42:47,359
我们只是要导出低密度脂蛋白（这里LD推测是Low Density的缩写，一般结合语境可能是指低密度脂蛋白，若有更准确背景信息可按需调整） 

1099
00:42:43,960 --> 00:42:47,359
图书馆，就像它在……里也说过的那样 

1100
00:42:51,000 --> 00:42:59,319
总结，然后用唇形模拟说出64来结束它

1101
00:42:55,040 --> 00:43:02,000
哇，太棒了，现在我们只需按下 Ctrl + C 键了。

1102
00:42:59,319 --> 00:43:08,040
Ctrl W 和 Ctrl

1103
00:43:02,000 --> 00:43:11,200
Q 或者 col w q，我们退出那个，嗯，然后我们

1104
00:43:08,040 --> 00:43:14,760
哦，我发现我们漏掉了一些东西，所以

1105
00:43:11,200 --> 00:43:17,000
使用 CUDA 12.5 而不只是 CUDA 嗯，所以我们

1106
00:43:14,760 --> 00:43:21,559
可以继续并再次深入研究这个，然后

1107
00:43:17,000 --> 00:43:21,559
然后只需找到那部分并添加

1108
00:43:21,800 --> 00:43:25,800
嗯，然后右键点击并粘贴那个。

1109
00:43:24,119 --> 00:43:28,480
退回去，然后只删除最后一个

1110
00:43:25,800 --> 00:43:32,559
CUDA部分很棒

1111
00:43:28,480 --> 00:43:35,079
C 12.5，不错，现在我们可以退出那个了

1112
00:43:32,559 --> 00:43:39,119
再次，并且

1113
00:43:35,079 --> 00:43:41,160
源，然后我们只需执行 nvcc 呃——版本命令

1114
00:43:39,119 --> 00:43:44,079
这就是英伟达CUDA编译器，所以

1115
00:43:41,160 --> 00:43:45,960
这正在运行，然后是英伟达的 SMI，所以

1116
00:43:44,079 --> 00:43:48,000
实际上，我们可以跟踪我们的GPU统计数据，就像这样

1117
00:43:45,960 --> 00:43:49,960
只要这两个都正常工作，嗯，我们就……

1118
00:43:48,000 --> 00:43:52,319
正确地完成了工作，所以如果你没有（做到）

1119
00:43:49,960 --> 00:43:53,240
如果你在使用 nvcc 时遇到错误

1120
00:43:52,319 --> 00:43:55,760
或者

1121
00:43:53,240 --> 00:43:58,240
NVMe 呃，那可不太好，你需要

1122
00:43:55,760 --> 00:44:01,640
要弄清楚那件事，呃，当然，我没办法做到。 

1123
00:43:58,240 --> 00:44:04,280
掩盖所有的错误，但是

1124
00:44:01,640 --> 00:44:06,559
嗯，先不说这个了，我们接着往下进行

1125
00:44:04,280 --> 00:44:07,720
并设置一个小的CUDA测试，只是为了

1126
00:44:06,559 --> 00:44:09,880
确保一切都运转正常

1127
00:44:07,720 --> 00:44:12,000
妥善地进行，并且我们能够执行一份文档

1128
00:44:09,880 --> 00:44:15,000
或者是CUDA脚本，所以我就做了一个

1129
00:44:12,000 --> 00:44:18,480
名为 cuda 安装测试的目录以及

1130
00:44:15,000 --> 00:44:19,960
我们打算用 Vim 进入那个（文件或系统之类，需结合语境）。 

1131
00:44:18,480 --> 00:44:21,559
那个目录，然后我们要进行编辑

1132
00:44:19,960 --> 00:44:23,680
我们要创建一个新的主函数。cuu

1133
00:44:21,559 --> 00:44:25,920
文件，在这里面我正要去做（此处原英文表意不太完整，“going”后可能省略了一些内容） 

1134
00:44:23,680 --> 00:44:28,599
去继续粘贴呃一些函数

1135
00:44:25,920 --> 00:44:30,319
所以，呃，我们包含了 CUDA 运行时头文件

1136
00:44:28,599 --> 00:44:32,880
我们包含了作为一部分的输入输出流

1137
00:44:30,319 --> 00:44:36,800
C++ 中允许我们使用诸如……之类的东西的（部分） 

1138
00:44:32,880 --> 00:44:39,119
我们为……声明标准命名空间 STD 

注：原文 “C out” 可能有误，推测正确表述可能是 “We” ，“C out” 表意不明，按你提供的原文严格翻译如上。 

1139
00:44:36,800 --> 00:44:42,119
为了标准，然后我们向外看到，你好

1140
00:44:39,119 --> 00:44:46,079
世界 在 我们的 主函数里 所以 如果我们

1141
00:44:42,119 --> 00:44:49,079
执行 nvcc 命令输出主二进制文件，然后

1142
00:44:46,079 --> 00:44:51,400
主文件。库，我们应该呃能够运行

1143
00:44:49,079 --> 00:44:53,920
这个二进制文件并得到“Hello World”

1144
00:44:51,400 --> 00:44:56,079
太棒了，所以如果第一次尝试这个就成功了，对于……

1145
00:44:53,920 --> 00:44:57,680
你 要是成功了那就太棒了 要是没成功那就是……

1146
00:44:56,079 --> 00:44:59,839
没那么棒，但 但你应该很棒的

1147
00:44:57,680 --> 00:45:02,040
仅通过导航就能弄明白它

1148
00:44:59,839 --> 00:45:04,440
呃，论坛，就像 GitHub 一样，我所涉及的那些东西

1149
00:45:02,040 --> 00:45:05,880
在四处浏览之前推荐

1150
00:45:04,440 --> 00:45:08,680
并弄清楚如何安装 CUDA

1151
00:45:05,880 --> 00:45:10,800
Windows 工具包 嗯，它基本上

1152
00:45:08,680 --> 00:45:13,440
这同样适用于云图 我打算

1153
00:45:10,800 --> 00:45:14,800
在这里先看一些简要说明，不过

1154
00:45:13,440 --> 00:45:16,720
我打算切换到乌班图系统。

1155
00:45:14,800 --> 00:45:18,520
因为这就是我的全部追求所在

1156
00:45:16,720 --> 00:45:19,960
基于那就是我做所有事情的地方

1157
00:45:18,520 --> 00:45:22,240
物品以及所有东西的摆放位置和

1158
00:45:19,960 --> 00:45:23,880
针对……进行了优化，所以我会在……见到你

（由于文本不完整，可能无法准确理解完整意思，以上仅按字面翻译。） 

1159
00:45:22,240 --> 00:45:26,240
另一边，如果我们可以继续并打开一个

1160
00:45:23,880 --> 00:45:27,920
在这里打开 Chrome 浏览器标签页，然后直接输入 Cuda

1161
00:45:26,240 --> 00:45:31,760
工具包下载

（注：原英文“downlo”可能拼写有误，推测完整单词是“download” ）

1162
00:45:27,920 --> 00:45:36,440
所以，我们按照你的英热单位（BTU）来选择这一个。

1163
00:45:31,760 --> 00:45:39,079
同样的情况，我们用的是 Linux x64 系统，可能是我的（问题） 

1164
00:45:36,440 --> 00:45:40,760
对你来说会不一样 嗯

1165
00:45:39,079 --> 00:45:44,839
你提供的 “YouTu this” 并不是一个符合常见英语表达习惯的短语或句子，推测可能存在拼写错误，从现有内容直译为“优兔这个” ，不过这样的表达可能并不准确表意。你可以检查一下原文是否正确。 

1166
00:45:40,760 --> 00:45:48,319
一个本地运行文件，嗯，你可以这么做

1167
00:45:44,839 --> 00:45:50,480
你也可以进行网络或本地操作，所以对于…… 

1168
00:45:48,319 --> 00:45:53,319
我呢，我做过网络方面的工作，但经验不算多。 

1169
00:45:50,480 --> 00:45:54,920
回去一段时间并且不得不卸载它

1170
00:45:53,319 --> 00:45:57,720
然后再次重新安装它，只会导致

1171
00:45:54,920 --> 00:45:59,680
我遇到了一堆奇怪的图形，呃，错误。

1172
00:45:57,720 --> 00:46:03,240
所以我不会那么做，以免把事情搞砸

1173
00:45:59,680 --> 00:46:04,559
和我的操作系统打交道太多了，但是

1174
00:46:03,240 --> 00:46:06,359
你应该能够直接插上这个

1175
00:46:04,559 --> 00:46:10,359
直接输入到终端，所以你应该是

1176
00:46:06,359 --> 00:46:17,000
能够直接到这里来，然后，呃，插上插头

1177
00:46:10,359 --> 00:46:18,200
在W里获取呃……Debian文件嗯

1178
00:46:17,000 --> 00:46:20,520
然后就是这剩下的部分以及

1179
00:46:18,200 --> 00:46:23,280
安装CUDA工具包，然后只需

1180
00:46:20,520 --> 00:46:25,720
我刚刚获取了旧版 CUDA 驱动程序

1181
00:46:23,280 --> 00:46:29,079
这是旧版的CUDA驱动程序吗，如果…… 

1182
00:46:25,720 --> 00:46:31,079
那不管用，做这个，嗯，还有

1183
00:46:29,079 --> 00:46:37,280
那么你当然会想直接去做

1184
00:46:31,079 --> 00:46:39,400
运行 um nbcc 版本，然后运行 Nvidia SMI

1185
00:46:37,280 --> 00:46:43,040
而且你应该能看到呃一些有用的东西

1186
00:46:39,400 --> 00:46:46,079
在这里弹出，所以呃，如果这些不……

1187
00:46:43,040 --> 00:46:47,559
马上为你工作 嗯 你知道的 你

1188
00:46:46,079 --> 00:46:49,160
你可能想直接重启你的电脑。

1189
00:46:47,559 --> 00:46:51,359
那通常是最好的选择，然后

1190
00:46:49,160 --> 00:46:52,559
再尝试做某件事 嗯 如果你已经在做了的话

1191
00:46:51,359 --> 00:46:54,920
把这些安装好，你甚至都没有（安装）

1192
00:46:52,559 --> 00:46:57,079
为此担心，所以我可能会

1193
00:46:54,920 --> 00:47:00,440
先检查这些，可能早该说了

1194
00:46:57,079 --> 00:47:04,319
首先，不过，呃，对，你是奥达（这里“Auda”可能是特定人名或事物名，需结合具体语境确定更准确译法） 

1195
00:47:00,440 --> 00:47:04,319
编译器能正常工作，然后是英伟达

1196
00:47:06,760 --> 00:47:13,359
SMI 所以现在我们终于可以深入探讨一些

1197
00:47:09,800 --> 00:47:15,839
编码，嗯，为了真正理解

1198
00:47:13,359 --> 00:47:18,720
如何使用CUDA，你需要先涵盖 

1199
00:47:15,839 --> 00:47:20,880
C 和 C++，所以实际上这门课程并不是

1200
00:47:18,720 --> 00:47:22,880
关于C和C++，所以我打算

1201
00:47:20,880 --> 00:47:24,359
给你们提供一些资源用于……（原句似乎不完整）

1202
00:47:22,880 --> 00:47:26,440
学习这些内容，然后我会参与进来。

1203
00:47:24,359 --> 00:47:28,440
更多一些更高级的话题 呃 只是

1204
00:47:26,440 --> 00:47:30,520
守护并审视……（此处原文“and and”可能有误，推测多了一个“and” ）

1205
00:47:28,440 --> 00:47:31,960
主题 所以对于你们当中那些新来的人来说

1206
00:47:30,520 --> 00:47:36,000
对于你们当中那些……的人来说，关于这件事

1207
00:47:31,960 --> 00:47:37,960
刚接触底层 C、C++、CUDA 编程

1208
00:47:36,000 --> 00:47:40,280
嗯，我有一些资源给你，一些

1209
00:47:37,960 --> 00:47:42,760
好文章，一些不错的，呃，东西来…… （注：原英文表述不太完整和连贯，译文也只能尽量对应） 

1210
00:47:40,280 --> 00:47:45,520
通过……来管理，并且如果你已经……

1211
00:47:42,760 --> 00:47:48,240
体验，呃，基本上跳过这部分就行。

1212
00:47:45,520 --> 00:47:50,440
部分，甚至，甚至仍然看着它去……（此英文表述不太符合常见语法规则，翻译可能存在表意不够清晰的情况） 

1213
00:47:48,240 --> 00:47:51,960
也许复习一下基础知识，然后我会

1214
00:47:50,440 --> 00:47:57,200
涵盖一些更高级的主题，对吧

1215
00:47:51,960 --> 00:47:59,040
在这之后，所以学习 C 语言和 C++ 很难

1216
00:47:57,200 --> 00:48:00,680
所以你真的得定义一下什么

1217
00:47:59,040 --> 00:48:02,200
最好的资源是什么以及如何…… 

1218
00:48:00,680 --> 00:48:03,680
真正地把东西学好 什么是

1219
00:48:02,200 --> 00:48:07,040
你此刻最好的时间利用方式是

1220
00:48:03,680 --> 00:48:08,680
我们都面临的一个常见困境，所以我来了

1221
00:48:07,040 --> 00:48:13,040
在一篇关于最佳（事物）的Reddit文章中

1222
00:48:08,680 --> 00:48:15,760
学习 C++ 的资源，而且它相当……

注：原句“it it”可能有误，推测可能是“it is” 。 

1223
00:48:13,040 --> 00:48:17,920
很多人说去学习C++，在plus.com 上还有一堆（相关内容） 

1224
00:48:15,760 --> 00:48:20,440
其他你可能会喜欢的链接，所以

1225
00:48:17,920 --> 00:48:22,000
学习 C++ 。com 很不错 我从未……（原英文表述可能有误，正常可能是“learn C++ on learncpp.com is good” 之类表述） 

1226
00:48:20,440 --> 00:48:24,839
之前用过这个，所以我不知道该怎么（用） 

1227
00:48:22,000 --> 00:48:26,559
相对来说还不错，嗯，就是这样

1228
00:48:24,839 --> 00:48:28,760
当然，那是一种选择，然后

1229
00:48:26,559 --> 00:48:30,599
有学习 C 语言的最佳方法，所以看看

1230
00:48:28,760 --> 00:48:35,160
通过这个，我差不多发现了

1231
00:48:30,599 --> 00:48:37,599
每个人都喜欢那个，嗯，现代的 C 这个（这段英文表述不太清晰流畅）

1232
00:48:35,160 --> 00:48:41,119
一本《C语言编程：现代方法》，所以

1233
00:48:37,599 --> 00:48:43,280
这是一本 这是一本较新的书 嗯 但那就是……

1234
00:48:41,119 --> 00:48:44,599
人们是如何找到学习C语言的最佳方法的

1235
00:48:43,280 --> 00:48:46,720
嗯，如果你只是想学习这个

1236
00:48:44,599 --> 00:48:48,920
免费地，然后你知道的，就去试试

1237
00:48:46,720 --> 00:48:52,440
通过语法并将其理解为

1238
00:48:48,920 --> 00:48:54,480
尽快 嗯 有一些

1239
00:48:52,440 --> 00:48:56,000
我会推荐且已有的资源

1240
00:48:54,480 --> 00:48:58,880
稍微翻阅了一下，感觉如此自在

1241
00:48:56,000 --> 00:49:01,200
编码训练营在这方面有一些不错的内容，嗯

1242
00:48:58,880 --> 00:49:03,599
C语言编程不过是一堆呃，博客文章而已。

1243
00:49:01,200 --> 00:49:05,480
本质上是关于如何几乎完全地

1244
00:49:03,599 --> 00:49:06,359
只是在学习这门语言，然后你

1245
00:49:05,480 --> 00:49:08,960
有；拥有；持有；吃；喝；进行；经受；让；使；邀请；允许；有…的可能性；感到；显示出；患（病）；生育；得到；抓住；认为；与…性交；接受；明白；懂得；雇用；把…算作；表现出（某种行为、样子等）

注：“have”含义丰富，需根据具体语境确定其准确释义。若你有包含 “have” 的完整句子，请提供给我，以便我更精准地翻译。鉴于你原文就 “have” 一个词，以上是常见释义列举。 

1246
00:49:06,359 --> 00:49:12,680
C++ 呃，你知道的，也许再来一些

1247
00:49:08,960 --> 00:49:16,720
高级的东西，嗯，你懂的

1248
00:49:12,680 --> 00:49:18,680
库，一堆现代 C++ 的东西，嗯

1249
00:49:16,720 --> 00:49:20,160
所以免费代码营地（Free Code Camp）是一个很棒的资源

1250
00:49:18,680 --> 00:49:22,200
然后就是那个我个人……

1251
00:49:20,160 --> 00:49:25,599
被困住很长时间，并且还在持续

1252
00:49:22,200 --> 00:49:27,760
要使用的是 W3 学校（W3 学堂），所以它差不多是…… 

1253
00:49:25,599 --> 00:49:31,040
就像一个不错的、易于阅读、让人看着舒服的……

1254
00:49:27,760 --> 00:49:34,000
眼睛相关文档，还是只是一个介绍

1255
00:49:31,040 --> 00:49:36,799
而是关于如何使用 C 和 C++，所以我有

1256
00:49:34,000 --> 00:49:40,119
两者都在这里 嗯 我建议如果你是新手

1257
00:49:36,799 --> 00:49:42,720
针对这个，只需逐一查看这些，并且

1258
00:49:40,119 --> 00:49:44,720
做大量关于……的练习题

1259
00:49:42,720 --> 00:49:46,640
这些当中的每一个，嗯，所有这些

1260
00:49:44,720 --> 00:49:47,960
在那里是非常重要的，那里有一些

1261
00:49:46,640 --> 00:49:49,319
其中一些你可能实际上并不会用到

1262
00:49:47,960 --> 00:49:51,040
在课程中明确提及，但它仍然是

1263
00:49:49,319 --> 00:49:54,319
不管怎样，能了解到这件事就好，这只对你而言。

1264
00:49:51,040 --> 00:49:56,480
知道有那种，呃，你知道的，低水平的，呃

1265
00:49:54,319 --> 00:49:58,760
大脑，这样你就能剖析问题

1266
00:49:56,480 --> 00:50:00,079
对于我们可能涉及的 CUDA 应用程序而言 

1267
00:49:58,760 --> 00:50:02,880
不包括在这当中

1268
00:50:00,079 --> 00:50:04,400
当然，所以我建议就像

1269
00:50:02,880 --> 00:50:08,000
浏览所有这些，全部向下查看

1270
00:50:04,400 --> 00:50:10,440
喜欢这些例子的方式，嗯，比如

1271
00:50:08,000 --> 00:50:12,200
所有东西，然后C++也是一样的

1272
00:50:10,440 --> 00:50:15,160
嗯，那么，你所有的基础知识，你的

1273
00:50:12,200 --> 00:50:19,359
函数 你的类 嗯 然后往下

1274
00:50:15,160 --> 00:50:21,359
也举些例子，所以，呃，就是这样

1275
00:50:19,359 --> 00:50:24,040
基本上我所拥有的关于……的基础知识就这些了
（注：原文句子似乎未完整，“of”后面应该还有内容） 

1276
00:50:21,359 --> 00:50:27,119
中文 现在我们要继续进行下去，并且……

注：“CN” 这里不太明确其具体准确含义，从字面看可能是 “中文” 意思，若结合特定语境它可能有其他含义。 

1277
00:50:24,040 --> 00:50:28,640
触及要点

1278
00:50:27,119 --> 00:50:32,000
我们将从指针开始讲起。

1279
00:50:28,640 --> 00:50:32,000
如果你访问github.com

1280
00:50:32,119 --> 00:50:37,480
伊诺西·库达课程，嗯，然后去一下

1281
00:50:35,920 --> 00:50:38,760
那么，你不会突然去……

1282
00:50:37,480 --> 00:50:40,079
德夫，这一切都将被打乱了

1283
00:50:38,760 --> 00:50:42,440
一旦你开始看到了，就准备好了

1284
00:50:40,079 --> 00:50:44,559
这个，但是，呃，本质上你只是

1285
00:50:42,440 --> 00:50:46,319
打算把这个 C（文件或内容，需结合具体语境）放到一个……的目录中

1286
00:50:44,559 --> 00:50:49,240
你的选择，呃，然后我们就可以走了，并且…… 

1287
00:50:46,319 --> 00:50:51,280
那么，开始进行 C 和 C++ 复习吧

1288
00:50:49,240 --> 00:50:52,559
我在我的 VS Code 里把这些都弄好了，并且

1289
00:50:51,280 --> 00:50:55,480
它都放大好了，这对你来说很不错呢

（原句似乎表述不完整，你可以检查下或补充更多内容） 

1290
00:50:52,559 --> 00:50:57,240
看，不过嗯，我们将从一个开始

1291
00:50:55,480 --> 00:51:01,559
符号指针示例

1292
00:50:57,240 --> 00:51:04,200
所以，呃，我们初始化一个整数，整数 X

1293
00:51:01,559 --> 00:51:06,960
到 10，这是一个数据，这是数据部分

1294
00:51:04,200 --> 00:51:09,960
X 微米，然后我们初始化一个指针

1295
00:51:06,960 --> 00:51:12,480
打字 所以这个星号呃 那意味着我们是

1296
00:51:09,960 --> 00:51:13,799
创建一个指向整数的指针，呃，以及

1297
00:51:12,480 --> 00:51:17,240
我们正在设定，我们正在设定这个

1298
00:51:13,799 --> 00:51:19,720
名称等于指针，然后这个，呃

1299
00:51:17,240 --> 00:51:22,559
安珀桑德（可能是公司名、人名等，需结合语境确定准确译法）说我们将会得到

1300
00:51:19,720 --> 00:51:25,319
X的内存地址，所以我们有X

1301
00:51:22,559 --> 00:51:26,920
这里是10，然后耳鼻喉科医生说，呃

1302
00:51:25,319 --> 00:51:29,200
我们要获取……的内存地址

1303
00:51:26,920 --> 00:51:31,480
X 的，嗯，它将是……

1304
00:51:29,200 --> 00:51:34,319
指向 10 的指针

1305
00:51:31,480 --> 00:51:38,960
嗯，然后我们就可以打印了。

1306
00:51:34,319 --> 00:51:43,040
把这个弄出来，所以如果我使用GCC，然后我们来做

1307
00:51:38,960 --> 00:51:45,440
Z 01，然后运行它，你会看到

 

1308
00:51:43,040 --> 00:51:47,920
我们得到一个地址，所以我有了指针

1309
00:51:45,440 --> 00:51:49,280
我这里有指针类型，有……

1310
00:51:47,920 --> 00:51:53,599
有一个索引，你可以在那里找到

1311
00:51:49,280 --> 00:51:57,359
这些……嗯，如果我在这里打开一个标签页然后去（做某事）

1312
00:51:53,599 --> 00:51:59,599
呃 指针 呃 打印函数（注：这里“print f”应该是“printf”，它是C语言里的标准输出函数）

1313
00:51:57,359 --> 00:52:02,359
呃，就像在……里面为了…… 

1314
00:51:59,599 --> 00:52:04,440
例如，你拥有所有这些不同的

1315
00:52:02,359 --> 00:52:06,400
在C+ plus.com上有一些你可以（做的事情） 

1316
00:52:04,440 --> 00:52:09,000
用“嗯”，这些就像……

1317
00:52:06,400 --> 00:52:12,599
格式之类的东西

1318
00:52:09,000 --> 00:52:14,559
所以我们有，呃，我们有一个

1319
00:52:12,599 --> 00:52:17,240
指针 我们所说的就是这个值

1320
00:52:14,559 --> 00:52:20,680
返回，呃，我们得到一个内存地址到

1321
00:52:17,240 --> 00:52:22,799
值为 10，为了得到 10 我们正在传递

1322
00:52:20,680 --> 00:52:25,960
在指针里，然后我们对其使用星号来…… 

1323
00:52:22,799 --> 00:52:27,240
引用它，所以“差异”意味着呃，我们

1324
00:52:25,960 --> 00:52:29,119
本质上，我们有这个，我们有这个

1325
00:52:27,240 --> 00:52:31,359
数据相关的事物，其值为10，我们有这个 

1326
00:52:29,119 --> 00:52:33,680
将内存地址设为 10，这是级别。 

1327
00:52:31,359 --> 00:52:35,559
上面以及 E 参考值将仅仅是……

1328
00:52:33,680 --> 00:52:36,920
往下走，只是打算回到……

1329
00:52:35,559 --> 00:52:39,000
回到那个话题，所以我们有这段回忆

1330
00:52:36,920 --> 00:52:43,000
地址仅进行解引用，然后返回到

1331
00:52:39,000 --> 00:52:46,040
10 嗯，这里的下一个例子有点……

1332
00:52:43,000 --> 00:52:48,520
有点棘手，嗯，但没关系，它……它……

1333
00:52:46,040 --> 00:52:50,359
相对直观，所以我不指望

1334
00:52:48,520 --> 00:52:52,760
这有那么难吗，但实际上是什么

1335
00:52:50,359 --> 00:52:56,680
我们正在做的是，我们将一个值初始化为

1336
00:52:52,760 --> 00:52:59,839
42，然后我们创建一个，呃，一个指针，一个

1337
00:52:56,680 --> 00:53:01,559
名为指针一的整数指针类型

1338
00:52:59,839 --> 00:53:04,640
然后我们令其等于内存

1339
00:53:01,559 --> 00:53:06,760
值的地址，所以它是埃尔桑（Ersan，可能是特定人名）的内存

1340
00:53:04,640 --> 00:53:08,960
值的地址，嗯，所以它将会是

1341
00:53:06,760 --> 00:53:11,920
比如 42，然后我们创建指针 1

1342
00:53:08,960 --> 00:53:14,359
这是一个内存地址或一个指针 2

1343
00:53:11,920 --> 00:53:16,240
42，然后我们做同样的事情，所以我们

1344
00:53:14,359 --> 00:53:18,520
创建一个指向指针的指针，该指针是…… 

1345
00:53:16,240 --> 00:53:20,920
那两个星号是用来干什么的，呃，还有……

1346
00:53:18,520 --> 00:53:23,920
然后我们再做一次，琥珀色指针砂

1347
00:53:20,920 --> 00:53:26,720
因此，这个指针的一个内存地址，所以

1348
00:53:23,920 --> 00:53:29,599
那么你有 10，你有 42，然后

1349
00:53:26,720 --> 00:53:32,240
你有一个内存地址，它是那个……

注：原英文文本表述似乎不太完整或存在语病。 

1350
00:53:29,599 --> 00:53:33,960
你有指向，呃，42 的指针，然后你

1351
00:53:32,240 --> 00:53:37,440
在那上面还有另外一个，它是

1352
00:53:33,960 --> 00:53:39,760
指向指向一个值的指针的指针，并且

1353
00:53:37,440 --> 00:53:41,960
那么我们另找时间再做那件事吧，所以

1354
00:53:39,760 --> 00:53:47,480
这是一个指向指针的指针的指针

1355
00:53:41,960 --> 00:53:50,160
到一个值，嗯，然后，呃，这个逻辑会进行检查

1356
00:53:47,480 --> 00:53:53,720
输出，当我们把这个打印出来时，我们会…… 

1357
00:53:50,160 --> 00:53:55,440
将返回整数类型，所以……呃

1358
00:53:53,720 --> 00:53:58,200
然后我们就去“三 D 餐厅”（注：Triple D 常指美国美食节目《餐厅、汽车旅馆和小馆》Diners, Drive-Ins and Dives ） 

1359
00:53:55,440 --> 00:54:00,359
引用它，这样我们就有了这些多个

1360
00:53:58,200 --> 00:54:02,359
不同的层面，所以我们正在向上进入一个（这里句子不完整，翻译可能不太精准通顺） 

1361
00:54:00,359 --> 00:54:04,760
指针，如一级指针、二级指针

1362
00:54:02,359 --> 00:54:06,240
三级指针和间接引用是

1363
00:54:04,760 --> 00:54:07,960
就像下一个层级一样，所以我们出发

1364
00:54:06,240 --> 00:54:09,839
下降一、二、三层，然后回到

1365
00:54:07,960 --> 00:54:12,400
回到那个数值 42，它是一个

1366
00:54:09,839 --> 00:54:16,520
整数，并且我们可以放心地返回它，所以

1367
00:54:12,400 --> 00:54:20,000
如果我直接使用 GCC 然后进行编译

1368
00:54:16,520 --> 00:54:23,839
02 我们去执行那个行动，然后我们会得到一个保险箱

1369
00:54:20,000 --> 00:54:26,480
输出值 42
太棒了，所以现在我弹出

1370
00:54:23,839 --> 00:54:28,640
接下来是三号，也就是……的地方

1371
00:54:26,480 --> 00:54:29,960
事情开始变得有点奇怪了

1372
00:54:28,640 --> 00:54:32,119
呃，最初这有点像一个

1373
00:54:29,960 --> 00:54:34,440
这对我来说也是个有趣的话题，但这是

1374
00:54:32,119 --> 00:54:35,480
这是 void 指针，所以是 void 指针

1375
00:54:34,440 --> 00:54:38,160
有点搞笑，而且实际上

1376
00:54:35,480 --> 00:54:40,480
让我们能做出很多技巧动作，呃

1377
00:54:38,160 --> 00:54:42,720
考虑到诸如多态性之类的情况以及

1378
00:54:40,480 --> 00:54:46,240
呃，有些事情，但我们不会详细讨论

1379
00:54:42,720 --> 00:54:49,319
那可不少，那就像……呃……其他的…… 

1380
00:54:46,240 --> 00:54:51,720
这不在本次评测范围内，呃，所以

1381
00:54:49,319 --> 00:54:54,240
我们将一个名为 num 的整数初始化为

1382
00:54:51,720 --> 00:54:55,200
10 我们初始化一个名为 f num 的浮点数

1383
00:54:54,240 --> 00:54:58,240
等于

1384
00:54:55,200 --> 00:55:01,000
3.14 微米，然后我们有这个……这个空隙

1385
00:54:58,240 --> 00:55:03,040
指针，所以这意味着就好像如果

1386
00:55:01,000 --> 00:55:04,720
你有一个整数，然后有一个星号

1387
00:55:03,040 --> 00:55:08,359
那意味着它是一个指向……的指针

注：原英文句子似乎不完整，后面应该还有内容。但按照要求，直接给出了当前句子的翻译。 

1388
00:55:04,720 --> 00:55:11,640
整数，但 void 不是一种类型，所以就好像

1389
00:55:08,359 --> 00:55:13,480
一个指向无类型的指针，这意味着我们

1390
00:55:11,640 --> 00:55:16,000
实际上可以改变它的类型

1391
00:55:13,480 --> 00:55:19,359
指向的那个是个很酷的小……

1392
00:55:16,000 --> 00:55:22,440
你可以在 C 语言里实现的特性，嗯，所以我们

1393
00:55:19,359 --> 00:55:25,599
说，嗯，空指针将等于

1394
00:55:22,440 --> 00:55:29,280
这就是 num 的内存地址

1395
00:55:25,599 --> 00:55:32,359
对，嗯，然后我们在这里可以做的是

1396
00:55:29,280 --> 00:55:36,039
在这个打印部分，我们实质上

1397
00:55:32,359 --> 00:55:37,920
呃，我们把这个拿过来，把它转换为整数类型

1398
00:55:36,039 --> 00:55:40,039
指针类型，这就是这部分的内容

1399
00:55:37,920 --> 00:55:41,920
对于这些括号，然后在……里面

1400
00:55:40,039 --> 00:55:45,960
整数，然后在“A”之后是……（原文表述不太符合正常语法，译文只能按字面翻译） 

1401
00:55:41,920 --> 00:55:50,000
指针类型转换，然后我们对其进行解引用

1402
00:55:45,960 --> 00:55:51,079
所以我们有一个空指针，我们对其进行强制类型转换

1403
00:55:50,000 --> 00:55:53,599
到一个；给一个

（注：“to an”不是完整句子，“an”后一般会接以元音音素开头的可数名词单数，在不同语境会有不同的更准确的含义 ） 

1404
00:55:51,079 --> 00:55:55,559
整数，我们将其转换为整数类型，它是

1405
00:55:53,599 --> 00:55:57,400
最初保存着……的内存地址

1406
00:55:55,559 --> 00:55:59,640
整数；整型

1407
00:55:57,400 --> 00:56:01,640
嗯，然后我们在那之后对其进行解引用。

1408
00:55:59,640 --> 00:56:03,039
它是铸造的，所以它会上升到

1409
00:56:01,640 --> 00:56:05,359
这个内存地址，然后它将……

1410
00:56:03,039 --> 00:56:08,359
回到 10，它是……的值

1411
00:56:05,359 --> 00:56:13,440
数字，然后实际上我们只是进行……（这里原句似乎未完整） 

1412
00:56:08,359 --> 00:56:14,799
这里这个 F 数字也是一样的情况，嗯，我……

1413
00:56:13,440 --> 00:56:17,039
这里有很不错的简短描述，那（这里句子不完整，推测“that”后还有内容）

1414
00:56:14,799 --> 00:56:20,400
你可以自己阅读，呃，然后

1415
00:56:17,039 --> 00:56:22,880
一个有趣的小知识，所以实际上马利克

1416
00:56:20,400 --> 00:56:25,240
返回一个空指针，但我们看到它

1417
00:56:22,880 --> 00:56:27,079
在……之后指向一个特定的数据类型

1418
00:56:25,240 --> 00:56:29,440
所以选角
（注：“cast so” 这样的表述比较奇怪，可能有信息缺失，以上翻译仅供参考，需结合完整语境准确理解。） 

1419
00:56:27,079 --> 00:56:32,119
你通常认为马利克是什么样的人

1420
00:56:29,440 --> 00:56:33,640
这些 这些左括号 呃 这些

1421
00:56:32,119 --> 00:56:35,720
这个括号，然后你有了这个

1422
00:56:33,640 --> 00:56:38,079
里面实际的铸件，所以我们所做的是

1423
00:56:35,720 --> 00:56:39,920
这边就是你在马利克身上看到的东西，所以

1424
00:56:38,079 --> 00:56:41,640
实际上它返回的是一个空指针

1425
00:56:39,920 --> 00:56:43,760
然后你将其转换为特定的

1426
00:56:41,640 --> 00:56:46,480
比如整数或者浮点数，呃

1427
00:56:43,760 --> 00:56:50,319
指针，嗯，然后你可以使用那个

1428
00:56:46,480 --> 00:56:55,839
对于像数组这样的东西，嗯，所以

1429
00:56:50,319 --> 00:56:55,839
如果我们直接用GCC编译这个

1430
00:56:58,400 --> 00:57:04,920
然后运行，我们得到我们的整数，它是

1431
00:57:02,480 --> 00:57:08,680
呃，当然是整数类型，然后我们

1432
00:57:04,920 --> 00:57:11,839
获取我们的浮点数 3.14，它是一个呃

1433
00:57:08,680 --> 00:57:13,440
这是一个浮点类型，所以是 void 指针

1434
00:57:11,839 --> 00:57:14,880
不是 不是空指针 抱歉 是空值

1435
00:57:13,440 --> 00:57:16,680
指针真的很有趣，而你

1436
00:57:14,880 --> 00:57:19,200
可能觉得空指针很有趣

1437
00:57:16,680 --> 00:57:22,520
嗯，而且呢，但这些有点……

1438
00:57:19,200 --> 00:57:25,160
不同，所以空指针实际上可以

1439
00:57:22,520 --> 00:57:28,319
通过 if 语句让我们的代码更健壮

1440
00:57:25,160 --> 00:57:31,559
声明 嗯 打算移除那些二进制文件

1441
00:57:28,319 --> 00:57:34,359
目前先处理一些文件，以腾出些空间，嗯

1442
00:57:31,559 --> 00:57:39,079
但是我们将一个指针初始化为空指针

1443
00:57:34,359 --> 00:57:40,799
嗯，如果我们试着把这个打印出来，嗯，它是

1444
00:57:39,079 --> 00:57:43,160
它本质上会返回像


1445
00:57:40,799 --> 00:57:46,359
那里没有对的东西，就好像什么都没有

1446
00:57:43,160 --> 00:57:48,520
太空 实际上 在这儿 没有任何东西能……

1447
00:57:46,359 --> 00:57:49,839
你不能，你不能用那个指针来……（原句未结束，翻译根据已有内容处理） 

1448
00:57:48,520 --> 00:57:52,480
任何事物，因为它是空的，那就是…… 

1449
00:57:49,839 --> 00:57:54,640
这里的整个想法是，所以我们能做的是我们

1450
00:57:52,480 --> 00:57:57,760
可以检查指针是否等于

1451
00:57:54,640 --> 00:57:59,400
嗯，然后实际上我们就只是…… 

1452
00:57:57,760 --> 00:58:02,160
报告称也许我们抛出了一个错误

1453
00:57:59,400 --> 00:58:04,319
留言，或者我们，我们，我们发布一个警告，呃

1454
00:58:02,160 --> 00:58:06,280
如果……，则无法解引用此右值

1455
00:58:04,319 --> 00:58:09,079
指针并没有你所没有的东西

1456
00:58:06,280 --> 00:58:13,319
你这句话似乎存在拼写错误，可能正确的表达是 “Refer to nothing about something to you”，若按照这样理解，可译为：
对你而言，关于某事绝口不提。

如果这不是你想要的内容，请检查修正英文原文后再次提供。 

1457
00:58:09,079 --> 00:58:16,680
不能那么做，所以呃，我们实际上要改变

1458
00:58:13,319 --> 00:58:19,359
把那个处理好，然后我们分配内存到…… 

1459
00:58:16,680 --> 00:58:23,240
指针，所以指向这个指针，这样我们

1460
00:58:19,359 --> 00:58:24,839
之后可以安全地使用它，所以，呃，我是……

1461
00:58:23,240 --> 00:58:27,559
实际上要去编译这个了，所以

1462
00:58:24,839 --> 00:58:31,319
你可以，这样你就能明白它是什么了

1463
00:58:27,559 --> 00:58:33,599
嗯，初始指针值为 nil，所以

1464
00:58:31,319 --> 00:58:36,039
我们有指针类型，我们将其强制转换为一个

1465
00:58:33,599 --> 00:58:39,119
将要为空的空指针

1466
00:58:36,039 --> 00:58:41,920
当然，所以这样就说得通了，指针

1467
00:58:39,119 --> 00:58:43,640
为空，无法引用 D，这样不好，所以这个

1468
00:58:41,920 --> 00:58:46,400
这曾是

1469
00:58:43,640 --> 00:58:49,799
分配后为真，所以这就是……的地方

1470
00:58:46,400 --> 00:58:56,280
我们进入到这部分，马利克要去…… 

1471
00:58:49,799 --> 00:58:57,640
返回 呃 一个指向大小为整型的空指针

1472
00:58:56,280 --> 00:58:59,640
所以这实际上意味着

1473
00:58:57,640 --> 00:59:00,760
现在那里有某样东西，那里有。

1474
00:58:59,640 --> 00:59:03,280
那里有某样东西，它没有一个…… 

1475
00:59:00,760 --> 00:59:06,720
明确的数据类型，但我们有一些东西

1476
00:59:03,280 --> 00:59:10,079
那里，我觉得是 32 位的，所以

1477
00:59:06,720 --> 00:59:13,520
四个字节，嗯，然后我们检查是否

1478
00:59:10,079 --> 00:59:15,599
指针又等于 n 了，嗯，而且它

1479
00:59:13,520 --> 00:59:18,319
无法打印，内存分配失败

1480
00:59:15,599 --> 00:59:20,359
所以，那很好，然后我们接着来

1481
00:59:18,319 --> 00:59:24,280
第四项：分配指针之后

1482
00:59:20,359 --> 00:59:27,079
值是这个，所以我们把这个转换为一个呃

1483
00:59:24,280 --> 00:59:29,200
空指针，呃，实际上我们可以看到

1484
00:59:27,079 --> 00:59:31,839
这个这个这个内存地址我们可以

1485
00:59:29,200 --> 00:59:34,240
实际上能看到它确实有效，嗯，然后

1486
00:59:31,839 --> 00:59:36,119
我们可以，你知道的，我们，我们知道这……

注：原英文表述不太符合正常语法规范，这样的翻译只能尽量贴近字面意思。 

1487
00:59:34,240 --> 00:59:39,640
现在它存在了，所以我们可以用它来做…… （原句不完整，“for”后面内容缺失） 

1488
00:59:36,119 --> 00:59:41,960
所以，嗯，我们实际上会检查…… 

1489
00:59:39,640 --> 00:59:45,760
现在使用它是安全的，不会出现空指针问题，呃，然后呢。 

1490
00:59:41,960 --> 00:59:48,079
我们有这个，呃，我们有这个差异

注：原文“dreference”可能是“difference”的拼写错误 。 

1491
00:59:45,760 --> 00:59:50,400
指针，所以你对那个内存进行解引用操作

1492
00:59:48,079 --> 00:59:53,240
返回到数据部分，然后我们设置

1493
00:59:50,400 --> 00:59:56,599
那等于42，所以现在你有这个，呃

1494
00:59:53,240 --> 00:59:57,839
可以安全使用，嗯，你有这个，你就可以安全地……

1495
00:59:56,599 --> 01:00:00,400
使用内存地址和数据

1496
00:59:57,839 --> 01:00:03,160
与那个内存地址相关联，并且

1497
01:00:00,400 --> 01:00:05,480
然后我们可以释放那个指针，嗯，将其设置为

1498
01:00:03,160 --> 01:00:10,599
然后在释放……之后，接着我们看到

注：“uh”在口语中常为语气词，无实际语义，这里按情况灵活处理。 

1499
01:00:05,480 --> 01:00:13,839
又为空了，所以，呃，是的，如果

1500
01:00:10,599 --> 01:00:17,520
指针为空，所以我们知道它是（此处原句语义似乎不完整）

1501
01:00:13,839 --> 01:00:20,400
空指针安全地避免了释放后使用的问题

1502
01:00:17,520 --> 01:00:23,839
太棒了，所以这里的关键在于

1503
01:00:20,400 --> 01:00:25,520
我们可以不使用指针来呃 做

1504
01:00:23,839 --> 01:00:26,599
一些小技巧，然后我们就能让我们的代码……（原句似乎未完整）

1505
01:00:25,520 --> 01:00:29,440
三月

注：“Mar”是“March（三月）”的常见缩写形式。 

1506
01:00:26,599 --> 01:00:31,559
通过检查它是否为空，我们可以避免

1507
01:00:29,440 --> 01:00:33,079
遇到像段错误这样的意外错误

1508
01:00:31,559 --> 01:00:35,079
故障以及其他怪异的事情，那些是

1509
01:00:33,079 --> 01:00:36,400
很难追溯回去，对吧，有时候你

1510
01:00:35,079 --> 01:00:37,960
不想非得经历所有这些

1511
01:00:36,400 --> 01:00:40,319
只是为了找出一个错误，所以它是

1512
01:00:37,960 --> 01:00:41,799
最好还是呃，编写更健壮的代码

1513
01:00:40,319 --> 01:00:44,559
首先，并确保它

1514
01:00:41,799 --> 01:00:46,319
运行正常，所以在这个例子中

1515
01:00:44,559 --> 01:00:48,000
这里有不少事情正在发生

1516
01:00:46,319 --> 01:00:51,520
但我会试着，我会试着解释这一点

1517
01:00:48,000 --> 01:00:53,240
尽可能做到最好，所以我们有一个数组

1518
01:00:51,520 --> 01:00:56,160
呃，我们只是声明了一个长度为五的整数数组

1519
01:00:53,240 --> 01:00:59,440
数字，然后我们有一个，呃，指针

1520
01:00:56,160 --> 01:01:01,359
一个整数指针等于数组，所以在

1521
01:00:59,440 --> 01:01:03,400
C，因为我们就把它保留为 AR 形式

1522
01:01:01,359 --> 01:01:05,720
仅雷（Ray）会指向那个…… 

1523
01:01:03,400 --> 01:01:07,680
第一个元素，呃，因为那就是……那就是

1524
01:01:05,720 --> 01:01:09,839
记忆是如何排列的，没错，它就是这样发展的

1525
01:01:07,680 --> 01:01:11,839
本质上是要指出这到底在哪里

1526
01:01:09,839 --> 01:01:13,880
事情开始了，呃，接下来会是…… 

1527
01:01:11,839 --> 01:01:16,760
那当然会是12啦，但我们

1528
01:01:13,880 --> 01:01:19,119
要知道数组在其……（原句似乎不完整）方面是一个指针 

1529
01:01:16,760 --> 01:01:21,480
如果我们不进行解引用，或者如果我们……

需要说明的是，你提供的英文文本似乎并不完整，整体表意不太明确。 

1530
01:01:19,119 --> 01:01:23,920
不要对那个数组进行索引，嗯，它只是

1531
01:01:21,480 --> 01:01:26,799
单独成为一个指针，对吧，所以如果

1532
01:01:23,920 --> 01:01:30,920
我 如果我打印 f

1533
01:01:26,799 --> 01:01:33,799
呃，然后我们就走，就这么走

1534
01:01:30,920 --> 01:01:35,160
好的，我确定我会让副驾驶起来

1535
01:01:33,799 --> 01:01:39,520
完成；结束；使完整；使完美
完整的；完全的；彻底的；全部的；整个的

1536
01:01:35,160 --> 01:01:39,520
那不正确。

1537
01:01:41,359 --> 01:01:47,640
是的，我们会看到这个数组，如果我们

1538
01:01:45,280 --> 01:01:49,160
不要对它进行解引用，呃，就只关注它本身

1539
01:01:47,640 --> 01:01:52,880
拥有它，它是一个内存地址，它是一个

1540
01:01:49,160 --> 01:01:56,760
指向这个数组的指针，嗯，所以我们设置 我们

1541
01:01:52,880 --> 01:02:00,319
呃，让我把那个删掉，我们设置

1542
01:01:56,760 --> 01:02:01,839
呃，一个整型指针等于那个值

1543
01:02:00,319 --> 01:02:05,079
所以那是一个，那是一个内存地址，那个

1544
01:02:01,839 --> 01:02:07,319
嗯，现在我们很棒，我们来看看我们的……

1545
01:02:05,079 --> 01:02:09,760
一号位置，我打印出来的那个就是

1546
01:02:07,319 --> 01:02:13,319
快12点了，所以我们有那个（这里表述不太明确，需结合上下文）

 

1547
01:02:09,760 --> 01:02:15,760
数组在内存中的起始位置，呃，然后

1548
01:02:13,319 --> 01:02:16,880
我们只是对那个数字进行解引用，所以它

1549
01:02:15,760 --> 01:02:19,400
追溯到；回到

1550
01:02:16,880 --> 01:02:21,880
12 这就是这个星号的用途，并且

1551
01:02:19,400 --> 01:02:24,440
我们将其打印为整数

1552
01:02:21,880 --> 01:02:26,119
输入“真棒”，现在我们有一个 for 循环

1553
01:02:24,440 --> 01:02:29,880
这里到底在发生什么，这究竟是什么玩意儿

1554
01:02:26,119 --> 01:02:33,000
我们在做 我们有 我从零开始

1555
01:02:29,880 --> 01:02:34,920
我们想阻止它，呃，无论什么时候都行。

1556
01:02:33,000 --> 01:02:36,960
当它等于 5 时就继续，一旦等于 5 我们就停止它

1557
01:02:34,920 --> 01:02:39,319
然后我们每次递增 1

1558
01:02:36,960 --> 01:02:41,720
所以在这儿里面，我们有一个整数

1559
01:02:39,319 --> 01:02:44,599
输入，那将是 D

1560
01:02:41,720 --> 01:02:46,200
引用指针，所以不管是什么指针

1561
01:02:44,599 --> 01:02:49,160
是我们要把它追溯回去

1562
01:02:46,200 --> 01:02:50,839
恢复到它原本的数值，嗯，以及

1563
01:02:49,160 --> 01:02:52,440
然后在这儿我们要做这个

1564
01:02:50,839 --> 01:02:53,960
实际指针的指针类型

1565
01:02:52,440 --> 01:02:56,440
它本身，所以这就是内存地址

1566
01:02:53,960 --> 01:02:58,400
我们所看到的，嗯，然后我们只是

1567
01:02:56,440 --> 01:02:59,760
每次都要对这个进行递增操作 

1568
01:02:58,400 --> 01:03:01,039
每次这个循环进行时，我们打算

1569
01:02:59,760 --> 01:03:04,440
对它进行一次迭代，然后我们要去……

1570
01:03:01,039 --> 01:03:06,559
增加，我们打算增加，呃

1571
01:03:04,440 --> 01:03:09,440
指针，即内存地址

1572
01:03:06,559 --> 01:03:12,160
我们要对其进行递增操作

1573
01:03:09,440 --> 01:03:14,359
所以，呃，我这里有个小例子，那个……

1574
01:03:12,160 --> 01:03:16,480
写出来了，嗯，显然这些不会是

1575
01:03:14,359 --> 01:03:19,200
每次都是同样的例子，呃

1576
01:03:16,480 --> 01:03:23,039
它们会有所不同，但是呃

1577
01:03:19,200 --> 01:03:27,160
注意这个指针是如何递增的

1578
01:03:23,039 --> 01:03:31,520
向右移动四个字节，所以这个不在……（此处“this is is”表述有误，推测正确形式为“this is” ） 

1579
01:03:27,160 --> 01:03:35,079
呃，这里的位是以字节为单位的，所以如果我们这么做

1580
01:03:31,520 --> 01:03:38,200
一个字节中有8位，乘以4个字节，我们

1581
01:03:35,079 --> 01:03:39,799
获取 32 位，即整数 32 类型

1582
01:03:38,200 --> 01:03:41,799
经典整数

1583
01:03:39,799 --> 01:03:43,839
32 所以希望它能有点（作用/效果等，需结合上下文确定）

1584
01:03:41,799 --> 01:03:47,839
现在对记忆是如何存储的有了更多的认识

1585
01:03:43,839 --> 01:03:49,400
呃，至少在 CPU 方面是这样，所以，没错，我们

1586
01:03:47,839 --> 01:03:53,200
基本上就让这些被跳过了

1587
01:03:49,400 --> 01:03:56,240
每次四个字节 呃 4 字节乘以 8

1588
01:03:53,200 --> 01:04:00,480
每个字节的位数是 32 位，我们得到了我们的

1589
01:03:56,240 --> 01:04:03,440
从那一点我还要强调一下

1590
01:04:00,480 --> 01:04:06,039
呃，嗯，目前指针不在32位（模式）下。 

1591
01:04:03,440 --> 01:04:08,760
大小为比特，但我们将明白为什么要有 

1592
01:04:06,039 --> 01:04:13,240
就像现在在32里的它们可能会成为一个主要的……（注：原文“in32”表述不太清晰，可能存在信息缺失或笔误） 

1593
01:04:08,760 --> 01:04:17,359
问题，所以如果你真的要做……嗯，如果我们继续

1594
01:04:13,240 --> 01:04:19,920
Python，并且我们计算 2 的 32 次方，我们会得到

1595
01:04:17,359 --> 01:04:26,640
这个数字，看它有多大啊，这个

1596
01:04:19,920 --> 01:04:27,880
呃，是1、2、3、4、5、6、7、8，呃，9，所以就是这样

1597
01:04:26,640 --> 01:04:32,240
那大约是；那关于

注：“that's about”后面一般还会接其他内容，目前语义不完整，这样的翻译仅依据当前文本。 

1598
01:04:27,880 --> 01:04:36,359
4.2，那大约是4GB，嗯，在……的2的……次方方面（此处原文表述不太清晰） 

1599
01:04:32,240 --> 01:04:38,680
当然，那是4GB，所以如果你有比如说8GB（这里原文似乎表述不完整）

1600
01:04:36,359 --> 01:04:41,359
记忆的缺口，实际上并非如此

1601
01:04:38,680 --> 01:04:45,400
在这台机器上有很多，实际上我有64（个/份等，需结合具体语境确定）

1602
01:04:41,359 --> 01:04:47,079
所以我有 64GB 的内存被……占用了

1603
01:04:45,400 --> 01:04:48,119
就像一个单一的数组，我的意思是说

1604
01:04:47,079 --> 01:04:49,960
显然不会发生，那是个

1605
01:04:48,119 --> 01:04:52,319
非常大的数组，但咱们就说我

1606
01:04:49,960 --> 01:04:54,000
有那种，你知道的，64GB 的。

1607
01:04:52,319 --> 01:04:56,680
好吧，实际上我们要去……
（注：“long”在这里似乎不太符合语境，可能原文有误，但按要求直接翻译文本。） 

1608
01:04:54,000 --> 01:04:58,880
当我们尝试以那种方式进行索引时会溢出

1609
01:04:56,680 --> 01:05:01,359
所以稍后你会看到

（不过原句不完整，感觉后面还有内容。） 

1610
01:04:58,880 --> 01:05:04,440
使用呃某一个（东西）会更有用。

1611
01:05:01,359 --> 01:05:08,000
这些指针的类型，所以如果我们对 2 进行……（这里文本似乎不完整） 

1612
01:05:04,440 --> 01:05:10,839
这个“64” 所以你有一个双精度整数

1613
01:05:08,000 --> 01:05:13,559
所以在任天堂64（N64）上，你会看到这就像

1614
01:05:10,839 --> 01:05:15,920
极其巨大的 嗯，这是

1615
01:05:13,559 --> 01:05:19,039
就好像我不知道在……的某个地方

1616
01:05:15,920 --> 01:05:21,520
艾字节，这高得离谱了

1617
01:05:19,039 --> 01:05:24,200
嗯，是的，只是我们……我们打算……

1618
01:05:21,520 --> 01:05:27,200
稍后再处理这个，但现在这个

1619
01:05:24,200 --> 01:05:29,160
这大致的直觉是关于……呃……是怎样的……

1620
01:05:27,200 --> 01:05:31,000
这些指针被打印出来，所以如果我

1621
01:05:29,160 --> 01:05:33,440
往上滚动一点，你就会看到。

1622
01:05:31,000 --> 01:05:36,119
呃，我们打印出解引用后的指针

1623
01:05:33,440 --> 01:05:38,279
嗯，实际上就那样做

1624
01:05:36,119 --> 01:05:39,839
内存地址，然后我们对其进行解引用

1625
01:05:38,279 --> 01:05:41,680
基于它目前所处的指数情况

1626
01:05:39,839 --> 01:05:44,119
所以我们只是将索引加一，我们……我们

1627
01:05:41,680 --> 01:05:46,599
向前跳 32 位或四个字节，并且

1628
01:05:44,119 --> 01:05:48,359
然后我们把那个值打印出来，呃

1629
01:05:46,599 --> 01:05:52,480
每次，你从垂直方向去看它

1630
01:05:48,359 --> 01:05:57,480
这里，嗯，我只是

1631
01:05:52,480 --> 01:05:58,680
等清理完之后也许可以再运行一次

1632
01:05:57,480 --> 01:06:00,520
你会发现它，它就像

1633
01:05:58,680 --> 01:06:03,200
垂直方向上就像我们预想的那样直接跳过了 

1634
01:06:00,520 --> 01:06:05,760
期望，然后是这个指针，呃，它是

1635
01:06:03,200 --> 01:06:07,640
仅仅是那个内存地址，然后我

1636
01:06:05,760 --> 01:06:09,440
只是为了测试才把这个弄出来，你

1637
01:06:07,640 --> 01:06:11,880
不用担心那个，嗯，但是

1638
01:06:09,440 --> 01:06:13,240
是的，这就是关于，呃，的一般直觉。

1639
01:06:11,880 --> 01:06:15,599
这些东西是如何如何布置在……里的

1640
01:06:13,240 --> 01:06:18,440
记忆，所以第六个是一个有趣的…… 

1641
01:06:15,599 --> 01:06:21,119
其一，这有点要追溯到那个例子了

1642
01:06:18,440 --> 01:06:23,119
第二点，在这里，呃，我们有

1643
01:06:21,119 --> 01:06:25,039
这个值，然后是指针，指针

1644
01:06:23,119 --> 01:06:27,920
指针只是不断堆叠，呃，就是那样。

1645
01:06:25,039 --> 01:06:30,880
本质上，六号类型的人是这样的，所以我们有这些…… 

1646
01:06:27,920 --> 01:06:32,640
两个数组，数组 1 和数组 2，并且它们是

1647
01:06:30,880 --> 01:06:35,319
本质上只是这些向量或者这些

1648
01:06:32,640 --> 01:06:39,079
这些，这些数组 1、2、3、4，然后我们

1649
01:06:35,319 --> 01:06:41,559
有一个数组，呃，5、6、7、8，呃，然后

1650
01:06:39,079 --> 01:06:44,480
我们只是有一个整数指针，呃，指向…… 

1651
01:06:41,559 --> 01:06:46,359
那些数组，嗯，然后我们存储

1652
01:06:44,480 --> 01:06:49,240
另一种情况你可以说数组，我只是随便起的名字

1653
01:06:46,359 --> 01:06:51,359
对矩阵进行求导，然后我们存储

1654
01:06:49,240 --> 01:06:53,480
那些指针，呃，基本上在……之上

1655
01:06:51,359 --> 01:06:55,799
彼此 所以看起来我们是……

1656
01:06:53,480 --> 01:06:59,039
有这个，我们有这个矩阵，所以它是

1657
01:06:55,799 --> 01:07:02,880
指针一和指针二 指针一

1658
01:06:59,039 --> 01:07:04,760
呃，它是指向……的指针

1659
01:07:02,880 --> 01:07:06,760
那个数组，数组一，然后

1660
01:07:04,760 --> 01:07:09,079
指针二是那个内存地址

1661
01:07:06,760 --> 01:07:11,640
对于 对于 数组 两个 所以 从本质上讲 我们……

1662
01:07:09,079 --> 01:07:14,920
如果我们……如果我们看看这个，呃……

1663
01:07:11,640 --> 01:07:17,279
像这样的数组，这个矩阵，它有

1664
01:07:14,920 --> 01:07:19,799
指针一 指针二 如果我们把它翻转一下 那么

1665
01:07:17,279 --> 01:07:21,279
而不是像这样和这样 我们 我们

1666
01:07:19,799 --> 01:07:23,319
把它们一个叠在另一个上面，这样就



1667
01:07:21,279 --> 01:07:25,920
指针一，然后指针二，实际上

1668
01:07:23,319 --> 01:07:29,079
看起来像一个矩阵，所以你会有你的

1669
01:07:25,920 --> 01:07:31,520
数组一，它包含 1、2、3、4，然后

1670
01:07:29,079 --> 01:07:32,920
下面一个是五六七八

1671
01:07:31,520 --> 01:07:35,799
所以实际上它就像一个……它就是……它是……

1672
01:07:32,920 --> 01:07:38,799
就像一个网格，对吧，呃，如果我们进行迭代

1673
01:07:35,799 --> 01:07:38,799
通过这个

1674
01:07:41,960 --> 01:07:44,960
嗯

1675
01:07:45,000 --> 01:07:52,079
哦，你实际上会看到，嗯，我们刚刚

1676
01:07:48,400 --> 01:07:55,720
本质上是要遍历这些，所以，呃

1677
01:07:52,079 --> 01:07:58,079
我们 我们 我们做J和四 呃 然后我们 我们

1678
01:07:55,720 --> 01:08:00,720
在……打印出 D 参考矩阵

1679
01:07:58,079 --> 01:08:04,799
将我置于位置 I，使得位置 I 处于移动状态（注：原英文表述不太符合常规表达逻辑，此翻译是尽量贴合字面的意思） 

1680
01:08:00,720 --> 01:08:08,920
为……提供一个内存地址

1681
01:08:04,799 --> 01:08:14,400
呃，你知道的，会是第二名。

1682
01:08:08,920 --> 01:08:16,480
呃，那将会是这两个数组。

1683
01:08:14,400 --> 01:08:17,960
嗯，然后我们要进行解引用操作

1684
01:08:16,480 --> 01:08:20,000
那将给予我们我们的…… 

1685
01:08:17,960 --> 01:08:21,520
实际值，然后我们将

1686
01:08:20,000 --> 01:08:24,159
当然，每次都要重复这个操作，就像

注：你提供的文本可能不完整，建议补充完整以获得更准确合适的翻译。 

1687
01:08:21,520 --> 01:08:26,239
对于循环会继续进行，嗯，然后我们就接着做

1688
01:08:24,159 --> 01:08:29,159
换行一下，这样看起来会很不错很不错

1689
01:08:26,239 --> 01:08:30,799
所以呢，呃，我要说的差不多就这些了。

1690
01:08:29,159 --> 01:08:32,920
有了指针，我们要开始跳转了

1691
01:08:30,799 --> 01:08:35,000
现在进入自定义类型，这更多是关于什么的呢 

1692
01:08:32,920 --> 01:08:37,400
我当时正在谈论这个，为了这些 

1693
01:08:35,000 --> 01:08:39,880
奇怪的指针大小，嗯，我们打算……

1694
01:08:37,400 --> 01:08:39,880
潜入；投身于；深入探究

1695
01:08:40,560 --> 01:08:45,759
所以现在我要给你展示一下，挺……（这里“pretty”后面缺少内容，语义不完整） 

1696
01:08:42,960 --> 01:08:47,279
大致相当于火炬点

1697
01:08:45,759 --> 01:08:49,040
长类型，所以你可能已经见过这个了

1698
01:08:47,279 --> 01:08:50,400
之前，如果你……你知道的，我猜你

1699
01:08:49,040 --> 01:08:52,359
对 Python 有一定的了解，并且

1700
01:08:50,400 --> 01:08:54,799
PyTorch 所以我觉得那是最好的办法

1701
01:08:52,359 --> 01:08:57,080
为了说明这一点，我们有这个尺码 T

1702
01:08:54,799 --> 01:08:59,719
这个尺寸 _ T 这通常就是你……（原文“how you”后内容不完整） 

1703
01:08:57,080 --> 01:09:01,759
你用 C 语言把这个写出来的话，你会得到

1704
01:08:59,719 --> 01:09:03,679
呃，不管是什么类型，然后你就会

1705
01:09:01,759 --> 01:09:05,759
有下划线 T 来说明这是

1706
01:09:03,679 --> 01:09:10,359
就像你创建的一种自定义类型，T 是

1707
01:09:05,759 --> 01:09:13,480
对于类型，嗯，这是专门针对……的

1708
01:09:10,359 --> 01:09:16,000
你喜欢很大很大的数字，对吧，那么这个想法

1709
01:09:13,480 --> 01:09:17,719
这里，这将是一个未签名的（东西） 

1710
01:09:16,000 --> 01:09:20,839
这么久以来

注：“long so” 表述不太常见或可能有误，如果结合上下文有更准确的语义，请提供更多信息。若它想表达 “so long” ，则意思是“再见；好久” 。  

1711
01:09:17,719 --> 01:09:25,839
无符号整型 呃 长整型

1712
01:09:20,839 --> 01:09:29,199
所以整型，它将是一个 64 位无符号整型，也就是

1713
01:09:25,839 --> 01:09:31,679
如果我们这么做，结果会怎样呢，嗯

1714
01:09:29,199 --> 01:09:36,040
在在 PyTorch 里你会……（这里原英文表述可能有误，“in in” 连续两个 “in” 不符合正常语法） 

1715
01:09:31,679 --> 01:09:37,239
看，我用 Python 导入了 PyTorch，然后我们

1716
01:09:36,040 --> 01:09:42,080
可以制作；能够做

1717
01:09:37,239 --> 01:09:45,400
X 这只是一个整数数组，呃，并且

1718
01:09:42,080 --> 01:09:49,040
然后我们输入 x.dtype，我们会看到一个 torch。

1719
01:09:45,400 --> 01:09:51,600
N64，所以它就像那个64位的（设备）啊

1720
01:09:49,040 --> 01:09:54,199
我们真正想要存储的精度

1721
01:09:51,600 --> 01:09:57,199
大型，真正的大型矩阵，对吧，所以

1722
01:09:54,199 --> 01:09:59,840
尤其是在 CUDA 里，当你有，呃，比如……

1723
01:09:57,199 --> 01:10:02,440
非常非常大的张量，它们是

1724
01:09:59,840 --> 01:10:04,480
占用好几GB呢，嗯

1725
01:10:02,440 --> 01:10:06,280
就像在我的显卡上，我有 8GB 的（显存等，这里原文表述不完整） 

1726
01:10:04,480 --> 01:10:09,360
存储，所以如果我们正在使用

1727
01:10:06,280 --> 01:10:11,719
在32位的情况下，呃，你可能会遇到一些溢出问题

1728
01:10:09,360 --> 01:10:14,239
错误，或者你可能只会遇到一些（错误） 

1729
01:10:11,719 --> 01:10:15,880
一些意想不到的不良行为，那就是

1730
01:10:14,239 --> 01:10:17,520
打算去搅乱一些事情，所以你

1731
01:10:15,880 --> 01:10:20,400
不一定想要那个，而且那是

1732
01:10:17,520 --> 01:10:21,719
尺寸类型的关键所在，嗯，我

1733
01:10:20,400 --> 01:10:25,679
有点想给你看看这个

1734
01:10:21,719 --> 01:10:27,719
毕竟也没那么糟，所以你知道，只是

1735
01:10:25,679 --> 01:10:29,640
为了逐步讲解这个，我们有……我们有这个

1736
01:10:27,719 --> 01:10:33,199
和我们上次讨论过的相同的数组

1737
01:10:29,640 --> 01:10:37,000
我们做这种尺寸的 T 型，嗯，我们用的尺寸是……（这里原文未说完） 

1738
01:10:33,199 --> 01:10:39,880
然后数组的大小除以呃

1739
01:10:37,000 --> 01:10:42,840
除以单个个体的大小

1740
01:10:39,880 --> 01:10:47,360
整数，所以它就像是……的总大小

1741
01:10:42,840 --> 01:10:49,199
这个，呃，整个东西除以这个，呃

1742
01:10:47,360 --> 01:10:53,480
其中每一个单独事物的大小

1743
01:10:49,199 --> 01:10:57,040
这样你就能得到数组的总长度了

1744
01:10:53,480 --> 01:10:59,320
嗯，呃，所以如果我们选01，我已经……

1745
01:10:57,040 --> 01:11:01,199
编译了这个，呃，你会看到我们得到了那个

1746
01:10:59,320 --> 01:11:05,480
五个，所以里面有五个元素。

1747
01:11:01,199 --> 01:11:07,760
这里，呃，我们把这个尺寸打印出来，嗯，我会…… 

1748
01:11:05,480 --> 01:11:11,560
过一会儿再看一下这个“Zu”部分。

1749
01:11:07,760 --> 01:11:15,800
这里，嗯，但是我们得到了输出结果 5 以及

1750
01:11:11,560 --> 01:11:19,520
然后这个八号，嗯，我们把尺寸打印出来

1751
01:11:15,800 --> 01:11:24,120
关于这个，所以那是以，呃，那是以字节为单位的。

1752
01:11:19,520 --> 01:11:28,280
顺便说一下，当我们确定类似尺寸的时候

1753
01:11:24,120 --> 01:11:33,040
如果我们要做的话，以整数类型为例，让我们看看，打印

1754
01:11:28,280 --> 01:11:35,880
呃，我们就说整型吧

1755
01:11:33,040 --> 01:11:40,480
尺寸，呃，然后我们会

1756
01:11:35,880 --> 01:11:43,040
行，呃，当然，一口一口地来，我们会那么做的，呃

1757
01:11:40,480 --> 01:11:45,719
如果我只是编译这个

1758
01:11:43,040 --> 01:11:47,560
同样，我们会看到整型的大小以及字节数，所以

1759
01:11:45,719 --> 01:11:50,920
这是一个

1760
01:11:47,560 --> 01:11:54,280
32位整数 这仅仅是一个32位整数，并且它是

1761
01:11:50,920 --> 01:11:56,719
四个字节或32位，所以当我们有

1762
01:11:54,280 --> 01:11:59,800
这意味着它是64位的，只是顺便提一下

1763
01:11:56,719 --> 01:12:02,400
从那个角度来看，所以呃，当我们……

1764
01:11:59,800 --> 01:12:04,960
选这个T尺码，我们会看到它是一个……（这里句子不完整） 

1765
01:12:02,400 --> 01:12:08,000
无符号类型定义，所以我们进行一种类型

1766
01:12:04,960 --> 01:12:09,080
定义为无符号，所以它是一个，它仅仅是

1767
01:12:08,000 --> 01:12:10,639
要保持积极的心态，因为我们

1768
01:12:09,080 --> 01:12:12,840
收藏着，就像你知道你不能拥有一样

1769
01:12:10,639 --> 01:12:14,600
比如负尺寸，这就是逻辑，并且

1770
01:12:12,840 --> 01:12:17,000
然后我们有这个“长的”，这意味着它是

1771
01:12:14,600 --> 01:12:19,000
要……呃，它会莱利（可能是名字有误，猜测是特定人名）来讲

1772
01:12:17,000 --> 01:12:22,199
我们想要64位的操作系统

注：原英文表述 “where we we want” 可能存在语法错误，推测正确表达或许是 “which we want”  。   

1773
01:12:19,000 --> 01:12:24,719
位数不是32位，我们希望它是长整型的，嗯，而且

1774
01:12:22,199 --> 01:12:27,360
然后只要确定尺寸和T类型，这样我们就可以

1775
01:12:24,719 --> 01:12:29,760
实际上进入这个，然后我们可以看到，哦

1776
01:12:27,360 --> 01:12:31,520
typedef 大小类型，然后我们来做这个

1777
01:12:29,760 --> 01:12:34,199
我们声明这件事，这是在哪里呢

1778
01:12:31,520 --> 01:12:37,040
来自 哦 就在这儿 长期未署名的

1779
01:12:34,199 --> 01:12:38,880
整数 就像这样 超级简单

1780
01:12:37,040 --> 01:12:42,719
对；没错；好的

1781
01:12:38,880 --> 01:12:44,679
嗯，我想稍微澄清一下

1782
01:12:42,719 --> 01:12:47,040
就像这里到底是怎么回事啊我们

1783
01:12:44,679 --> 01:12:50,000
如果我愿意的话，随时可以回到这个链接

1784
01:12:47,040 --> 01:12:53,920
就在我这边的第二个屏幕上打开它

1785
01:12:50,000 --> 01:12:53,920
然后把它放过去

1786
01:12:54,000 --> 01:13:00,560
哦，呃，我们可以搜索…… 

1787
01:12:57,159 --> 01:13:03,520
我会把这个调大一点，我不……

1788
01:13:00,560 --> 01:13:08,320
知道吗 我能把它变大 好了 这样


1789
01:13:03,520 --> 01:13:11,440
如果我往上看，呃，我们会看到我们有…… 

1790
01:13:08,320 --> 01:13:15,120
这个，呃，我们有这个，我们有这个 Z 以及

1791
01:13:11,440 --> 01:13:19,440
然后我们有 U，所以 Z 是

1792
01:13:15,120 --> 01:13:22,560
呃，Z 就会是……呃，我做不到。

1793
01:13:19,440 --> 01:13:24,120
确切地记得这是为了什么，但

1794
01:13:22,560 --> 01:13:26,719
呃，然后我们有这个 U，它是

1795
01:13:24,120 --> 01:13:29,320
本质上只是右边的无符号数

1796
01:13:26,719 --> 01:13:31,520
所以这里的 U 表示无符号，嗯，然后我们

1797
01:13:29,320 --> 01:13:34,440
有这种尺寸的T型的，这是什么东西呢 

1798
01:13:31,520 --> 01:13:37,199
这就是字母Z所代表的意思，嗯，然后呢

1799
01:13:34,440 --> 01:13:39,920
我们只是把那个规划出来，所以，呃，你

1800
01:13:37,199 --> 01:13:42,280
想知道要是我们有一个，呃，要是我们仅仅有一个…… 

1801
01:13:39,920 --> 01:13:44,800
如果是常规整数，它的大小仍将是 T
（注：原英文句子可能缺少条件状语从句部分，比如 “If it were a” 之类，这里按完整意思猜测翻译） 

1802
01:13:42,280 --> 01:13:46,960
因为你可以拥有，你知道的，它仍然…… 

1803
01:13:44,800 --> 01:13:50,920
一个整数，你可以对它进行一些操作，但是

1804
01:13:46,960 --> 01:13:52,520
当我们遇到一个“u” 呃，然后你知道它是…… 

1805
01:13:50,920 --> 01:13:54,480
只是有点明确地说，你将要

1806
01:13:52,520 --> 01:13:56,719
有这种尺寸的 T 型的，所以就是那样的

1807
01:13:54,480 --> 01:14:00,360
有点像我们在那里处理事情的方式，而且我们可以

1808
01:13:56,719 --> 01:14:02,800
使用字母 Z 后面跟着字母 U，呃，来……

1809
01:14:00,360 --> 01:14:05,080
适当地把那个打印出来，以打印出…… 

1810
01:14:02,800 --> 01:14:07,080
那种类型的，这样你就知道你拥有了所有

1811
01:14:05,080 --> 01:14:09,080
这些其他的也一样，比如，呃，指针

1812
01:14:07,080 --> 01:14:11,440
差异；不同；差额；差值；（计算机文件等的）比较（程序）

1813
01:14:09,080 --> 01:14:13,960
呃，打个比方，但大体上就是那个……

1814
01:14:11,440 --> 01:14:13,960
直觉

1815
01:14:14,000 --> 01:14:19,199
就在那时，接下来我只是想

1816
01:14:16,639 --> 01:14:21,159
涵盖，呃，声明你自己的自定义类型

1817
01:14:19,199 --> 01:14:24,800
所以你知道我们在那个……里面看到了一个。

1818
01:14:21,159 --> 01:14:26,960
标准呃 C 库 标准输入输出库

1819
01:14:24,800 --> 01:14:28,360
呃，C 语言库，标准定义

1820
01:14:26,960 --> 01:14:32,199
图书馆，随便你想怎么称呼它，那个…… 

1821
01:14:28,360 --> 01:14:34,159
标题，嗯，而且同样重要的是

1822
01:14:32,199 --> 01:14:35,800
我们可以自行宣称，因为我们有可能（这么做）

1823
01:14:34,159 --> 01:14:37,360
甚至我们可能需要用到这些，而且我们

1824
01:14:35,800 --> 01:14:39,960
实际上稍后会在……中用到这些

1825
01:14:37,360 --> 01:14:41,880
当然，通常的情况是你

1826
01:14:39,960 --> 01:14:44,440
做一件叫做类型定义的事情，呃，也就是…… 

1827
01:14:41,880 --> 01:14:45,719
是一个类型定义，而且对于……咱们就……

1828
01:14:44,440 --> 01:14:47,320
说我们要为……表明一个观点

1829
01:14:45,719 --> 01:14:49,480
例如，它有一个 X 和一个 Y ，以及它们的……（这里“their”后面似乎缺少内容）

1830
01:14:47,320 --> 01:14:51,120
浮点数值，所以我们这样做

1831
01:14:49,480 --> 01:14:52,679
结构体，它将包含一些

1832
01:14:51,120 --> 01:14:54,600
它里面的元素将会有

1833
01:14:52,679 --> 01:14:57,199
有些，它会有一些这样的，我

1834
01:14:54,600 --> 01:14:58,600
猜猜你可以用这些物品来描述的物体

1835
01:14:57,199 --> 01:15:01,480
呃，它将有一个浮点型变量 X 并且

1836
01:14:58,600 --> 01:15:03,520
一个浮点数 Y，然后我们声明，我们说

1837
01:15:01,480 --> 01:15:05,719
这将是我们要做的一个类型要点

1838
01:15:03,520 --> 01:15:08,600
类型定义，呃，它将会是一个

1839
01:15:05,719 --> 01:15:10,760
结构体，然后我们要把它变成一个

1840
01:15:08,600 --> 01:15:12,480
本质上是点类型，然后在里面

1841
01:15:10,760 --> 01:15:15,400
由于这是……，所以这里是我们的 int main 函数 

1842
01:15:12,480 --> 01:15:17,000
已经声明了，我们可以说一个点类型

1843
01:15:15,400 --> 01:15:19,360
就像你知道的，你可以，你会的

1844
01:15:17,000 --> 01:15:21,480
做个INTP之类的人，我们只是

1845
01:15:19,360 --> 01:15:23,840
替换 替换整数或者其他的那个

1846
01:15:21,480 --> 01:15:25,760
类型是带点的，而我们正在制作那个

1847
01:15:23,840 --> 01:15:28,560
名为 p 的变量，然后我们要

1848
01:15:25,760 --> 01:15:30,560
在这里用一些值来填充它，所以

1849
01:15:28,560 --> 01:15:35,199
这将是我们的浮点数 X 以及我们的

1850
01:15:30,560 --> 01:15:38,080
呃，y是个浮点数，然后如果我们继续，呃，你知道的

1851
01:15:35,199 --> 01:15:41,400
如果我只是进行编译，这里点的大小

（需要说明的是，原英文句子可能表述不太完整准确，翻译尽量贴合原文意思） 

1852
01:15:38,080 --> 01:15:42,360
这个，然后运行，呃，你会看到……的大小

1853
01:15:41,400 --> 01:15:46,840
关键是

1854
01:15:42,360 --> 01:15:48,679
八，所以 8 字节等于 4 字节加 4 字节

1855
01:15:46,840 --> 01:15:50,920
更多字节，所以这些每一个都是浮点数

1856
01:15:48,679 --> 01:15:53,320
32，该数字在……中占用四个字节

1857
01:15:50,920 --> 01:15:55,360
记忆，所以当你把这些加在一起时，它

1858
01:15:53,320 --> 01:15:57,639
总共占用八个字节，所以这个

1859
01:15:55,360 --> 01:16:01,920
指着这个点，呃，类型将会……

1860
01:15:57,639 --> 01:16:03,960
覆盖呃在内存中占 8 个字节或 64 位 嗯

1861
01:16:01,920 --> 01:16:06,639
然后就是另一个 C++ 脚本，它是

1862
01:16:03,960 --> 01:16:08,800
实际上和这个完全一样，所以你

1863
01:16:06,639 --> 01:16:12,639
你能确切地声明一些事情吗？

不过原英文文本 “can you can declare things the exact” 表述有误，正确可能是 “Can you exactly declare things”  。 

1864
01:16:08,800 --> 01:16:14,400
同样的方式，嗯，在 C++ 里也是如此，只是你可能…… 

1865
01:16:12,639 --> 01:16:17,719
只是想使用类似输入输出流的东西

1866
01:16:14,400 --> 01:16:20,080
而不是，呃，就像你在 C++ 里可能会做的那样，你

1867
01:16:17,719 --> 01:16:23,679
会把这部分注释掉，然后你就可以继续了

1868
01:16:20,080 --> 01:16:26,360
呃，包含呃，输入输出（IO）

1869
01:16:23,679 --> 01:16:28,639
流式传输，然后你会使用，呃

1870
01:16:26,360 --> 01:16:32,040
使用命名空间

1871
01:16:28,639 --> 01:16:34,159
性传播疾病，然后你会，呃，然后你会

1872
01:16:32,040 --> 01:16:36,639
坚持到…结束；送…出门；为…送行

1873
01:16:34,159 --> 01:16:39,360
那；那个

1874
01:16:36,639 --> 01:16:41,560
哦，标识符 SE 是

1875
01:16:39,360 --> 01:16:44,159
未定义
好吧，我想不行
我不知道

1876
01:16:41,560 --> 01:16:46,840
为什么那不管用呢，嗯，但是，但是你

1877
01:16:44,159 --> 01:16:50,480
明白要点了，所以变化非常小，那么

1878
01:16:46,840 --> 01:16:52,639
现在，如果我们来看一下类型转换，呃，我

1879
01:16:50,480 --> 01:16:54,520
这里有两个文件，所以就只是……就只是……

1880
01:16:52,639 --> 01:16:57,800
单个 C 文件，然后是一个说明文件，所以……

1881
01:16:54,520 --> 01:17:01,120
在这里面，我有呃静态类型转换

1882
01:16:57,800 --> 01:17:03,679
动态转换 呃 常量转换以及

1883
01:17:01,120 --> 01:17:05,400
重新解释类型转换，所以我们只会去…… 

1884
01:17:03,679 --> 01:17:07,040
将介绍这些静态类型转换，因为

1885
01:17:05,400 --> 01:17:09,679
这些是安全的那些
这些主要是

1886
01:17:07,040 --> 01:17:13,239
如果你要用的话，你最终会用到什么

1887
01:17:09,679 --> 01:17:15,440
嗯，所以在这里，这非常简单。

1888
01:17:13,239 --> 01:17:16,920
你刚刚就像在说一种飘忽不定的东西 

1889
01:17:15,440 --> 01:17:20,040
要点编号

1890
01:17:16,920 --> 01:17:23,000
6969，然后我们要声明一个

1891
01:17:20,040 --> 01:17:25,800
整型，而我们所做的只是有这个 F

1892
01:17:23,000 --> 01:17:28,239
然后我们使用括号进行整数操作（由于原句不太完整和清晰，“brackets int”可能表述不太准确，这里是按字面大概的翻译） 

1893
01:17:25,800 --> 01:17:30,120
我们 我们把这些 我们真的就只是把

1894
01:17:28,239 --> 01:17:34,199
这个就在它前面，然后那会

1895
01:17:30,120 --> 01:17:36,480
静态类型转换 呃 把浮点数 69.6 转换为……（这里“n”可能有误，原英文不太完整准确表意）

1896
01:17:34,199 --> 01:17:38,560
转换为一个整数，而这将起到的作用是它会

1897
01:17:36,480 --> 01:17:42,199
只需截断最后一部分，所以在……中

1898
01:17:38,560 --> 01:17:45,679
内存本质上是以二进制和位的形式存在的

1899
01:17:42,199 --> 01:17:47,719
它会被布置成，嗯，它会有那个

1900
01:17:45,679 --> 01:17:49,280
第一部分 所以第一个，呃，第一个

1901
01:17:47,719 --> 01:17:51,760
整数部分，然后它会有这个

1902
01:17:49,280 --> 01:17:53,840
小数，然后它会有，呃，它会

1903
01:17:51,760 --> 01:17:56,520
它会有小数部分

1904
01:17:53,840 --> 01:17:58,800
之后，所以情况会是那样的。

1905
01:17:56,520 --> 01:18:00,760
十进制，然后在那之后，那么它会怎么做呢

1906
01:17:58,800 --> 01:18:04,000
是当它在进行类型转换时，它会……

1907
01:18:00,760 --> 01:18:06,679
呃，只要把这部分截断，然后给出

1908
01:18:04,000 --> 01:18:11,560
给我们这些……的更精确信息 

1909
01:18:06,679 --> 01:18:12,480
这些本质上是32位整数，所以，呃，它

1910
01:18:11,560 --> 01:18:14,600
那 那基本上就是它要发展的全部内容了

1911
01:18:12,480 --> 01:18:17,239
看起来它好像就会是……

1912
01:18:14,600 --> 01:18:19,360
69 呃，它不会有任何小数

1913
01:18:17,239 --> 01:18:23,440
它实际上会在这些地方进行四舍五入

1914
01:18:19,360 --> 01:18:26,320
往下说，你可以说，嗯，所以要是我突然……

1915
01:18:23,440 --> 01:18:28,840
进入；到……里面；朝，向；关于；转变成；对……很有兴趣，很喜欢

1916
01:18:26,320 --> 01:18:30,400
呃，类型

1917
01:18:28,840 --> 01:18:33,560
选角；铸件；铸造

1918
01:18:30,400 --> 01:18:37,120
然后奔跑

1919
01:18:33,560 --> 01:18:40,320
这个，你会看到，呃，我们得到这个整数

1920
01:18:37,120 --> 01:18:43,440
格式 所以就被截断了 然后当……的时候

1921
01:18:40,320 --> 01:18:47,760
我们塑造一个角色，嗯，实际上这是……

1922
01:18:43,440 --> 01:18:49,960
打算转换成，呃，阿斯克（不太明确“asky”具体所指），所以如果你

1923
01:18:47,760 --> 01:18:52,400
记住你的乘法口诀表，我继续说。

1924
01:18:49,960 --> 01:18:56,719
并在一旁提出这个问题

1925
01:18:52,400 --> 01:18:56,719
这里有一张天空桌（此处“asky”可能有误，推测正确的是“a sky” ） 

1926
01:18:56,880 --> 01:19:01,080
哦哟，它真的就在那儿呢

1927
01:18:58,520 --> 01:19:02,960
好的，问一问网站（注：Ask.com是一个美国的搜索网站 ）

1928
01:19:01,080 --> 01:19:06,199
嗯，我们可以

1929
01:19:02,960 --> 01:19:08,560
看呐，这边这个是一个

1930
01:19:06,199 --> 01:19:11,320
大写字母 E

1931
01:19:08,560 --> 01:19:14,120
对；没错；好的；行

1932
01:19:11,320 --> 01:19:17,639
所以是大写字母

1933
01:19:14,120 --> 01:19:19,600
E 大写的 E，看看，多么多么简单

1934
01:19:17,639 --> 01:19:22,480
那样做对吗？这么做也并非疯狂之举啊

1935
01:19:19,600 --> 01:19:24,159
将整数转换为字符，所以

1936
01:19:22,480 --> 01:19:25,159
就是这样，这就是类型转换的全部内容。

1937
01:19:24,159 --> 01:19:26,920
我不会再重复讲这个了。

1938
01:19:25,159 --> 01:19:28,800
广泛地，因为它并不像那种疯狂的（情况） 

1939
01:19:26,920 --> 01:19:30,159
我们最终在CUDA里使用的片段，但只是

1940
01:19:28,800 --> 01:19:31,560
把它说出来，提醒你

1941
01:19:30,159 --> 01:19:35,080
伙计们，这种类型的有多简单啊

1942
01:19:31,560 --> 01:19:38,000
问题是，我原本认为另一个话题是，呃

1943
01:19:35,080 --> 01:19:41,080
值得简要提及的是宏以及

1944
01:19:38,000 --> 01:19:43,280
全局变量，这样我们就可以……

1945
01:19:41,080 --> 01:19:46,520
本质上有这些基本的（东西） 

1946
01:19:43,280 --> 01:19:50,719
就像，呃，你知道的，如果……如果有定义，如果没有

1947
01:19:46,520 --> 01:19:53,040
定义了 L，如果……否则……然后……结束如果，呃，所以

1948
01:19:50,719 --> 01:19:54,880
这……我们本质上打算使用

1949
01:19:53,040 --> 01:19:57,880
这些稍后再申报

1950
01:19:54,880 --> 01:19:59,800
超参数，呃，就是不一样的（超参数和其他的不一样） 

1951
01:19:57,880 --> 01:20:01,400
我们需要获取的全球性事物

1952
01:19:59,800 --> 01:20:03,679
我们不想仅仅以……的身份通过

1953
01:20:01,400 --> 01:20:05,199
额外的，你知道那种臃肿的函数参数

1954
01:20:03,679 --> 01:20:06,960
当你在一场（此处原文不完整）中有大约20个论点时

1955
01:20:05,199 --> 01:20:08,679
功能方面，你可能想降低那个

注：由于原文“function”单独成一行，结合后面句子较难有非常符合语境的通顺译文，以上译文是在尽量贴合原文格式下的翻译。若有更详细的背景信息，译文可能会更准确合理。 

1956
01:20:06,960 --> 01:20:10,560
并且只需在本地声明其中的一些。

1957
01:20:08,679 --> 01:20:11,920
所以你可以在任何你想使用它们的地方使用它们，就像

1958
01:20:10,560 --> 01:20:13,520
只要它们没有改变，或者你（的情况）没有改变 

1959
01:20:11,920 --> 01:20:16,320
没对它们做任何奇怪的事

1960
01:20:13,520 --> 01:20:20,159
你……你没事吧，对吧，那么就像在这个（情况）里

1961
01:20:16,320 --> 01:20:23,480
例如，我会用，呃，大写的 π 来表示，然后…… 

1962
01:20:20,159 --> 01:20:25,960
然后我们让它等于，呃，一个两倍的值

1963
01:20:23,480 --> 01:20:29,280
那么，没错

1964
01:20:25,960 --> 01:20:31,040
呃，我们也能执行这些功能，所以它是……

1965
01:20:29,280 --> 01:20:33,360
有点像一个 Lambda 函数，如果你……

1966
01:20:31,040 --> 01:20:35,320
我们会用 Python 实现一个 Lambda 函数吗

1967
01:20:33,360 --> 01:20:38,000
这个区域，然后我们，我们不管怎样都继续前进

1968
01:20:35,320 --> 01:20:41,320
我们想进入，所以R是我们的半径，然后

1969
01:20:38,000 --> 01:20:44,440
实际上，我们所说的半径是皮恩（这里“piun”可能是拼写错误，正常英文里无此词）。 

1970
01:20:41,320 --> 01:20:46,040
r² 所以我们只需计算 π × r × r，然后就能得到

1971
01:20:44,440 --> 01:20:49,800
所以，这只是一个小的 Lambda（兰姆达）。

1972
01:20:46,040 --> 01:20:52,159
你可以将其作为宏来实现的功能，嗯，以及

1973
01:20:49,800 --> 01:20:55,159
那么，如果未定义半径，我们就有……所以

1974
01:20:52,159 --> 01:20:58,320
这里未定义“radius”，如果以及依赖（这里“DEP”可能是“dependence”等的缩写，结合语境可能更准确）如果

1975
01:20:55,159 --> 01:21:00,400
不太确定你说的“defin um”是什么，猜测可能是“define”。以下是尝试的翻译：
未定义半径，并且我们设定

1976
01:20:58,320 --> 01:21:04,040
将那个值设为 7，所以它将会是

1977
01:21:00,400 --> 01:21:06,960
一个整数 7 我们结束 若我们结束

1978
01:21:04,040 --> 01:21:09,440
整个这个街区以及半径范围是一个……

1979
01:21:06,960 --> 01:21:12,480
现在一个公开宣称的测量值等于

1980
01:21:09,440 --> 01:21:15,520
七，呃，然后我们有一些条件逻辑。

1981
01:21:12,480 --> 01:21:17,560
在下面这里，所以如果半径，呃，你知道它是……

1982
01:21:15,520 --> 01:21:20,159
大于 10，这不是我们所定义的

1983
01:21:17,560 --> 01:21:21,920
所以，这个，这个就像是打分之类的嗯

1984
01:21:20,159 --> 01:21:24,320
它也不小于五级

1985
01:21:21,920 --> 01:21:25,960
出去，然后，另外你……所以就这么继续着

1986
01:21:24,320 --> 01:21:28,080
保持在七，然后它将会

1987
01:21:25,960 --> 01:21:29,600
结束
如果这样，我们可以在这里进行条件逻辑判断，比如

1988
01:21:28,080 --> 01:21:32,000
嗯；好吧；嗯，这个嘛；哦，对了；哎呀；哟；那么，好吧；好吧，就这样吧；唔，这个……；嗯，那行；哎呀，好了；哟，得了吧；嗯，好啦

1989
01:21:29,600 --> 01:21:37,199
嗯，然后如果我直接把它弄破

1990
01:21:32,000 --> 01:21:40,480
从这个到，呃，宏，然后我们继续

1991
01:21:37,199 --> 01:21:40,480
类GCC

1992
01:21:41,520 --> 01:21:47,120
这个 我们打算 哦

1993
01:21:48,199 --> 01:21:53,159
双倍 我们会做 呃

1994
01:22:05,840 --> 01:22:13,600
完美，那么半径为 7 的圆的面积是多少。

1995
01:22:11,159 --> 01:22:14,880
嗯，会是这么多，而且那是

1996
01:22:13,600 --> 01:22:18,080
那是一个浮点数，我们…… 

1997
01:22:14,880 --> 01:22:19,600
这里有，所以，呃，这个半径，我……我没（表达完整，这里语义似乎不连贯）

1998
01:22:18,080 --> 01:22:21,320
小心点，这里这个半径实际上是一个

1999
01:22:19,600 --> 01:22:26,000
整数类型，所以我们只需将其设置回

2000
01:22:21,320 --> 01:22:28,600
嗯，然后它……然后它就起作用了，腹部这边……所以

2001
01:22:26,000 --> 01:22:31,560
呃，这就是你制作宏的方法。 

2002
01:22:28,600 --> 01:22:33,080
挺简单的，这部分就是我……的地方

2003
01:22:31,560 --> 01:22:34,639
理解变得有点模糊，我

2004
01:22:33,080 --> 01:22:37,199
没和编译器打过交道

2005
01:22:34,639 --> 01:22:39,760
广泛地阅读，但我确实找到了一些非常

2006
01:22:37,199 --> 01:22:41,480
关于呃，C 语言和 C++ 语言的优质资源

2007
01:22:39,760 --> 01:22:44,719
编译器 所以我刚刚提供了一些

2008
01:22:41,480 --> 01:22:47,239
这里有供你去学习的链接，嗯，GCC 是

2009
01:22:44,719 --> 01:22:52,320
最受欢迎的C编译器，所以那就是

2010
01:22:47,239 --> 01:22:54,920
GNU 呃 C 编译器 嗯 然后 g++ 是

2011
01:22:52,320 --> 01:22:57,239
同样的事情，但针对 C++

2012
01:22:54,920 --> 01:22:59,280
所以，呃，你知道我有不同的文章。

2013
01:22:57,239 --> 01:23:02,840
来自免费代码营（Free Code Camp）的这个，你可以

2014
01:22:59,280 --> 01:23:05,159
去看看，所以，呃，有……有……

2015
01:23:02,840 --> 01:23:06,400
这一个，然后我们还有另一个

2016
01:23:05,159 --> 01:23:09,400
作为；如同；当……时；因为；尽管

2017
01:23:06,400 --> 01:23:12,840
那么，编译器是用来解释什么的呢？

2018
01:23:09,400 --> 01:23:15,360
初学者 嗯，就像打个比方

2019
01:23:12,840 --> 01:23:18,600
本质上只是在转换，呃

2020
01:23:15,360 --> 01:23:21,400
将你的机器码转换为，呃

2021
01:23:18,600 --> 01:23:23,560
一直到汇编，而且你拥有所有（内容）

2022
01:23:21,400 --> 01:23:25,800
介于两者之间的这些表现形式

2023
01:23:23,560 --> 01:23:27,360
计算机用来辅助工作的（这段英文表述不太符合常见语法规范，但按要求进行了翻译）

2024
01:23:25,800 --> 01:23:30,320
能更好地理解事物 呃 然后

2025
01:23:27,360 --> 01:23:33,440
它会将那段汇编代码转换为

2026
01:23:30,320 --> 01:23:36,440
呃，本质上是呃，CPU指令

2027
01:23:33,440 --> 01:23:38,520
以比特和字节来表示，也就是二进制的 1

2028
01:23:36,440 --> 01:23:40,719
还有零，呃，然后那些会被发送出去

2029
01:23:38,520 --> 01:23:42,199
通过，正如，本质上是电子以及

2030
01:23:40,719 --> 01:23:44,280
通过你的……通过你的……（这里文本不太完整，语义不太明确） 

2031
01:23:42,199 --> 01:23:47,679
计算机中的电路，而那是

2032
01:23:44,280 --> 01:23:50,199
实际上是什么在执行这些东西呢，嗯，还有

2033
01:23:47,679 --> 01:23:51,840
那么仅仅 C 和 C++ 编译器有点（此处句子不完整，语义未表达完）

2034
01:23:50,199 --> 01:23:54,159
比特；一点；少量；片刻；钻头；马嚼子；辅币；老一套；比特（二进制信息单位）

2035
01:23:51,840 --> 01:23:56,480
呃，可能难度会稍微高一点，我

2036
01:23:54,159 --> 01:23:59,320
要知道 C++ 是一种比……更高级的语言（原句不完整） 

2037
01:23:56,480 --> 01:24:01,320
呃，但是这些真的就像……

2038
01:23:59,320 --> 01:24:04,000
很好的解释，可我实在……

2039
01:24:01,320 --> 01:24:06,679
在不搞砸的情况下超越自己，所以我

2040
01:24:04,000 --> 01:24:09,760
在这里提供了这些链接 嗯 希望如此

2041
01:24:06,679 --> 01:24:12,199
这一切都说得通，但呃，我们不会这么做。

2042
01:24:09,760 --> 01:24:14,960
真的需要对……了解太多

注：原句“about”后面内容缺失，以上是根据现有内容翻译。 

2043
01:24:12,199 --> 01:24:18,199
编译器
在下游，了解这些情况是有益的

2044
01:24:14,960 --> 01:24:20,760
他们正在做什么，但为了调试

2045
01:24:18,199 --> 01:24:22,760
代码，你只需要大致了解那种 

2046
01:24:20,760 --> 01:24:24,000
编译器的架构是什么

2047
01:24:22,760 --> 01:24:26,400
它在做什么，比如它在哪里，在哪里

2048
01:24:24,000 --> 01:24:28,960
这东西不一定像所有的……（这里句子似乎不完整）

2049
01:24:26,400 --> 01:24:30,840
数学以及正在发生的表征，嗯

2050
01:24:28,960 --> 01:24:34,280
当然，知道这一点挺好的，但事实并非如此。

2051
01:24:30,840 --> 01:24:35,639
需要编写能正常运行的代码，所以，呃

2052
01:24:34,280 --> 01:24:37,040
我们稍后再看，就像我们只是

2053
01:24:35,639 --> 01:24:39,000
基本上要输入这些

2054
01:24:37,040 --> 01:24:40,440
编译器标志以及诸如此类的东西

2055
01:24:39,000 --> 01:24:43,719
实际上，这就是下一部分的内容。

2056
01:24:40,440 --> 01:24:45,639
呃，它是关于 Makefile 的，所以是 Makefile

2057
01:24:43,719 --> 01:24:47,840
真的很有用，它们会起到帮助作用。

2058
01:24:45,639 --> 01:24:51,320
你呃，在……方面更有效率一些

2059
01:24:47,840 --> 01:24:53,440
正在开发 C、C++ 和 CUDA 代码，所以

2060
01:24:51,320 --> 01:24:56,639
而不是直接进入这里然后仅仅

2061
01:24:53,440 --> 01:24:58,280
每次都要敲呃，你懂的，GCC 这几个字母

2062
01:24:56,639 --> 01:25:00,199
也许，也许你有自动补全功能

2063
01:24:58,280 --> 01:25:01,800
像我，但不管怎样你只是想要

2064
01:25:00,199 --> 01:25:03,679
这是一个更快的过程，而你希望

2065
01:25:01,800 --> 01:25:06,040
能够实现自动化，并且拥有更多……

2066
01:25:03,679 --> 01:25:07,960
对所发生的事情拥有掌控力，呃，还有仅仅是…… 

2067
01:25:06,040 --> 01:25:11,080
更好地管理事务，创建文件是……什么（此处原英文文本不太符合正常语法表达，翻译可能不够通顺自然）

2068
01:25:07,960 --> 01:25:12,719
你想在文件里面这样做 它 它

（不过你提供的英文文本似乎存在表述不通顺的问题，可能有错误哦。） 

2069
01:25:11,080 --> 01:25:14,040
看起来真的很复杂，而且就好像

2070
01:25:12,719 --> 01:25:17,280
正在学习这门新语言，但它

注：原英文句子似乎不完整。

2071
01:25:14,040 --> 01:25:21,280
真的，没那么糟糕，嗯，你可以

2072
01:25:17,280 --> 01:25:24,360
定义变量，比如让 GCC 等于 GCC

2073
01:25:21,280 --> 01:25:26,360
为了使用这些，呃，我只需要

2074
01:25:24,360 --> 01:25:28,400
先输入美元符号，然后输入括号，并且

2075
01:25:26,360 --> 01:25:30,320
然后把那个变量放到……里面（原文不完整）

2076
01:25:28,400 --> 01:25:31,719
里面的变量名，然后它就会

2077
01:25:30,320 --> 01:25:34,520
当……的时候，几乎都会参考这个。

2078
01:25:31,719 --> 01:25:37,719
叫……嗯，顺便说一下，这是一个命令

2079
01:25:34,520 --> 01:25:39,320
所以你，我们马上就会看到这个了，嗯

2080
01:25:37,719 --> 01:25:41,600
我打算做一个小实验，和……（这里原文没说完）

2081
01:25:39,320 --> 01:25:44,040
这里有CUDA脚本，但我们仅仅有

2082
01:25:41,600 --> 01:25:46,719
这个 nvcc 映射到英伟达 CUDA

2083
01:25:44,040 --> 01:25:48,360
编译器，然后我们有 CUDA 标志，所以

2084
01:25:46,719 --> 01:25:50,199
这只是一件类似这样的小事。

2085
01:25:48,360 --> 01:25:51,639
我们即将看到我的 GPU 架构

2086
01:25:50,199 --> 01:25:54,320
以后你不必为此担心。

2087
01:25:51,639 --> 01:25:59,199
就是现在，但这就跟你一样，我的显卡

2088
01:25:54,320 --> 01:26:02,520
架构是一个呃 8.6 计算能力的架构 

2089
01:25:59,199 --> 01:26:04,600
能力，呃，或者

2090
01:26:02,520 --> 01:26:07,600
计算兼容性 我觉得它是

2091
01:26:04,600 --> 01:26:09,480
能力，嗯，不管怎样，这只是我们

2092
01:26:07,600 --> 01:26:11,040
可以只用旗帜，然后我们就可以

2093
01:26:09,480 --> 01:26:13,480
有更多我们要代入的变量

2094
01:26:11,040 --> 01:26:14,600
这些东西，但如果我回到阅读（状态）

2095
01:26:13,480 --> 01:26:18,760
为了我

2096
01:26:14,600 --> 01:26:20,600
我们有这些目标和先决条件

2097
01:26:18,760 --> 01:26:23,080
然后我们的命令嵌套在……里面

2098
01:26:20,600 --> 01:26:25,360
那么，这到底是如何运作的呢，嗯

2099
01:26:23,080 --> 01:26:29,520
我打算给你展示这个，嗯，就通过……

2100
01:26:25,360 --> 01:26:33,960
差不多就是这样的例子，所以，如果我

2101
01:26:29,520 --> 01:26:36,920
走
如果我走了，我实际上可以把这个删掉

2102
01:26:33,960 --> 01:26:40,320
如果我只是去做的话

注：你提供的英文内容似乎不完整，不过按照要求为你完成了翻译。 

2103
01:26:36,920 --> 01:26:42,719
01 看看它在这里是如何形成二进制的，并且

2104
01:26:40,320 --> 01:26:45,880
然后我就可以运行这个二进制文件，它会显示

2105
01:26:42,719 --> 01:26:48,280
嘘，这个，这个打印“F”，就，就…… 

2106
01:26:45,880 --> 01:26:50,920
打印“boo”，就好像它能正常运行一样，嗯，就从

2107
01:26:48,280 --> 01:26:53,119
制作01 那么我们正在做的是我们有

2108
01:26:50,920 --> 01:26:55,400
这个“make”命令，它是用于编译（或“制作”，具体结合语境确定）的。 

2109
01:26:53,119 --> 01:26:58,119
文件在某种程度上描绘了那里的情况，然后我们

2110
01:26:55,400 --> 01:26:59,840
有 01 这部分，它就是目标，所以

2111
01:26:58,119 --> 01:27:01,239
这，这就是目标，这是左边

2112
01:26:59,840 --> 01:27:04,440
结肠的一侧，然后之后是

2113
01:27:01,239 --> 01:27:07,639
它们的先决条件，所以注意我是如何……我……

2114
01:27:04,440 --> 01:27:11,679
移除了那另一部分 那个 

2115
01:27:07,639 --> 01:27:15,520
01c 所以从本质上来说，这意味着我们是

2116
01:27:11,679 --> 01:27:17,560
打算呃，要么确认这是……

2117
01:27:15,520 --> 01:27:20,440
这已经存在或者曾经存在过

2118
01:27:17,560 --> 01:27:22,560
好了，嗯，如果还没完成，我们打算……

2119
01:27:20,440 --> 01:27:25,520
去做吧，这样你就会明白在这些当中

2120
01:27:22,560 --> 01:27:28,159
下面有例子，但是

2121
01:27:25,520 --> 01:27:30,000
只是为了填补其余部分，这样我们就有一个

2122
01:27:28,159 --> 01:27:32,159
有一堆事情正在发生，我们有这个

2123
01:27:30,000 --> 01:27:34,679
我们有一个名为 GCC 的变量，它仅仅是

2124
01:27:32,159 --> 01:27:38,040
说你知道，这本质上就是…… 

2125
01:27:34,679 --> 01:27:41,119
只是去，呃，你懂的

2126
01:27:38,040 --> 01:27:43,360
GCC 嗯，它只是在做那件事，然后我们

2127
01:27:41,119 --> 01:27:46,000
把这个 @ 符号放在……前面

2128
01:27:43,360 --> 01:27:50,119
它，这意味着不要在……里把这个打印出来

2129
01:27:46,000 --> 01:27:50,960
终端，所以如果我只是，呃，把这个移除

2130
01:27:50,119 --> 01:27:54,639
和；并且；然后；而且

2131
01:27:50,960 --> 01:27:58,400
去，呃，把那个“at”删掉

2132
01:27:54,639 --> 01:28:00,639
然后去，呃

2133
01:27:58,400 --> 01:28:04,080
清理 我只是 我只是把这个拿掉

2134
01:28:00,639 --> 01:28:08,159
为了 为了 这样它才能发挥最大作用

2135
01:28:04,080 --> 01:28:10,679
有了感觉，然后我去弄，呃，01，你会……

2136
01:28:08,159 --> 01:28:15,040
看呐，实际上它确实在……给我们展示这个。 

2137
01:28:10,679 --> 01:28:16,960
终端 嗯 但如果我在那里放一个@符号

2138
01:28:15,040 --> 01:28:18,320
那么这就不对了，所以只是……

2139
01:28:16,960 --> 01:28:20,080
把它移除，这只会让事情变得更……

2140
01:28:18,320 --> 01:28:22,239
干净整洁，而且这就像是一种最佳做法

2141
01:28:20,080 --> 01:28:25,000
只是很容易看到你想要看到的东西，嗯。

2142
01:28:22,239 --> 01:28:26,840
也许就看看那些，呃

2143
01:28:25,000 --> 01:28:28,840
可能会做出奇怪的事情，而你只希望

2144
01:28:26,840 --> 01:28:31,199
以确保你所有的变量

2145
01:28:28,840 --> 01:28:34,480
是正确的，嗯，但这非常简单

2146
01:28:31,199 --> 01:28:37,119
你不需要把这个打印出来，嗯，还有

2147
01:28:34,480 --> 01:28:39,600
然后直接跳到，呃，就像第……号

2148
01:28:37,119 --> 01:28:44,360
这里有两个

2149
01:28:39,600 --> 01:28:45,800
所以，呃，第二点实际上是……

2150
01:28:44,360 --> 01:28:49,159
同样的事情

2151
01:28:45,800 --> 01:28:51,119
所以，呃，我甚至都不会去执行那个。

2152
01:28:49,159 --> 01:28:54,800
我们甚至都不需要运行这个

2153
01:28:51,119 --> 01:28:58,000
嗯，然后03只是CA编译器

2154
01:28:54,800 --> 01:28:59,080
所以我们使用 nvcc 命令，然后加上 CUDA 编译选项，这样…… 

2155
01:28:58,000 --> 01:29:01,440
这本质上它将会是什么情况

注：原英文句子表述不太完整和规范，更自然的表达可能类似 “which is essentially what it's going to be”  。以上翻译是基于给定原文进行的。 

2156
01:28:59,080 --> 01:29:05,560
看起来它要走了

2157
01:29:01,440 --> 01:29:10,159
nvcc 达斯拱门

注：“Das Arch”可能并不是一个准确的表达，“Arch”常见意思有“拱门；拱” ， “Das”在德语里是“这个；那个”等意思，但不清楚这里具体语境和想表达的准确内容。如果“Arch”想表达NVIDIA的架构相关意思，可能更合适的理解需结合更完整的上下文。 

2158
01:29:05,560 --> 01:29:11,960
呃，把那个处理掉，然后，嗯，它是……

2159
01:29:10,159 --> 01:29:13,480
即将通过；即将提交（具体含义需结合语境，“pass in”常见有“通过、提交”等意思 ）

如果结合更合适的语境，可进一步优化译文。比如：
I'm going to pass in my homework.（我打算交作业。） 
The bill is going to pass in the parliament.（这项法案即将在议会通过。） 

2160
01:29:11,960 --> 01:29:16,320
哦

2161
01:29:13,480 --> 01:29:19,679
03 看，那就是我们想要的二进制文件

2162
01:29:16,320 --> 01:29:22,119
存在，然后

2163
01:29:19,679 --> 01:29:24,880
那会持续下去，而且我们应该

2164
01:29:22,119 --> 01:29:27,440
能够达到零下3摄氏度，它会显示

注：这里“03 C”推测为“-3°C” ，一般表达零下3摄氏度用“-3°C”  ，英文是“minus three degrees Celsius”  。 

2165
01:29:24,880 --> 01:29:29,719
从这里发出嘘声，对，所以就只是……

2166
01:29:27,440 --> 01:29:31,920
同样的情况，嗯，我们只是把像 CUDA 这样的东西包含进来。

2167
01:29:29,719 --> 01:29:34,400
运行时间，搞这么多就为了显得花哨

2168
01:29:31,920 --> 01:29:35,600
但它只是，只是输出了启动信息。

2169
01:29:34,400 --> 01:29:38,000
靴子；启动；解雇；行李箱

注：“the boot”有多个常见释义，需结合具体语境确定最准确的含义。 

2170
01:29:35,600 --> 01:29:40,320
命令；指令；指挥；控制；掌握；运用能力；司令部；指挥部；管辖区域
（也可作动词，意为）命令；指挥；控制；拥有；博得；俯瞰；应得；值得

2171
01:29:38,000 --> 01:29:42,920
嗯，是的，这……这是一个……这非常

2172
01:29:40,320 --> 01:29:45,119
简单的例子，所以从本质上来说它仅仅是

2173
01:29:42,920 --> 01:29:47,760
转换，呃，它正在转换这些

2174
01:29:45,119 --> 01:29:49,440
变量名，并且不打印任何内容

2175
01:29:47,760 --> 01:29:52,400
外面；出去；离开；出局；过时；熄灭；完结；到室外；向外；出现；公开；明显；彻底地；完全地

由于“out”含义较多，需结合具体语境来确定最合适的译法。你可以补充更多相关内容。 

2176
01:29:49,440 --> 01:29:53,840
嗯，我们就去做03，它会搞定的。 

2177
01:29:52,400 --> 01:29:55,280
完全一样的事情，看，这需要一点（时间/功夫等，需结合语境）

2178
01:29:53,840 --> 01:29:59,880
当……的时候；虽然；然而

2179
01:29:55,280 --> 01:30:02,280
完全一样的情况，嗯，我们这里很干净

2180
01:29:59,880 --> 01:30:04,040
实际上将要执行的命令

2181
01:30:02,280 --> 01:30:07,239
移除所有这些二进制文件，这样当我们

2182
01:30:04,040 --> 01:30:08,719
想把一切都清理干净，呃，然后就……

2183
01:30:07,239 --> 01:30:10,400
你知道的，要把它弄得美观又得体。

2184
01:30:08,719 --> 01:30:12,000
就好像我们从未做过像我正在做的这样的工作

2185
01:30:10,400 --> 01:30:14,600
和你们这些人打交道，我要删（东西）了

2186
01:30:12,000 --> 01:30:16,000
在进行课程学习之前，先处理这些二进制文件（注：这里原句可能不太完整，“these binaries”可根据具体语境更准确翻译） 

2187
01:30:14,600 --> 01:30:19,840
呃，因为当我有（某个东西，需结合前文判断）的时候，它看起来很丑。 

2188
01:30:16,000 --> 01:30:23,760
更多的文件，这样我就可以直接去，呃，制作

2189
01:30:19,840 --> 01:30:26,239
干干净净地消失了，嗯，所以呢，就是这样

2190
01:30:23,760 --> 01:30:27,400
就像一个非常非常简单的例子，而且它是

2191
01:30:26,239 --> 01:30:29,880
只是，就好像先制作，然后……

2192
01:30:27,400 --> 01:30:31,360
不管目标是什么，呃，它又升上去了。

2193
01:30:29,880 --> 01:30:34,639
对于这些

2194
01:30:31,360 --> 01:30:39,679
这些有点意思。

2195
01:30:34,639 --> 01:30:41,520
所以01非核心对象，这是用于表示物体的

2196
01:30:39,679 --> 01:30:45,520
这将，呃

2197
01:30:41,520 --> 01:30:48,000
GCC 呃，编译呃，它将接收…… 

2198
01:30:45,520 --> 01:30:50,440
这段 C 代码，它将输出呃

2199
01:30:48,000 --> 01:30:52,440
这个“o”文件或者这个目标文件，所以它接下来会…… 

2200
01:30:50,440 --> 01:30:53,639
基本上会是这样，但

2201
01:30:52,440 --> 01:30:58,199
它只是要生成目标文件

2202
01:30:53,639 --> 01:31:02,280
而不是一个二进制的“嗯”，然后是这个 01

2203
01:30:58,199 --> 01:31:05,639
呃，对象，所以这个对象，呃，执行

2204
01:31:02,280 --> 01:31:08,560
跑，这会涉及到这个……这个

2205
01:31:05,639 --> 01:31:10,320
将前一个作为前提条件，以便

2206
01:31:08,560 --> 01:31:12,000
意味着这一个必须已经是

2207
01:31:10,320 --> 01:31:13,440
完整的，如果它不完整，我们就……

2208
01:31:12,000 --> 01:31:18,199
打算运行它并确保它是

2209
01:31:13,440 --> 01:31:19,320
为了让这个起作用需要完成，所以，呃

2210
01:31:18,199 --> 01:31:22,760
我们要走了

2211
01:31:19,320 --> 01:31:24,960
呃，将这个目标文件编译成一个

2212
01:31:22,760 --> 01:31:27,360
二进制，所以你有像 C 语言这样的（东西）

2213
01:31:24,960 --> 01:31:31,520
C语言表示形式，然后是对象

2214
01:31:27,360 --> 01:31:33,719
我们在这里处理的文件，然后是这个

2215
01:31:31,520 --> 01:31:36,119
有人拿到那个新的目标文件，然后

2216
01:31:33,719 --> 01:31:39,719
将其转换为二进制，然后我们

2217
01:31:36,119 --> 01:31:46,080
在这一行执行那个二进制文件，所以如果我

2218
01:31:39,719 --> 01:31:47,159
去，呃，制作，然后 01，呃，对象文件，呃，

2219
01:31:46,080 --> 01:31:49,960
执行；实施；使生效；处决；完成；演奏；表演

2220
01:31:47,159 --> 01:31:50,800
运行，而且我们没有这些文件中的任何一个。

2221
01:31:49,960 --> 01:31:54,480
在；在……之内

2222
01:31:50,800 --> 01:31:57,760
这里它将会

注：原英文句子不完整，此翻译仅按照字面进行处理。 

2223
01:31:54,480 --> 01:32:00,239
实际上这将，呃，确保

2224
01:31:57,760 --> 01:32:03,080
这被称为“第一”，因为它还没有

2225
01:32:00,239 --> 01:32:05,400
嗯，所以它将会……它将会

2226
01:32:03,080 --> 01:32:07,119
将这个 C 文件转换为目标文件，然后

2227
01:32:05,400 --> 01:32:08,440
它将把那个物体转换成一个

2228
01:32:07,119 --> 01:32:11,400
二进制，并且它将执行那个操作

2229
01:32:08,440 --> 01:32:13,280
二进制，所以这只是……我可能过度……

（原英文文本似乎不完整） 

2230
01:32:11,400 --> 01:32:16,159
稍微解释一下事情，但这是

2231
01:32:13,280 --> 01:32:18,800
这差不多就是关于你如何……的想法。

注：原句不完整，“how you”后面应该还有内容。 

2232
01:32:16,159 --> 01:32:21,040
呃，你如何能实现仅对 C 语言进行自动化操作呢 

2233
01:32:18,800 --> 01:32:23,119
编译
C++ 编译
我们要开始了

2234
01:32:21,040 --> 01:32:24,440
更多地将其用于呃 CUDA 脚本

2235
01:32:23,119 --> 01:32:26,719
沿着这条路；在远处；在未来

2236
01:32:24,440 --> 01:32:28,239
呃，但那就是大致的想法了。

2237
01:32:26,719 --> 01:32:30,199
然后是顶部这个虚假的部分

2238
01:32:28,239 --> 01:32:32,600
可能看起来有点奇怪，但这个

2239
01:32:30,199 --> 01:32:36,719
本质上意味着 呃 我们不是 我们不是

2240
01:32:32,600 --> 01:32:39,639
打算，呃，这就像是一种……方式

2241
01:32:36,719 --> 01:32:41,760
让，呃，东西使用起来更方便，做到这样

2242
01:32:39,639 --> 01:32:44,719
你不会遇到我所碰到的那些错误，我之前还算顺利。（注：原英文句子似乎表述不太完整或有语病，但按要求进行了翻译） 

2243
01:32:41,760 --> 01:32:47,560
这里有个解释，所以，嗯，假设我们有一个制作（这里“make”含义不太明确，需结合具体语境确定更合适的表达）

2244
01:32:44,719 --> 01:32:49,360
文件 创建一个名为 clean 的目标文件

2245
01:32:47,560 --> 01:32:51,880
所以在这个，这个清理命令中，那个

2246
01:32:49,360 --> 01:32:53,280
我猜这样一切又会变得美好起来了

2247
01:32:51,880 --> 01:32:55,280
我们在……中有一个名为 clean 的目录

2248
01:32:53,280 --> 01:32:57,760
与 make 文件在同一目录下，所以这里

2249
01:32:55,280 --> 01:33:00,080
如果我们有个叫“干净”的东西，嗯，如果我们

2250
01:32:57,760 --> 01:33:02,400
运行“make clean”，“make”将不会运行该（此处原英文表述不完整，可能缺少后续内容）

2251
01:33:00,080 --> 01:33:04,159
命令 嗯，它不会运行该命令

2252
01:33:02,400 --> 01:33:06,520
在目标处清洁，因为要清洁

2253
01:33:04,159 --> 01:33:06,520
已经

2254
01:33:07,760 --> 01:33:11,360
相反它会看到那个

2255
01:33:09,600 --> 01:33:13,040
目录“clean”已存在，将不会

2256
01:33:11,360 --> 01:33:14,639
它不会运行它，所以简而言之，我们

2257
01:33:13,040 --> 01:33:16,560
本质上是采用一系列映射关系

2258
01:33:14,639 --> 01:33:19,560
从目标名称到

2259
01:33:16,560 --> 01:33:21,159
命令 嗯，那就是……那就是这个的所在之处

2260
01:33:19,560 --> 01:33:22,760
虚假的东西源于此，所以它就像一个

2261
01:33:21,159 --> 01:33:24,440
如果你愿意这么说的话，这就像一场骗局，而我不愿意（这么认为）。

注：原英文句子不太完整和通顺，这里根据语义做了一定补充让译文更自然。 

2262
01:33:22,760 --> 01:33:27,800
知道那背后的理念是什么

2263
01:33:24,440 --> 01:33:29,639
命名，但这就是它的运作方式，嗯

2264
01:33:27,800 --> 01:33:32,280
然后我们还有一些其他的东西

2265
01:33:29,639 --> 01:33:34,600
这里面的东西，所以我已经检查过了

2266
01:33:32,280 --> 01:33:38,719
@符号，然后还有这个

2267
01:33:34,600 --> 01:33:42,840
所以，冒号等于，嗯，我不（知道/明白等，需结合语境确定准确语义） 

2268
01:33:38,719 --> 01:33:45,159
我觉得我们在这里用这个，但是，呃，等于

2269
01:33:42,840 --> 01:33:46,840
用于对变量进行除法运算，或者呃

2270
01:33:45,159 --> 01:33:48,560
这被称为递归赋值，所以

2271
01:33:46,840 --> 01:33:50,560
两者都用于对变量进行除法运算，两者均……（句子似乎不完整） 

2272
01:33:48,560 --> 01:33:54,159
这些……这一个是递归的

2273
01:33:50,560 --> 01:33:57,000
赋值，所以变量的值是

2274
01:33:54,159 --> 01:33:58,840
每次使用时都会重新评估，嗯，并且

2275
01:33:57,000 --> 01:34:01,159
那么这是一个简单的作业，或者

2276
01:33:58,840 --> 01:34:03,040
立即求值的那个，它仅被求值一次

2277
01:34:01,159 --> 01:34:04,600
在定义的层面上，所以这是

2278
01:34:03,040 --> 01:34:06,760
就像通常你想要的更安全的选择

2279
01:34:04,600 --> 01:34:08,600
如果你把事情变得非常复杂，情况就会变糟

注：原英文表述不太完整，推测可能是想说“如果把事情搞得特别复杂就会陷入困境”之类的意思，以上翻译根据常见语义做了一定补充。 

2280
01:34:06,760 --> 01:34:10,000
制作你最终可能会碰到的文件

2281
01:34:08,600 --> 01:34:12,480
这些递归相关的事情很奇怪

2282
01:34:10,000 --> 01:34:14,520
作业，所以一般来说这样做是安全的

2283
01:34:12,480 --> 01:34:17,040
用这些，但看起来……看起来

2284
01:34:14,520 --> 01:34:19,480
有点搞笑，所以我没把它包含进去

2285
01:34:17,040 --> 01:34:22,119
这个例子，嗯，我们会用到它。

2286
01:34:19,480 --> 01:34:24,719
不过沿着这条路走下去
所以最后但并非最不重要的是 

2287
01:34:22,119 --> 01:34:28,000
至少，呃，我们有调试器，所以调试器是

2288
01:34:24,719 --> 01:34:30,280
仅仅作为……的替代方案就很棒了

2289
01:34:28,000 --> 01:34:32,400
只是添加打印行
打印
仅仅打印

2290
01:34:30,280 --> 01:34:34,840
这个印刷品，我们在这儿做出来啦，耶！

2291
01:34:32,400 --> 01:34:37,000
我们做到了啊
我们失败了
不管怎样
只是

2292
01:34:34,840 --> 01:34:38,760
添加那些只会让你的代码变得臃肿，所以

2293
01:34:37,000 --> 01:34:40,840
有调试器会让这件事容易得多

2294
01:34:38,760 --> 01:34:43,199
在你……呃，实际上你可以往下走到

2295
01:34:40,840 --> 01:34:45,960
逐字汇编，然后看看那个（地方）在哪里

注：由于文本不完整，翻译可能无法完全准确传达其确切含义。 

2296
01:34:43,199 --> 01:34:47,239
电子存在于你的代码里，呃，就像在……

2297
01:34:45,960 --> 01:34:49,800
你在你的剧本里写的，比如什么是……（此句英文原句可能表述有误，正确的或许是 “You're in your script, like what is...”  ） 

2298
01:34:47,239 --> 01:34:51,639
硬件上正在发生的情况，所以，呃

2299
01:34:49,800 --> 01:34:53,440
调试器非常有用，而且在

2300
01:34:51,639 --> 01:34:57,239
特别是，我们接下来要讨论

2301
01:34:53,440 --> 01:35:00,040
关于用于 C 和 C++ 的 GDB 调试器，所以……

2302
01:34:57,239 --> 01:35:03,159
你用它们来做……嗯，反正我不去了。 

2303
01:35:00,040 --> 01:35:04,400
来非常详细地解释这些，我

2304
01:35:03,159 --> 01:35:05,960
在我自己的世界里感觉不自在

2305
01:35:04,400 --> 01:35:10,080
对这些的解释，因为有……

2306
01:35:05,960 --> 01:35:13,520
只是发生了很多事，嗯，但有……

2307
01:35:10,080 --> 01:35:15,119
一些你通常想要的命令

2308
01:35:13,520 --> 01:35:18,560
熟悉它 大部分时候仅仅是

2309
01:35:15,119 --> 01:35:21,520
指令以及清楚该寻找什么

2310
01:35:18,560 --> 01:35:23,199
在你的剧本里，所以我在……中有这些

2311
01:35:21,520 --> 01:35:24,560
自述文件，仅仅是带有一些

2312
01:35:23,199 --> 01:35:27,719
解释；说明；阐述；辩解；剖白

2313
01:35:24,560 --> 01:35:30,760
嗯，不过这里有一个非常好的概述。

2314
01:35:27,719 --> 01:35:35,080
所以这是通过低层次学习完成的，已经……

（原句表述可能存在一些不完整或不准确的地方，“lowle”可能是“low-level”之类的拼写错误。） 

2315
01:35:30,760 --> 01:35:36,880
这里有一则广告，但呃，本质上

2316
01:35:35,080 --> 01:35:40,280
这只是 这真的很不错

2317
01:35:36,880 --> 01:35:41,639
关于呃 GDB 的概述，呃，只是深入探讨一下

2318
01:35:40,280 --> 01:35:45,000
组装并做一堆很酷的（事）

2319
01:35:41,639 --> 01:35:49,119
用那种方式编写技巧和调试 C 代码

注：原英文 “tricks and and debuging” 可能存在拼写错误，推测 “and and” 为笔误，“debuging” 正确拼写应为 “debugging” 。 

2320
01:35:45,000 --> 01:35:49,119
所以我确实推荐你去看那个

2321
01:35:50,239 --> 01:35:54,320
视频 好了，我们终于可以拍一个

2322
01:35:52,360 --> 01:35:56,080
喘口气吧，刚才可真够累人的

2323
01:35:54,320 --> 01:35:58,360
呃，但我真的希望这一切会朝着……（这里文本不完整，going后面应该还有内容） 

2324
01:35:56,080 --> 01:35:59,960
为了在某种程度上缓解一下，呃，这是

2325
01:35:58,360 --> 01:36:01,600
被设计成一个更被动的部分，在那里

2326
01:35:59,960 --> 01:36:03,639
你可以有点儿就那么闲坐着，然后

2327
01:36:01,600 --> 01:36:05,600
听一听，看一看，然后尽情享受就好

2328
01:36:03,639 --> 01:36:08,760
呃，这里不涉及任何编码。

2329
01:36:05,600 --> 01:36:11,560
呃，所以我想我可以提供一些

2330
01:36:08,760 --> 01:36:13,080
不同类型硬件的相关背景信息

2331
01:36:11,560 --> 01:36:14,280
GPU的整体用途是什么，我……

2332
01:36:13,080 --> 01:36:15,960
意思是你可能已经知道他们是什么（这里原句不完整，推测可能表达这个意思） 

2333
01:36:14,280 --> 01:36:17,400
不过我只是想提供那个

2334
01:36:15,960 --> 01:36:19,920
背景 只是为了让我们能处于（达成）……（这里原文不完整，意思不太明确）

2335
01:36:17,400 --> 01:36:22,159
完全一致，嗯，只是为了

2336
01:36:19,920 --> 01:36:24,760
我猜是提供某种内部的（东西）

2337
01:36:22,159 --> 01:36:26,600
为下一部分做准备，呃

2338
01:36:24,760 --> 01:36:29,040
偶尔有这些休息时间挺好的，就为了……

2339
01:36:26,600 --> 01:36:31,679
你知道的，让你的思绪稍微慢下来，然后

2340
01:36:29,040 --> 01:36:36,800
呃，给自己一些时间

2341
01:36:31,679 --> 01:36:38,400
但首先，我们有这些中央处理器，好的

2342
01:36:36,800 --> 01:36:40,560
你已经知道什么是 CPU 了，它是

2343
01:36:38,400 --> 01:36:43,360
通用
每（此处“per”后内容缺失，表意不完整）高时钟速度

2344
01:36:40,560 --> 01:36:45,880
核心 数量极少的核心 在……上的

注：你提供的内容似乎并不是一个完整、通顺的英文句子，这只是逐词翻译。 

2345
01:36:43,360 --> 01:36:48,000
芯片内存非常大，所以也许你

2346
01:36:45,880 --> 01:36:49,440
不知道那个……关于……上面的缓存

2347
01:36:48,000 --> 01:36:52,800
与……相比，芯片实际上相当大（这里原句不完整，compared后面应该还有内容） 

2348
01:36:49,440 --> 01:36:56,199
到图形处理器（GPU）嗯，这是因为你知道

2349
01:36:52,800 --> 01:36:58,480
从，呃，从 CPU 到……的内存带宽

2350
01:36:56,199 --> 01:37:00,360
你电脑上的那些内存插槽

2351
01:36:58,480 --> 01:37:01,760
将会是，呃，像那样的转移

2352
01:37:00,360 --> 01:37:03,119
速度将会非常慢，你有…… 

2353
01:37:01,760 --> 01:37:05,199
将电子一路从……移动

注：原文“from”后缺少内容，译文只能根据现有内容进行翻译。 

2354
01:37:03,119 --> 01:37:07,320
把主板的这部分接到这一部分上

2355
01:37:05,199 --> 01:37:09,040
而且那需要时间，对吧，你……你……

2356
01:37:07,320 --> 01:37:10,960
只是一直在等待数据以（这里原句不完整，翻译按已有内容处理）

2357
01:37:09,040 --> 01:37:12,960
到达，而那差不多就是所占用的（时间等，需结合上下文） 

2358
01:37:10,960 --> 01:37:15,000
大部分时间都是这样，所以你有

2359
01:37:12,960 --> 01:37:16,400
这些大型缓存仅仅是为了像……这样有目的地（使用）

2360
01:37:15,000 --> 01:37:21,159
加载预加载的内容，以便

2361
01:37:16,400 --> 01:37:23,360
它们可以使用了，嗯，你有更低（的……，这里信息不完整，“lower”后可能缺内容）

2362
01:37:21,159 --> 01:37:25,840
延迟，所以CPU的整个理念是要

2363
01:37:23,360 --> 01:37:27,280
尽快完成这项任务就行

注：原英文表述存在一些重复用词的口语化现象，一般规范表达可能是 “Just complete this task as quickly as possible” 。此翻译基于给定原文。 

2364
01:37:25,840 --> 01:37:30,119
尽可能并仅返回该值

2365
01:37:27,280 --> 01:37:31,639
赶紧完成它，尽快完成它，嗯，还有

2366
01:37:30,119 --> 01:37:34,639
那么它们的吞吐量也很低，所以

2367
01:37:31,639 --> 01:37:38,520
低吞吐量意味着，嗯，它无法像……那样去做

2368
01:37:34,639 --> 01:37:41,560
相比较而言，它没办法像……那样做

2369
01:37:38,520 --> 01:37:42,719
每秒的操作次数和 GPU 所能达到的一样多

2370
01:37:41,560 --> 01:37:44,639
如果你说的是简单的（情况）

2371
01:37:42,719 --> 01:37:46,840
说明，如果它们更复杂的话

2372
01:37:44,639 --> 01:37:48,639
像管理和加载数据之类的操作以及

2373
01:37:46,840 --> 01:37:51,400
进行像文件读取和写入之类的操作 

2374
01:37:48,639 --> 01:37:54,239
那样会更快，但如果你正在说话

2375
01:37:51,400 --> 01:37:55,920
喜欢数学和矩阵乘法

2376
01:37:54,239 --> 01:37:58,280
呃，这将会非常显著地……（这里原句不完整，推测后面还有内容） 

2377
01:37:55,920 --> 01:38:01,040
更低的吞吐量被更多地提及。

2378
01:37:58,280 --> 01:38:04,000
比如每秒的操作次数，所以如果我

2379
01:38:01,040 --> 01:38:05,800
让一堆核心以比如说，呃，（这样的状态）运行

2380
01:38:04,000 --> 01:38:08,159
每秒20亿次时钟周期，而且我有

2381
01:38:05,800 --> 01:38:10,040
其中6000个对阵6个核心，这些核心是

2382
01:38:08,159 --> 01:38:11,760
以每秒50亿次时钟周期的速度运行

2383
01:38:10,040 --> 01:38:13,119
正确地做数学计算，有多少运算呢？

2384
01:38:11,760 --> 01:38:15,080
你打算在这一个上怎么做，相比……

2385
01:38:13,119 --> 01:38:16,960
就是那个，那就是GPU的关键所在。

2386
01:38:15,080 --> 01:38:19,199
更多的核心，稍低的时钟频率

2387
01:38:16,960 --> 01:38:20,760
速度 嗯 但核心数量要多得多 它是

2388
01:38:19,199 --> 01:38:24,400
CPU数量完全处于劣势，而且那是

2389
01:38:20,760 --> 01:38:27,560
为什么它更快，嗯，然后接着说

2390
01:38:24,400 --> 01:38:28,880
我们有的GPU，90系列还未发布

2391
01:38:27,560 --> 01:38:35,000
不过我觉得把它放上去挺有趣的

2392
01:38:28,880 --> 01:38:37,440
呃，GPU（图形处理器）非常专业化，所以

2393
01:38:35,000 --> 01:38:39,480
他们可以完成更简单的指令。

2394
01:38:37,440 --> 01:38:41,159
更容易处理，因此这就是为什么他们……

2395
01:38:39,480 --> 01:38:43,520
上面有更小的控制器，这些控制器……（这里which引导的句子未完整，翻译结合语境理解会更准确） 

2396
01:38:41,159 --> 01:38:46,040
你马上就会看到 嗯 他们有一个

2397
01:38:43,520 --> 01:38:49,239
更低的时钟频率，就像我之前多次说过的那样

2398
01:38:46,040 --> 01:38:51,040
核心数量较少且缓存较小，所以因为你

2399
01:38:49,239 --> 01:38:52,679
把那个存在芯片内存里，因为你

2400
01:38:51,040 --> 01:38:54,639
实际上有你能使用的这种显存

注：原句似乎不完整，“that you can”之后可能还有内容。但按照要求，根据现有内容进行了翻译。 

2401
01:38:52,679 --> 01:38:56,320
在 GPU 上的访问，并且那个

2402
01:38:54,639 --> 01:38:58,520
这就是所有的英伟达硬件了。

2403
01:38:56,320 --> 01:39:01,520
工程师们本质上是为……进行了优化

2404
01:38:58,520 --> 01:39:03,480
访问那个，嗯，你能够获得一个

2405
01:39:01,520 --> 01:39:06,840
这样一来，内存带宽要高得多。

2406
01:39:03,480 --> 01:39:09,480
在类似每（单位）高达100GB的（情况）下

2407
01:39:06,840 --> 01:39:12,400
第二个范围，嗯，所以就好像是……它是……它是

2408
01:39:09,480 --> 01:39:14,199
肯定有好几百个呢，嗯，你有……

2409
01:39:12,400 --> 01:39:16,360
这次延迟更高，记住，不是…… 

2410
01:39:14,199 --> 01:39:18,040
因为你知道要尽量减少时间

2411
01:39:16,360 --> 01:39:20,760
完成这项任务需要的时间，然后

2412
01:39:18,040 --> 01:39:22,840
只要做得对，它就会更优化。

2413
01:39:20,760 --> 01:39:25,520
关于吞吐量，我们已经讨论过了

2414
01:39:22,840 --> 01:39:28,599
关于这个，但是，嗯，然后你有这些

2415
01:39:25,520 --> 01:39:30,719
最近遇到的张量处理单元（TPUs）以及

2416
01:39:28,599 --> 01:39:35,040
这些是用于现代深度学习的。

2417
01:39:30,719 --> 01:39:36,920
应用程序，所以张量处理单元（TPU）实际上是用于…… 

2418
01:39:35,040 --> 01:39:38,599
就像你一样快速处理张量

2419
01:39:36,920 --> 01:39:40,639
矩阵乘法 快速 线性

2420
01:39:38,599 --> 01:39:42,719
代数，就是这样，这就是张量代数

2421
01:39:40,639 --> 01:39:45,440
线性张量运算是否是线性的

2422
01:39:42,719 --> 01:39:48,960
代数，嗯，而且它只是专门用于…… 

2423
01:39:45,440 --> 01:39:50,639
这样做是为了让张量处理单元（TPU）更快，但……

2424
01:39:48,960 --> 01:39:52,719
更昂贵且专注于

2425
01:39:50,639 --> 01:39:54,320
通常不是消费级硬件，所以

2426
01:39:52,719 --> 01:39:57,360
这就是为什么我们要学习，你懂的

2427
01:39:54,320 --> 01:39:58,400
在配备 GPU 的基础设施之上进行构建

2428
01:39:57,360 --> 01:40:01,159
因为你知道，实际上你可以

2429
01:39:58,400 --> 01:40:04,840
买得起的话，你可以在家里放一个。

2430
01:40:01,159 --> 01:40:07,080
而且成本相当低，嗯，然后你

2431
01:40:04,840 --> 01:40:09,159
有这些 FBT（此处可能为特定缩写，需结合上下文确定准确含义），我没指望你（……） 

2432
01:40:07,080 --> 01:40:11,199
知道这些是什么，但这些田地

2433
01:40:09,159 --> 01:40:13,000
可编程门阵列非常

2434
01:40:11,199 --> 01:40:15,880
专门的硬件部件，这些……（此处“that”引导的从句没完整，可根据后续内容进一步翻译） 

2435
01:40:13,000 --> 01:40:18,520
本质上说，呃，不用非得……

2436
01:40:15,880 --> 01:40:20,679
编写类似（某种程序）或构建定制硬件

2437
01:40:18,520 --> 01:40:22,400
配置，呃，比如针对某一特定任务的配置

2438
01:40:20,679 --> 01:40:24,040
为了制作你所需要的东西

2439
01:40:22,400 --> 01:40:26,119
跑得非常非常快

2440
01:40:24,040 --> 01:40:29,159
嗯，你可以对这些进行编程，你能做到

2441
01:40:26,119 --> 01:40:32,080
只需对实际的芯片进行编程，来做呃

2442
01:40:29,159 --> 01:40:34,880
关于什么的更精细的内容

2443
01:40:32,080 --> 01:40:36,719
你想要这样，以便能对它有更多的掌控。

2444
01:40:34,880 --> 01:40:39,880
非常昂贵
极低的延迟
非常…… 

2445
01:40:36,719 --> 01:40:41,480
高吞吐量 呃 高功率 所有这些

2446
01:40:39,880 --> 01:40:44,239
没错，这些……这些更多的是

2447
01:40:41,480 --> 01:40:45,800
价格昂贵，但呃，它们能够用于……

2448
01:40:44,239 --> 01:40:48,040
模块化，如果你

2449
01:40:45,800 --> 01:40:50,880
嗯，然后只是为了一些……

2450
01:40:48,040 --> 01:40:54,440
关于GPU历史的背景，你知道的

2451
01:40:50,880 --> 01:40:56,840
早在1993年，当詹森创办英伟达公司的时候

2452
01:40:54,440 --> 01:40:59,159
他们有，呃，你知道的，他们……

2453
01:40:56,840 --> 01:41:03,840
英伟达（GeForce）显卡，所有这些，我都没有

2454
01:40:59,159 --> 01:41:06,239
在这个时期还活着，嗯，但你有

2455
01:41:03,840 --> 01:41:08,440
呃，然后你就开始涉及到，你懂的

2456
01:41:06,239 --> 01:41:10,880
在 G47 之后，你开始得到

2457
01:41:08,440 --> 01:41:15,320
放进，呃，这些，这些更好的里面，所以就像

2458
01:41:10,880 --> 01:41:17,800
特斯拉卡、渡轮，呃，开普勒

2459
01:41:15,320 --> 01:41:19,239
麦克斯韦、帕斯卡，然后伏特是什么时候（出现的）呢

2460
01:41:17,800 --> 01:41:21,760
事情真的开始有起色了 

2461
01:41:19,239 --> 01:41:24,440
帕斯卡和伏特显卡，然后你就有了

2462
01:41:21,760 --> 01:41:27,040
去皮（Taring，此处可能结合语境有更准确意思），然后是一个，这就是我的卡（表述不太通顺，原文可能存在信息缺失或错误） 

2463
01:41:24,440 --> 01:41:29,239
基于……然后你有了霍珀

2464
01:41:27,040 --> 01:41:31,360
呃，万一你不知道，霍珀

2465
01:41:29,239 --> 01:41:35,520
卡片真的非常快，就像…… 

2466
01:41:31,360 --> 01:41:38,360
H100系列和H20系列，甚至还有最近的…… 

2467
01:41:35,520 --> 01:41:41,280
发布了英伟达布莱克威尔芯片 是的

2468
01:41:38,360 --> 01:41:43,719
那些太荒谬了 嗯 这……这……

2469
01:41:41,280 --> 01:41:46,679
当然有点过时了，所以呢

2470
01:41:43,719 --> 01:41:48,599
实际上，呃，这里有像薯片一样的东西，呃，我

2471
01:41:46,679 --> 01:41:51,000
刚拿到一张过时的截图

2472
01:41:48,599 --> 01:41:52,760
但你能明白，事情就是这样

2473
01:41:51,000 --> 01:41:56,159
进展到，呃，然后你会看到类似……的情况

2474
01:41:52,760 --> 01:41:57,920
因此，这里每个核心的相对时钟速度

2475
01:41:56,159 --> 01:41:59,639
你知道，其中有些真的是……

2476
01:41:57,920 --> 01:42:02,400
真的很高，但数量不是很多

2477
01:41:59,639 --> 01:42:04,199
核心一，然后英伟达有点弄明白了

2478
01:42:02,400 --> 01:42:08,000
好吧，我们应该再放更多……（此处文本不完整，“put more”后面应该还有内容）

2479
01:42:04,199 --> 01:42:11,880
而且这些东西有更多的核心，对吧，嗯

2480
01:42:08,000 --> 01:42:14,040
然后你就得到了整体的，呃，我

2481
01:42:11,880 --> 01:42:17,119
想想浮点性能是什么

2482
01:42:14,040 --> 01:42:19,840
这真是如此

2483
01:42:17,119 --> 01:42:21,800
呃，是的，一旦你到了伏尔塔，那就是…… 

2484
01:42:19,840 --> 01:42:24,760
情况开始变得，呃，情况开始……

2485
01:42:21,800 --> 01:42:27,040
嗨到飞起，所以我觉得这是，呃

2486
01:42:24,760 --> 01:42:30,440
双精度吉咖

2487
01:42:27,040 --> 01:42:33,760
失败了，所以

2488
01:42:30,440 --> 01:42:36,040
呃，你知道的，基本上是六个太拉（单位，Tera 一般指太拉，是数量级词头，表示 10 的 12 次方 ）

2489
01:42:33,760 --> 01:42:38,239
在FTA架构上的计算浮点运算次数

2490
01:42:36,040 --> 01:42:40,360
这相当不错，嗯，然后它会变得……

2491
01:42:38,239 --> 01:42:43,599
从那以后我的情况越来越好

2492
01:42:40,360 --> 01:42:45,840
我想我现在拥有的它运行速度很快

2493
01:42:43,599 --> 01:42:50,040
大约；左右

2494
01:42:45,840 --> 01:42:51,679
23 呃，夸斯（Kuas）上有 23 万亿次浮点运算能力，所以夸斯是

2495
01:42:50,040 --> 01:42:53,560
快速线性代数库，它

注：由于原英文文本不完整，这样的翻译只是根据现有内容逐字译出，语义上可能不完整通顺。 

2496
01:42:51,679 --> 01:42:55,320
能非常快速地进行矩阵乘法运算，并且

2497
01:42:53,560 --> 01:42:59,320
我在那儿呢，我马上就要变美啦。

2498
01:42:55,320 --> 01:43:02,320
很像 20 呃 20 吉次浮点运算每秒的单精度……

注：“gig flops” 通常指 “giga floating-point operations per second”，即 “吉次浮点运算每秒” ，原句似乎表述不太完整。 

2499
01:42:59,320 --> 01:43:04,440
精确计算，嗯，就是那样，就是那样。

2500
01:43:02,320 --> 01:43:06,159
那 那相当……

2501
01:43:04,440 --> 01:43:08,800
好的

（不过这里“good”常见含义有“好的；优秀的；愉快的”等，可结合具体语境看是否需要更精准的表达 ）

若单纯按指令要求的字面翻译就是：好

2502
01:43:06,159 --> 01:43:10,639
嗯，是什么让这些东西如此快呢？

2503
01:43:08,800 --> 01:43:15,400
深度学习，我实际上并未涉及

2504
01:43:10,639 --> 01:43:17,280
这个，嗯，在中央处理器（CPU）方面，你拥有的非常少。

2505
01:43:15,400 --> 01:43:18,760
核心，你有这些大型控制单元

2506
01:43:17,280 --> 01:43:20,239
那些占用了大量空间的东西，你

2507
01:43:18,760 --> 01:43:23,599
到处都有这些缓存，它们……（此处原英文句子未完整，翻译可能不太达意）

2508
01:43:20,239 --> 01:43:26,080
正在淹没那个东西，嗯

2509
01:43:23,599 --> 01:43:28,080
就好像在那里，你……你不是……

2510
01:43:26,080 --> 01:43:29,560
给那么多……呃，给……那么大的影响力给……（这里原文似乎不完整） 

2511
01:43:28,080 --> 01:43:31,800
当然行，就像这门课程能做到的那样

2512
01:43:29,560 --> 01:43:33,520
高级复杂指令，但在那里

2513
01:43:31,800 --> 01:43:35,760
它们没有那么多，所以你只能

2514
01:43:33,520 --> 01:43:37,679
做这么多，然而如果你有这个

2515
01:43:35,760 --> 01:43:40,719
其他你拥有的建筑类型 

2516
01:43:37,679 --> 01:43:44,840
更简单的说明
更简单的控制器

2517
01:43:40,719 --> 01:43:46,800
更简单的，呃，寄存器，小一些的，呃，但

2518
01:43:44,840 --> 01:43:48,520
大量的核心，就像看看这其中大部分是怎样的

2519
01:43:46,800 --> 01:43:51,280
被核心部分占用，然后仅仅是

2520
01:43:48,520 --> 01:43:54,239
缓存和随机存取存储器（RAM）嗯，那是，那是理想的情况

2521
01:43:51,280 --> 01:43:57,119
对于显卡等等，在这里你也是如此。

2522
01:43:54,239 --> 01:43:58,920
本质上，这里的集成开发环境（IDE）的理念是

2523
01:43:57,119 --> 01:44:00,199
你正试图拼凑一幅拼图。

2524
01:43:58,920 --> 01:44:03,360
你正在尝试拼一幅拼图。

2525
01:44:00,199 --> 01:44:05,520
谜题，关键在于它并非如此 

2526
01:44:03,360 --> 01:44:07,000
不管你以何种顺序去做，所以你

2527
01:44:05,520 --> 01:44:09,440
你不必这样争吵，而且

2528
01:44:07,000 --> 01:44:11,080
那么，或者你……这一列，这一列，这…… 

2529
01:44:09,440 --> 01:44:13,239
就好像你做这件事无关紧要一样

2530
01:44:11,080 --> 01:44:15,000
在这里，这块（东西），那边，要做得像个方块一样 

2531
01:44:13,239 --> 01:44:16,719
就像那儿的一大块，这并不重要，因为

2532
01:44:15,000 --> 01:44:18,080
只要它全部组装在一起

2533
01:44:16,719 --> 01:44:19,960
最后一切都妥善解决了，那才是你在乎的

2534
01:44:18,080 --> 01:44:23,400
关于，而这正是GPU真正的……（这里文本似乎不完整）

2535
01:44:19,960 --> 01:44:25,440
擅长，所以通常你会做一些像这样的事情

2536
01:44:23,400 --> 01:44:27,360
就像，呃，你知道的，一个类似多个的那种

2537
01:44:25,440 --> 01:44:29,080
一次拼一块拼图或多块拼图 

2538
01:44:27,360 --> 01:44:30,719
一次处理成组的拼图碎片，所以

2539
01:44:29,080 --> 01:44:33,080
你会有一个类似 2×2 的，或者像一个

2540
01:44:30,719 --> 01:44:35,199
一个4×4的拼图板，你会……

2541
01:44:33,080 --> 01:44:37,840
也许一次做（某事），那种情况就像…… 

2542
01:44:35,199 --> 01:44:40,440
这就是呃CUDA背后的直觉思路，并且

2543
01:44:37,840 --> 01:44:42,599
你如何对GPU进行编程以使其快速运行？ 

2544
01:44:40,440 --> 01:44:44,520
快速解决这些问题，嗯，在……方面 

2545
01:44:42,599 --> 01:44:46,440
CPU 你可能只能做到像

2546
01:44:44,520 --> 01:44:48,840
看，这里只有四个核心，所以你

2547
01:44:46,440 --> 01:44:50,560
可能只能做呃，给定的四个

2548
01:44:48,840 --> 01:44:53,480
同时，那个谜题的各个部分 

2549
01:44:50,560 --> 01:44:56,360
呃，曾经，而说到图形处理器（GPU），你知道，咱们来…… 

2550
01:44:53,480 --> 01:44:59,040
比如说你有大约六千个核心，对吧，呃

2551
01:44:56,360 --> 01:45:00,760
如果这个，如果这个谜题就像……我也不清楚

2552
01:44:59,040 --> 01:45:03,520
知道 说 喜欢

2553
01:45:00,760 --> 01:45:06,080
一万二千，如果它有……如果它有一万二千

2554
01:45:03,520 --> 01:45:08,560
碎片 嗯，你可以有效地做到这一点

2555
01:45:06,080 --> 01:45:10,880
分两步操作，因为你能够做到

2556
01:45:08,560 --> 01:45:12,880
先处理其中的6000个，然后再处理……

2557
01:45:10,880 --> 01:45:14,520
另外6000在第二批，所以它是

2558
01:45:12,880 --> 01:45:18,280
实际上你要进行两项操作

2559
01:45:14,520 --> 01:45:21,119
它在……但如果你用12000除以4，四个（这里“four four”表述可能有误，也许是想表达“4” ） 

2560
01:45:18,280 --> 01:45:23,080
意思是 CPU 核心数量，嗯，你

2561
01:45:21,119 --> 01:45:25,080
实际上能进行3000次手术，再见

2562
01:45:23,080 --> 01:45:28,280
可以看出那是如何能够被大幅加速的

2563
01:45:25,080 --> 01:45:30,760
呃，这就是为什么图形处理器（GPU）如此快速的原因。

2564
01:45:28,280 --> 01:45:33,280
因为你能，因为你可以做到那件事

2565
01:45:30,760 --> 01:45:34,920
嗯，现在，有一些，有

2566
01:45:33,280 --> 01:45:36,960
我们用来指代这些的一些常用术语

2567
01:45:34,920 --> 01:45:38,360
把事情弄清楚，所以CPU是主机，你是…… 

2568
01:45:36,960 --> 01:45:40,679
一旦我们开始，就去库达看这个。

2569
01:45:38,360 --> 01:45:42,960
编写内核 呃，中央处理器被称为

2570
01:45:40,679 --> 01:45:44,239
主持人，这很明显，然后它

2571
01:45:42,960 --> 01:45:46,159
只是有点，只是有点说得通

2572
01:45:44,239 --> 01:45:48,119
因为它要以那种方式被命名，然后

2573
01:45:46,159 --> 01:45:50,520
GPU 就是那个设备，所以你有…… 

2574
01:45:48,119 --> 01:45:56,040
主机中央处理器（CPU），然后是图形处理器（GPU），这是……

2575
01:45:50,520 --> 01:45:57,360
设备 呃，中央处理器（CPU）主要会……

2576
01:45:56,040 --> 01:45:59,280
那里将会有一场演出。

2577
01:45:57,360 --> 01:46:02,440
延迟（以秒为单位），所以你看到的是

2578
01:45:59,280 --> 01:46:05,080
延迟——我完成一项给定任务的速度能有多快

2579
01:46:02,440 --> 01:46:06,599
并且图形处理器（GPU）的吞吐量是以每（此处原句未说完）任务数来衡量的

2580
01:46:05,080 --> 01:46:08,960
第二，例如，如果你正在进行一项

2581
01:46:06,599 --> 01:46:12,880
渲染任务，这就像有多少像素一样

2582
01:46:08,960 --> 01:46:14,960
我能每秒渲染一次吗，呃，还是说要渲染多少次呢？

2583
01:46:12,880 --> 01:46:17,560
呃，我不知道我能有多少像素

2584
01:46:14,960 --> 01:46:21,360
我能吗？是的，当然可以，每秒渲染，那就是…… 

2585
01:46:17,560 --> 01:46:25,040
好的，嗯，在一个典型的CUDA程序中，你会…… 

2586
01:46:21,360 --> 01:46:26,960
打算在，呃，在……上分配一些内存

2587
01:46:25,040 --> 01:46:28,960
CPU内存，所以它将会是一个

2588
01:46:26,960 --> 01:46:31,880
经典的，就像 C·马利克那样，就是这样

2589
01:46:28,960 --> 01:46:34,280
你打算做什么，然后一旦它…… 

2590
01:46:31,880 --> 01:46:37,760
在 CPU 或主机上分配，你将（此处句子不完整）

2591
01:46:34,280 --> 01:46:40,960
从主机复制到设备，或者从 CPU 复制到

2592
01:46:37,760 --> 01:46:43,440
GPU 嗯，然后一旦数据到了 GPU 上，你

2593
01:46:40,960 --> 01:46:45,520
实际上可以启动一个内核，该内核是

2594
01:46:43,440 --> 01:46:47,599
这些并行功能是什么

2595
01:46:45,520 --> 01:46:50,199
本质上，所以在中央处理器（CPU）上你有一个……一个

2596
01:46:47,599 --> 01:46:52,119
函数 然后如果你有一个GPU 你就有一个内核

注：原英文文本可能存在表述不完整或有误的情况，“function then GPU you have a a kernel” 正常来讲可能表述不通顺，推测也许是 “If you have a GPU, then you have a kernel” 这类的表述。以上翻译是按照原文逐词翻译并尽量组织通顺。 

2597
01:46:50,199 --> 01:46:54,040
这是一个可以被……的 GPU 功能

注：原英文句子不完整，以上是按现有内容进行的翻译。 

2598
01:46:52,119 --> 01:46:56,400
并行化的

2599
01:46:54,040 --> 01:46:58,840
嗯，那就是主要的直觉。

2600
01:46:56,400 --> 01:47:00,960
有你
你从 CPU 移动开始

2601
01:46:58,840 --> 01:47:02,800
一切 把一切事情都做得非常快 在……上

2602
01:47:00,960 --> 01:47:04,280
GPU，然后一旦你完成了……

2603
01:47:02,800 --> 01:47:05,639
结果是你把它们移回去，然后再做

2604
01:47:04,280 --> 01:47:07,320
从那以后，你想怎么处置它们都行

2605
01:47:05,639 --> 01:47:09,280
你甚至可能会继续给它喂食

2606
01:47:07,320 --> 01:47:11,920
越来越深入到越来越多的核心部分

2607
01:47:09,280 --> 01:47:13,360
直到整件事都处理得当，呃

2608
01:47:11,920 --> 01:47:16,400
但那就像是，那就是，那就是

2609
01:47:13,360 --> 01:47:18,360
理想的工作流程是你有一个中央处理器（CPU），然后

2610
01:47:16,400 --> 01:47:20,159
这个 GPU（图形处理器）的东西就像一个中间人。

2611
01:47:18,360 --> 01:47:24,639
你必须将其转换回 CPU 以用于

2612
01:47:20,159 --> 01:47:26,639
用它们做些有用的事

2613
01:47:24,639 --> 01:47:28,040
内核看起来像一个串行程序

2614
01:47:26,639 --> 01:47:29,679
所以如果你打算看看这些

2615
01:47:28,040 --> 01:47:32,560
马上我们就要进入……

2616
01:47:29,679 --> 01:47:35,040
实际上在写这些，但是，呃，这……这……

2617
01:47:32,560 --> 01:47:38,639
将会非常简单

2618
01:47:35,040 --> 01:47:40,920
函数，而且它将要……它将要……

2619
01:47:38,639 --> 01:47:42,480
有很少的几行内容，呃，它将会……

2620
01:47:40,920 --> 01:47:44,119
它看起来会像这样，很基础

2621
01:47:42,480 --> 01:47:47,480
系列剧本，只不过它将会有

2622
01:47:44,119 --> 01:47:49,480
其中的一些关键术语，嗯，这些主要是

2623
01:47:47,480 --> 01:47:50,719
线程、线程块和网格甚至都不…… 

2624
01:47:49,480 --> 01:47:51,800
现在先别担心那些条款，我们……

2625
01:47:50,719 --> 01:47:54,119
要深入探讨那些，我打算……

2626
01:47:51,800 --> 01:47:56,520
解释一下它们背后的理念，呃

2627
01:47:54,119 --> 01:47:58,280
我打算解释一下，呃，几乎是……

2628
01:47:56,520 --> 01:48:00,000
为你提供完整的CUDA架构，而且仅仅是……（这里句子似乎不完整）

2629
01:47:58,280 --> 01:48:02,520
帮你弄明白这些到底是什么鬼

2630
01:48:00,000 --> 01:48:04,239
目前有些常见的术语用于……（原句似乎不完整） 

2631
01:48:02,520 --> 01:48:07,840
记住，在我们真正开始之前

2632
01:48:04,239 --> 01:48:09,679
投入到这些事情当中呢，呃，嗯

2633
01:48:07,840 --> 01:48:11,840
首先是内核，所以内核就像是

2634
01:48:09,679 --> 01:48:15,239
一个奇怪的术语，嗯，你可能曾经想过

2635
01:48:11,840 --> 01:48:16,800
像爆米花玉米粒一样，就像，就是这样

2636
01:48:15,239 --> 01:48:18,840
我以为我像什么呢，像爆米花吗？ 

2637
01:48:16,800 --> 01:48:21,639
凯尔丝，我们为什么要用那些在……在……上面呢？

2638
01:48:18,840 --> 01:48:23,400
电脑，这说不通啊，嗯，还有

2639
01:48:21,639 --> 01:48:25,599
然后我转而研究卷积

2640
01:48:23,400 --> 01:48:27,239
内核，这就像，呃，当你做……的时候

2641
01:48:25,599 --> 01:48:28,960
就像你可能会进行的卷积运算一样

2642
01:48:27,239 --> 01:48:30,320
如果你看过美国有线电视新闻网（CNN）的报道，就会见过这个。 

2643
01:48:28,960 --> 01:48:31,840
可能已经做了很多事情

2644
01:48:30,320 --> 01:48:34,440
PyTorch，并且你已经大致浏览了……（注：原句不完整，此处是大致通顺的译文） 

2645
01:48:31,840 --> 01:48:36,599
关于那一点的直觉，它就像一种滑动

2646
01:48:34,440 --> 01:48:39,480
执行类似……操作的内核

注：原英文文本似乎表述不太完整或准确，以上翻译是根据现有内容尽量通顺表达。 

2647
01:48:36,599 --> 01:48:42,520
图像处理的事儿，对，就是

2648
01:48:39,480 --> 01:48:44,199
图片，嗯，那个……那个滤镜那个

2649
01:48:42,520 --> 01:48:46,679
滑动并进行计算，那是

2650
01:48:44,199 --> 01:48:48,639
叫做内核，所以我当时就在想，呃，它是吗

2651
01:48:46,679 --> 01:48:50,960
不，不，不是的，这不是一个…… 

2652
01:48:48,639 --> 01:48:53,480
卷积核，呃，它也不是一个

2653
01:48:50,960 --> 01:48:54,920
Linux内核也不例外，但也足够了，所以

2654
01:48:53,480 --> 01:48:57,119
有很多不同的内核，我们

2655
01:48:54,920 --> 01:48:58,719
实际上有四个内核。

2656
01:48:57,119 --> 01:49:01,360
爆米花玉米粒
卷积核

2657
01:48:58,719 --> 01:49:02,760
Linux内核，呃，但最好的还是GPU

2658
01:49:01,360 --> 01:49:04,800
内核，所以那就是我们要处理的那些东西

2659
01:49:02,760 --> 01:49:06,480
和嗯……实际上有一个（在合作）

2660
01:49:04,800 --> 01:49:09,760
你所突出显示的小关键词

2661
01:49:06,480 --> 01:49:12,360
戈尔 全球非核心部分 非核心部分以及那个

注：“goore”可能是拼写错误，你可检查确认正确内容后再让我翻译。 

2662
01:49:09,760 --> 01:49:13,960
在 GPU 上定义一个内核，所以有

2663
01:49:12,360 --> 01:49:17,199
实际上，我们有一种可以明确表达的方式

2664
01:49:13,960 --> 01:49:19,320
那个，呃，对，不是外部的

2665
01:49:17,199 --> 01:49:21,960
故事 我也有同样的想法 这是

2666
01:49:19,320 --> 01:49:23,400
比如是哪一个呢 嗯 不过没错 所以

2667
01:49:21,960 --> 01:49:25,560
我们将分成两条线索来进行。

2668
01:49:23,400 --> 01:49:27,920
方块和网格，那将是其中之一

2669
01:49:25,560 --> 01:49:30,679
下一章的主要内容



2670
01:49:27,920 --> 01:49:34,920
嗯，然后再有两个，有点像是那种……就

2671
01:49:30,679 --> 01:49:37,800
行话术语是个宝贝，所以 G 女士，呃，这个

2672
01:49:34,920 --> 01:49:41,280
代表通用矩阵乘法

2673
01:49:37,800 --> 01:49:44,080
所以一般来说，这意味着呃，你

2674
01:49:41,280 --> 01:49:47,880
有 这可不只是像……一样成倍增加

2675
01:49:44,080 --> 01:49:52,199
而且一个* 香脂C 它不是 它不是一种枫香树

2676
01:49:47,880 --> 01:49:54,480
嗯，完全地，实际上你在做机器学习，嗯，还有

2677
01:49:52,199 --> 01:49:56,360
然后你有了这个阿尔法，你有了这个

2678
01:49:54,480 --> 01:49:59,400
你用来缩放的阿尔法参数

2679
01:49:56,360 --> 01:50:03,000
那个的结果，呃，然后你把它加上

2680
01:49:59,400 --> 01:50:05,199
呃，用这个β缩放因子乘以这个再乘以…… 

2681
01:50:03,000 --> 01:50:07,320
矩阵C，它的形状为

2682
01:50:05,199 --> 01:50:09,000
输出矩阵，所以那那有点像一个

2683
01:50:07,320 --> 01:50:11,320
很多线性代数的内容，而我并不擅长（此处结合语境推测补充“擅长”，若有更明确信息可调整） 

2684
01:50:09,000 --> 01:50:12,880
现在要讲的内容，但以防万一

2685
01:50:11,320 --> 01:50:16,239
那就好像，万一这能让……有意义的话

2686
01:50:12,880 --> 01:50:19,199
你 本质上这是这个“阿尔法时间”呃

2687
01:50:16,239 --> 01:50:22,159
此时加入 A 和 B 各若干毫升，然后你再加入那个（物质）。 

2688
01:50:19,199 --> 01:50:26,639
得到一个标量 B * C，其形状为

2689
01:50:22,159 --> 01:50:29,440
那个矩阵，嗯，那就是宝石的意义所在 

2690
01:50:26,639 --> 01:50:31,800
所以这是一个……它是一个轻微的（这里“mmal”可能有误，推测是“minor”之类的词），但还有更多……呃……以及

2691
01:50:29,440 --> 01:50:34,199
那么你有S宝石，所以就只是这样

2692
01:50:31,800 --> 01:50:36,000
普通的大型多人在线游戏，但带有……呃，单人（元素） 

2693
01:50:34,199 --> 01:50:38,920
精度，所以它明确是单精度的

2694
01:50:36,000 --> 01:50:40,000
精度，嗯，你可以做一个半M（这里不太明确M代表什么），所以

2695
01:50:38,920 --> 01:50:42,639
就像一个

2696
01:50:40,000 --> 01:50:45,079
fp6 呃，你可以做双摩尔（操作），你（接着做）

2697
01:50:42,639 --> 01:50:46,599
通常不会，不过这就像FP一样

2698
01:50:45,079 --> 01:50:52,040
双精度浮点运算（通常指64位浮点精度，不过“fp64”也可能在特定语境中有其他含义，这是比较常见的理解）

2699
01:50:46,599 --> 01:50:55,440
嗯，但没错，所以一般来说，嗯，宝石

2700
01:50:52,040 --> 01:50:58,920
那些宝石很重要，然后你有……

2701
01:50:55,440 --> 01:51:02,440
中央处理器，它也被称为主机

2702
01:50:58,920 --> 01:51:05,440
与 GPU 相比，它运行哪些函数 

2703
01:51:02,440 --> 01:51:07,280
这被称为设备，它在运行

2704
01:51:05,440 --> 01:51:10,440
内核；核心；果仁；谷粒

2705
01:51:07,280 --> 01:51:12,480
嗯，我希望基本上就是这样了。

2706
01:51:10,440 --> 01:51:14,400
我希望那不算太难，呃，我们……

2707
01:51:12,480 --> 01:51:17,040
现在要去研究一些内核了，这个

2708
01:51:14,400 --> 01:51:18,719
这部分接下来会，呃，稍微有点……

2709
01:51:17,040 --> 01:51:19,840
这会有点紧张刺激。

2710
01:51:18,719 --> 01:51:22,159
你需要稍微注意一下。

2711
01:51:19,840 --> 01:51:24,000
有点，不过呢，这会很有趣的，而且我

2712
01:51:22,159 --> 01:51:26,320
承诺在最后，呃，你会去…… 

2713
01:51:24,000 --> 01:51:28,480
真正获得启迪，你将会

2714
01:51:26,320 --> 01:51:29,920
就像CUDA的第一部分不是

2715
01:51:28,480 --> 01:51:31,840
实际上，那并不难，我们只是打算……

2716
01:51:29,920 --> 01:51:33,159
涵盖非常非常基础的内核，比如

2717
01:51:31,840 --> 01:51:35,159
向量加法，它不会是…… 

2718
01:51:33,159 --> 01:51:36,599
也没那么糟啦 嗯 不过还是先介绍一下

2719
01:51:35,159 --> 01:51:38,880
你对哲学以及整个（事物）

注：原英文表述不太完整通顺，这是根据字面进行的翻译。 

2720
01:51:36,599 --> 01:51:41,239
类似基础的呃，CUDA的设计原则

2721
01:51:38,880 --> 01:51:41,239
座位；坐处（如椅子等）；（椅子等的）座部；所在地；活动中心；席位；（议会、委员会等的）席位；当选机会；臀部

坐下；使就座；可容纳…人就座

2722
01:51:41,560 --> 01:51:45,840
编程 好了，现在事情在推进

2723
01:51:44,000 --> 01:51:48,119
从更专业一点的角度来讲，但我

2724
01:51:45,840 --> 01:51:50,360
我想我们可以平稳地进入

2725
01:51:48,119 --> 01:51:52,119
仅仅通过进行一项有趣且有用的活动

2726
01:51:50,360 --> 01:51:55,119
于是我打开了一堆维基百科页面

2727
01:51:52,119 --> 01:51:56,719
关于各种GPU架构的文章

2728
01:51:55,119 --> 01:51:58,400
然后我们将深入探讨……是什么样的情况（注：原句“what does”不完整，此处根据语境补充大致含义）

2729
01:51:56,719 --> 01:52:02,480
你的显卡实际上看起来像什么样？

2730
01:51:58,400 --> 01:52:04,320
那个的统计数据是怎样的，嗯，所以就……

2731
01:52:02,480 --> 01:52:05,679
一般来说，喜欢看看这些，咱们……

2732
01:52:04,320 --> 01:52:07,320
你知道我们只是在寻找东西

2733
01:52:05,679 --> 01:52:09,800
那些可能了解一下会有用的

2734
01:52:07,320 --> 01:52:11,840
一些小小的历史，有点像呃

2735
01:52:09,800 --> 01:52:13,599
我们之前的GPU部分介绍

2736
01:52:11,840 --> 01:52:16,599
做了；干了；有；吃了（do的过去式）

2737
01:52:13,599 --> 01:52:18,520
嗯，所以就像帕斯卡（Pascal）是一种较早的（编程语言），它…… 

2738
01:52:16,599 --> 01:52:20,280
我们过去有，嗯，有一堆……

2739
01:52:18,520 --> 01:52:23,560
关于这个有很酷的东西，比如1080

2740
01:52:20,280 --> 01:52:26,159
以及 以及 以及 10 以及 10 70

2741
01:52:23,560 --> 01:52:27,560
呃，我们俩都基于帕斯卡（编程语言），嗯，你懂的。

2742
01:52:26,159 --> 01:52:29,760
你有一堆关于……的信息

2743
01:52:27,560 --> 01:52:34,159
你知道这一切都是从哪儿来的，嗯

2744
01:52:29,760 --> 01:52:36,639
但真正酷的是，嗯，如果我们

2745
01:52:34,159 --> 01:52:38,119
向下滚动，你会看到所有的技术信息 

2746
01:52:36,639 --> 01:52:41,599
关于这些事情的细节，这简直太疯狂了，竟然……

2747
01:52:38,119 --> 01:52:42,880
很多维基百科有，嗯，但没错，就像你一样

2748
01:52:41,599 --> 01:52:44,760
我们有这些

2749
01:52:42,880 --> 01:52:47,040
那些桌子

2750
01:52:44,760 --> 01:52:49,320
那实际上会告诉我们，就像

2751
01:52:47,040 --> 01:52:53,360
哪 哪一代 哪几代

2752
01:52:49,320 --> 01:52:56,280
有那种，你懂的，有质感的铸件之类的东西 

2753
01:52:53,360 --> 01:52:59,880
根据销售和营销（Sales and Marketing，推测此处SM是这个意思，需结合上下文确定），我们稍后会详细讨论。 

2754
01:52:56,280 --> 01:53:02,280
嗯，每个呃流多处理器（SM）专用的共享内存，或者

2755
01:52:59,880 --> 01:53:04,119
流式多处理器
二级缓存 每个

2756
01:53:02,280 --> 01:53:05,679
芯片，没错，所以你拥有所有这些

2757
01:53:04,119 --> 01:53:07,960
统计数据，而且你可以进行某种比较

2758
01:53:05,679 --> 01:53:10,639
随着时间的推移，所以如果我们跳到

2759
01:53:07,960 --> 01:53:14,239
皇帝，实际上这就是我的显卡，我的……

注：你提供的文本似乎不太完整和通顺，可能存在一些表述上的问题。 

2760
01:53:10,639 --> 01:53:19,000
RTX 3070 基于

2761
01:53:14,239 --> 01:53:23,320
嗯，你往下滚动，然后，呃，你会看到那个

2762
01:53:19,000 --> 01:53:26,880
同样的情况，对吧，所以就像二级缓存，嗯，还有

2763
01:53:23,320 --> 01:53:31,400
然后二级缓存，比如 512 千字节，并且

2764
01:53:26,880 --> 01:53:34,520
那么这个是，嗯，40兆字节，对吧？

2765
01:53:31,400 --> 01:53:37,760
所以你会得到一些有趣的对比

2766
01:53:34,520 --> 01:53:40,719
这里 但是

2767
01:53:37,760 --> 01:53:42,560
嗯，是的，这些……这有点像是那种……

2768
01:53:40,719 --> 01:53:44,599
你想关注的事情呃 当……的时候

2769
01:53:42,560 --> 01:53:46,520
尤其是在涉及到像显卡规格这类问题时

2770
01:53:44,599 --> 01:53:49,719
你没有一个，对吧，你打算……

2771
01:53:46,520 --> 01:53:51,679
在这里能找到很多有用的信息 嗯

2772
01:53:49,719 --> 01:53:53,360
你知道，像你这样去安佩尔（注：“Ampere”可能是具体的人名、地名、机构名等，需结合上下文确定准确含义） 

2773
01:53:51,679 --> 01:53:56,280
这些已被用于……的A100（可能是某种设备型号）

2774
01:53:53,360 --> 01:53:58,280
训练非常大的模型，呃，就是这样

2775
01:53:56,280 --> 01:54:00,960
100安培，没错，就是这样。 

2776
01:53:58,280 --> 01:54:04,159
叫，嗯

2777
01:54:00,960 --> 01:54:06,199
所以有一堆很酷的统计数据，嗯，哪些…… 

2778
01:54:04,159 --> 01:54:08,679
不同的精度和数据类型会

2779
01:54:06,199 --> 01:54:13,119
他们也支持

2780
01:54:08,679 --> 01:54:17,239
比如，呃，举个例子来说

2781
01:54:13,119 --> 01:54:17,239
转一圈 转一圈

2782
01:54:18,079 --> 01:54:22,920
支持伏打（Volta，这里可能指某种技术、设备等，需要结合上下文确定具体所指）
不支持大脑

2783
01:54:20,440 --> 01:54:24,639
浮点16，但A100确实支持大脑浮点格式（注：这里“brain”推测可能指“Brain Floating Point（大脑浮点格式，如BF16）” ，结合上下文理解更准确） 

2784
01:54:22,920 --> 01:54:26,320
16号公寓，像那样有趣的事情

2785
01:54:24,639 --> 01:54:29,320
你可以在某种程度上只做一个侧面的（操作等，需结合上下文明确语义） 

2786
01:54:26,320 --> 01:54:31,400
阿尔茨海默病（AD）的比较，喜欢这样的微观蕾丝 

2787
01:54:29,320 --> 01:54:34,239
建筑是40年代所使用的（这种表述结合语境可能有更准确的意思，由于原文有限，只能直译） 

2788
01:54:31,400 --> 01:54:38,360
系列卡片，所以这里类似30系列的卡片

2789
01:54:34,239 --> 01:54:41,199
系列 嗯，我相信如果我们真的去……

2790
01:54:38,360 --> 01:54:41,199
伏打；沃尔塔

2791
01:54:41,719 --> 01:54:46,360
架构，呃，伏特架构

2792
01:54:44,440 --> 01:54:50,520
微架构 嗯，我认为这是

2793
01:54:46,360 --> 01:54:53,040
用于20系列中

2794
01:54:50,520 --> 01:54:54,960
卡片 20

2795
01:54:53,040 --> 01:54:57,920
这将会是

2796
01:54:54,960 --> 01:55:00,920
某个地方
好吧，也许

2797
01:54:57,920 --> 01:55:02,840
不；不是；没有

2798
01:55:00,920 --> 01:55:04,880
不管怎样，你能找到一堆很酷的

2799
01:55:02,840 --> 01:55:06,760
关于这些的统计数据，“a love La”是40

注：你提供的内容可能存在表述不清晰或有误的情况，导致译文可能不够准确表意。 

2800
01:55:04,880 --> 01:55:09,639
系列卡片，你能从中获取大量信息

2801
01:55:06,760 --> 01:55:11,480
就像二级缓存一样，它又是……（这里原文表述不太完整，可能有省略或不规范，此为结合已有内容的大致翻译） 

2802
01:55:09,639 --> 01:55:14,440
更大，而不是大约40兆字节

2803
01:55:11,480 --> 01:55:15,960
这里是 96，这很棒，嗯，一级缓存

2804
01:55:14,440 --> 01:55:19,280
实际上才是更重要的，所以你

2805
01:55:15,960 --> 01:55:21,960
知道的，就像18兆字节之类的，诸如此类。 

2806
01:55:19,280 --> 01:55:24,599
呃，接下来是霍珀，实际上它是

2807
01:55:21,960 --> 01:55:27,560
目前最先进的 GPU 是什么

2808
01:55:24,599 --> 01:55:29,040
或者接近最先进水平，嗯，是…… 

2809
01:55:27,560 --> 01:55:31,840
最先进的实际上是 

2810
01:55:29,040 --> 01:55:33,800
布莱克威尔，呃，微架构，但这个

2811
01:55:31,840 --> 01:55:35,920
霍珀也很像第二名

2812
01:55:33,800 --> 01:55:38,159
最近的一个，这些就是……的东西（此处原文不完整，无法准确译出完整意思） 

2813
01:55:35,920 --> 01:55:41,239
H100系列（这里推测h100s是指某种产品系列，但因信息有限只能宽泛翻译）基于这些，它们被用于…… 

2814
01:55:38,159 --> 01:55:43,360
训练像 GPT - 4 之类的模型 呃 所以你

2815
01:55:41,239 --> 01:55:45,599
你能找到一堆关于……的统计数据吗？

注：原文似乎未完整，后面应有具体内容，但按照原文完整呈现翻译。 

2816
01:55:43,360 --> 01:55:49,480
那些无需实际去使用的（东西）

2817
01:55:45,599 --> 01:55:52,079
呃，有一点，但如果我们真的想……

2818
01:55:49,480 --> 01:55:54,800
打印一些关于我们GPU的信息，我只是

2819
01:55:52,079 --> 01:55:57,440
我打算在这里打开一个新的终端标签页 嗯

2820
01:55:54,800 --> 01:56:02,440
如果我们……我打算把这个拖到一边去

2821
01:55:57,440 --> 01:56:04,360
去一下嗯 CUDA 示例那边

2822
01:56:02,440 --> 01:56:05,239
GitHub 这将打印一些内容

2823
01:56:04,360 --> 01:56:06,800
关于你的；关于你们的

2824
01:56:05,239 --> 01:56:11,719
图形处理器；显卡；图形处理单元

2825
01:56:06,800 --> 01:56:14,040
所以如果我们，呃，拿起这个，然后我们就……就……

2826
01:56:11,719 --> 01:56:16,400
获取克隆体

2827
01:56:14,040 --> 01:56:17,880
这需要花点时间来做。

2828
01:56:16,400 --> 01:56:20,119
但是我们可以在这个里面往下滚动。 

2829
01:56:17,880 --> 01:56:23,280
与此同时，我们可以看看，呃，如果你在……

2830
01:56:20,119 --> 01:56:25,520
在 Linux 系统中，你可以说“cd 进入” 

2831
01:56:23,280 --> 01:56:28,639
你想要的任何目录，并且

2832
01:56:25,520 --> 01:56:30,560
然后，然后去，呃，实际去做

2833
01:56:28,639 --> 01:56:32,360
用于与之一起运行程序的二进制文件

2834
01:56:30,560 --> 01:56:34,560
所以如果我们在这里把这个打印出来，让我

2835
01:56:32,360 --> 01:56:37,040
实际上制造；实际上做

2836
01:56:34,560 --> 01:56:39,360
这部分

2837
01:56:37,040 --> 01:56:44,520
更大的

2838
01:56:39,360 --> 01:56:48,239
嗯，我们可以进入 Cuda 示例目录，然后

2839
01:56:44,520 --> 01:56:50,400
在这里面，我们有，呃，样品，所以我们

2840
01:56:48,239 --> 01:56:53,040
如所见，进入我们的示例目录

2841
01:56:50,400 --> 01:56:55,079
那里有 CD 放进样本里。

不过原英文句子“there so CD into samples”表述不太符合正常语法逻辑，可能存在拼写或表达错误。 

2842
01:56:53,040 --> 01:56:57,679
然后我们有

2843
01:56:55,079 --> 01:56:59,119
嗯，我们有很多不同的，所以

2844
01:56:57,679 --> 01:57:00,800
有些事情你可以去尝试一下

2845
01:56:59,119 --> 01:57:02,440
在这里，我不知道这些有多容易。

2846
01:57:00,800 --> 01:57:05,400
要使用
我还没和它们一起玩过呢

2847
01:57:02,440 --> 01:57:06,920
但我们要进入实用工具目录并

2848
01:57:05,400 --> 01:57:09,639
注意我们是如何进行这个设备查询的

2849
01:57:06,920 --> 01:57:12,639
这里的东西，所以实际上这将 

2850
01:57:09,639 --> 01:57:17,440
变成一个

2851
01:57:12,639 --> 01:57:17,440
嗯，我们目前还无法执行那个，但如果我们……

2852
01:57:17,599 --> 01:57:23,719
那么我们实际上可以做到，而且我们能够看到

2853
01:57:20,560 --> 01:57:24,920
关于我们GPU的一堆细节，所以我

2854
01:57:23,719 --> 01:57:28,560
建议你自己做这件事

2855
01:57:24,920 --> 01:57:29,760
系统 但呃 一个可烹饪的设备 所以

2856
01:57:28,560 --> 01:57:33,440
我的（设备）上插了一块 GPU。 

2857
01:57:29,760 --> 01:57:37,040
那块 GPU 所在的主板是英伟达 GeForce RTX（系列）的 

2858
01:57:33,440 --> 01:57:39,079
370 英伟达CUDA驱动版本为12.5，如

2859
01:57:37,040 --> 01:57:41,119
嗯，至于运行时版本，呃，CUDA

2860
01:57:39,079 --> 01:57:43,920
能力，所以这实际上非常

2861
01:57:41,119 --> 01:57:46,159
重要的是，这里的 8.6 是你的

2862
01:57:43,920 --> 01:57:49,199
可能会有所不同 嗯 你可能有……（这里句子似乎未完整） 

2863
01:57:46,159 --> 01:57:52,400
同样的 GPU，你可能不会（有这样的情况），但这个 8.6 是…… 

2864
01:57:49,199 --> 01:57:54,239
实际上，这在我们……我们的（做事方式）方面非常关键。 

2865
01:57:52,400 --> 01:57:56,880
了解我们的图形处理器（GPU）支持什么

2866
01:57:54,239 --> 01:57:59,360
所以可能会有一些操作，这些操作 

2867
01:57:56,880 --> 01:58:01,639
起作用，而且可能有些并不起作用

2868
01:57:59,360 --> 01:58:03,239
所以如果我只是把这个，嗯，拖到……

2869
01:58:01,639 --> 01:58:05,480
这边我们不用担心

2870
01:58:03,239 --> 01:58:07,280
至于目前关于其余部分的情况

2871
01:58:05,480 --> 01:58:09,840
也许其中一些，也许其中一些之后再说

2872
01:58:07,280 --> 01:58:12,360
但是，呃，我就把那个给你吧。

2873
01:58:09,840 --> 01:58:16,639
信息

2874
01:58:12,360 --> 01:58:19,040
所以如果我们去呃

2875
01:58:16,639 --> 01:58:22,260
CUDA 呃

2876
01:58:19,040 --> 01:58:25,199
能力
计算能力

2877
01:58:22,260 --> 01:58:28,599
[音乐]

2878
01:58:25,199 --> 01:58:28,599
嗯，这是什么？

2879
01:58:28,760 --> 01:58:37,239
被称为肯定是英伟达 GeForce 系列产品 嗯 查看 8.6

2880
01:58:34,800 --> 01:58:37,239
就像

2881
01:58:38,159 --> 01:58:42,040
那个，呃，我得回库达去了。

2882
01:58:40,400 --> 01:58:43,480
实际上能获取有用信息的文档



2883
01:58:42,040 --> 01:58:46,880
这个，呃

2884
01:58:43,480 --> 01:58:46,880
CUDA CUDA

2885
01:58:48,400 --> 01:58:58,880
文档 所以如果我们去那个（地方/事物，需结合上下文确定）

2886
01:58:53,840 --> 01:59:03,440
呃，CUDA C，我们肯定会使用CUDA C的。 

2887
01:58:58,880 --> 01:59:09,360
C++ 嗯，不，我们不会使用 CUDA。

2888
01:59:03,440 --> 01:59:13,760
C++，我们接下来要讲到呃 CUDA C

2889
01:59:09,360 --> 01:59:16,199
CUDA搜索 CUDA C编程指南以及

2890
01:59:13,760 --> 01:59:18,880
在CUDA的C编程指南里

2891
01:59:16,199 --> 01:59:22,560
是的

2892
01:59:18,880 --> 01:59:24,320
嗯，能力

2893
01:59:22,560 --> 01:59:27,199
比如说像这样，这就是…… 

2894
01:59:24,320 --> 01:59:31,440
我正在寻找一些线程块集群

2895
01:59:27,199 --> 01:59:36,320
在……呃……两个（这里“in in”表述可能有误，也许是表述结巴之类情况），然后你去…… 

2896
01:59:31,440 --> 01:59:38,840
2.2.1 它是线程块集群

2897
01:59:36,320 --> 01:59:42,599
嗯，只有当你有一个……时你才能得到这些。 

2898
01:59:38,840 --> 01:59:44,400
计算能力 9.0 或更高，嗯，所以

2899
01:59:42,599 --> 01:59:46,119
计算能力越高， 

2900
01:59:44,400 --> 01:59:48,599
呃，更好些



2901
01:59:46,119 --> 01:59:50,239
所以实际上我无法使用线程块

2902
01:59:48,599 --> 01:59:52,239
我的上面有簇状物，因为那

2903
01:59:50,239 --> 01:59:53,360
架构不支持这些

2904
01:59:52,239 --> 01:59:56,360
你将要面对的是至关重要的事情

2905
01:59:53,360 --> 01:59:57,920
小心，而且你知道，当你……你……

2906
01:59:56,360 --> 01:59:59,840
实际上可能能够利用

2907
01:59:57,920 --> 02:00:01,800
某些别人无法拥有的特征

2908
01:59:59,840 --> 02:00:04,079
就好像如果你有一台A100，而某人

2909
02:00:01,800 --> 02:00:05,360
其他人有一个 v00，你实际上是可以做到的

2910
02:00:04,079 --> 02:00:07,159
他们做不到而你能做的事情

2911
02:00:05,360 --> 02:00:08,400
让事情进展得更快、更高效 

2912
02:00:07,159 --> 02:00:10,440
因为建筑方面的事情

2913
02:00:08,400 --> 02:00:13,480
实际上支持，所以这些是，这些是

2914
02:00:10,440 --> 02:00:16,320
你要留意的事情，嗯

2915
02:00:13,480 --> 02:00:18,719
但不管怎样，呃，话说到这儿，我们

2916
02:00:16,320 --> 02:00:21,079
实际上可以直接着手处理一些事情

2917
02:00:18,719 --> 02:00:23,880
关于，基本上就是……到底如何…… 

2918
02:00:21,079 --> 02:00:25,760
CUDA架构是如何工作的，怎样，怎样，怎样

2919
02:00:23,880 --> 02:00:27,599
我们是否编写代码，以及如何编写……（原英文文本表述不太准确和完整，这里尽量按字面意思翻译） 

2920
02:00:25,760 --> 02:00:30,320
整件事都合适

2921
02:00:27,599 --> 02:00:32,440
在一起，所以现在我们实际上可以得到

2922
02:00:30,320 --> 02:00:35,000
真的很关注库达（Cuda）正在做的事情以及那个

2923
02:00:32,440 --> 02:00:37,400
整个层级结构，所以在……内部

2924
02:00:35,000 --> 02:00:40,520
在这里，我调出了第五章的内容。 

2925
02:00:37,400 --> 02:00:42,400
你自己的内核，嗯，然后是CUDA基础

2926
02:00:40,520 --> 02:00:45,840
然后只要有说明文件和身份证（或ID，可根据具体语境确定，如身份标识等）就行

2927
02:00:42,400 --> 02:00:49,119
执行或索引文件，所以如果你这么做，我…… 

2928
02:00:45,840 --> 02:00:52,639
相信在这方面按下Ctrl + Shift + V（粘贴纯文本快捷键，推测这里“control”应为“Ctrl”，在英文语境中“control”常指“Ctrl”键 ）

2929
02:00:49,119 --> 02:00:56,040
或者 Ctrl（控制键），我不知道它的快捷键绑定是什么

2930
02:00:52,639 --> 02:00:59,599
是Ctrl Alt V 还是Ctrl Shift V ，在这儿呢

2931
02:00:56,040 --> 02:01:02,280
好的，嗯，然后我们把这个拉起来。

2932
02:00:59,599 --> 02:01:04,800
在这边，呃，只是为了

2933
02:01:02,280 --> 02:01:08,119
参考 咱们来梳理一下这种……

2934
02:01:04,800 --> 02:01:11,800
手牵手；携手；齐心协力

2935
02:01:08,119 --> 02:01:11,800
所以我要进行缩放

2936
02:01:11,880 --> 02:01:15,560
我们刚刚把这个打印出来了，我们刚刚

2937
02:01:14,119 --> 02:01:18,480
打印出设备查询信息，这样我们就不会

2938
02:01:15,560 --> 02:01:21,159
真的需要把那个……嗯，不过当它……的时候

2939
02:01:18,480 --> 02:01:22,599
说到那种比较容易的事情来…… 

2940
02:01:21,159 --> 02:01:24,119
理解；掌握

我的意思是我们已经去过了

2941
02:01:22,599 --> 02:01:26,280
关于这个，所以你有宿主，它是

2942
02:01:24,119 --> 02:01:28,280
中央处理器（CPU）并使用那些内存条在……上（此处原文表述不完整）

2943
02:01:26,280 --> 02:01:31,119
你的主板，然后是设备或者

2944
02:01:28,280 --> 02:01:34,239
GPU使用片上显存或视频（此处“视频”表述可能不太准确，需结合具体语境，这里是按字面直译） 

2945
02:01:31,119 --> 02:01:39,079
内存，嗯，用于台式机的

2946
02:01:34,239 --> 02:01:42,239
PCS 即表面层运行时间

2947
02:01:39,079 --> 02:01:46,159
通常会说“嗯，你看，你给……下定义”

2948
02:01:42,239 --> 02:01:47,760
关于主机或CPU的一些输入，呃

2949
02:01:46,159 --> 02:01:49,560
然后你之后想要在……上运行它（这里“它”指代前文提及的事物，原文未给出明确信息） 

2950
02:01:47,760 --> 02:01:52,679
GPU，但首先你实际上得

2951
02:01:49,560 --> 02:01:55,320
在整个系统内存上定义它

2952
02:01:52,679 --> 02:01:59,560
然后你会把它复制到 GPU 上

2953
02:01:55,320 --> 02:02:02,599
记忆 嗯 然后你会 呃 接着

2954
02:01:59,560 --> 02:02:04,119
你将使用那个在 GPU 上执行。

2955
02:02:02,599 --> 02:02:06,079
记忆 你会处决你 你会

2956
02:02:04,119 --> 02:02:09,239
启动一个CUDA内核，并且那个CUDA

2957
02:02:06,079 --> 02:02:11,159
内核会使用那个呃 GPU 内存，并且

2958
02:02:09,239 --> 02:02:13,520
用它做些事情，也许还能再做一些

2959
02:02:11,159 --> 02:02:15,920
有用的计算，然后一旦那（完成）…… 

2960
02:02:13,520 --> 02:02:17,639
好了 呃 你要确保一切都是…… 

2961
02:02:15,920 --> 02:02:19,119
一切都同步得好像什么都没发生一样

2962
02:02:17,639 --> 02:02:21,000
没有什么在等着你，你愿意吗

2963
02:02:19,119 --> 02:02:23,599
会同步所有内容，然后

2964
02:02:21,000 --> 02:02:25,199
所以你也会把它转回 CPU

2965
02:02:23,599 --> 02:02:26,639
或者是主持人，这样你就可以……（原文表述不太完整和清晰） 

2966
02:02:25,199 --> 02:02:28,639
知道了，把它打印出来或者做些有用的事

2967
02:02:26,639 --> 02:02:30,679
有了它，通常情况下就是这样……（这里原文表述似乎不完整）

2968
02:02:28,639 --> 02:02:34,760
运行时会发出“嗯”的声音，你会在……中看到这个情况

2969
02:02:30,679 --> 02:02:36,719
我们后面的章节 嗯 命名方案

2970
02:02:34,760 --> 02:02:39,760
就像我们实际上，嗯，我们……

2971
02:02:36,719 --> 02:02:41,719
实际上，给我们的数据片段命名是

2972
02:02:39,760 --> 02:02:45,040
非常关键，所以通常你会……

2973
02:02:41,719 --> 02:02:47,040
你要做的是输入“host”或者“H”，然后

2974
02:02:45,040 --> 02:02:50,280
下划线 无论变量名是什么

2975
02:02:47,040 --> 02:02:52,159
所以如果它像《黑客帝国》A那样，你就做……（原句“you do hore”可能存在拼写错误，正确表述或许是“you do something”之类的，这里按照原文翻译出来意思不太通顺） 

2976
02:02:50,280 --> 02:02:55,000
矩阵A，这意味着它是在……上定义的

2977
02:02:52,159 --> 02:02:59,040
主持人 所以你打算去做你的……你的

2978
02:02:55,000 --> 02:03:01,320
马利克，你的……你的……你的C 马利克，嗯，和

2979
02:02:59,040 --> 02:03:03,400
这个，然后你要进行一次CUDA操作

2980
02:03:01,320 --> 02:03:06,079
内存复制，我们稍后会在……中看到它。（由于文本不完整，“in a”后面应该还有内容） 

2981
02:03:03,400 --> 02:03:07,400
第二，嗯，那就是你要去的地方

2982
02:03:06,079 --> 02:03:10,360
这位主持人和你，本质上你…… （原英文表述不太完整和规范，此翻译按字面尽量处理） 

2983
02:03:07,400 --> 02:03:13,960
把它转移到另一个……到这个……

2984
02:03:10,360 --> 02:03:17,239
其他变量，呃，设备，所以是设备A

2985
02:03:13,960 --> 02:03:19,159
那是它的图形处理器（GPU）版本，呃，就是那个的GPU版本，所以

2986
02:03:17,239 --> 02:03:22,480
它只是存在于两个不同的部分上

2987
02:03:19,159 --> 02:03:25,440
关于记忆，嗯，这只是为了……（原句似乎未完整）

2988
02:03:22,480 --> 02:03:28,239
设置变量名 a
现在我们有这个了

2989
02:03:25,440 --> 02:03:31,639
全球的，你可能已经见过了

2990
02:03:28,239 --> 02:03:33,840
嗯，这在全球范围内都是可见的，并且这是

2991
02:03:31,639 --> 02:03:35,880
非常宽泛，这就是，这通常是

2992
02:03:33,840 --> 02:03:39,599
内核会是什么样子呢，呃

2993
02:03:35,880 --> 02:03:42,360
除非你是在打，呃，比如说一个单独的（电话之类，需结合语境明确所指） 

2994
02:03:39,599 --> 02:03:45,679
呃，在……里面调用一个单独的内核

2995
02:03:42,360 --> 02:03:47,440
另一个你会用到的，比如说设备，嗯

2996
02:03:45,679 --> 02:03:49,960
但在这个例子中，我们就只坚持（这样做） 

2997
02:03:47,440 --> 02:03:51,360
有了全局的（信息等，结合语境推测），你知道，你可以读一篇……（此处英文句子不完整，翻译仅按字面大致处理） 

2998
02:03:49,960 --> 02:03:52,400
如果再稍微深入探讨一下这个问题……（原句表述不太完整和规范） 

2999
02:03:51,360 --> 02:03:54,159
你想要

3000
02:03:52,400 --> 02:03:56,480
但我们打算为……使用“全球”这个词（这里“for the”后面内容缺失）

3001
02:03:54,159 --> 02:03:57,760
大部分设备，我们之后可能会看到

3002
02:03:56,480 --> 02:04:01,000
在……里面；在……期间

由于 “in the” 并非完整表达，你可补充完整内容以便我更准确翻译。 

3003
02:03:57,760 --> 02:04:03,719
课程，然后主持人呃只会去……（注：此英文文本不太完整和表意明确，这样的翻译可能存在表意不清晰情况） 

3004
02:04:01,000 --> 02:04:06,360
在 CPU 上运行，所以，呃，别……别真的（这么做）

3005
02:04:03,719 --> 02:04:07,960
担心那个 嗯 这有点……

3006
02:04:06,360 --> 02:04:10,400
只是告诉CUDA你打算……

3007
02:04:07,960 --> 02:04:11,760
在 CPU 上运行，但你可能

3008
02:04:10,400 --> 02:04:13,400
实际上并不需要，因为你只是

3009
02:04:11,760 --> 02:04:16,880
打算用，你知道的，就像用虚空那样

3010
02:04:13,400 --> 02:04:19,960
而不是
而不是全球的空白
对吧

3011
02:04:16,880 --> 02:04:23,360
嗯，现在这个……这个库达苹果酸（注：“Cuda malic”可能并不是一个常见的准确表达，这里“malic”常见意思是“苹果酸的” ，“Cuda”不知是否为特定名称等） 

3012
02:04:19,960 --> 02:04:25,280
因此在图形处理器（GP）显存上进行短期内存分配

3013
02:04:23,360 --> 02:04:29,079
那是GPU上的全局内存

3014
02:04:25,280 --> 02:04:32,760
本身 所以在这个例子中 你 你

3015
02:04:29,079 --> 02:04:35,840
知道 定义一堆，呃，一堆，呃

3016
02:04:32,760 --> 02:04:42,040
本质上是数组，所以是一个指针

3017
02:04:35,840 --> 02:04:44,119
到一个设备，呃，一个浮点数组，它是一个

3018
02:04:42,040 --> 02:04:46,639
指针在……上

（注：此译文因文本不完整，语义可能不准确，需结合完整内容进一步理解。） 

3019
02:04:44,119 --> 02:04:50,159
设备，呃，它是用于……然后那个……

3020
02:04:46,639 --> 02:04:53,079
B 和 C 也是同样的情况，现在你做库达姆（此处“kudam”可能是特定术语，需结合上下文确定准确含义）。 

3021
02:04:50,159 --> 02:04:55,719
马利克，意思是你把它分配到图形处理器（GPU）上

3022
02:04:53,079 --> 02:04:57,559
所以你要为此处理内存地址，所以

3023
02:04:55,719 --> 02:04:59,440
你输入了用于……的内存地址

注：原文“for for”可能存在重复错误，你可检查确认。 

3024
02:04:57,559 --> 02:05:02,239
这东西

3025
02:04:59,440 --> 02:05:03,960
嗯，然后你基本上想怎么做都行。 

3026
02:05:02,239 --> 02:05:06,719
你知道，这么说吧，你有一个

3027
02:05:03,960 --> 02:05:08,599
上面定义的尺寸，对吧，呃，就像它是……

3028
02:05:06,719 --> 02:05:11,040
也许举个例子来说，它就像一个矩阵，并且

3029
02:05:08,599 --> 02:05:14,040
它的尺寸，你知道的，就像个正方形

3030
02:05:11,040 --> 02:05:15,920
矩阵大小为 n 乘 n，而你要做的所有事情是……

3031
02:05:14,040 --> 02:05:18,239
要做的就是说你知道我们想

3032
02:05:15,920 --> 02:05:20,639
分配这么多内存 呃 这些内存

3033
02:05:18,239 --> 02:05:23,280
地址，而那将仅仅是一个

3034
02:05:20,639 --> 02:05:26,840
比如说一个 128 阶的方阵

3035
02:05:23,280 --> 02:05:30,199
* 无论一个浮点数是多大，它的 128 倍大小

3036
02:05:26,840 --> 02:05:33,639
那么在那种情况下，我觉得会是四个。

3037
02:05:30,199 --> 02:05:35,480
因为一个浮点数是，呃，四个字节，在（此处“where”单独看语义不太完整，需结合更多上下文理解其确切含义）

3038
02:05:33,639 --> 02:05:37,880
每个 B 是 8 位，你有一个浮点数

3039
02:05:35,480 --> 02:05:40,599
第32点，算一下，然后你……

3040
02:05:37,880 --> 02:05:43,000
最终得到呃……字节的总量

3041
02:05:40,599 --> 02:05:45,920
你需要为，呃，分配…… 

3042
02:05:43,000 --> 02:05:49,119
这个装置，呃，一个矩阵等等

3043
02:05:45,920 --> 02:05:52,320
同样也经过 b 和 c

3044
02:05:49,119 --> 02:05:54,880
嗯，现在 CUDA 内存复制（Cuda M Copy）可以从两者进行复制。 

3045
02:05:52,320 --> 02:05:59,119
设备到主机
主机到设备
或 设备

3046
02:05:54,880 --> 02:06:01,880
针对极端情况进行设计，所以，嗯，你懂的

3047
02:05:59,119 --> 02:06:05,360
你会 你会稍微拖延一下时间

3048
02:06:01,880 --> 02:06:08,400
在这里，卡门（Camem 可能拼写有误，推测想表达的人名）可以将主机内容复制到设备或配置管理（CM 可能指 Configuration Management）中 

3049
02:06:05,360 --> 02:06:10,239
将设备数据复制到主机，嗯，就是这样

3050
02:06:08,400 --> 02:06:11,960
事情会如何发展 嗯 实际上我们

3051
02:06:10,239 --> 02:06:15,599
马上来看看这个的用法

3052
02:06:11,960 --> 02:06:17,079
在这儿，但是，嗯，理解坎姆文案是…… 

3053
02:06:15,599 --> 02:06:19,199
只是打算 只是打算抄袭东西

3054
02:06:17,079 --> 02:06:20,360
然后四处转转，显然Cuda释放（操作）…… （注：这里“Cuda free”结合语境可能有更准确的表述，仅从这部分英文看“free”可理解为释放，但要结合专业场景确认。）

3055
02:06:19,199 --> 02:06:22,079
只是打算释放一下……上的内存

3056
02:06:20,360 --> 02:06:23,880
设备，所以当你……你完成了…… 

3057
02:06:22,079 --> 02:06:26,159
某样东西，或者你不再需要它了

3058
02:06:23,880 --> 02:06:28,000
你知道的，如果它很大的话，就把它腾出来。

3059
02:06:26,159 --> 02:06:30,199
如果这是个大的，呃，你知道的，如果只是

3060
02:06:28,000 --> 02:06:33,159
像一个整数或者其他什么的，就只是一个

3061
02:06:30,199 --> 02:06:34,320
浮点型，嗯，就像定义一个浮点型变量 a 等于 1 或者

3062
02:06:33,159 --> 02:06:36,239
有时候感觉你没必要这样做。（注：原英文表述不太准确，推测可能想表达类似意思）
有时候就好像你不需要去…… 

3063
02:06:34,320 --> 02:06:37,400
释放那个，嗯，但如果它是一个大数组

3064
02:06:36,239 --> 02:06:41,000
像这样，你需要解脱了

3065
02:06:37,400 --> 02:06:44,679
那个，嗯

3066
02:06:41,000 --> 02:06:46,400
现在，NVCC 编译器是我们将会……

3067
02:06:44,679 --> 02:06:49,119
再深入探究一下或许在……里再多挖掘一点

注：原英文文本似乎并不完整，这样的翻译只能是结合常见语境做出的大致处理。 

3068
02:06:46,400 --> 02:06:53,719
未来，嗯，但这真的就是你的全部了

3069
02:06:49,119 --> 02:06:58,239
需要知道，所以主机代码是，呃

3070
02:06:53,719 --> 02:07:01,400
本质上，这些 nvcc 编译器将会进行编译。 

3071
02:06:58,239 --> 02:07:04,480
把这一切都归结为呃……某件事

3072
02:07:01,400 --> 02:07:08,199
GPU 实际上可以执行，但 CPU （这里句子不完整，推测原文可能没表述完） 

3073
02:07:04,480 --> 02:07:09,960
将要运行它，所以，呃，CPU 将要

3074
02:07:08,199 --> 02:07:12,239
解读一下那话是什么意思，而且它是

3075
02:07:09,960 --> 02:07:14,159
要去发射一些东西，然后告诉……

3076
02:07:12,239 --> 02:07:18,960
让 GPU 去做事情，它可不仅仅会…… 

3077
02:07:14,159 --> 02:07:20,920
直接编译到 GPU 上，对吧，呃

3078
02:07:18,960 --> 02:07:22,559
当它需要在 GPU 上运行时，当……当它……

3079
02:07:20,920 --> 02:07:24,400
实际上需要那些关于……的指示

3080
02:07:22,559 --> 02:07:26,840
该做什么呢，它即将被编译

3081
02:07:24,400 --> 02:07:28,520
一直到PTX，它是并行线程

3082
02:07:26,840 --> 02:07:32,679
执行指令，所以那就像是

3083
02:07:28,520 --> 02:07:36,679
与 x86 或汇编语言等效的 GPU 层面的（东西） 呃

3084
02:07:32,679 --> 02:07:38,520
你知道，就像对于呃，CPU 或者主机来说呃

3085
02:07:36,679 --> 02:07:40,440
然后它还会进一步……

3086
02:07:38,520 --> 02:07:43,239
将其编译成着色器汇编代码

3087
02:07:40,440 --> 02:07:44,880
我们不用担心这个，嗯

3088
02:07:43,239 --> 02:07:47,199
而这仅仅是……而且这是稳定的

3089
02:07:44,880 --> 02:07:49,559
在所有不同的英伟达显卡上

3090
02:07:47,199 --> 02:07:51,119
所以你不用担心那个，嗯

3091
02:07:49,559 --> 02:07:52,199
然后，准时制（及时制）仅仅是一种……（这里句子不完整，推测可能想说“准时制（及时制）仅仅是一种类型” ，因为“just in time”常见表达“准时制；及时制” ）

3092
02:07:51,119 --> 02:07:55,199
编译；编纂（此处“compil”可能是“compile”的不完整形式） 

3093
02:07:52,199 --> 02:07:59,920
所以；那么

3094
02:07:55,199 --> 02:08:01,119
嗯，CUDA层级结构，是的，就是这个，就是它。

3095
02:07:59,920 --> 02:08:03,000
事情开始变得有点……

3096
02:08:01,119 --> 02:08:05,920
直观的；直觉的；凭直觉获知的

3097
02:08:03,000 --> 02:08:09,719
所以想象一下，你有……就好像你……

3098
02:08:05,920 --> 02:08:12,480
有这个巨大的、类似立方体的三维空间

3099
02:08:09,719 --> 02:08:14,400
呃，这个空间被称为网格。

3100
02:08:12,480 --> 02:08:16,639
就在这个网格里面，你要去…… 

3101
02:08:14,400 --> 02:08:19,800
有一堆这样的小立方体

3102
02:08:16,639 --> 02:08:22,159
立方体体积，那些被称为块，呃

3103
02:08:19,800 --> 02:08:24,639
并且那些那些模块是有组织的

3104
02:08:22,159 --> 02:08:27,000
呃，你知道你可以把它们做成任何样子。

3105
02:08:24,639 --> 02:08:29,079
你想要的尺寸，本质上就是这样

3106
02:08:27,000 --> 02:08:31,159
呃，可以把它想象成，就像，就像，就像……

3107
02:08:29,079 --> 02:08:32,440
棱镜之类的东西，呃，而且你有一个

3108
02:08:31,159 --> 02:08:34,840
一堆这样的东西被组织在这个巨大的（物体）里

3109
02:08:32,440 --> 02:08:36,639
3D 体积，也就是网格以及那些

3110
02:08:34,840 --> 02:08:38,360
单个方块里面有东西

3111
02:08:36,639 --> 02:08:40,040
它们被称为线程，而那些线程

3112
02:08:38,360 --> 02:08:42,400
将要为……进行你的数学运算

3113
02:08:40,040 --> 02:08:46,440
你看，这里面有很多内容值得细细剖析。 

3114
02:08:42,400 --> 02:08:48,360
在这儿，但是那些单独的线，嗯

3115
02:08:46,440 --> 02:08:49,599
可以在这些模块内部进行交流

3116
02:08:48,360 --> 02:08:52,000
这是需要记住的重要部分。

3117
02:08:49,599 --> 02:08:53,760
等我们之后优化东西的时候用

3118
02:08:52,000 --> 02:08:55,760
但本质上，我们拥有……的原因是

3119
02:08:53,760 --> 02:08:58,280
里面所有这些不同的部分

3120
02:08:55,760 --> 02:09:01,199
这个巨大的网格是为了让我们能够获得

3121
02:08:58,280 --> 02:09:03,199
GPU的并行性，所以当你有……

3122
02:09:01,199 --> 02:09:04,599
这个街区在做这件事，你知道的，在做……

3123
02:09:03,199 --> 02:09:05,920
拼图的这一块，然后是这块

3124
02:09:04,599 --> 02:09:08,040
在完成拼图的另一部分，并且

3125
02:09:05,920 --> 02:09:09,880
他们都或多或少地尽了自己的一份力，而且在

3126
02:09:08,040 --> 02:09:10,960
如果他们都各尽其责，一切就会结束

3127
02:09:09,880 --> 02:09:12,480
成功了，然后他们都这样（表惊讶等语气，具体根据语境理解）

3128
02:09:10,960 --> 02:09:15,440
同步起来，并且你要确保那一点

3129
02:09:12,480 --> 02:09:17,440
一切运行正常，嗯，你知道的

3130
02:09:15,440 --> 02:09:20,119
这 这总比只有一个要好

3131
02:09:17,440 --> 02:09:21,920
CPU线程逐个遍历每个个体

3132
02:09:20,119 --> 02:09:24,040
在那个问题里的事情，并且一件一件地去做

3133
02:09:21,920 --> 02:09:25,840
到一点钟的时候
你会有一堆…… 

3134
02:09:24,040 --> 02:09:28,639
这些块或者这些内部的线程

3135
02:09:25,840 --> 02:09:30,400
那些，呃，你懂的方块

3136
02:09:28,639 --> 02:09:32,280
它正在进行的一些小规模独立行动

3137
02:09:30,400 --> 02:09:35,880
数量较少的操作，并且它们

3138
02:09:32,280 --> 02:09:37,000
时钟速度较低，呃，但它们是

3139
02:09:35,880 --> 02:09:38,880
它将在很大程度上解决这个问题

3140
02:09:37,000 --> 02:09:41,480
更快，因为它在……里面（这里“it's in”后面内容缺失，需结合完整语境准确理解“in”的具体所指） 

3141
02:09:38,880 --> 02:09:43,880
并行，这就是整个理念。

3142
02:09:41,480 --> 02:09:45,639
这里，你有这个 3D 体积（此处表述不太准确，结合语境“3D Volume”可能更合适的表达是“3D 立体模型”“3D 容积”等，需根据具体情境确定） 

3143
02:09:43,880 --> 02:09:48,079
叫做网格，在它里面你有

3144
02:09:45,639 --> 02:09:50,800
这些其他的，呃，你有这些其他的3D（内容）

3145
02:09:48,079 --> 02:09:52,800
有点像立方体或者长方体之类的，不管啦，嗯

3146
02:09:50,800 --> 02:09:54,239
在这些里面你有线程，并且

3147
02:09:52,800 --> 02:09:59,639
那些线程也将去做

3148
02:09:54,239 --> 02:10:02,159
有些事情，所以我需要喘口气，但我们还是会继续前行 

3149
02:09:59,639 --> 02:10:04,040
进入，呃，一些更专业的术语中，在一个…… 

3150
02:10:02,159 --> 02:10:07,079
第二，这里，所以要谈到这些技术方面的（内容）

3151
02:10:04,040 --> 02:10:09,840
从术语角度我们可以看到这个网格暗区是存在的

3152
02:10:07,079 --> 02:10:13,480
在我们的内核里，在我们的全球……呃

3153
02:10:09,840 --> 02:10:17,599
内核，我们有一个块索引，它就是你

3154
02:10:13,480 --> 02:10:22,400
知道这些，这三个，嗯

3155
02:10:17,599 --> 02:10:24,719
并且块尺寸存在，呃，这里和这里

3156
02:10:22,400 --> 02:10:28,360
还有这里，还有这里，还有这里，对吧，你

3157
02:10:24,719 --> 02:10:31,679
有所有这些，呃，然后是线程索引，所以

3158
02:10:28,360 --> 02:10:35,440
这个网格维度是……中的块数

3159
02:10:31,679 --> 02:10:39,679
你知道的，就像网格尺寸那样的网格

3160
02:10:35,440 --> 02:10:43,280
点 X 将会呃 在这个 这个里面

3161
02:10:39,679 --> 02:10:44,719
体积 uh 网格，X 是什么

3162
02:10:43,280 --> 02:10:46,760
那个的维度，所以就像……那是什么呢

3163
02:10:44,719 --> 02:10:48,159
长度，然后网格维度、儒略日即将……

3164
02:10:46,760 --> 02:10:50,440
就像在问高度是多少，然后呢

3165
02:10:48,159 --> 02:10:53,400
也许网格维度 Z 将会是那个

3166
02:10:50,440 --> 02:10:56,960
那个的深度，对，嗯，然后是……

3167
02:10:53,400 --> 02:10:59,480
块索引将要……实际上并非如此

3168
02:10:56,960 --> 02:11:02,960
呃，关于街区本身，但比如说在哪里呢

3169
02:10:59,480 --> 02:11:06,119
它是网格内的方块所在之处吗？

3170
02:11:02,960 --> 02:11:08,719
所以网格尺寸就像是在问它有多长

3171
02:11:06,119 --> 02:11:10,520
它 怎么样 什么 是什么 那是什么样的 尺寸

3172
02:11:08,719 --> 02:11:14,280
在运行的电网本身方面

3173
02:11:10,520 --> 02:11:16,199
GPU，然后块索引是在……呃，哪里呢

3174
02:11:14,280 --> 02:11:19,880
每个单独的块，所以一个块将会

3175
02:11:16,199 --> 02:11:22,800
在呃，也许是 x 方向上都有一个块索引

3176
02:11:19,880 --> 02:11:24,480
y 和 Z 维度，那将会是

3177
02:11:22,800 --> 02:11:28,599
本质上，它在那里面的坐标

3178
02:11:24,480 --> 02:11:32,040
网格，呃，然后块维度是怎样的

3179
02:11:28,599 --> 02:11:34,119
那个街区很大，网格能容纳很多东西 

3180
02:11:32,040 --> 02:11:36,559
一堆积木，其中一块积木能放进去 

3181
02:11:34,119 --> 02:11:39,119
将线程放入其中，所以块维度是

3182
02:11:36,559 --> 02:11:42,239
就像，这有多大，是不是更小一些呢

3183
02:11:39,119 --> 02:11:45,320
正方体，或者这个，又或者这个长方体

3184
02:11:42,239 --> 02:11:47,480
嗯，然后线程索引就像是哪个…… 

3185
02:11:45,320 --> 02:11:48,800
那么在那个块内它是哪个线程呢

3186
02:11:47,480 --> 02:11:51,320
你可以看到这是如何类似空间的

3187
02:11:48,800 --> 02:11:52,960
沿着层级往下，你会在其中看到这种三维（效果）。 

3188
02:11:51,320 --> 02:11:54,880
网格，然后是这个方块中的三维效果

3189
02:11:52,960 --> 02:11:57,000
所以如果你仔细想想，这有点像是6D的感觉。 

3190
02:11:54,880 --> 02:11:58,040
从那个角度去想这件事 嗯 我不想 我……

3191
02:11:57,000 --> 02:11:59,639
不想让那显得有压迫感

3192
02:11:58,040 --> 02:12:00,840
虽然就像六维的一样 我不想要

3193
02:11:59,639 --> 02:12:03,079
那会让人有压迫感，其实只是友善的表现而已 

3194
02:12:00,840 --> 02:12:05,360
关于它是如何……它是一个高效的（此处原文表述不太完整和清晰） 

3195
02:12:03,079 --> 02:12:06,960
并行处理事务的方式以及

3196
02:12:05,360 --> 02:12:09,599
一种将其可视化的方式，就像一个

3197
02:12:06,960 --> 02:12:12,239
软件抽象，对，呃，就是那个

3198
02:12:09,599 --> 02:12:14,280
这就是那里的想法

3199
02:12:12,239 --> 02:12:17,800
嗯，还有

3200
02:12:14,280 --> 02:12:19,760
然后像……我是说，我，我，我猜

3201
02:12:17,800 --> 02:12:21,559
这种这种空间概念

3202
02:12:19,760 --> 02:12:23,880
现在有点说得通了，所以现在我们可以走了

3203
02:12:21,559 --> 02:12:26,360
探究为什么这会奏效，嗯，还有某种程度上

3204
02:12:23,880 --> 02:12:29,559
比如更具体的细节部分，所以

3205
02:12:26,360 --> 02:12:32,480
每个线程，嗯，本身都有本地内存

3206
02:12:29,559 --> 02:12:34,719
在这上面，所以是非常快速的寄存器

3207
02:12:32,480 --> 02:12:38,079
并且对该单独线程是私有的

3208
02:12:34,719 --> 02:12:40,800
所以，举个例子，如果你想添加，嗯，A

3209
02:12:38,079 --> 02:12:43,079
以及 B，在那里就像 1、2、3 然后全部…… 

3210
02:12:40,800 --> 02:12:45,159
一直到 n 的路径，它就像长度一样

3211
02:12:43,079 --> 02:12:46,760
然后2、4、6，就像这样按……计数

3212
02:12:45,159 --> 02:12:49,679
一个个地数，然后 B 正在以（某种方式）计数。 

3213
02:12:46,760 --> 02:12:53,480
每个线程做两个和，每次做一个 

3214
02:12:49,679 --> 02:12:57,119
添加，所以就像在索引位置（比如说零位置）添加线程

3215
02:12:53,480 --> 02:13:00,199
这句话可能存在表述错误，从现有的内容来看，较难直接准确翻译出通顺合理的句子，大致可以勉强翻译为：
会像在那个那个线索处一样 

3216
02:12:57,119 --> 02:13:03,880
向右索引，因此线程索引

3217
02:13:00,199 --> 02:13:05,639
它本身会告诉你如何对数据进行索引

3218
02:13:03,880 --> 02:13:08,040
然后你可以使用那个元素，那个

3219
02:13:05,639 --> 02:13:10,440
它从自身的索引中获取，从……（原句不完整）

3220
02:13:08,040 --> 02:13:12,040
在整个空间中的线程索引，而你

3221
02:13:10,440 --> 02:13:14,599
实际上可以用那个进行运算，所以

3222
02:13:12,040 --> 02:13:18,079
这就像是一个小窍门，呃

3223
02:13:14,599 --> 02:13:20,760
本质上两者都在获取正确的（东西） 

3224
02:13:18,079 --> 02:13:22,800
数据元素，呃，以及添加和进行……（这里“doing”后面缺少内容，表述不太完整） 

3225
02:13:20,760 --> 02:13:27,960
同时对它们进行数学运算

3226
02:13:22,800 --> 02:13:30,360
所以最后我们要做的，你知道的，呃，就是 1 加 2

3227
02:13:27,960 --> 02:13:33,440
对，用一根线，而且它穿进去了

3228
02:13:30,360 --> 02:13:36,239
并且它正在访问这个索引，呃，那个

3229
02:13:33,440 --> 02:13:37,800
索引 数据基于其基于

注：你提供的英文句子似乎表述不太完整或存在语病，导致翻译出来的内容逻辑不太清晰。如果还有疑问或有修正后的内容，欢迎继续向我提问。 

3230
02:13:36,239 --> 02:13:39,920
线程的索引，并且它正在将它们相加

3231
02:13:37,800 --> 02:13:43,719
一起，呃，然后对你来说也是同样的情况

3232
02:13:39,920 --> 02:13:46,440
知道，也许是第二条线索，对吧，嗯，所以

3233
02:13:43,719 --> 02:13:47,719
这就有点像整个……的那种样子

3234
02:13:46,440 --> 02:13:49,480
那……那就是整个（事情）的样子，呃

3235
02:13:47,719 --> 02:13:52,679
索引的事情成功了，这就是为什么它是

3236
02:13:49,480 --> 02:13:55,000
太酷了，嗯，然后出现扭曲，而且它有点……

3237
02:13:52,679 --> 02:13:57,679
如果你仔细看的话，会很有趣的

（不过原英文文本似乎表述不太完整和准确） 

3238
02:13:55,000 --> 02:14:01,440
这篇维基百科文章它是……

注：原英文句子似乎不完整，翻译可能会因句子未完整呈现而在表意上有欠缺。 

3239
02:13:57,679 --> 02:14:04,679
就像经纱和纬纱，对吧，所以你

3240
02:14:01,440 --> 02:14:08,559
呃，你有这些扭曲，它们是

3241
02:14:04,679 --> 02:14:08,559
经历着，就像这些这些

3242
02:14:08,960 --> 02:14:13,239
呃，这些正在发生的扭曲现象

3243
02:14:11,639 --> 02:14:16,079
穿过它，比如上上下下，然后那…… 

3244
02:14:13,239 --> 02:14:17,119
纬线就像，呃，经线那样的东西。

3245
02:14:16,079 --> 02:14:21,719
穿梭而过，所以它们就像

3246
02:14:17,119 --> 02:14:25,000
像这样相互交错，所以，呃，你，你

3247
02:14:21,719 --> 02:14:29,079
你可以在某种程度上这样想，呃

3248
02:14:25,000 --> 02:14:30,840
扭曲，就像，呃，就像是什么，是什么

3249
02:14:29,079 --> 02:14:35,000
展望未来，所以你可以说就像一个

3250
02:14:30,840 --> 02:14:39,079
经纱是一组纱线

3251
02:14:35,000 --> 02:14:43,079
嗯，经纱和纬纱，呃，垂直的经纱

3252
02:14:39,079 --> 02:14:46,159
纱线，呃，复数形式下是固定不动的。 

3253
02:14:43,079 --> 02:14:48,679
嗯，然后画出了水平分量。 

3254
02:14:46,159 --> 02:14:50,639
穿过它们，所以从本质上说你拥有了所有

3255
02:14:48,679 --> 02:14:52,280
这些战争就像一堆丝线

3256
02:14:50,639 --> 02:14:54,719
本质上，它是一堆线程，这些线程……（这里原句未完整，可能后续还有内容） 

3257
02:14:52,280 --> 02:14:56,119
那些进进出出的……以及……

3258
02:14:54,719 --> 02:14:58,280
你可以把这些线程想象成

3259
02:14:56,119 --> 02:14:59,599
进行他们自己的数学运算，而你

3260
02:14:58,280 --> 02:15:01,599
把它们一堆一堆地归在一起放在……里

注：由于原英文文本没有完整表达出“in”后面的内容，所以翻译只能到此。你可以补充完整内容以便我给出更准确的翻译。 

3261
02:14:59,599 --> 02:15:03,400
一次空间翘曲，没错，那就是全部

3262
02:15:01,599 --> 02:15:06,400
那儿有个主意

3263
02:15:03,400 --> 02:15:09,320
嗯，所以你知道，就像我在……里说的那样

3264
02:15:06,400 --> 02:15:10,400
维基百科文章中的“扭曲”（注：由于原文表述不太符合常见语法规范，“warp”常见释义有“扭曲；弯曲；变形”等，这里结合语境暂这样翻译） 

3265
02:15:09,320 --> 02:15:14,079
是一组；是一套

注：这里需要结合上下文来确定更精准的表述，“a set of”常见意思有“一组；一套；一副”等。 

3266
02:15:10,400 --> 02:15:15,880
纱线；一组纱线或其他物品

3267
02:15:14,079 --> 02:15:17,400
在织布机上原地拉伸，在那个（地方） 

3268
02:15:15,880 --> 02:15:19,520
纬纱在织造过程中被引入。

3269
02:15:17,400 --> 02:15:21,599
该过程被视为纵向的

3270
02:15:19,520 --> 02:15:23,840
镶嵌在一块已完成的、带有两种（元素）的织物中 

3271
02:15:21,599 --> 02:15:25,280
或者更多组元素 我 我不

3272
02:15:23,840 --> 02:15:26,760
期望你能理解那只是

3273
02:15:25,280 --> 02:15:29,119
喜欢线程被分组的这个想法

3274
02:15:26,760 --> 02:15:31,639
进入扭曲空间，嗯，然后是那阵风

3275
02:15:29,119 --> 02:15:33,000
有点像它是那个别的，呃

3276
02:15:31,639 --> 02:15:38,159
垂直的；正交的；直立的；陡峭的

3277
02:15:33,000 --> 02:15:40,679
部分，嗯，所以扭曲点在方块里面，所以

3278
02:15:38,159 --> 02:15:43,400
记住，我们有类似那种网格的东西

3279
02:15:40,679 --> 02:15:47,159
然后是块，接着是线程，嗯

3280
02:15:43,400 --> 02:15:49,320
在方块内部，你有传送门，这些传送门……（由于原句不完整，此处根据语义逻辑适当补充“这些传送门”以体现连贯性） 

3281
02:15:47,159 --> 02:15:51,719
照顾好线程，这样这些块（就能正常运行等，需结合上下文明确“blocks”含义）

3282
02:15:49,320 --> 02:15:54,040
他们自己并没有完全应对好……（这里文本不完整，仅从这部分给出大致符合语境的翻译） 

3283
02:15:51,719 --> 02:15:56,360
线程 实际上是那些线程束（warps）才是……（这里原文句子似乎不完整） 

3284
02:15:54,040 --> 02:15:59,760
正在做很多那样的工作

3285
02:15:56,360 --> 02:16:02,159
所以你通常会像这样来组织一次曲速航行（这里“warp”常见意思是“曲速”，但需结合具体语境确定最准确含义 ） 

3286
02:15:59,760 --> 02:16:05,679
一组线程，就像，呃，我认为那个…… 

3287
02:16:02,159 --> 02:16:07,920
最大值是32个线程，所以一个线程束将

3288
02:16:05,679 --> 02:16:09,440
一次在一个（环境等，需结合上文）中处理32个线程

3289
02:16:07,920 --> 02:16:11,400
街区；大块；障碍物；阻碍；堵塞；阻止；拦截；封锁

3290
02:16:09,440 --> 02:16:14,239
嗯，没有办法避开这一点。 

3291
02:16:11,400 --> 02:16:17,520
使用扭曲，扭曲调度器会使得

3292
02:16:14,239 --> 02:16:20,239
翘曲通道在运行，呃，所以你可以这样想

3293
02:16:17,520 --> 02:16:21,480
比如也许是翘曲调度器，就像…… （原英文文本似乎不完整）

3294
02:16:20,239 --> 02:16:25,159
像纬线一样

3295
02:16:21,480 --> 02:16:26,400
对，所以呢，这有点像是要去……

3296
02:16:25,159 --> 02:16:28,480
穿过并确保他们不会遭遇

3297
02:16:26,400 --> 02:16:29,920
就像理清了头绪之类的，还有……

3298
02:16:28,480 --> 02:16:31,559
确保一切都能顺利解决

3299
02:16:29,920 --> 02:16:34,519
合适的话，你可以使用任何类比。

3300
02:16:31,559 --> 02:16:36,399
行呢，不过那个线程束调度器

3301
02:16:34,519 --> 02:16:39,280
确保那些成组的经线……（原英文句子似乎不完整）

3302
02:16:36,399 --> 02:16:41,800
线程运行，嗯，然后你会

3303
02:16:39,280 --> 02:16:44,599
通常每个有四个线程束调度器

3304
02:16:41,800 --> 02:16:47,200
SM以及SM有点像那种更小的，就像……

3305
02:16:44,599 --> 02:16:48,599
片上流式多处理器

3306
02:16:47,200 --> 02:16:51,639
那些就是这些东西，而且你可以拥有

3307
02:16:48,599 --> 02:16:55,479
每个流多处理器（SM）有四个重复调度器，所以

3308
02:16:51,639 --> 02:16:59,479
嗯，你知道的，算一下，那是128。

3309
02:16:55,479 --> 02:16:59,479
每个流式多处理器（SM）的线程数

3310
02:17:01,240 --> 02:17:07,880
嗯，然后我们有积木，所以积木是

3311
02:17:05,040 --> 02:17:09,479
有趣的是，每个块都有共享内存

3312
02:17:07,880 --> 02:17:11,200
嗯，在那个范围内对所有线程可见

3313
02:17:09,479 --> 02:17:12,920
线程块，所以所有这些都像你一样

3314
02:17:11,200 --> 02:17:16,120
知道线程一可以看到相同的内容

3315
02:17:12,920 --> 02:17:19,599
那个线程32可以，呃，它们可以，或者……

3316
02:17:16,120 --> 02:17:21,679
甚至像那种我也不清楚，比如 500 这样的线程

3317
02:17:19,599 --> 02:17:24,599
就此而言，嗯

3318
02:17:21,679 --> 02:17:26,359
嗯，他们都能看到相同的数据，所以

3319
02:17:24,599 --> 02:17:28,599
就像在曲速飞行中，他们能够，他们能够

3320
02:17:26,359 --> 02:17:30,760
有点能看出他们是可以交流的

3321
02:17:28,599 --> 02:17:33,399
更快，但在一个街区内他们仍然可以

3322
02:17:30,760 --> 02:17:36,519
通过这个能非常快速地交流，呃

3323
02:17:33,399 --> 02:17:37,920
我们称之为一级缓存的共享内存

3324
02:17:36,519 --> 02:17:39,840
我马上就深入探讨这个问题。

3325
02:17:37,920 --> 02:17:43,280
当我们进入下一部分时，但是那个

3326
02:17:39,840 --> 02:17:49,719
一级缓存对于速度非常重要，并且

3327
02:17:43,280 --> 02:17:49,719
优化呃，内核，所以呃

3328
02:17:52,399 --> 02:17:55,960
是的，本质上就是同样的事情

3329
02:17:53,599 --> 02:18:00,000
我说的，呃，共享内存，共享

3330
02:17:55,960 --> 02:18:02,359
记忆更高效，嗯，它是…… 

3331
02:18:00,000 --> 02:18:04,200
更快 我认为是最大内存

3332
02:18:02,359 --> 02:18:07,359
你通过共享内存获得的带宽是

3333
02:18:04,200 --> 02:18:10,519
大概，呃，就差不多 15 左右

3334
02:18:07,359 --> 02:18:13,760
每秒数太字节，然后，呃，全球的

3335
02:18:10,519 --> 02:18:15,840
显存，所以就像我运行英伟达系统管理接口（Nvidia SMI）的时候，呃

3336
02:18:13,760 --> 02:18:19,200
像；喜欢

3337
02:18:15,840 --> 02:18:22,719
由此你可以看出我得到了……（这里get后面似乎缺少内容，译文根据已有原文尽量通顺表达）

3338
02:18:19,200 --> 02:18:25,559
嗯，就像这样，这个，这是我的，这个，这个

3339
02:18:22,719 --> 02:18:28,280
实际上速度大概是六七百

3340
02:18:25,559 --> 02:18:30,200
加布有第二段共享记忆是

3341
02:18:28,280 --> 02:18:35,040
比如15太字节，所以真的是……

3342
02:18:30,200 --> 02:18:38,240
快，嗯，而且块使用，呃，共享的

3343
02:18:35,040 --> 02:18:41,800
记忆，你知道的，呃，在一个……

3344
02:18:38,240 --> 02:18:45,719
单个的社交媒体管理人员，所以社交媒体管理人员会处理那个。 

3345
02:18:41,800 --> 02:18:47,639
嗯，然后是网格，嗯，在时间流逝期间

3346
02:18:45,719 --> 02:18:50,000
执行块内的线程

3347
02:18:47,639 --> 02:18:51,399
网格内的（元素）可以访问全局内存

3348
02:18:50,000 --> 02:18:53,000
嗯，所以那是普遍存在的情况。 

3349
02:18:51,399 --> 02:18:55,880
应用的；适用的；实用的；已申请的；已应用的

3350
02:18:53,000 --> 02:18:57,760
嗯，你可以，你能制作一些东西，你知道的。

3351
02:18:55,880 --> 02:18:59,639
如果你想使用线程的话会更高级一些

3352
02:18:57,760 --> 02:19:02,559
但它将默认使用 GPU。

3353
02:18:59,639 --> 02:19:07,000
你刚提到的 8192 兆字节的内存

3354
02:19:02,559 --> 02:19:11,200
看到了 嗯 它会包含一堆……

3355
02:19:07,000 --> 02:19:13,479
积木，嗯，这里的整个想法是

3356
02:19:11,200 --> 02:19:15,000
那是带有网格和方块以及

3357
02:19:13,479 --> 02:19:16,800
Threads（软件名），是你呀，你只需要…… 

3358
02:19:15,000 --> 02:19:18,319
从概念上讲，担忧在做什么呢

3359
02:19:16,800 --> 02:19:20,280
你不必担心事情会怎样

3360
02:19:18,319 --> 02:19:22,399
在硬件层面进行处理，因为这

3361
02:19:20,280 --> 02:19:24,840
整个CUDA，这整个CUDA层级结构是

3362
02:19:22,399 --> 02:19:26,599
一种软件抽象，对，所以这个……那么

3363
02:19:24,840 --> 02:19:28,000
硬件实际上看起来并不像

3364
02:19:26,599 --> 02:19:30,120
像这样的网格、块和线程

3365
02:19:28,000 --> 02:19:31,880
客观上看起来并非如此啊

3366
02:19:30,120 --> 02:19:34,479
看起来不同，并且被编译成

3367
02:19:31,880 --> 02:19:37,479
实际上并不……的着色器汇编代码

3368
02:19:34,479 --> 02:19:40,599
靠近看；仔细看

3369
02:19:37,479 --> 02:19:41,920
呃，接近这个……这个就是对的情况了

3370
02:19:40,599 --> 02:19:43,639
现在，实际上它是在……上运行的（原句似乎不完整）

3371
02:19:41,920 --> 02:19:45,479
硬件，对，所以有……有

3372
02:19:43,639 --> 02:19:47,519
这里有各种各样不同的层次，它是…… 

3373
02:19:45,479 --> 02:19:49,319
有点难以从中找到头绪，不过

3374
02:19:47,519 --> 02:19:51,240
这有很多，这在某种程度上就是我为什么…… 

3375
02:19:49,319 --> 02:19:54,479
给你展示这些东西是为了给你一个

3376
02:19:51,240 --> 02:19:59,040
更好地掌握那个

3377
02:19:54,479 --> 02:20:01,560
嗯，那么让我们来深入了解一下这个……身份（ID 一般指身份标识，这里可根据具体语境调整）

3378
02:19:59,040 --> 02:20:05,200
执行脚本实际上现在正在进行中

3379
02:20:01,560 --> 02:20:07,280
进入实际的CUDA索引方案

3380
02:20:05,200 --> 02:20:10,720
就像我们在Threads上看到的那样，呃，只不过我们是

3381
02:20:07,280 --> 02:20:13,200
在网格块的层面上，呃

3382
02:20:10,720 --> 02:20:14,680
还有线，所以一切呃，这个这个

3383
02:20:13,200 --> 02:20:16,960
特别是这个脚本旨在

3384
02:20:14,680 --> 02:20:20,120
为我们打印出一些，呃，有用的东西

3385
02:20:16,960 --> 02:20:23,760
所以正如我们所见，呃，身份，你知道所有情况的。 

3386
02:20:20,120 --> 02:20:26,880
这些不同的块索引，嗯，所有的

3387
02:20:23,760 --> 02:20:29,319
这些，呃，哦，我要接着说…… 

3388
02:20:26,880 --> 02:20:32,920
这些稍后再说，但本质上

3389
02:20:29,319 --> 02:20:34,840
像你一样，嗯，如果我们往下走

3390
02:20:32,920 --> 02:20:37,800
嗯，我们，我们有所有这些术语。

3391
02:20:34,840 --> 02:20:39,520
我们所定义的正确

3392
02:20:37,800 --> 02:20:45,479
所以

3393
02:20:39,520 --> 02:20:48,080
呃，X 方块，Y 方块，Z 方块，对吧，那么 B

3394
02:20:45,479 --> 02:20:50,680
然后 T 代表“线”，那么我……

3395
02:20:48,080 --> 02:20:53,520
我这里特别指的是，呃，这是…… （这里“this is the”后面内容缺失，所以译文根据情况做了处理） 

3396
02:20:50,680 --> 02:20:57,000
这是块维度，所以在……里面

3397
02:20:53,520 --> 02:20:59,080
网格，你会有，呃，像这样的 X

3398
02:20:57,000 --> 02:21:01,800
X 维度的长度将是

3399
02:20:59,080 --> 02:21:05,160
两个，然后高度维度是

3400
02:21:01,800 --> 02:21:06,800
三，并且深度维度 Z 是四

3401
02:21:05,160 --> 02:21:08,960
对，所以你会有这样一个网格

3402
02:21:06,800 --> 02:21:11,720
呃，音量，而且会是那样的

3403
02:21:08,960 --> 02:21:14,479
形状，然后在每一个单独的（个体/事物等，需结合具体语境确定“individual”准确所指）当中

3404
02:21:11,720 --> 02:21:17,560
那个网格里面的那个里面的方块

3405
02:21:14,479 --> 02:21:20,640
嗯，你会拿到这些线的。

3406
02:21:17,560 --> 02:21:22,760
昏暗，呃，从本质上来说这就是……

3407
02:21:20,640 --> 02:21:24,600
块维度 这是 嗯 这是

3408
02:21:22,760 --> 02:21:28,319
网格维度，这是块

3409
02:21:24,600 --> 02:21:29,640
维度，嗯，所以你在……的里面

3410
02:21:28,319 --> 02:21:32,439
你将拥有每一块（积木/街区等，需结合具体语境确定“block”含义）

3411
02:21:29,640 --> 02:21:34,160
本质上是四个长、四个高以及四个 

3412
02:21:32,439 --> 02:21:37,720
深，没错，所以会是这个，这个

3413
02:21:34,160 --> 02:21:41,000
完美立方，本质上，嗯，以及

3414
02:21:37,720 --> 02:21:43,600
所以我们往下算，我们可以进行计算

3415
02:21:41,000 --> 02:21:46,800
每个网格中的方块总数，所以

3416
02:21:43,600 --> 02:21:48,439
本质上就是基数、时间、宽度、时间

3417
02:21:46,800 --> 02:21:49,920
提升你的经典配方，同样如此

3418
02:21:48,439 --> 02:21:51,080
对于每个线程块的线程数，并且我们可以得到

3419
02:21:49,920 --> 02:21:52,720
总数；总数量

3420
02:21:51,080 --> 02:21:54,960
在这些当中的每一个里面，然后我们可以啊

3421
02:21:52,720 --> 02:21:58,160
然后把它们打印出来，对吧，每（这里“blocks per” 表述不太完整，需结合更多语境确定准确意思）

3422
02:21:54,960 --> 02:22:00,760
每个块的网格线程数，嗯，然后是总数

3423
02:21:58,160 --> 02:22:02,680
线程数量，所以我们有一定的（此处句子不完整）

3424
02:22:00,760 --> 02:22:04,120
每个线程块中的线程数量，然后如果

3425
02:22:02,680 --> 02:22:05,680
我们将其乘以我们（拥有）的方块数量

3426
02:22:04,120 --> 02:22:07,920
获取……的总数

3427
02:22:05,680 --> 02:22:10,600
线程，现在我们有了另一种类型（往下看） 

3428
02:22:07,920 --> 02:22:13,319
这里称为维度3，它特定于

3429
02:22:10,600 --> 02:22:15,200
CUDA，但从本质上讲这仅仅是……（此处句子不完整）

3430
02:22:13,319 --> 02:22:18,520
和我们之前看到的一样，所以是方块

3431
02:22:15,200 --> 02:22:21,479
每个网格，所以我们有这个，这些，嗯，这些

3432
02:22:18,520 --> 02:22:23,439
这些网格维度，即 X、Y 和 Z，以及

3433
02:22:21,479 --> 02:22:26,200
然后对于一个……里面的线程也是同样的情况

3434
02:22:23,439 --> 02:22:29,600
块，所以这个块，块的尺寸

3435
02:22:26,200 --> 02:22:31,760
嗯，意思是 x、y 和 z，然后我们代入

3436
02:22:29,600 --> 02:22:34,760
把这些放入我们称之为……的内核中

3437
02:22:31,760 --> 02:22:37,200
我是谁
我们有这个全球性的，呃，我们有

3438
02:22:34,760 --> 02:22:40,960
这个全局标题

3439
02:22:37,200 --> 02:22:42,200
然后我们做这三件事，嗯，我们做这些事

3440
02:22:40,960 --> 02:22:43,600
这三个符号我记不起来了

3441
02:22:42,200 --> 02:22:45,680
这些被叫做什么，就好像是更少的那种（这里句子表意不太完整清晰）

3442
02:22:43,600 --> 02:22:48,280
小于或大于符号，呃，然后

3443
02:22:45,680 --> 02:22:51,160
你输入呃……方块的总数

3444
02:22:48,280 --> 02:22:53,160
每网格微米，或者网格尺寸为

3445
02:22:51,160 --> 02:22:54,680
第一个参数，然后是线程

3446
02:22:53,160 --> 02:22:56,560
每块作为第二个，然后还有

3447
02:22:54,680 --> 02:22:58,000
其他一些你之后可以做的事情

3448
02:22:56,560 --> 02:22:59,120
你马上就会看到那些了，不过

3449
02:22:58,000 --> 02:23:01,560
这些就是你所有需要担心的事情了。 

3450
02:22:59,120 --> 02:23:02,880
大约就在现在，所以网格尺寸

3451
02:23:01,560 --> 02:23:04,960
然后是那块积木（此处“block”需结合具体语境判断更合适的意思，常见还有“街区；方块；障碍物”等意思 ）

3452
02:23:02,880 --> 02:23:06,240
尺寸，呃，然后我们看到一个设备

3453
02:23:04,960 --> 02:23:07,720
同步以确保一切

3454
02:23:06,240 --> 02:23:09,760
被耽搁了，我们可以继续进行…… 

3455
02:23:07,720 --> 02:23:12,520
不管我们还需要做什么，嗯，就是这个

3456
02:23:09,760 --> 02:23:14,279
那实际上会被这样使用，嗯

3457
02:23:12,520 --> 02:23:15,560
所以现在当我们真的来到这里时

3458
02:23:14,279 --> 02:23:17,399
事情从这里开始变得有点……

3459
02:23:15,560 --> 02:23:18,880
在空间上很直观
好吧，我不去了

3460
02:23:17,399 --> 02:23:20,680
要说这部分可能就像其中一个…… 

3461
02:23:18,880 --> 02:23:24,920
最难理解，但我打算……

3462
02:23:20,680 --> 02:23:28,319
尽我所能解释一下，所以这个方块 ID

3463
02:23:24,920 --> 02:23:30,800
这是什么？嗯，这本质上是

3464
02:23:28,319 --> 02:23:33,080
你 你可以想到呃一群

3465
02:23:30,800 --> 02:23:35,600
公寓里的套间

3466
02:23:33,080 --> 02:23:38,080
复杂的，嗯，每一个里面都有好几层

3467
02:23:35,600 --> 02:23:39,800
公寓，然后是类似房间号的数字

3468
02:23:38,080 --> 02:23:42,960
就在那一层，对吧，所以我们正在努力

3469
02:23:39,800 --> 02:23:45,319
去寻找在那之外我们所处的位置

3470
02:23:42,960 --> 02:23:46,880
公寓楼群，没错，所以你可以想象

3471
02:23:45,319 --> 02:23:49,880
把它当作

3472
02:23:46,880 --> 02:23:51,920
嗯，你知道吗，你的公寓就像一个

3473
02:23:49,880 --> 02:23:56,240
就像一幅画，对吧，它就像一件独特的作品

3474
02:23:51,920 --> 02:24:00,279
在这一程度上的痛苦，嗯，所以

3475
02:23:56,240 --> 02:24:03,680
在这一个里你，呃，在……在……这个里

3476
02:24:00,279 --> 02:24:08,120
公寓小区，你实际上是要（做……） 

3477
02:24:03,680 --> 02:24:09,840
嗯，网格尺寸、像素，所以就是这个，这个长度部分

3478
02:24:08,120 --> 02:24:12,600
然后是字母 Y

3479
02:24:09,840 --> 02:24:16,080
分量，呃，然后乘以任意的 Z

3480
02:24:12,600 --> 02:24:18,439
那么，块索引 `doz` 无论在哪里都是……

注：原英文文本可能存在一些拼写错误或不完整表述，这可能会影响准确理解和翻译的效果。 

3481
02:24:16,080 --> 02:24:20,399
块位置 它不是 它根本不是

3482
02:24:18,439 --> 02:24:22,399
就像某物有多大 它的大小情况是……

注：原英文句子表述不太完整和规范，但按要求进行了逐词翻译并尽量体现连贯性。 

3483
02:24:20,399 --> 02:24:24,960
索引或位置，所以你有

3484
02:24:22,399 --> 02:24:27,399
这种疼痛，其程度是 x 乘以 Y，然后还有 a （这里由于“a”表意不明，只能按原文直译，具体含义需结合上下文理解） 

3485
02:24:24,960 --> 02:24:29,160
深度，也就是 z，所以不管怎样就像是…… 

3486
02:24:27,399 --> 02:24:30,560
痛苦如此巨大，然后就陷得那么深，所以

3487
02:24:29,160 --> 02:24:32,640
就像这些窗格，它们就像

3488
02:24:30,560 --> 02:24:34,359
逐层堆叠，按深度方向排列，对吧

3489
02:24:32,640 --> 02:24:37,640
它正在深入发展，所以你会有这些

3490
02:24:34,359 --> 02:24:39,399
那些像是往那个方向去的窗格 嗯

3491
02:24:37,640 --> 02:24:44,000
然后你有

3492
02:24:39,399 --> 02:24:46,920
呃，块索引（block idx）、y 方向偏移（doy）、时间、网格维度（grid dim）、x 方向偏移（dox）

3493
02:24:44,000 --> 02:24:49,760
所以你可以把这个想象成，呃，就像……

3494
02:24:46,920 --> 02:24:51,880
网格di就像这样，像一个地板

3495
02:24:49,760 --> 02:24:56,399
没错，那套公寓里的一层，呃

3496
02:24:51,880 --> 02:24:58,160
建筑物，并且块 ID x.y 如下所示

3497
02:24:56,399 --> 02:25:00,960
哪 是哪一层啊，所以你得……

3498
02:24:58,160 --> 02:25:03,439
往上走相应数量的楼层就能到那里

3499
02:25:00,960 --> 02:25:05,520
嗯，所以基本上就像是你开始……

3500
02:25:03,439 --> 02:25:06,960
从底部开始，你像这样进行很多次

3501
02:25:05,520 --> 02:25:08,439
然后有这么多，接着又有这么多

3502
02:25:06,960 --> 02:25:09,880
就好像那些每一个都像是一堆

3503
02:25:08,439 --> 02:25:11,640
你要穿过才能到达的房间

注：你提供的文本不完整，可能没有表达出完整的意思。若你还有后续内容，可以继续让我翻译。 

3504
02:25:09,880 --> 02:25:13,800
下一层楼，没错，你最终会绕过去

3505
02:25:11,640 --> 02:25:16,200
到这一个，然后你，呃，接着

3506
02:25:13,800 --> 02:25:19,319
一旦你到达实际的X位置

3507
02:25:16,200 --> 02:25:20,840
这就好比 x 是你所指的长度

3508
02:25:19,319 --> 02:25:22,840
实际上，就停在那儿吧，所以这就好像是……

3509
02:25:20,840 --> 02:25:26,240
你经历了好些…… 

3510
02:25:22,840 --> 02:25:28,479
像佩因斯（Paines）那样深沉的痛苦 嗯 一排排 高高在上 

注：“paines”可能是一个人名，音译为“佩因斯” ，需结合具体语境判断。 

3511
02:25:26,240 --> 02:25:30,040
这是楼层数，嗯，还有

3512
02:25:28,479 --> 02:25:31,439
然后你最终就会得到像这样的东西

注：原英文表述 “this this” 可能有误，但按照要求进行了翻译。 

3513
02:25:30,040 --> 02:25:33,359
最后一部分，就好像在说“好吧，那又怎样”

3514
02:25:31,439 --> 02:25:35,359
是我所在这层楼的偏移量

3515
02:25:33,359 --> 02:25:38,439
我的公寓在哪里，而且它就像……就像……

3516
02:25:35,359 --> 02:25:41,760
就在这里，它好像有深度，然后就…… 

3517
02:25:38,439 --> 02:25:43,680
向上深度增加，楼层数量增加，并且

3518
02:25:41,760 --> 02:25:45,359
然后就像这样，我现在在这儿，而且那是

3519
02:25:43,680 --> 02:25:49,160
你怎么，呃，那就是你找到你的……的方式

3520
02:25:45,359 --> 02:25:50,520
街区编号，呃，比如是哪个公寓小区

3521
02:25:49,160 --> 02:25:52,040
或者你住在哪个公寓楼呢

3522
02:25:50,520 --> 02:25:54,160
连同那整个城市或者那……

3523
02:25:52,040 --> 02:25:56,960
三维空间中的赋能综合体

3524
02:25:54,160 --> 02:25:59,600
场景：此块偏移量是

3525
02:25:56,960 --> 02:26:01,399
本质上就是你选取的“你”的数量

3526
02:25:59,600 --> 02:26:03,479
每个线程块的总线程数，所以这个线程块

3527
02:26:01,399 --> 02:26:05,920
尺寸 每个里面有多少根线

3528
02:26:03,479 --> 02:26:07,240
你知道，在X中有这么多线程。

3529
02:26:05,920 --> 02:26:09,520
这么多线程，还有 Y，并且数量一样多

3530
02:26:07,240 --> 02:26:10,840
线程Z 你 你 你把所有那些相乘

3531
02:26:09,520 --> 02:26:15,600
将你获得每……的总线程数（原句似乎不完整） 

3532
02:26:10,840 --> 02:26:17,600
街区或者说每套公寓的居住人数 嗯 还有

3533
02:26:15,600 --> 02:26:20,760
然后乘以我们的公寓号，所以它是

3534
02:26:17,600 --> 02:26:22,800
就像，呃，正在运行的线程总数

3535
02:26:20,760 --> 02:26:26,960
本质上是符合你的喜好的，哪个，哪个

3536
02:26:22,800 --> 02:26:29,520
线程索引，嗯，你喜欢多少……

注：原英文文本似乎不太符合正常表达逻辑，可能存在信息缺失或表述有误的情况。 

3537
02:26:26,960 --> 02:26:32,680
线在你的呃公寓前面，怎么样

3538
02:26:29,520 --> 02:26:35,000
很多人呃在你公寓前面

3539
02:26:32,680 --> 02:26:36,359
呃，你的公寓房号，就是那个（房号）

3540
02:26:35,000 --> 02:26:38,960
我们在这里要说的是，所以我们进行了计算

3541
02:26:36,359 --> 02:26:40,760
之前的这个方块 ID，然后我们……我们

3542
02:26:38,960 --> 02:26:42,520
只是找到类似那样的，但在……层面上

3543
02:26:40,760 --> 02:26:46,439
取而代之的是线程，而那就是关键所在（此处“block”结合语境理解为关键、要点，也可根据更准确语境调整） 

3544
02:26:42,520 --> 02:26:47,920
用于，呃，计算的偏移量，你知道是哪种（偏移量）

3545
02:26:46,439 --> 02:26:49,880
我们所处的环节，然后我们就可以继续了

3546
02:26:47,920 --> 02:26:51,880
并且使用我们所用的相同类比

3547
02:26:49,880 --> 02:26:54,319
用于块 ID，线程除外

3548
02:26:51,880 --> 02:26:56,920
偏移量，所以你知道它就像线程 ID

3549
02:26:54,319 --> 02:26:58,920
x.x 方块 ID x.x 就好像这些是

3550
02:26:56,920 --> 02:27:00,680
就像基本上映射的那样，只是它是

3551
02:26:58,920 --> 02:27:03,680
就像等级制度中的较低层级，它是

3552
02:27:00,680 --> 02:27:07,800
破成了线，而不是

3553
02:27:03,680 --> 02:27:10,040
嗯，不是用方块，对吧，所以你

3554
02:27:07,800 --> 02:27:11,680
你能计算出是哪个人……你（此英文原句表述可能有误，不太符合正常语法逻辑，翻译仅按字面意思处理）

3555
02:27:10,040 --> 02:27:14,319
都在那个单独的公寓内

3556
02:27:11,680 --> 02:27:15,920
就好像如果它是，好像它是一个大的…… （此英文表述不太完整和清晰，译文可能存在表意不明确情况） 

3557
02:27:14,319 --> 02:27:17,160
带有多层的公寓，并且

3558
02:27:15,920 --> 02:27:18,960
里面好像有好几层呢，你

3559
02:27:17,160 --> 02:27:21,600
可以利用那个，但你懂我的意思了吧

3560
02:27:18,960 --> 02:27:23,920
这是一个……这是一个三维类比，嗯，然后我们

3561
02:27:21,600 --> 02:27:25,520
能从中找出我们是哪个人

3562
02:27:23,920 --> 02:27:29,000
或者本质上是哪条线索在……

3563
02:27:25,520 --> 02:27:31,040
就是那个街区，所以当你添加那个…… （原句似乎不完整） 

3564
02:27:29,000 --> 02:27:33,040
块偏移量，所以……的总数

3565
02:27:31,040 --> 02:27:36,160
通向你公寓的线索

3566
02:27:33,040 --> 02:27:37,720
另外，你属于其中的哪一类呢，呃

3567
02:27:36,160 --> 02:27:39,319
在那个公寓号范围内，然后你

3568
02:27:37,720 --> 02:27:41,240
实际上可以找到你所在的线程

3569
02:27:39,319 --> 02:27:43,840
在整个网格中，然后你可以做

3570
02:27:41,240 --> 02:27:46,800
把那个弄好，那就是我们要做的

3571
02:27:43,840 --> 02:27:48,840
说签署全球身份标识以实现全球化 

3572
02:27:46,800 --> 02:27:51,399
整个公寓内的人员身份识别码

注：这里“person ID”直译为“人员身份识别码” ，如果结合具体语境有更合适的表达，可根据实际情况调整。 

3573
02:27:48,840 --> 02:27:53,200
复杂的 嗯

3574
02:27:51,399 --> 02:27:55,040
就是这样，所以有很多事情要…… （原句似乎不完整） 

3575
02:27:53,200 --> 02:27:57,040
在那里打开行李
随时可以再看一些

3576
02:27:55,040 --> 02:27:59,720
这一点的，甚至尝试去想象其中一些

3577
02:27:57,040 --> 02:28:02,160
你自己来做这个，也许把它写出来，嗯

3578
02:27:59,720 --> 02:28:04,920
但当我们真的去的时候

3579
02:28:02,160 --> 02:28:09,120
当我们进入这里的终端时

3580
02:28:04,920 --> 02:28:15,920
然后进入五个，嗯，然后转向……（这里“cud”可能拼写有误，推测可能是“turn” ）到……

3581
02:28:09,120 --> 02:28:21,160
基础部分，如果我们这样操作，呃，使用 nvcc -d -o ，我们从 0 开始……我们 

3582
02:28:15,920 --> 02:28:24,160
执行01，然后像这样再执行01

3583
02:28:21,160 --> 02:28:26,160
嗯，它会编译这个二进制文件，而这个二进制文件我们…… 

3584
02:28:24,160 --> 02:28:29,720
看这里，然后我们就可以直接继续去做（此处原文未明确“做什么”） 

3585
02:28:26,160 --> 02:28:31,840
执行那个，它会给我们展示呃

3586
02:28:29,720 --> 02:28:35,319
确切地说，我们刚刚提到的所有这些就是……（原句表述不太完整和通顺，翻译可能存在一定局限性） 

3587
02:28:31,840 --> 02:28:38,720
我们刚刚才打开行李，所以我是说，我不能，我……

3588
02:28:35,319 --> 02:28:42,800
无法把这一切都显示在屏幕上，但是

3589
02:28:38,720 --> 02:28:42,800
呃，比如说，如果我们来看

3590
02:28:42,840 --> 02:28:49,680
就像它是如何向上计数的，对吧

3591
02:28:46,520 --> 02:28:52,080
那么，嗯，你拥有了你所有的……

3592
02:28:49,680 --> 02:28:56,640
这里有不同的维度，而且你可以，呃

3593
02:28:52,080 --> 02:29:00,960
在最后，我相信它会输出这个

3594
02:28:56,640 --> 02:29:04,200
呃，特定的线程偏移量，所以我们

3595
02:29:00,960 --> 02:29:07,279
注意到它大概是63，然后它

3596
02:29:04,200 --> 02:29:10,240
跳到 32 了，所以现在是 32 并且

3597
02:29:07,279 --> 02:29:12,439
然后它朝着……而去

3598
02:29:10,240 --> 02:29:14,880
嗯，它是这样的

3599
02:29:12,439 --> 02:29:19,359
呃，用于…… （注：“for uh”表述不太完整，这样的翻译仅供参考其大致可能表达的意思） 

3600
02:29:14,880 --> 02:29:24,000
32个数字，所以如果我们取30，我的意思是它是…… 

3601
02:29:19,359 --> 02:29:28,000
从技术层面讲，就像是负一，呃，但

3602
02:29:24,000 --> 02:29:32,520
你在这里能使用的最佳类比是

3603
02:29:28,000 --> 02:29:35,399
这是 32 个线程，对吧，嗯，那是一个

3604
02:29:32,520 --> 02:29:37,279
warp 所以当我们谈到 32 个线程时

3605
02:29:35,399 --> 02:29:39,399
在翘曲状态下，它看起来就是这个样子

3606
02:29:37,279 --> 02:29:42,560
同样地，你也回到这里来，你会……

3607
02:29:39,399 --> 02:29:45,680
看，它正好停在32，然后你就会继续

3608
02:29:42,560 --> 02:29:49,200
从那里向上，所以范围大概是从 0 到 31

3609
02:29:45,680 --> 02:29:51,720
所以就像 0 1 2 3 4，所以就像是从 1 到

3610
02:29:49,200 --> 02:29:53,600
31 有 31 个元素，然后你会得到

3611
02:29:51,720 --> 02:29:55,720
那个额外的零使它变成了 32

3612
02:29:53,600 --> 02:29:58,319
那只是索引方案，对吧

3613
02:29:55,720 --> 02:30:00,399
然后当你从32变到63时，它是

3614
02:29:58,319 --> 02:30:04,640
这是同样的想法，嗯，因为你去…… 

3615
02:30:00,399 --> 02:30:07,319
从 0 到 63 而不是从 1 到 64，所以你

3616
02:30:04,640 --> 02:30:10,359
实际上确实有32个元素，呃，32个

3617
02:30:07,319 --> 02:30:12,520
那里每个线程束中的线程数，嗯，然后

3618
02:30:10,359 --> 02:30:15,120
你可以在……中看到全局线程 ID。（注：原英文句子不完整，这里只能按现有内容翻译） 

3619
02:30:12,520 --> 02:30:17,279
整个电网，所以当我们……当我们

3620
02:30:15,120 --> 02:30:21,000
实际上把这些相乘，我们得到你（此处原文表述似乎不太符合常见逻辑，译文可能较难完全贴合准确语义） 

3621
02:30:17,279 --> 02:30:23,640
要知道在这个网格中，我们有 2×3 （这里表述不太完整准确，推测可能是想说网格中有 2 行 3 列之类的意思 ）

3622
02:30:21,000 --> 02:30:26,359
也就是 6，然后 6 乘以 4 等于

3623
02:30:23,640 --> 02:30:33,200
24

3624
02:30:26,359 --> 02:30:34,960
嗯，24乘以4再乘以4，那么结果是16，然后还是16 

3625
02:30:33,200 --> 02:30:38,840
* 4 是 是

3626
02:30:34,960 --> 02:30:42,640
64 所以你可以看到整个这里是 1536

3627
02:30:38,840 --> 02:30:45,479
把事情做对，所以嗯，如果我们像这样滚动

3628
02:30:42,640 --> 02:30:48,080
回顾过去，我们可以看到，呃

3629
02:30:45,479 --> 02:30:52,399
1535年，事情就在那里结束了，那就是…… 

3630
02:30:48,080 --> 02:30:55,240
最后一个，所以，嗯，比如说方块

3631
02:30:52,399 --> 02:30:58,200
嗯，它有两个元素，所以它是

3632
02:30:55,240 --> 02:30:59,479
将会是零和一，然后这个

3633
02:30:58,200 --> 02:31:04,240
将会有三个元素，所以它是

3634
02:30:59,479 --> 02:31:06,680
将会是，嗯，0、1、2，然后这是

3635
02:31:04,240 --> 02:31:10,240
四个元素，所以会是 0 1 2

3636
02:31:06,680 --> 02:31:11,680
3 是 4，对吧，呃，然后是螺纹

3637
02:31:10,240 --> 02:31:15,920
因为它们每个都能达到四，这是

3638
02:31:11,680 --> 02:31:18,680
将会是 0 1 2 3 0 1 2 3 0 1 2 3 嗯

3639
02:31:15,920 --> 02:31:20,279
然后你最终基本上会得到……

3640
02:31:18,680 --> 02:31:21,680
不管最后那个数字是多少，所以

3641
02:31:20,279 --> 02:31:23,520
你可以看到这一切是如何累积起来的

3642
02:31:21,680 --> 02:31:26,319
以及这种索引方案是如何运作的，并且

3643
02:31:23,520 --> 02:31:28,920
我们如何使用这些来对……的片段进行索引

3644
02:31:26,319 --> 02:31:31,680
数据嗯，使用像真正的线程那样，并且

3645
02:31:28,920 --> 02:31:34,160
块索引，然后，接着做

3646
02:31:31,680 --> 02:31:35,560
用那个，嗯，进行非常快速的并行运算

3647
02:31:34,160 --> 02:31:37,160
这就是这里的整个想法
咱们走吧

3648
02:31:35,560 --> 02:31:39,240
向前迈进，投身到内核领域中去

3649
02:31:37,160 --> 02:31:40,760
现在，好的，那么现在我们要做一个

3650
02:31:39,240 --> 02:31:42,120
运用一点我们的数学知识，然后我们就…… 

3651
02:31:40,760 --> 02:31:43,240
实际上，你知道的，打算去看看什么

3652
02:31:42,120 --> 02:31:45,680
这些内核实际上正在做并且

3653
02:31:43,240 --> 02:31:47,040
这样就能了解它们在底层是如何运作的

3654
02:31:45,680 --> 02:31:49,319
实际上这非常简单，这是

3655
02:31:47,040 --> 02:31:50,479
这已经是最简单的情况了，嗯，但本质上

3656
02:31:49,319 --> 02:31:53,359
我们只是要处理一些向量问题

3657
02:31:50,479 --> 02:31:56,880
加法作为一种练习，所以把这些相加

3658
02:31:53,359 --> 02:32:00,479
两个元素逐个相加 1 + 6 2 + 7 3

3659
02:31:56,880 --> 02:32:03,040
+ 8 诸如此类，然后我们得到了所有这些，嗯，非常非常…… 

3660
02:32:00,479 --> 02:32:05,479
简单易懂，我们能行

3661
02:32:03,040 --> 02:32:08,439
我这里有一个很明显的 CPU 示例

3662
02:32:05,479 --> 02:32:12,560
而且赏心悦目

3663
02:32:08,439 --> 02:32:14,160
嗯，我们有一个 GPU 示例，它是

3664
02:32:12,560 --> 02:32:15,960
实际上有点奇怪，这是一个……这是

3665
02:32:14,160 --> 02:32:18,080
与这个不同，因为在这里我们有

3666
02:32:15,960 --> 02:32:20,720
一个 for 循环，在这里我们有这个这个它

3667
02:32:18,080 --> 02:32:23,160
术语，即 ID 块索引 时间 块 于

3668
02:32:20,720 --> 02:32:25,279
再加上第九线程，我要解释一下

3669
02:32:23,160 --> 02:32:26,880
马上就来处理这个，但这不行啊

3670
02:32:25,279 --> 02:32:28,439
有一个 for 循环，本质上是什么

3671
02:32:26,880 --> 02:32:30,800
这就像我之前说的那样在进行着

3672
02:32:28,439 --> 02:32:32,319
这只是在展开这个循环，所以你

3673
02:32:30,800 --> 02:32:33,840
知道CPU打算这么做

3674
02:32:32,319 --> 02:32:35,920
迭代，这一次，然后是这一次

3675
02:32:33,840 --> 02:32:37,600
然后这一个，显卡将要……

3676
02:32:35,920 --> 02:32:39,479
把所有这些单独的迭代都拿出来，

3677
02:32:37,600 --> 02:32:41,840
将它分布到一堆块中

3678
02:32:39,479 --> 02:32:43,240
或者，或者你可以说，呃，而且它是

3679
02:32:41,840 --> 02:32:45,640
打算并行化该操作，并且

3680
02:32:43,240 --> 02:32:48,479
让它变得非常非常快，所以不要……

3681
02:32:45,640 --> 02:32:50,240
分开做的话，比如做一千万（的量）

3682
02:32:48,479 --> 02:32:52,680
像按顺序这样的不同操作

3683
02:32:50,240 --> 02:32:55,600
这大约需要一万次。

3684
02:32:52,680 --> 02:32:58,840
单位，微米，比如说你有，你知道的，一万（个/份等，需结合语境确定具体含义） 

3685
02:32:55,600 --> 02:33:00,720
西科尔（Cicor）要像这样把这个拆分

3686
02:32:58,840 --> 02:33:03,000
嗯，就这样吧，实际上还挺多的。

3687
02:33:00,720 --> 02:33:04,880
现在更少了，那只有大约一千。

3688
02:33:03,000 --> 02:33:07,560
次数、深度，你必须这样做，以至于它是…… 

3689
02:33:04,880 --> 02:33:08,840
它的速度提升了，呃，提升的幅度大得离谱，仅仅是因为

3690
02:33:07,560 --> 02:33:12,200
将它分散开来，而且那是

3691
02:33:08,840 --> 02:33:13,840
当然是理论上的，但嗯，你知道的，我们

3692
02:33:12,200 --> 02:33:15,080
初始化向量，这应该是这个

3693
02:33:13,840 --> 02:33:17,160
如果你已经（做过相关事情），应该会非常直观易懂。 

3694
02:33:15,080 --> 02:33:19,040
像随意写下的任何杂乱内容一样

3695
02:33:17,160 --> 02:33:20,439
在它准备……之前，C 语言里的“gens”（注：“gens”可能不是常规词汇，需结合更多语境明确） 

3696
02:33:19,040 --> 02:33:22,600
本质上采取；基本上拿

注：“essentially take”不是完整句子，其准确含义需结合具体语境确定。 

3697
02:33:20,439 --> 02:33:26,960
呃，一个介于零和……之间的随机整数

3698
02:33:22,600 --> 02:33:28,200
兰德最大值 所以兰德最大值是这个 嗯 非常…… 

3699
02:33:26,960 --> 02:33:30,920
容易理解，这将是一场

3700
02:33:28,200 --> 02:33:32,680
浮点数，嗯，然后一个

3701
02:33:30,920 --> 02:33:34,640
计时函数只是用来测量

3702
02:33:32,680 --> 02:33:37,520
执行时间 同样在这个脚本里 我们

3703
02:33:34,640 --> 02:33:39,359
正在进行基准测试，因此进行性能预热

3704
02:33:37,520 --> 02:33:42,319
跑步能让你把事情都调动起来，并且……

3705
02:33:39,359 --> 02:33:44,560
然后对 CPU 到 GPU 进行基准测试，看看情况如何

3706
02:33:42,319 --> 02:33:46,319
嗯，确实如此，嗯，但这其实并不是……

3707
02:33:44,560 --> 02:33:50,040
这里重要的部分是我想要的……（原句不完整）

3708
02:33:46,319 --> 02:33:52,000
主要扩展的是 是什么 是什么 是什么

3709
02:33:50,040 --> 02:33:53,319
这里的内容专门适用于CUDA。

3710
02:33:52,000 --> 02:33:56,680
你真正需要做的是……（这里原句不完整，推测表达“你真正需要……” ）

3711
02:33:53,319 --> 02:33:58,960
明白，所以我们有这个库达·马利克

3712
02:33:56,680 --> 02:34:00,800
这和马利克的情况一样，只是它是

3713
02:33:58,960 --> 02:34:02,640
在图形处理器（GPU）上，所以它会去做那件事，它是……

3714
02:34:00,800 --> 02:34:07,439
打算在……上分配内存

（这里原文“on on”可能有误，推测应该是“on” ） 

3715
02:34:02,640 --> 02:34:10,760
全局动态随机存取存储器（GDAM）或者图形处理器（GPU）上的显存，呃

3716
02:34:07,439 --> 02:34:14,720
这一切真正拥有的只是一个设备指针

3717
02:34:10,760 --> 02:34:18,720
还有一个尺寸，所以我们有这个，我们有这个

3718
02:34:14,720 --> 02:34:21,960
设备a 此设备是一个向量或数组

3719
02:34:18,720 --> 02:34:23,840
呃，这里声明的是一个指针

3720
02:34:21,960 --> 02:34:25,120
嗯，然后我们为那个设置尺寸。

3721
02:34:23,840 --> 02:34:28,680
没错，而这仅仅是回忆

3722
02:34:25,120 --> 02:34:31,359
那个的地址，所以，呃，我们进行分配

3723
02:34:28,680 --> 02:34:33,040
带有CUDA的设备内存，马利克，嗯，还有

3724
02:34:31,359 --> 02:34:34,560
然后当我们实际上想移动……（此处文本似乎不完整）

3725
02:34:33,040 --> 02:34:36,319
我们在主机上创建的东西

3726
02:34:34,560 --> 02:34:39,359
因为记住，我们初始化了这些

3727
02:34:36,319 --> 02:34:41,680
全球范围内的向量，或者仅仅是……（原文此处表述不太完整和清晰） 

3728
02:34:39,359 --> 02:34:43,560
常规的 CPU 函数，所以实际上我们

3729
02:34:41,680 --> 02:34:46,200
现在得把这些复制过去，还有我们该怎么……

3730
02:34:43,560 --> 02:34:50,760
要做到这一点，我们实际上只需着眼于

3731
02:34:46,200 --> 02:34:52,479
这个目的地、源头，它有多大

3732
02:34:50,760 --> 02:34:56,319
那我们想要什么样的文案呢

3733
02:34:52,479 --> 02:34:57,880
这样做，目标是设备，因此用“d”

3734
02:34:56,319 --> 02:35:02,319
源头是

3735
02:34:57,880 --> 02:35:05,200
主持人 它尺寸很大 嗯 就像我们说的那样

3736
02:35:02,319 --> 02:35:07,880
这时，CM将主机内容复制到设备，所以

3737
02:35:05,200 --> 02:35:11,399
CPU 数据将转移到 GPU，并且这意味着 

3738
02:35:07,880 --> 02:35:11,399
这非常简单。

3739
02:35:11,560 --> 02:35:17,040
嗯，我们定义，呃，这些数字块，它们……（原句似乎不完整） 

3740
02:35:15,240 --> 02:35:19,760
和我们所（预想/经历等，需结合上文确定）的有点不同

3741
02:35:17,040 --> 02:35:22,120
在这个索引工作中做了（些事）呃，因为

3742
02:35:19,760 --> 02:35:26,720
实际上它并非我们所认为的这种三维类型

3743
02:35:22,120 --> 02:35:29,800
之前看到过 嗯 不过它仍然能用

3744
02:35:26,720 --> 02:35:34,120
这整件事的想法是，呃，如果

3745
02:35:29,800 --> 02:35:36,200
而不是说，呃，如果不是拥有

3746
02:35:34,120 --> 02:35:39,600
比如2、3、4，如果我们就想让它这样

3747
02:35:36,200 --> 02:35:44,279
就像一段呃，这是什么，这

3748
02:35:39,600 --> 02:35:46,680
24 是 2 * 3 * 4 的结果吗？24 确实是 2 * 3 * 4 的结果，那么你会……你……

3749
02:35:44,279 --> 02:35:50,439
实际上可以把这个设置为 24 并且

3750
02:35:46,680 --> 02:35:54,000
然后把这些设为 1，并且只是有呃

3751
02:35:50,439 --> 02:35:56,960
麻木的街区，然后把这个放进去

3752
02:35:54,000 --> 02:35:59,960
呃，实际上在核心启动时

3753
02:35:56,960 --> 02:36:02,279
只是将整数转换为类似“dim”的形式

3754
02:35:59,960 --> 02:36:04,319
三，然后就感觉，感觉麻木了

3755
02:36:02,279 --> 02:36:06,479
积木，然后一个加一个，所以就只是

3756
02:36:04,319 --> 02:36:08,240
就好像它只有长度，而且它……

3757
02:36:06,479 --> 02:36:10,600
仍然喜欢它，仍然看起来像

3758
02:36:08,240 --> 02:36:12,359
体积的，但它只是被布置好了

3759
02:36:10,600 --> 02:36:14,319
呈线性变化，所以最终看起来像一个

3760
02:36:12,359 --> 02:36:17,399
线条，并且可以将其解读为一条线

3761
02:36:14,319 --> 02:36:21,200
在硬件方面

3762
02:36:17,399 --> 02:36:23,439
嗯，然后你可能会问，好吧，那该怎么做呢

3763
02:36:21,200 --> 02:36:25,359
我们究竟该如何计算块的数量呢，嗯

3764
02:36:23,439 --> 02:36:27,560
这非常有趣。

3765
02:36:25,359 --> 02:36:29,240
所以我们有一堆事情在进行中

3766
02:36:27,560 --> 02:36:33,160
在这里，而且这似乎有点滑稽，所以我们

3767
02:36:29,240 --> 02:36:35,160
有 n 加上块大小再减一，并且我是

3768
02:36:33,160 --> 02:36:36,880
现在要在这里把这个演示出来

3769
02:36:35,160 --> 02:36:38,600
只是为了搞清楚这到底是什么

3770
02:36:36,880 --> 02:36:41,439
麻木能屏蔽一切，这意味着我真的躺下了（此处由于缺乏更多语境，“laid”的准确含义可能存在偏差，“laid”常见为“lay（躺）”的过去式） 

3771
02:36:38,600 --> 02:36:44,920
为这个代码块做一些计算

3772
02:36:41,439 --> 02:36:46,520
size 是内部线程的数量

3773
02:36:44,920 --> 02:36:48,040
一块
它就是这块的大小

3774
02:36:46,520 --> 02:36:50,880
它本身，哪些螺纹会合适

3775
02:36:48,040 --> 02:36:53,160
对，所以如果我们有，那就……

3776
02:36:50,880 --> 02:36:56,080
比如说，不是处理 1000 万个元素，像 

3777
02:36:53,160 --> 02:36:58,560
我们这里有，比如说我们有 1.24

3778
02:36:56,080 --> 02:37:03,040
元素，对吧，呃，如果我们试图匹配

3779
02:36:58,560 --> 02:37:04,359
1，每个（组）256 个线程处理 24 个元素

3780
02:37:03,040 --> 02:37:05,920
阻碍，这意味着我们可能要……

3781
02:37:04,359 --> 02:37:10,920
想要四块，对吧，它会把它分开的

3782
02:37:05,920 --> 02:37:13,319
均匀分布，因为256乘以4等于1024微米，所以

3783
02:37:10,920 --> 02:37:15,240
我们实际上必须计算这个。

3784
02:37:13,319 --> 02:37:19,200
手动操作，但我们必须牢记

3785
02:37:15,240 --> 02:37:20,319
我们正在做，呃，就像我们……这里有（这句话英文表述不太完整和通顺，只能尽量按原文翻译） 

3786
02:37:19,200 --> 02:37:22,680
更多我们必须记录追踪的事情

3787
02:37:20,319 --> 02:37:26,279
万一要说这个数字最终会是

3788
02:37:22,680 --> 02:37:29,279
就像 1025 那样，所以实际上我把它写下来了

3789
02:37:26,279 --> 02:37:32,840
一个能进行这种数学运算的脚本

3790
02:37:29,279 --> 02:37:36,640
呃，对我们来说非常合适。嗯，那么让我们先来……

3791
02:37:32,840 --> 02:37:39,600
看这个，所以你有这个，呃，1024

3792
02:37:36,640 --> 02:37:42,240
再加上256，那就是……那就是……的长度

3793
02:37:39,600 --> 02:37:43,880
数组加上块大小，即正确的数字

3794
02:37:42,240 --> 02:37:46,600
每个线程块的线程数量，那么你就要去（做某事，这里上下文缺失） 

3795
02:37:43,880 --> 02:37:49,240
做减一的运算，然后不管结果是多少

3796
02:37:46,600 --> 02:37:51,080
用那个除以块大小，呃，然后

3797
02:37:49,240 --> 02:37:53,720
然后

3798
02:37:51,080 --> 02:37:56,600
呃，编译器会自动地（运行等，需结合上下文理解这里自动做什么） 

3799
02:37:53,720 --> 02:37:59,399
准备直接给出这个答案，它会……

3800
02:37:56,600 --> 02:38:02,319
把那些小数位截断

3801
02:37:59,399 --> 02:38:03,920
所以如果你得到比如4.99或者其他什么数值，它就是…… 

3802
02:38:02,319 --> 02:38:05,240
打算拿走那0.99美元，然后就……

3803
02:38:03,920 --> 02:38:07,520
把它截断，这样你就会结束

3804
02:38:05,240 --> 02:38:11,279
带着四个（东西/人等，需结合语境）起来，所以如果我们要为……做（某事） 

3805
02:38:07,520 --> 02:38:16,680
例如 1.00

注：这里原文“1,00”可能有误，在英语里表达小数通常用“.” 而不是“,” ，一般“1.00”更符合常见用法，故这里按常规理解翻译。 

3806
02:38:11,279 --> 02:38:21,520
嗯，1024 加 256，那是多少呢，1100？

3807
02:38:16,680 --> 02:38:23,160
+ 200 是 1200，然后 56 + 24 是 80，所以

3808
02:38:21,520 --> 02:38:27,160
我们得到

3809
02:38:23,160 --> 02:38:33,080
1280 微米，要是我们用这个数值除以…… 

3810
02:38:27,160 --> 02:38:33,080
256 最后我们得到了大概……是什么呢？

3811
02:38:34,640 --> 02:38:40,840
答案除以 256，我们得到

3812
02:38:41,800 --> 02:38:47,920
嗯，我们得到了这个数字，但要记住我们

3813
02:38:45,960 --> 02:38:49,600
有这里的这一个，实际上我…… 

3814
02:38:47,920 --> 02:38:53,520
有那么一瞬间忘了我们有……

3815
02:38:49,600 --> 02:38:56,000
那个，所以从技术层面讲是呃79，所以

3816
02:38:53,520 --> 02:38:57,960
最后你得到了这个N9部件，事情就结束了。

3817
02:38:56,000 --> 02:39:01,439
向上取整结果只是 4，因为你进行了截断操作

3818
02:38:57,960 --> 02:39:03,040
不过，如果最终你有……（此处文本似乎不完整）

3819
02:39:01,439 --> 02:39:05,279
这就像

3820
02:39:03,040 --> 02:39:08,240
1.25 那么这个数字实际上正要…… 

3821
02:39:05,279 --> 02:39:11,920
最终变成 1280，因为你只是

3822
02:39:08,240 --> 02:39:14,319
给你知道的1279加1，然后你…… 

3823
02:39:11,920 --> 02:39:16,359
最终得到五个，所以万一你最终……

3824
02:39:14,319 --> 02:39:18,720
添加一个你想要的额外元素

3825
02:39:16,359 --> 02:39:20,080
为其分配空间和资源，或者

3826
02:39:18,720 --> 02:39:22,120
否则你将得不到那个答案，

3827
02:39:20,080 --> 02:39:23,680
你想要，所以这就是这一切在搞的事情

3828
02:39:22,120 --> 02:39:25,560
在这里，而且我们确保，这仅仅是

3829
02:39:23,680 --> 02:39:30,240
就像一次精心的计算，以确保

3830
02:39:25,560 --> 02:39:32,920
希望一切都能如我们所愿，嗯

3831
02:39:30,240 --> 02:39:35,399
所以这只是一个小脚本

3832
02:39:32,920 --> 02:39:37,040
那是我写来测试这个的，但我不……

3833
02:39:35,399 --> 02:39:40,040
需要那个

3834
02:39:37,040 --> 02:39:40,040
再也；不再

3835
02:39:42,800 --> 02:39:50,040
嗯

3836
02:39:44,520 --> 02:39:52,040
那么，再进一步，嗯

3837
02:39:50,040 --> 02:39:56,080
本质上，在这个内核里，我们让

3838
02:39:52,040 --> 02:39:58,200
我靠过来，所以在这个内核里我们有

3839
02:39:56,080 --> 02:40:00,640
仅仅是这个X维度被呈现出来

3840
02:39:58,200 --> 02:40:02,840
对，所以你正在做的是你有

3841
02:40:00,640 --> 02:40:05,439
这个块，块索引是哪个就是哪个

3842
02:40:02,840 --> 02:40:08,600
挡住它，它在那一行里

注：原英文表述不太符合常见语法规范，翻译是基于字面尽量通顺表达。 

3843
02:40:05,439 --> 02:40:12,160
网格，然后你要将其乘以

3844
02:40:08,600 --> 02:40:14,319
块的大小，那么有多少呢 

3845
02:40:12,160 --> 02:40:17,640
每个块中有线程数乘以……（此处“times the”后面内容缺失，翻译只能根据现有内容处理） 

3846
02:40:14,319 --> 02:40:19,880
块的数量，呃，然后加上

3847
02:40:17,640 --> 02:40:22,840
无论哪个 无论什么

3848
02:40:19,880 --> 02:40:26,960
我们现在所处的线索，所以这为我们提供了

3849
02:40:22,840 --> 02:40:29,279
那根线，嗯，在那条类似的线上

3850
02:40:26,960 --> 02:40:31,439
一个网格，对吧，所以我们最终得到了

3851
02:40:29,279 --> 02:40:34,520
无论我们身处何地，我们都会利用那个（资源/条件等，需结合上下文确定具体指代） 

3852
02:40:31,439 --> 02:40:37,359
线程索引，以便随后访问其中的元素

3853
02:40:34,520 --> 02:40:40,319
A、B 和 C 呃，然后我们就进行一个……

3854
02:40:37,359 --> 02:40:42,200
一个加法运算，所以无论你了解哪一个

3855
02:40:40,319 --> 02:40:44,600
在某些情况下，这可能会是这样

3856
02:40:42,200 --> 02:40:46,800
就像你知道的，250万，而且在某些（情况下） 

3857
02:40:44,600 --> 02:40:48,920
在某些情况下，可能会是三个，呃，在那种（情况）下

3858
02:40:46,800 --> 02:40:50,840
万一它们会是相同的数字

3859
02:40:48,920 --> 02:40:52,000
呃，然后他们要加上，并且

3860
02:40:50,840 --> 02:40:53,479
我们会得到我们想要的答案

3861
02:40:52,000 --> 02:40:56,359
预计它可能只是不会在……发生

3862
02:40:53,479 --> 02:40:59,439
顺序 就像一个循环 可能 没错 所以

3863
02:40:56,359 --> 02:41:01,120
而不是像，呃，先做那个…… 

3864
02:40:59,439 --> 02:41:02,720
呃，第一个索引和第二个索引

3865
02:41:01,120 --> 02:41:04,040
而第三个会像散开一样

3866
02:41:02,720 --> 02:41:05,800
然后分发这些，而这才刚刚开始

3867
02:41:04,040 --> 02:41:08,040
要快，对吧，所以这就是……

3868
02:41:05,800 --> 02:41:10,880
整个想法就在那儿

3869
02:41:08,040 --> 02:41:14,279
嗯，如果我们继续并实际运行

3870
02:41:10,880 --> 02:41:14,279
这个脚本

3871
02:41:16,479 --> 02:41:23,439
嗯，到 0 0，然后我们就可以只弄 0

3872
02:41:20,040 --> 02:41:26,800
输入向量 ad，然后我们就运行

3873
02:41:23,439 --> 02:41:29,200
这个文件正在执行“oneup”运行，呃，C

3874
02:41:26,800 --> 02:41:33,240
基准测试以及 CPU 基准测试，还有 GPU 基准测试等

3875
02:41:29,200 --> 02:41:35,800
CPU平均时间大约是……0.14

3876
02:41:33,240 --> 02:41:38,279
毫秒，这真的很快

3877
02:41:35,800 --> 02:41:41,479
然而，GPU的平均时间是

3878
02:41:38,279 --> 02:41:44,439
明显少于那个，大约143倍

3879
02:41:41,479 --> 02:41:47,120
速度提升了近144倍 呃 还有结果

3880
02:41:44,439 --> 02:41:49,760
当我们比较它们时能匹配上，呃，索引

3881
02:41:47,120 --> 02:41:52,600
按索引还是按元素，所以我们只是

3882
02:41:49,760 --> 02:41:55,080
在这里验证结果，嗯，我们确保

3883
02:41:52,600 --> 02:41:57,040
……的绝对值

注：你提供的文本似乎不完整，这里只能按现有内容翻译。 

3884
02:41:55,080 --> 02:42:00,359
那两者之间的差异更大了

3885
02:41:57,040 --> 02:42:02,560
比呃 1×10⁵要……，这只是一个常见的（情况） 

3886
02:42:00,359 --> 02:42:04,640
验证相关的东西，这样你就会看到那个

3887
02:42:02,560 --> 02:42:07,160
当我们在比较事物的时候，呃，你知道的

3888
02:42:04,640 --> 02:42:09,520
更像是当我们更深入地研究 CUDA 时，它是…… 

3889
02:42:07,160 --> 02:42:11,560
将会是你这个关于“基准”的概念

3890
02:42:09,520 --> 02:42:14,600
呃，你可以得出一个平均时间跨度

3891
02:42:11,560 --> 02:42:16,200
所有的尝试，然后你要确保 

3892
02:42:14,600 --> 02:42:18,000
你通过……正在得到正确的结果

3893
02:42:16,200 --> 02:42:20,000
有这样一个公差系数，所以

3894
02:42:18,000 --> 02:42:23,640
有时候，这可能会低得离谱。

3895
02:42:20,000 --> 02:42:25,560
或者它可能会超级高，嗯，但是

3896
02:42:23,640 --> 02:42:28,279
那 那通常就是我们要做的方式

3897
02:42:25,560 --> 02:42:31,000
那么接下来我们有第二个……的例子

3898
02:42:28,279 --> 02:42:34,000
向量加法，嗯，这在很大程度上……（注：原英文文本似乎不完整，此处翻译尽量按语义通顺原则处理） 

3899
02:42:31,000 --> 02:42:36,760
然而，同样地，并非仅仅拥有

3900
02:42:34,000 --> 02:42:39,920
这个，呃，一维的，就像 x 轴

3901
02:42:36,760 --> 02:42:43,520
那种我们有一、二、三、四的情况

3902
02:42:39,920 --> 02:42:45,399
台词，嗯，我们还有很多，所以继续

3903
02:42:43,520 --> 02:42:47,840
回到索引那个例子，在那里

3904
02:42:45,399 --> 02:42:49,560
我们知道，有三个维度，嗯，如果

3905
02:42:47,840 --> 02:42:52,439
我们实际上将其应用于矢量版。

3906
02:42:49,560 --> 02:42:54,000
我们明显感觉到速度变慢了，所以这个

3907
02:42:52,439 --> 02:42:56,040
你首先会注意到的是，这个

3908
02:42:54,000 --> 02:42:58,040
台词多得多，但你却好像

3909
02:42:56,040 --> 02:42:59,960
埃利奥特，当然，这将会是…… 

3910
02:42:58,040 --> 02:43:02,000
更快了，没错，它占满了整个空间

3911
02:42:59,960 --> 02:43:04,200
而不是仅仅，呃，而不是仅仅一个

3912
02:43:02,000 --> 02:43:06,439
稍微往右一点 嗯，那个……问题在于

3913
02:43:04,200 --> 02:43:08,520
问题是 CUDA 实际上无法正常运行

注：原英文句子 “this is that it Cuda is not really going” 表述有误，推测可能想表达 “The problem is that CUDA is not really working” 之类的意思，以上是结合推测给出的翻译。 

3914
02:43:06,439 --> 02:43:10,120
为安排事情而发愁

3915
02:43:08,520 --> 02:43:11,479
让它们跑得很快，而且……

3916
02:43:10,120 --> 02:43:13,840
编译成某种即将出现的东西

3917
02:43:11,479 --> 02:43:15,520
要真正快速地工作，嗯，这是……

3918
02:43:13,840 --> 02:43:17,640
更确切地说，那些计算是什么呢？

3919
02:43:15,520 --> 02:43:20,120
你实际上在单一的（情况/行为等，需结合语境确定具体含义）中所做的事情

3920
02:43:17,640 --> 02:43:21,800
呃，线对，所以这是个，这是

3921
02:43:20,120 --> 02:43:26,000
一个线程里将会发生什么

3922
02:43:21,800 --> 02:43:28,840
注意我们是如何做 1 2 3 4 5 六的

3923
02:43:26,000 --> 02:43:31,080
运算，所以，嗯，3加3

3924
02:43:28,840 --> 02:43:33,760
相乘，然后三个存储，所以等于

3925
02:43:31,080 --> 02:43:35,479
也签一下，然后这个，就像

3926
02:43:33,760 --> 02:43:37,520
你有一堆这样的比较

3927
02:43:35,479 --> 02:43:40,319
而且这就像一堆数学问题

3928
02:43:37,520 --> 02:43:44,720
你 这 这就像很难读懂，对吧

3929
02:43:40,319 --> 02:43:49,560
关键在于，这的确……

3930
02:43:44,720 --> 02:43:52,840
一一得一 存一或一

3931
02:43:49,560 --> 02:43:55,319
将两家商店和两则广告相乘

3932
02:43:52,840 --> 02:43:58,840
明显比这个少，所以这个（此处“这个”指代需结合前文确定）

3933
02:43:55,319 --> 02:44:00,840
重点是，嗯，只有在……的时候才使用 3D 方面

3934
02:43:58,840 --> 02:44:02,080
当情况是这样的时候，你绝对需要这么做。

3935
02:44:00,840 --> 02:44:03,960
取决于你的算法，还有你

3936
02:44:02,080 --> 02:44:05,720
没必要呃 当你 当你

3937
02:44:03,960 --> 02:44:08,600
实际上有类似那样的东西

3938
02:44:05,720 --> 02:44:09,760
呃，在空间上是三维的话，那么你可以使用

3939
02:44:08,600 --> 02:44:11,080
像这样的东西，因为它可能

3940
02:44:09,760 --> 02:44:13,520
实际上工作会轻松一点，而且你不会……

（原文“w't”可能是“won't”的拼写错误 ）

3941
02:44:11,080 --> 02:44:15,520
必须把所有这些计算都做完

3942
02:44:13,520 --> 02:44:17,600
把这个三维空间布置成类似……

3943
02:44:15,520 --> 02:44:19,240
这个一维的东西，嗯，还有你

3944
02:44:17,600 --> 02:44:21,800
得担心像东西缠绕之类的事情

3945
02:44:19,240 --> 02:44:23,319
转来转去，大踏步走动，诸如此类的嗯

3946
02:44:21,800 --> 02:44:24,960
所以，大致就是那样，主要是…… 

3947
02:44:23,319 --> 02:44:27,880
那里存在瓶颈，而且我真的只是做了一个

3948
02:44:24,960 --> 02:44:29,960
3D与1D的比较

3949
02:44:27,880 --> 02:44:32,560
矢量版内核，这样我们就可以继续了

3950
02:44:29,960 --> 02:44:35,560
并且实际上对其进行编译

3951
02:44:32,560 --> 02:44:35,560
这里

3952
02:44:36,800 --> 02:44:43,880
嗯，所以我们注意到它们都很多。

3953
02:44:39,600 --> 02:44:47,720
然而，速度更快……嗯，加快中央处理器（CPU）的速度

3954
02:44:43,880 --> 02:44:49,640
与 GPU 一维相比，就像 GPU 一维是 106 那样

3955
02:44:47,720 --> 02:44:52,600
速度快了数倍，但 3D 效果仅有 102（这里 102 没有明确的单位或含义，可根据具体语境调整）

3956
02:44:49,640 --> 02:44:57,479
快了数倍，所以实际上这个更快。

3957
02:44:52,600 --> 02:45:00,880
比那个，比GPU 3D，嗯，不是以一种（方式）

3958
02:44:57,479 --> 02:45:02,880
数量多得离谱，但你知道，大概到3这个程度 

3959
02:45:00,880 --> 02:45:05,120
也许4%，而且如果你扩大你的……

3960
02:45:02,880 --> 02:45:08,200
数字方面，它可能会增长，但你明白……

3961
02:45:05,120 --> 02:45:10,279
呃，有很多不必要的（东西）

3962
02:45:08,200 --> 02:45:12,279
那里的计算，嗯，而且它只是某种类型的（这里“kind”意思不太明确，需要结合上下文准确理解，“某种类型的”是比较宽泛的译法 ） 

3963
02:45:10,279 --> 02:45:14,760
走这条路更简单些，和……（此处“with”后面缺少内容，句子表意不完整） 

3964
02:45:12,279 --> 02:45:16,800
一维；一维的（这里“the 1D”结合语境可能有不同准确含义，常见可理解为“一维” ） 

3965
02:45:14,760 --> 02:45:18,080
内核 现在我们深入探讨某样…… 

3966
02:45:16,800 --> 02:45:19,520
更直观一点

3967
02:45:18,080 --> 02:45:21,120
通过算法调用的矩阵

3968
02:45:19,520 --> 02:45:23,000
乘法，你可能已经（了解过）

3969
02:45:21,120 --> 02:45:24,840
做了这件事，在这种情况下你是知道这件事的

3970
02:45:23,000 --> 02:45:26,160
可能只是你做的一些简单的回顾

3971
02:45:24,840 --> 02:45:27,560
你可能想直接跳到后面，这取决于你。

3972
02:45:26,160 --> 02:45:30,000
你说得没错，但我还是要再讲一遍这个内容。 

3973
02:45:27,560 --> 02:45:31,760
不管怎样，因为有些人

3974
02:45:30,000 --> 02:45:34,520
可能并不知晓，有时候这样也挺好

3975
02:45:31,760 --> 02:45:37,080
对那个进行一点复习，这样我们就……

3976
02:45:34,520 --> 02:45:39,520
本质上是要写出那种幼稚的（内容） 

3977
02:45:37,080 --> 02:45:42,520
版本 矩阵的简单版本

3978
02:45:39,520 --> 02:45:45,880
乘法 CUDA 内核，它是……（这里原文句子似乎未完整） 

3979
02:45:42,520 --> 02:45:49,680
最慢的那种，但它是最基础的，而且

3980
02:45:45,880 --> 02:45:54,399
直观易懂，嗯

3981
02:45:49,680 --> 02:45:58,080
所以矩阵看起来是这样的，你有

3982
02:45:54,399 --> 02:46:00,439
行，而且你有列，对吧，嗯，让

3983
02:45:58,080 --> 02:46:04,439
实际上我在这里再放大一点

3984
02:46:00,439 --> 02:46:07,640
那么行和列，嗯，比如说 A 是

3985
02:46:04,439 --> 02:46:11,040
一个 3 行 2 列的（矩阵之类的，需结合上下文），因为它有三行且 

3986
02:46:07,640 --> 02:46:13,359
两列靠右，所以就好像是三列

3987
02:46:11,040 --> 02:46:16,160
高和两个长，就像是宽乘以…… 

3988
02:46:13,359 --> 02:46:18,200
你可以说高度，或者是高度乘以宽度

3989
02:46:16,160 --> 02:46:21,000
然后我们有矩阵 B，它是一个 2×4 的矩阵，所以

3990
02:46:18,200 --> 02:46:24,840
它是两行，呃，四列，四……

3991
02:46:21,000 --> 02:46:27,160
列，对吧，呃，想法是……

3992
02:46:24,840 --> 02:46:30,160
只要这两个内项是

3993
02:46:27,160 --> 02:46:31,359
同样的，然后，呃，然后我们，然后它

3994
02:46:30,160 --> 02:46:34,319
实际上是可行的，我们被允许那样做。

3995
02:46:31,359 --> 02:46:36,160
矩阵乘法 嗯 你会看到的

3996
02:46:34,319 --> 02:46:37,880
为什么一转眼到了这里，然后是这些

3997
02:46:36,160 --> 02:46:39,680
外部尺寸 这三个和四个

3998
02:46:37,880 --> 02:46:44,040
最终会成为……的新尺寸

3999
02:46:39,680 --> 02:46:46,880
新的输出矩阵 C 呃，所以我们有你

4000
02:46:44,040 --> 02:46:49,880
知道 1 2 3 4 5 6 以及 7 8 9 10 11 12 13

4001
02:46:46,880 --> 02:46:52,520
14 而且我们在这里所做的事情是，这非常……

4002
02:46:49,880 --> 02:46:55,279
这非常简单，你基本上数到7就行

4003
02:46:52,520 --> 02:46:57,720
还有11，你，你拿着这个，你拥有这个

4004
02:46:55,279 --> 02:47:00,520
呃，这个B是这样的，然后A是……

4005
02:46:57,720 --> 02:47:05,200
像这样，所以你取这个 7 然后

4006
02:47:00,520 --> 02:47:10,520
在B中是11英寸，然后你转动它，接着你做…… 

4007
02:47:05,200 --> 02:47:13,080
与呃 1 和 2 做一个点积，所以你

4008
02:47:10,520 --> 02:47:14,840
拿上7路和11路（车相关推测，这里信息不全表意不明），你换乘

4009
02:47:13,080 --> 02:47:17,080
结束了，所以这个7将会……

4010
02:47:14,840 --> 02:47:19,279
与 1 相乘，然后结果是 11 。

4011
02:47:17,080 --> 02:47:21,920
接下来要和这个 2 相乘，对吧，那么

4012
02:47:19,279 --> 02:47:24,160
你就像……就像歪着的，呃

4013
02:47:21,920 --> 02:47:25,560
然后当你用 1 乘以 1 时

4014
02:47:24,160 --> 02:47:27,760
用这七个，你会得到七个和两个

4015
02:47:25,560 --> 02:47:29,479
呃，11 乘以 2 得到 22，然后你会…… 

4016
02:47:27,760 --> 02:47:32,040
把那些加起来得到

4017
02:47:29,479 --> 02:47:33,080
29 微米，我们可以在这里清楚地看到，就像

（注：“um”常见为“微米”的英文缩写“μm”的不规范写法） 

4018
02:47:32,040 --> 02:47:36,080
第一个；最初的；首要的

4019
02:47:33,080 --> 02:47:38,840
元素，所以注意它是如何像……

4020
02:47:36,080 --> 02:47:41,279
第一列与第一行对齐

4021
02:47:38,840 --> 02:47:43,479
在一起，所以就好像他们是

4022
02:47:41,279 --> 02:47:45,640
他们就像指着一个点，那是

4023
02:47:43,479 --> 02:47:47,960
就像第一排，它就像第一排

4024
02:47:45,640 --> 02:47:49,840
在上面这里，而不是在下面第一排

4025
02:47:47,960 --> 02:47:51,800
然后第一列，列以及

4026
02:47:49,840 --> 02:47:55,359
他们聚在一起，然后你得到了这个顶级的（东西）

4027
02:47:51,800 --> 02:47:57,200
左上角的东西，嗯，然后就是……还有……

4028
02:47:55,359 --> 02:47:59,080
这就是我们最终得出这个29的原因。

4029
02:47:57,200 --> 02:48:01,720
值，然后本质上你只需做

4030
02:47:59,080 --> 02:48:04,439
这是给他们其他人的，所以你，呃，选 8

4031
02:48:01,720 --> 02:48:07,359
然后 还有12 接着你把它翻转过来

4032
02:48:04,439 --> 02:48:09,880
把它侧过来，它就会成倍增加。

4033
02:48:07,359 --> 02:48:12,359
伴随着一和二

4034
02:48:09,880 --> 02:48:15,359
嗯，然后你把那个放进去

4035
02:48:12,359 --> 02:48:17,960
这里你有第二列，并且

4036
02:48:15,359 --> 02:48:20,080
第一行，所以它会……它是

4037
02:48:17,960 --> 02:48:23,200
打算在第二列集合，并且

4038
02:48:20,080 --> 02:48:24,920
第一行，对，嗯，然后你就……

4039
02:48:23,200 --> 02:48:26,920
对其余的部分继续这样做。

4040
02:48:24,920 --> 02:48:29,600
直到你得出最终答案

4041
02:48:26,920 --> 02:48:33,200
所以本质上你就像在翻转

4042
02:48:29,600 --> 02:48:35,240
将矩阵 B 的列与矩阵 A 的行进行对应操作（注：这里原句表述不是完整句子，此为结合常见数学语境的理解性意译）

4043
02:48:33,200 --> 02:48:37,880
你正在进行点积运算

4044
02:48:35,240 --> 02:48:39,800
这里每个，呃，每个像……一样的（此处原文表述不太清晰完整）

4045
02:48:37,880 --> 02:48:41,640
逐元素地进行相乘操作

4046
02:48:39,800 --> 02:48:43,200
然后你把所有你减少的部分加起来，然后你

4047
02:48:41,640 --> 02:48:45,080
把它们全部加起来，然后你就搞砸了。（这里 “squash” 结合语境猜测是“搞砸、弄糟”之意，具体需结合更多背景信息确定更准确译法 ） 

4048
02:48:43,200 --> 02:48:49,080
然后你最终得到了这个最终的（成果/结果等，需结合语境确定更合适的表述） 

4049
02:48:45,080 --> 02:48:53,680
矩阵，呃，它的形状是，呃，3×4，所以

4050
02:48:49,080 --> 02:48:56,960
三，呃，三行，三行高，由……（此处“by”后面内容缺失，翻译不太完整） 

4051
02:48:53,680 --> 02:49:00,479
四列宽，然后，然后

4052
02:48:56,960 --> 02:49:02,120
那就是你做地鼠的方法，嗯，所以当……

4053
02:49:00,479 --> 02:49:04,319
我们进入……我的意思是，通常当……

4054
02:49:02,120 --> 02:49:05,439
你正在写，你知道很难去……（原句似乎表述不太完整和通顺） 

4055
02:49:04,319 --> 02:49:06,520
当……的时候理解像这样的算法

4056
02:49:05,439 --> 02:49:09,080
你正试图把这一切都塞进你的…… 

4057
02:49:06,520 --> 02:49:11,200
理想情况下，你想把它写在……（这里文本似乎不完整）

4058
02:49:09,080 --> 02:49:12,960
如果您直接切入的话，首先是中央处理器

4059
02:49:11,200 --> 02:49:13,960
GPU并尝试进行优化，你可能是…… 

4060
02:49:12,960 --> 02:49:15,319
搞砸了
你可能不会

4061
02:49:13,960 --> 02:49:17,479
去获取你正在寻找的答案

4062
02:49:15,319 --> 02:49:19,960
因为事情会变得很奇怪，所以

4063
02:49:17,479 --> 02:49:21,479
你把……写出来，甚至可能回到……

注：原文“you write out the maybe even go back to” 本身不是一个完整表意清晰的句子，“the” 后面缺少内容，此翻译是尽量按字面呈现。 

4064
02:49:19,960 --> 02:49:24,040
Python 并用 Python 把这个写出来

4065
02:49:21,479 --> 02:49:25,760
首先，这样你就能将它形象化，嗯，还有

4066
02:49:24,040 --> 02:49:28,880
确保你的（内容）和 P 一样匹配。

4067
02:49:25,760 --> 02:49:30,960
朝着麻木之类的状态，然后

4068
02:49:28,880 --> 02:49:33,800
然后你用 C 语言把这个写出来，接着你

4069
02:49:30,960 --> 02:49:36,760
说好吧，那么我们要怎么做一个……嗯……一个M莫恩呢？ 

4070
02:49:33,800 --> 02:49:40,040
这里是中央处理器，所以你有你的A和你的…… 

4071
02:49:36,760 --> 02:49:47,160
B 以及你的 C 矩阵，嗯，然后是你的

4072
02:49:40,040 --> 02:49:49,160
形状 m、k、n，所以 m 是，呃，这个，这个怎么样

4073
02:49:47,160 --> 02:49:53,560
在这种情况下，“a”是如此之高，“m”将会是……

注：原英文文本表述似乎不太符合正常语法逻辑，此翻译是尽量贴合原文的字面意思。 

4074
02:49:49,160 --> 02:49:56,880
三千（这里推测“k”代表“千”）会是两千，所以是两个两千以及…… 

4075
02:49:53,560 --> 02:50:00,439
那么n就会是4，对吧，所以你最后会

4076
02:49:56,880 --> 02:50:03,479
像这样做

4077
02:50:00,439 --> 02:50:06,560
嗯 呃 对，就像这样

4078
02:50:03,479 --> 02:50:08,760
自动补全 M * K，然后你进行乘法运算

4079
02:50:06,560 --> 02:50:12,000
用一个 K 乘 n 矩阵，然后你会得到一个

4080
02:50:08,760 --> 02:50:15,040
我的矩阵，只是把这个间隔开，这样它就是

4081
02:50:12,000 --> 02:50:15,040
更容易看到

4082
02:50:17,359 --> 02:50:23,160
呃，就是这样，所以当我们……

4083
02:50:20,160 --> 02:50:25,760
看看我们这里的嵌套 for 循环，我们

4084
02:50:23,160 --> 02:50:27,120
可以看到我们对 M 进行迭代，所以那是

4085
02:50:25,760 --> 02:50:31,640
这；那；这些；那些（根据语境，“the”是定冠词，通常无实际单独的中文词汇与之精准对应，在句子中体现其特指等作用） 

4086
02:50:27,120 --> 02:50:33,960
呃，那是一个直角的高度，那是……

4087
02:50:31,640 --> 02:50:35,399
我们拥有的行数，然后

4088
02:50:33,960 --> 02:50:37,120
我们要对每个（元素）进行自增操作（注：这里 “I plus plus” 推测是编程里的 “i++”，原句表述不太符合常见规范） 

4089
02:50:35,399 --> 02:50:38,880
时间，并记住当它被搁置的时候

4090
02:50:37,120 --> 02:50:40,960
在内存里，它实际上不会

4091
02:50:38,880 --> 02:50:44,560
是一个矩阵，它将是一个数组，所以

4092
02:50:40,960 --> 02:50:47,120
你会有像 1、2、3、4、5、6 这样的（情况）

4093
02:50:44,560 --> 02:50:48,399
而不是像数组那样的 1 或 2 ，并且

4094
02:50:47,120 --> 02:50:49,840
然后在它下面再放一个数组，接着

4095
02:50:48,399 --> 02:50:52,560
另外，事情不是那样的，是……

4096
02:50:49,840 --> 02:50:55,239
一下子全摆出来了，所以你得

4097
02:50:52,560 --> 02:50:56,840
实际上，手动考虑像……这样的情况

4098
02:50:55,239 --> 02:50:58,239
包裹起来，所以你实际上必须

4099
02:50:56,840 --> 02:51:01,560
你写作的时候要记住这一点。

4100
02:50:58,239 --> 02:51:04,120
这些，而那也是棘手的部分

4101
02:51:01,560 --> 02:51:11,800
嗯，那么你有 J，它将……

4102
02:51:04,120 --> 02:51:15,000
遍历嗯，n ，呃，n 是……

4103
02:51:11,800 --> 02:51:18,880
列的数量

4104
02:51:15,000 --> 02:51:21,560
在这里，然后我们对它进行自增操作。

4105
02:51:18,880 --> 02:51:23,600
就像我们进行的每一次迭代那样，我们做这个

4106
02:51:21,560 --> 02:51:25,720
累计总和，所以我们打算

4107
02:51:23,600 --> 02:51:29,720
累积成总数，没错，因为

4108
02:51:25,720 --> 02:51:31,720
你要走了 你实际上呃

4109
02:51:29,720 --> 02:51:33,399
当你处于……状态时就开始积累东西

注：原英文句子表述不太完整和规范，此翻译是基于现有内容尽量通顺表达。 

4110
02:51:31,720 --> 02:51:35,319
我们进行加法运算，然后我们就得到了所有结果。

4111
02:51:33,399 --> 02:51:36,720
这些进行相乘，然后我们进行融合并相加

4112
02:51:35,319 --> 02:51:39,880
把它们放在一起，这就是这个……（注：原英文表述不太完整） 

4113
02:51:36,720 --> 02:51:42,600
累计总和是用于，呃，所以当……的时候

4114
02:51:39,880 --> 02:51:50,200
当我们进行迭代时，我们会遍历嗯，当我们进行迭代时 

4115
02:51:42,600 --> 02:51:52,439
通过 k um，其中 K 呃 是那个

4116
02:51:50,200 --> 02:51:56,080
可以说，那个……X维度在一种（语境或情况，这里原文不完整表意不明）之中 

4117
02:51:52,439 --> 02:51:57,760
或者列的数量，然后是 B 中的 K

4118
02:51:56,080 --> 02:52:00,479
会是高度还是数字呢

4119
02:51:57,760 --> 02:52:03,239
向右的行数，然后你进行迭代

4120
02:52:00,479 --> 02:52:05,960
通过那个，当你进行计算的时候

4121
02:52:03,239 --> 02:52:07,840
你基本上是把它加上去，然后你做，嗯，你（这里原句不太完整和通顺，翻译可能有表意不清的情况）

4122
02:52:05,960 --> 02:52:10,680
实际上，这就是那个点所在的位置。（注：原英文表述不太符合常见语法，这里根据推测进行了连贯的翻译） 

4123
02:52:07,840 --> 02:52:13,560
产品正好进来了，你做一个这样的（这里“a so”表述不太准确，推测大概意思） 

4124
02:52:10,680 --> 02:52:17,000
这句话表述不太符合正常语法逻辑，勉强翻译为：
那就是我 我喜欢的地方 不管什么 我就是 咱们…… 

4125
02:52:13,560 --> 02:52:19,160
比如说我就像是，嗯，我是零，对吧，所以我是

4126
02:52:17,000 --> 02:52:21,399
打算去，嗯

4127
02:52:19,160 --> 02:52:23,479
我要成为不管这是什么的存在，对吧

4128
02:52:21,399 --> 02:52:28,840
这将是第一个，第一个

4129
02:52:23,479 --> 02:52:32,120
一乘以任意的K，并且K，呃，K在…… 

4130
02:52:28,840 --> 02:52:36,080
这个案子会很顺利，所以……

4131
02:52:32,120 --> 02:52:39,319
当你有零，第零个

4132
02:52:36,080 --> 02:52:40,479
嗯，当 I 为零，而 K 为任意值时

4133
02:52:39,319 --> 02:52:42,479
数字 它最终仍然会是…… 

4134
02:52:40,479 --> 02:52:44,040
等于零，这样你就得到了 L

4135
02:52:42,479 --> 02:52:47,439
之后，而且那将会是

4136
02:52:44,040 --> 02:52:50,239
无论哪个地点、在什么时候、无论是什么东西、无论它是什么

4137
02:52:47,439 --> 02:52:51,359
无论它是通过……通过 K 那就是

4138
02:52:50,239 --> 02:52:55,200
它最终会到哪里，所以就像

4139
02:52:51,359 --> 02:52:56,680
整行的偏移量，嗯，而且它是

4140
02:52:55,200 --> 02:53:00,960
要去乘同样的东西，它是

4141
02:52:56,680 --> 02:53:04,680
打算做嗯 所以L才是关键所在

4142
02:53:00,960 --> 02:53:06,359
经过 K，它将会是，嗯，那个……

4143
02:53:04,680 --> 02:53:07,800
上下移动而非左右移动

4144
02:53:06,359 --> 02:53:11,560
它将会上升并且

4145
02:53:07,800 --> 02:53:15,960
向下，然后你会得到这个 n 项，它

4146
02:53:11,560 --> 02:53:17,439
我们可以说，呃，也许也是呃零，如果

4147
02:53:15,960 --> 02:53:19,840
你在这里只做第一个。

4148
02:53:17,439 --> 02:53:22,200
就像左上角的最顶端，然后

4149
02:53:19,840 --> 02:53:24,040
假设在这种情况下 j 为零，所以它就只是

4150
02:53:22,200 --> 02:53:26,319
最终会撞到 它要…… 

4151
02:53:24,040 --> 02:53:28,239
最终会达到相同的值，所以

4152
02:53:26,319 --> 02:53:30,720
最后你只会得到第一个…… （这里文本似乎不完整） 

4153
02:53:28,239 --> 02:53:32,760
首先是要点，呃，然后你……你

4154
02:53:30,720 --> 02:53:36,399
将它们相乘，然后再相加。

4155
02:53:32,760 --> 02:53:38,720
那个，嗯，你把它们相乘，你

4156
02:53:36,399 --> 02:53:41,080
将第一个……那个和……那个相乘

注：原文表述存在重复和不完整情况，译文尽量贴合原文。 

4157
02:53:38,720 --> 02:53:42,520
七个一起在第一个里面，然后

4158
02:53:41,080 --> 02:53:45,479
你最终会撞到第二个，而这个（第二个）…… 

4159
02:53:42,520 --> 02:53:48,840
是2和11，嗯，然后得到……

4160
02:53:45,479 --> 02:53:52,600
总结起来，而你正在做 

4161
02:53:48,840 --> 02:53:55,239
每次都是这样 呃 这个 for 循环

4162
02:53:52,600 --> 02:53:56,760
这第二个，呃，for 循环触发了，对吧

4163
02:53:55,239 --> 02:54:01,640
所以每次这个经过一个……

4164
02:53:56,760 --> 02:54:06,160
每一次迭代你都在触及 n，而 n 呢，呃

4165
02:54:01,640 --> 02:54:07,960
仅仅 n 就是随便哪个值，呃

4166
02:54:06,160 --> 02:54:09,399
无论哪个值本质上即将到来

4167
02:54:07,960 --> 02:54:10,800
下一个右转，所以你刚刚在获取 

4168
02:54:09,399 --> 02:54:12,760
这个，还有这个，然后是这个

4169
02:54:10,800 --> 02:54:14,920
然后是这个，以此类推

4170
02:54:12,760 --> 02:54:17,880
直到最后，然后你最终只是

4171
02:54:14,920 --> 02:54:20,000
把这个写下来，这样你基本上……

4172
02:54:17,880 --> 02:54:21,760
将值 C 赋给那个总和（无论它是多少）

4173
02:54:20,000 --> 02:54:25,720
这样你就可以计算出下一个点了

4174
02:54:21,760 --> 02:54:27,880
产品 所以 呃 这个 这个挺……呃……

4175
02:54:25,720 --> 02:54:29,760
直观地说，我鼓励你……我的意思是，如果是这种情况

4176
02:54:27,880 --> 02:54:32,439
如果你……的话，这并不完全说得通

4177
02:54:29,760 --> 02:54:34,720
还没学过线性入门课程呢 

4178
02:54:32,439 --> 02:54:36,239
代数课程 我完全懂了 嗯

4179
02:54:34,720 --> 02:54:38,399
你可能只想让我们通过

4180
02:54:36,239 --> 02:54:40,200
你知道语言模型，或者了解过一些（语言模型）

4181
02:54:38,399 --> 02:54:41,600
互联网上一些直观易懂的视频

4182
02:54:40,200 --> 02:54:45,399
然后多少了解一下正在发生什么

4183
02:54:41,600 --> 02:54:47,439
在这儿试着理解一下，呃，比如……是什么样的

4184
02:54:45,399 --> 02:54:49,960
当它们……的时候，事情是如何发展的呢 

4185
02:54:47,439 --> 02:54:51,680
当他们真的喜欢干的东西之类的时候

4186
02:54:49,960 --> 02:54:53,640
嗯，支付这件事非常重要。

4187
02:54:51,680 --> 02:54:57,880
注意像这样的，比如那个 K 当……

4188
02:54:53,640 --> 02:55:01,080
这个“K”正在收尾，例如“K”就是，呃，“K”

4189
02:54:57,880 --> 02:55:02,880
在这里，并且 K 本质上就是这个这个

4190
02:55:01,080 --> 02:55:05,439
长度，所以它会像这样

4191
02:55:02,880 --> 02:55:08,080
无论哪一行，无论哪一行，无论哪一行，呃，你选的这一行

4192
02:55:05,439 --> 02:55:09,479
想要你把那整个都包裹起来

4193
02:55:08,080 --> 02:55:11,800
划呀，所以你想一直划到……

4194
02:55:09,479 --> 02:55:14,239
它，然后包裹起来，接着你的偏移量是

4195
02:55:11,800 --> 02:55:16,000
将会是那样，然后这里也是同样的想法

4196
02:55:14,239 --> 02:55:19,160
只不过这里不是行，而是会是……

4197
02:55:16,000 --> 02:55:21,399
像列一样 列向右偏移

4198
02:55:19,160 --> 02:55:25,920
嗯，那就是，那就是整个想法。

4199
02:55:21,399 --> 02:55:27,680
嗯，然后我们来看看显卡。

4200
02:55:25,920 --> 02:55:30,040
实现方式，这有点……

4201
02:55:27,680 --> 02:55:32,640
不同，但我们本质上是在使用

4202
02:55:30,040 --> 02:55:36,239
而不只是一个“i”或者一个单一的身份标识 

4203
02:55:32,640 --> 02:55:39,840
索引项 我们使用行和列，所以在

4204
02:55:36,239 --> 02:55:42,560
在这个网格中，我们有方块 ID x.y *

4205
02:55:39,840 --> 02:55:46,080
块维度 日序 块索引 你知道的

4206
02:55:42,560 --> 02:55:48,479
呃，那个街区在哪里呢

4207
02:55:46,080 --> 02:55:51,439
本质上，问题的阻碍就在这里。

4208
02:55:48,479 --> 02:55:53,640
垂直方向，嗯，而且我们刚刚得到

4209
02:55:51,439 --> 02:55:56,200
本质上，那些垂直的、像线一样的……

4210
02:55:53,640 --> 02:55:58,200
我们想要哪条线程呢，呃……

4211
02:55:56,200 --> 02:56:00,200
考虑像这样的垂直网格以及

4212
02:55:58,200 --> 02:56:02,760
我们现在有的所有街区，呃

4213
02:56:00,200 --> 02:56:04,880
回到我之前所说的，而且我们

4214
02:56:02,760 --> 02:56:07,960
对X做同样的事情，这样我们就得到了这个

4215
02:56:04,880 --> 02:56:10,359
我们在垂直方向上有螺纹。

4216
02:56:07,960 --> 02:56:13,080
以及水平方向的

4217
02:56:10,359 --> 02:56:14,640
方向 呃 然后我们 正如我们所希望的那样去做（这里原句不太完整和表意明确，根据已有内容大致翻译）

4218
02:56:13,080 --> 02:56:17,920
这实际上非常 这实际上

4219
02:56:14,640 --> 02:56:19,399
呃，实际上这是必需的。

4220
02:56:17,920 --> 02:56:21,399
有这个，你需要这个条件语句

4221
02:56:19,399 --> 02:56:23,760
在这儿是因为如果事情偏离了轨道或者

4222
02:56:21,399 --> 02:56:25,600
如果你有太多线程，那么

4223
02:56:23,760 --> 02:56:27,479
他们可能会去计算那些值，这些值 

4224
02:56:25,600 --> 02:56:29,040
你不会希望它可能会被访问

注：原英文句子表述不太符合常规语法，以上是尽力按照语义翻译。 

4225
02:56:27,479 --> 02:56:30,520
内存中的其他部分，它不是

4226
02:56:29,040 --> 02:56:32,319
有所克制，对吧，所以它不会……

4227
02:56:30,520 --> 02:56:33,720
当你认为应该停下来的时候就停下来吧，你

4228
02:56:32,319 --> 02:56:37,479
实际上需要进行谨慎的限制

4229
02:56:33,720 --> 02:56:41,560
在这件事上然后说好吧，我们……我们想

4230
02:56:37,479 --> 02:56:43,359
一旦行到了M就停止，因为

4231
02:56:41,560 --> 02:56:45,840
除此之外，没有其他的价值了。

4232
02:56:43,359 --> 02:56:49,560
然后列也是一样的，对吧

4233
02:56:45,840 --> 02:56:55,479
所以，嗯，就像我们到这儿上面的时候，我们

4234
02:56:49,560 --> 02:56:57,800
我们有一个 m 行 n 列的矩阵，对吧，所以 m 是…… 

4235
02:56:55,479 --> 02:57:05,040
嗯，这是……

4236
02:56:57,800 --> 02:57:09,600
那部分，呃，它去哪儿了？

4237
02:57:05,040 --> 02:57:13,439
是的，m 代表行，所以行就是 y，对吧，这个，这个

4238
02:57:09,600 --> 02:57:16,680
为什么是这个高度部分，然后 n 是……就是那个

4239
02:57:13,439 --> 02:57:18,720
呃，那个宽度，水平部分 X

4240
02:57:16,680 --> 02:57:20,239
所以，那就是要关联到 X 的那些列

4241
02:57:18,720 --> 02:57:21,359
对，所以你得……这只是

4242
02:57:20,239 --> 02:57:24,520
那种你必须成为的人（或事物，需结合上下文理解“thing”所指） 

4243
02:57:21,359 --> 02:57:26,200
小心点，嗯，CUDA处理这个非常…… 

4244
02:57:24,520 --> 02:57:29,239
嗯，但你只需要把这个包含进去。

4245
02:57:26,200 --> 02:57:31,520
if语句，然后本质上你会

4246
02:57:29,239 --> 02:57:34,840
对于每个线程，嗯，因为这是

4247
02:57:31,520 --> 02:57:38,399
它自身在一个线程里，你打算呃

4248
02:57:34,840 --> 02:57:39,880
本质上就是做一个点积运算

4249
02:57:38,399 --> 02:57:44,399
元素之间，而你，你正要…… 

4250
02:57:39,880 --> 02:57:47,080
基本上要做一排，一排的（事情） 

4251
02:57:44,399 --> 02:57:48,760
一个A的……以及一列B的……而这是

4252
02:57:47,080 --> 02:57:50,319
每个线程要完成的操作

4253
02:57:48,760 --> 02:57:52,479
所以每一个不同的线程都将

4254
02:57:50,319 --> 02:57:55,279
有一个不同的，也许是另一种，呃

4255
02:57:52,479 --> 02:57:59,279
A的每一行与B的不同列……（原文“to to to”表述有误，这里按原文格式翻译）

4256
02:57:55,279 --> 02:58:02,080
计算 所以你有这个 嗯 你有

4257
02:57:59,279 --> 02:58:03,600
这个 K 项，它来自这里，嗯，并且

4258
02:58:02,080 --> 02:58:05,600
你 你正在逐一尝试那个，并且

4259
02:58:03,600 --> 02:58:08,319
你 你实际上只是应用同样的（方法/事物等，需结合语境确定）

4260
02:58:05,600 --> 02:58:10,960
包装，但不必担心

4261
02:58:08,319 --> 02:58:14,040
你担心所有这些嵌套的 for 循环

4262
02:58:10,960 --> 02:58:16,720
相反，是关于呃……行和列，所以

4263
02:58:14,040 --> 02:58:18,960
这些实际上是……呃，这些是

4264
02:58:16,720 --> 02:58:21,560
你知道我们用线程进行索引的方式

4265
02:58:18,960 --> 02:58:24,399
就像我之前说的那样

4266
02:58:21,560 --> 02:58:26,960
嗯，不过没错，呃，我打算挖掘一下。 

4267
02:58:24,399 --> 02:58:28,439
更倾向于直觉方面

4268
02:58:26,960 --> 02:58:30,880
在课程的后面部分，当我们……的时候，这背后（的原因等）

（注：原句不完整，这里只能进行这样不完整的翻译，你可以补充完整句子以便得到更准确的结果。） 

4269
02:58:28,439 --> 02:58:33,279
最终优化矩阵乘法

4270
02:58:30,880 --> 02:58:36,479
这个，呃，这个被称作天真的（东西） 

4271
02:58:33,279 --> 02:58:38,279
内核，它，它非常，它非常受限

4272
02:58:36,479 --> 02:58:42,359
它没有大量的优化。

4273
02:58:38,279 --> 02:58:44,560
这又不是不快，它是挺快的

4274
02:58:42,359 --> 02:58:46,279
这听起来像是……什么的速度？

注：原英文 “aunds” 可能是 “sounds” 的拼写错误。 

4275
02:58:44,560 --> 02:58:48,359
最先进的 实际上它相当……

4276
02:58:46,279 --> 02:58:50,040
比较慢 嗯 
而且我们打算

4277
02:58:48,359 --> 02:58:52,319
稍后对这个进行优化，而且这就要

注：原英文句子似乎未完整表述意思。 

4278
02:58:50,040 --> 02:58:53,800
成为你将会遇到的最直观的事情

4279
02:58:52,319 --> 02:58:56,520
可能在整个这门课程中学到的是

4280
02:58:53,800 --> 02:58:58,279
在CUDA中进行矩阵乘法，所以不要

4281
02:58:56,520 --> 02:59:01,399
如果这并没有完全理解，别担心 

4282
02:58:58,279 --> 02:59:03,920
现在呢，嗯，只是有点担心…… 

4283
02:59:01,399 --> 02:59:05,479
这些线索在哪里，我们现在处于怎样的情况

4284
02:59:03,920 --> 02:59:07,439
弄清楚我们是如何得到这一行以及

4285
02:59:05,479 --> 02:59:09,319
列值，然后是这个包装

4286
02:59:07,439 --> 02:59:13,279
我们这里所拥有的，然后那个那个

4287
02:59:09,319 --> 02:59:18,120
偏移部分右侧包裹以及

4288
02:59:13,279 --> 02:59:19,319
偏移 偏移 嗯，没错，就是这样

4289
02:59:18,120 --> 02:59:23,200
这几乎就是你所有需要担心的事情了。

4290
02:59:19,319 --> 02:59:25,640
目前来说呢，嗯，然后我们就来处理你这边的情况。（注：原文表述不太符合常规语法逻辑，此为结合语境尽量合理的翻译） 

4291
02:59:23,200 --> 02:59:28,279
熟悉相同的路线
进行热身跑

4292
02:59:25,640 --> 02:59:31,960
在20个基准测试中对其进行基准测试，或者

4293
02:59:28,279 --> 02:59:34,520
在20次运行中，嗯，基准测试CPU与…… 

4294
02:59:31,960 --> 02:59:37,560
GPU，然后返回平均时间于……（原句似乎不完整）

4295
02:59:34,520 --> 02:59:40,960
微秒，所以如果我只是，呃，打开一个

4296
02:59:37,560 --> 02:59:48,479
在这里终止，然后出发

4297
02:59:40,960 --> 02:59:51,640
全国广播公司新闻频道（NBCC）领先两分，我们继续推进。 

4298
02:59:48,479 --> 02:59:54,160
将R组建起来

4299
02:59:51,640 --> 02:59:55,640
运行正常，这真的是我亲手做的

4300
02:59:54,160 --> 02:59:59,000
非常大的矩阵，也许我们应该

4301
02:59:55,640 --> 03:00:01,279
把这些缩小一点

4302
02:59:59,000 --> 03:00:05,840
嗯，我们可以

4303
03:00:01,279 --> 03:00:08,840
走吧，咱们去看看，也许……

4304
03:00:05,840 --> 03:00:08,840
256

4305
03:00:10,359 --> 03:00:15,279
512

4306
03:00:13,080 --> 03:00:16,279
256 是啊，CPU 可不会乐意的

4307
03:00:15,279 --> 03:00:19,680
那个；那

4308
03:00:16,279 --> 03:00:22,920
一个，呃，所以它正在对 CPU 进行基准测试，并且

4309
03:00:19,680 --> 03:00:25,680
所以这需要89000微秒，并且这个

4310
03:00:22,920 --> 03:00:28,359
花费了88微秒，所以我们就像出来了一样

4311
03:00:25,680 --> 03:00:34,200
用这些小矩阵组成的盒子，我们

4312
03:00:28,359 --> 03:00:38,840
使用 CUDA 可实现 1000 倍的速度提升

4313
03:00:34,200 --> 03:00:40,239
嗯，就是这样，所以这，呃，这就是…… 

4314
03:00:38,840 --> 03:00:42,399
这是，呃，这差不多就是我们测试的方式

4315
03:00:40,239 --> 03:00:44,120
诸如此类的事情，不过现在我们要走了。

4316
03:00:42,399 --> 03:00:46,439
勇往直前，直接投身进去，就像你会怎么做那样

4317
03:00:44,120 --> 03:00:49,200
描述这些嗯 我知道我们还没去

4318
03:00:46,439 --> 03:00:51,680
深入探究了，嗯，比如 CUDA 是如何……（此处原文未完整，翻译为便于理解做了适当补充） 

4319
03:00:49,200 --> 03:00:56,000
实际上，它在底层完全能正常运行。 

4320
03:00:51,680 --> 03:00:57,000
还有更多事情要做，但嗯，在一个……

4321
03:00:56,000 --> 03:01:00,000
稍微一会儿我们要去逛逛

4322
03:00:57,000 --> 03:01:01,560
画像分析，我想讲一下，呃

4323
03:01:00,000 --> 03:01:03,399
实际上，在我们做之前还有一些其他的事情

4324
03:01:01,560 --> 03:01:06,840
那让我把这个结束吧

4325
03:01:03,399 --> 03:01:12,319
我们突然来到了这里的说明文档中 仅仅是这样

4326
03:01:06,840 --> 03:01:17,399
关闭这个 关闭这个 嗯 继续

4327
03:01:12,319 --> 03:01:17,399
稍微缩小一点视角

（注：“zoom out”常见意为“缩小画面、拉远视角” ，具体含义需结合语境确定，这里给出一种较常见的表达） 

4328
03:01:18,520 --> 03:01:24,479
当然，所以再强调一下，我们有这些……这些暗淡的（东西） 

4329
03:01:22,000 --> 03:01:26,040
这三种模糊的类型，嗯，我当时…… 

4330
03:01:24,479 --> 03:01:27,399
谈论之前这些应该会让

4331
03:01:26,040 --> 03:01:30,439
已经感觉到了，这些……这些不应该存在

4332
03:01:27,399 --> 03:01:33,439
就好像太难把握了

4333
03:01:30,439 --> 03:01:36,560
嗯，这就是它通常的样子。

4334
03:01:33,439 --> 03:01:39,200
对，你把这个放进去

4335
03:01:36,560 --> 03:01:42,160
就像我之前说的，你把这个放进去

4336
03:01:39,200 --> 03:01:44,040
它将简化为三维，所以

4337
03:01:42,160 --> 03:01:47,239
这看起来会是一个 16 乘 1 的（东西）

4338
03:01:44,040 --> 03:01:49,200
可以说通过一个呃张量，而且它是

4339
03:01:47,239 --> 03:01:50,760
打算把那个添加到内核启动中

4340
03:01:49,200 --> 03:01:52,359
配置
这是内核启动

4341
03:01:50,760 --> 03:01:55,760
配置方面，我们还能做更多的事

4342
03:01:52,359 --> 03:01:59,880
把它加上，嗯，已经讲过这些内容了。

4343
03:01:55,760 --> 03:02:02,200
已经，呃，然后你还有更多的东西

4344
03:01:59,880 --> 03:02:06,399
你可以往里面添加东西，嗯，所以我们有了网格。

4345
03:02:02,200 --> 03:02:10,920
将网格维度，呃，从 1 维调整到 3 维

4346
03:02:06,399 --> 03:02:13,239
在 1 到 3D 中对块进行处理，然后是这个，呃，NS

4347
03:02:10,920 --> 03:02:16,319
所以这是共享部分的字节数

4348
03:02:13,239 --> 03:02:18,479
为……按块分配的内存

4349
03:02:16,319 --> 03:02:22,160
这个电话，嗯，所以你打算……

4350
03:02:18,479 --> 03:02:24,760
为一个块显式地分配内存

4351
03:02:22,160 --> 03:02:27,920
嗯，在共享内存里，共享内存的速度非常快

4352
03:02:24,760 --> 03:02:31,120
所以通常你会省略这个，呃

4353
03:02:27,920 --> 03:02:32,760
然而，如果你有一个具体的，呃

4354
03:02:31,120 --> 03:02:34,279
像你试图部署的那种生产环境

4355
03:02:32,760 --> 03:02:36,239
一个投入生产运行的CTIC内核

4356
03:02:34,279 --> 03:02:38,720
你可能会以非常非常快的速度做某事（注：原英文表述不太完整和规范，这里根据字面大致翻译）

4357
03:02:36,239 --> 03:02:40,080
实际上想利用这个来获利

4358
03:02:38,720 --> 03:02:41,560
因为这会让你更明确

4359
03:02:40,080 --> 03:02:43,319
对所发生的事情有掌控权，而且你可以

4360
03:02:41,560 --> 03:02:45,319
更好地衡量绩效，并且

4361
03:02:43,319 --> 03:02:46,640
你可能会得到一些小的……

4362
03:02:45,319 --> 03:02:49,479
从中获得一些微小的性能提升

4363
03:02:46,640 --> 03:02:52,560
还有这个“s”项，它……（这里“s term”不太明确具体含义，可能需要结合上下文进一步理解，暂按字面翻译） 

4364
03:02:49,479 --> 03:02:54,520
呃，直播开始了，我要开始啦。 

4365
03:02:52,560 --> 03:02:55,920
实际上涵盖了第五条溪流，所以

4366
03:02:54,520 --> 03:02:57,319
别太担心这个，但是……但是

4367
03:02:55,920 --> 03:03:00,120
流相当酷，它们能让你做

4368
03:02:57,319 --> 03:03:02,800
一些 一些有趣的东西

4369
03:03:00,120 --> 03:03:05,840
嗯，然后这个我没说过。

4370
03:03:02,800 --> 03:03:08,359
这完全是太多的CUDA设备了

4371
03:03:05,840 --> 03:03:10,880
同步并使线程同步，以便用于CUDA

4372
03:03:08,359 --> 03:03:13,960
设备同步可确保所有的

4373
03:03:10,880 --> 03:03:17,439
内核，或者针对一个的所有呃线程

4374
03:03:13,960 --> 03:03:19,200
问题是所有的，就像所有的…… 

4375
03:03:17,439 --> 03:03:21,120
所有不同的并行计算

4376
03:03:19,200 --> 03:03:23,160
在你开始之前，针对一个问题的准备工作就已完成

4377
03:03:21,120 --> 03:03:25,040
接下来，所以当你……当你启动一个…… 

4378
03:03:23,160 --> 03:03:26,640
内核它将会有一堆的

4379
03:03:25,040 --> 03:03:30,239
平行的块和一堆线程

4380
03:03:26,640 --> 03:03:31,840
并行处理这个巨大的问题 嗯

4381
03:03:30,239 --> 03:03:33,800
而且他们可能不会都在……结束

4382
03:03:31,840 --> 03:03:36,120
与此同时，就像他们中的一些人就只是喜欢做（某件事） 

4383
03:03:33,800 --> 03:03:38,880
对于物理学而言，他们……他们可能不太……

4384
03:03:36,120 --> 03:03:41,399
同时精确地完成，所以你

4385
03:03:38,880 --> 03:03:43,640
你必须明确地对它们进行同步

4386
03:03:41,399 --> 03:03:47,399
得加上这个小屏障，这个

4387
03:03:43,640 --> 03:03:48,960
这（这个）乌梅（宇美、梅之类，具体看上下文）本质上阻止了一场竞赛 

4388
03:03:47,399 --> 03:03:52,920
条件；状况；状态；病情；疾病；环境；处境；条件规定；条款；先决条件；前提；（健康或体力的）状况，状态；（事物的）状态，状况；给……加条件；使适应；使习惯于；对……有重要影响；决定；支配；使取决于；使健康；使处于良好状态；对（胚胎、细胞）做条件培养；处理（头发等）以改善外观和质地；（通过训练或经历）使形成条件反射；（使）适应；调节（空气）；给（水泥、玻璃）做防护处理

4389
03:03:48,960 --> 03:03:54,520
所以，如果你有一堆线程，嗯

4390
03:03:52,920 --> 03:03:56,640
比如在这一个里面，当你……

4391
03:03:54,520 --> 03:03:57,840
当你处于移动状态时进行位运算移位

4392
03:03:56,640 --> 03:03:59,239
这边这个，然后是这个

4393
03:03:57,840 --> 03:04:01,720
这边这个，然后那边那个

4394
03:03:59,239 --> 03:04:03,399
理想情况下，你会希望去做……

4395
03:04:01,720 --> 03:04:05,200
这是按一定顺序排列的，而不是像

4396
03:04:03,399 --> 03:04:08,399
在不该发生的时候到来之前存储些东西

4397
03:04:05,200 --> 03:04:11,239
要像……比如说，如果我那样被存放起来

4398
03:04:08,399 --> 03:04:13,640
做这一个，嗯，然后这个是

4399
03:04:11,239 --> 03:04:15,279
本应在之后发生，但结果却是

4400
03:04:13,640 --> 03:04:18,840
先做这个，因为我们之前没做过

4401
03:04:15,279 --> 03:04:20,640
正确同步 嗯 你可以 你会

4402
03:04:18,840 --> 03:04:22,279
最后得到错误的答案，对吧，所以

4403
03:04:20,640 --> 03:04:24,680
你必须有意地同步这个

4404
03:04:22,279 --> 03:04:26,279
线程，这样所有的（事物）无论……

4405
03:04:24,680 --> 03:04:27,760
像这一个可能要领先很多了

4406
03:04:26,279 --> 03:04:29,800
你得等所有其他的（人/物）。

4407
03:04:27,760 --> 03:04:31,840
为了让他们赶上并达到……

（这里原文不完整，“hit the”后面似乎缺了内容） 

4408
03:04:29,800 --> 03:04:33,319
同样的位置，所以你说“好的，这个是……”

4409
03:04:31,840 --> 03:04:35,239
完成了，但这些不是，我们要走了

4410
03:04:33,319 --> 03:04:36,720
等待所有这些同步完成

4411
03:04:35,239 --> 03:04:39,319
在一起，然后我们就可以继续这个

4412
03:04:36,720 --> 03:04:41,960
下一步，没错，那就是呃……CUDA

4413
03:04:39,319 --> 03:04:44,279
设备同步
同步即可

4414
03:04:41,960 --> 03:04:47,040
呃，你通常把这个放在……之后

注：原文 “uh after you typically put this after” 表述不太完整和通顺，可能在 “after” 后还有内容未给出。此翻译根据现有内容进行。 

4415
03:04:44,279 --> 03:04:50,040
启动一个内核，然后同步线程

4416
03:04:47,040 --> 03:04:52,880
被置于一个内核单元中以应对威胁 

4417
03:04:50,040 --> 03:04:54,319
在它内部执行，所以有一种情况就像是

4418
03:04:52,880 --> 03:04:56,040
就像当你试图……的时候那样

4419
03:04:54,319 --> 03:04:57,680
同步整个电网，然后再同步一个

4420
03:04:56,040 --> 03:05:00,720
就像同步所有线程一样

4421
03:04:57,680 --> 03:05:04,720
在一个类似的……之内

注：你提供的“within a within like”并不是一个完整、表意明确的英文表达，这样的翻译只是基于字面尽量呈现，可能与确切含义有偏差。你可以检查并补充更完整准确的内容。 

4422
03:05:00,720 --> 03:05:06,040
在一个曲速场内部，就像你可能已经…… 

4423
03:05:04,720 --> 03:05:07,600
能看出我有那么一点儿

4424
03:05:06,040 --> 03:05:09,399
对最后那个答案不太确定，所以我

4425
03:05:07,600 --> 03:05:12,279
决定查一下并同步线程

4426
03:05:09,399 --> 03:05:14,640
实际上是在呃线的层面上

4427
03:05:12,279 --> 03:05:18,160
用方块而不是翘曲，这样你就可以做

4428
03:05:14,640 --> 03:05:21,600
同步扭曲而不是同步线程

4429
03:05:18,160 --> 03:05:24,479
实际上回到这里，然后我们在……继续

4430
03:05:21,600 --> 03:05:30,239
同步同步线程，实际上你可以

4431
03:05:24,479 --> 03:05:30,239
嗯，如果你想进行时空扭曲操作，你可以（这么做）。 

注：原文 “do um” 可能表述有误，推测这里 “um” 是语气词“嗯”，按合理语义逻辑进行了整体翻译。 

4432
03:05:30,840 --> 03:05:36,840
多斯汀（注：若“do stin”不是人名等特定词汇，由于它不是常见英文表达，结合具体语境可能有不同理解，仅从字面较难准确翻译，这里暂音译） 

4433
03:05:34,600 --> 03:05:39,359
扭曲；弯曲；变形；翘曲；（空间或时间的）弯曲；（使）快速移动；（使）快速前往；经线；经纱

4434
03:05:36,840 --> 03:05:41,560
嗯，要同步……内的所有线程

4435
03:05:39,359 --> 03:05:43,920
扭曲，然后这个会那样做它

4436
03:05:41,560 --> 03:05:46,920
同样的事情，但换成了一个线程块

4437
03:05:43,920 --> 03:05:46,920
相反；取而代之；而是

4438
03:05:51,720 --> 03:05:58,600
一个范围内的所有红色物体

注：由于原英文表述不太完整清晰，此翻译是根据字面做出的大致处理。 

4439
03:05:56,120 --> 03:06:01,080
战争

4440
03:05:58,600 --> 03:06:02,279
嗯，然后这是针对一整根线的。

4441
03:06:01,080 --> 03:06:04,319
块，所以仅仅只是一块

4442
03:06:02,279 --> 03:06:08,239
说明一下，还有另外一件很酷的事

4443
03:06:04,319 --> 03:06:11,040
我在学习CUDA时偶然发现的是

4444
03:06:08,239 --> 03:06:12,880
你实际上要如何添加呃明确的（内容）

4445
03:06:11,040 --> 03:06:16,160
旗帜，而且实际上你可以

4446
03:06:12,880 --> 03:06:18,200
将类似对数的东西转换为以 f 为底的对数

4447
03:06:16,160 --> 03:06:19,800
使用编译器标志

4448
03:06:18,200 --> 03:06:23,399
嗯，我知道有那么一点点

4449
03:06:19,800 --> 03:06:26,520
在那里打开行李，但如果我只是回到

4450
03:06:23,399 --> 03:06:28,000
呃，这里的这个合集，实际上，不，我们

4451
03:06:26,520 --> 03:06:30,279
甚至都不用 我们甚至都不用任何……（注：原文表意不太完整）

4452
03:06:28,000 --> 03:06:32,920
那些 M 函数，但如果我要说

4453
03:06:30,279 --> 03:06:34,680
在一个内核里面做日志记录之类的，嗯，那个

4454
03:06:32,920 --> 03:06:36,920
会比我使用……时的速度更慢

4455
03:06:34,680 --> 03:06:39,439
对数 F 所以对数 f 就像一个工具

4456
03:06:36,920 --> 03:06:42,000
操作和日志是主机操作，所以

4457
03:06:39,439 --> 03:06:45,479
专为在 CPU 上运行而设计，当然是在 CPU 上运行

4458
03:06:42,000 --> 03:06:48,279
对，嗯，所以实际上我们可以去使用

4459
03:06:45,479 --> 03:06:51,640
快速数学作为编译器的一部分

4460
03:06:48,279 --> 03:06:56,160
旗帜，我可以……呃

4461
03:06:51,640 --> 03:06:56,160
使用 使用快速数学运算 比如

4462
03:06:57,720 --> 03:07:01,600
这，当然了，我们实际上不会看到

4463
03:06:59,920 --> 03:07:06,680
有什么不同
任何差异

4464
03:07:01,600 --> 03:07:08,800
但是，嗯，是的，就像1006 X一样，还是那回事

4465
03:07:06,680 --> 03:07:10,640
嗯，但这实际上会转换这个

4466
03:07:08,800 --> 03:07:13,840
针对这个情况，万一你……万一你……

4467
03:07:10,640 --> 03:07:15,520
你自己还没做过那个呢，所以

4468
03:07:13,840 --> 03:07:20,720
这实际上来自于CUDA数学。

4469
03:07:15,520 --> 03:07:28,359
API参考手册，那么，如果我们来看一下

4470
03:07:20,720 --> 03:07:32,560
比如说一些单精度的，呃

4471
03:07:28,359 --> 03:07:34,080
内在特性 是的 那么 呃 单精度

4472
03:07:32,560 --> 03:07:36,040
所支持的内置函数

4473
03:07:34,080 --> 03:07:39,279
仅在设备中

4474
03:07:36,040 --> 03:07:44,160
马上编写代码，注意看它有点像 Co F 

4475
03:07:39,279 --> 03:07:50,000
呃，x，呃，以 10 为底取幂，f

4476
03:07:44,160 --> 03:07:52,399
指数函数 嗯，然后就像你知道的，F加上 嗯

4477
03:07:50,000 --> 03:07:53,840
向零取整
没错，所有这些

4478
03:07:52,399 --> 03:07:57,080
这些 这些是为执行而设计的

4479
03:07:53,840 --> 03:08:00,560
在设备上，嗯，而且它们末尾有 F

4480
03:07:57,080 --> 03:08:03,200
但如果你只是想做类似……只是……

4481
03:08:00,560 --> 03:08:06,279
例如，来自 math.h 库的 Coast （此处“Coast”可能有误，推测可能是“cos” ）

4482
03:08:03,200 --> 03:08:08,080
还有 C，那不会……那不会像……那样运行

4483
03:08:06,279 --> 03:08:09,279
很快，所以这是你要做的另一件小事

4484
03:08:08,080 --> 03:08:12,520
如果你是……的话，可以添加到你的内核中

4485
03:08:09,279 --> 03:08:14,120
试着说，就像，嗯，如果你是……

4486
03:08:12,520 --> 03:08:16,920
试着做类似软最大值之类的事情

4487
03:08:14,120 --> 03:08:18,880
在一个内核中，或者如果你试图，呃

4488
03:08:16,920 --> 03:08:20,760
也许做一些类似……类似数字方面的（事情）

4489
03:08:18,880 --> 03:08:24,640
信号处理，没错，你可以添加

4490
03:08:20,760 --> 03:08:28,359
这些以及……然后获得呃一些好处以及…… 

4491
03:08:24,640 --> 03:08:30,000
从性能方面来看，在那些当中，嗯，还有

4492
03:08:28,359 --> 03:08:32,840
我这儿也是一样，就好像如果你想做……

4493
03:08:30,000 --> 03:08:35,840
一个融合乘法累加，嗯，这会像

4494
03:08:32,840 --> 03:08:38,040
说出实际的，呃，这会…… 

4495
03:08:35,840 --> 03:08:40,840
实际上，就把这个倒进……

4496
03:08:38,040 --> 03:08:43,800
说明，而不是像……那样做

4497
03:08:40,840 --> 03:08:46,000
分开，呃，乘法和加法运算

4498
03:08:43,800 --> 03:08:47,560
你正在把它们融合在一起，这样你就可以

4499
03:08:46,000 --> 03:08:51,840
像这样耍些小把戏，只是为了

4500
03:08:47,560 --> 03:08:54,560
但从性能方面加快事情的进展

4501
03:08:51,840 --> 03:08:57,279
呃，对，现在我们可以……呃，现在我们可以

4502
03:08:54,560 --> 03:08:59,600
实际上深入探究呃

4503
03:08:57,279 --> 03:09:01,520
侧写 我实际上忘记去做了

4504
03:08:59,600 --> 03:09:03,200
手动进行分块矩阵乘法，所以我

4505
03:09:01,520 --> 03:09:05,399
我想我现在就把这件事插空做了

4506
03:09:03,200 --> 03:09:06,680
然后，让你的大脑思考一下这个问题

（注：原英文句子似乎未完整） 

4507
03:09:05,399 --> 03:09:09,840
在我们真正开始之前的一小会儿

4508
03:09:06,680 --> 03:09:12,000
使用它并应用它，嗯，但在这之前

4509
03:09:09,840 --> 03:09:15,359
我们有了关于矩阵的这个想法

4510
03:09:12,000 --> 03:09:17,920
乘法，嗯，就是你要进行的那种（这里原句表述不太完整清晰，只能大致按字面翻译）

4511
03:09:15,359 --> 03:09:20,439
像一个

4512
03:09:17,920 --> 03:09:25,359
你有个类似矩阵的东西

4513
03:09:20,439 --> 03:09:28,080
而且你能明白或许不是……我是说

4514
03:09:25,359 --> 03:09:28,080
打算移动这个

4515
03:09:33,359 --> 03:09:41,640
下开关 马克

4516
03:09:36,640 --> 03:09:41,640
这里有一个矩阵

4517
03:09:44,160 --> 03:09:49,319
也许是一个里面有一些数字的东西和你有关 （注：原句表述不太准确，推测更准确可能是 “a something with some numbers in it maybe” ，这样语义更通顺，此翻译是基于现有原文翻译） 

4518
03:09:51,279 --> 03:09:57,560
还有 B，这里的整个想法是我们要做

4519
03:09:55,520 --> 03:10:02,680
将这个与……相乘（这里原文表述可能不太完整准确，“product”作动词有“使相乘”的意思 ，结合“this with”推测可能是这样的意思）

4520
03:09:57,560 --> 03:10:05,279
这个 这个 和这个 这个 和这个 做

4521
03:10:02,680 --> 03:10:09,479
同样的事情，然后我们把它降下来

4522
03:10:05,279 --> 03:10:10,760
一直到这里，直到最后，嗯

4523
03:10:09,479 --> 03:10:13,120
这是处理矩阵的一种方法

4524
03:10:10,760 --> 03:10:15,120
乘法 然而你实际上可以

4525
03:10:13,120 --> 03:10:17,600
通过使用……使这更高效

4526
03:10:15,120 --> 03:10:19,479
一种叫做打桩的东西

4527
03:10:17,600 --> 03:10:21,720
所以我会就此提供一些例子。

4528
03:10:19,479 --> 03:10:24,080
在课程的后期，但这就是思路。

4529
03:10:21,720 --> 03:10:27,920
这里

4530
03:10:24,080 --> 03:10:31,520
嗯，你有这些，呃，你有这两个

4531
03:10:27,920 --> 03:10:33,479
矩阵 A 和矩阵 B，所以我打算……

4532
03:10:31,520 --> 03:10:35,600
你得稍微看一下这个。

4533
03:10:33,479 --> 03:10:38,479
不同的

4534
03:10:35,600 --> 03:10:41,239
但这就是它的样子

4535
03:10:38,479 --> 03:10:45,120
像；喜欢；想要

4536
03:10:41,239 --> 03:10:48,239
那么我们可以说

4537
03:10:45,120 --> 03:10:52,000
嗯，就说这是 A，而这是

4538
03:10:48,239 --> 03:10:53,920
B 好的，然后你有这个 C 矩阵

4539
03:10:52,000 --> 03:10:55,359
那你是怎么像第一次那样计算的呢

4540
03:10:53,920 --> 03:10:57,000
元素 右边 嗯 你会 你会

4541
03:10:55,359 --> 03:10:58,479
通常拿这一排，然后拿这个

4542
03:10:57,000 --> 03:10:59,840
列，然后你会把它放在那里

4543
03:10:58,479 --> 03:11:03,000
因为那是它们的相交之处

4544
03:10:59,840 --> 03:11:05,680
对，嗯，但是你能做的是你可以

4545
03:11:03,000 --> 03:11:08,319
实际上拿一大块，你可以拿一块

4546
03:11:05,680 --> 03:11:12,000
像一个真正的正方形或长方形那样的块状物

4547
03:11:08,319 --> 03:11:14,040
比如，也许这个，我就把这个放这儿

4548
03:11:12,000 --> 03:11:16,880
分成类似独立的部分

4549
03:11:14,040 --> 03:11:18,920
片段说这就像，你知道的那种感觉

4550
03:11:16,880 --> 03:11:22,880
也许是个 9

注：原英文“maybe a a 9”表述有误，多了一个“a” ，正常应是“maybe a 9” 。 

4551
03:11:18,920 --> 03:11:26,439
by9 没错，这也是一个 9

4552
03:11:22,880 --> 03:11:29,520
从技术上讲，这里的每一个……（注：原文“each this each of”表述有误，此翻译按其大致逻辑进行处理） 

4553
03:11:26,439 --> 03:11:31,359
从技术层面讲，这就像一个 3×3 的方块，或者

4554
03:11:29,520 --> 03:11:35,279
一个本身就有意义的矩阵，所以我们现在

4555
03:11:31,359 --> 03:11:35,279
只是把这个拆分，拆分成

4556
03:11:35,880 --> 03:11:40,960
瓷砖，那么在这里你能做什么呢

4557
03:11:42,279 --> 03:11:51,880
正如我在这里所阐述的，你可以做到

4558
03:11:46,239 --> 03:11:54,600
你能……你能去一次，你可以做一次……（此英文表述不太符合常规语法，译文可能不太通顺） 

4559
03:11:51,880 --> 03:11:57,479
矩阵 这里是矩阵 乘以 矩阵

4560
03:11:54,600 --> 03:12:01,479
呃，这里 A 和 B 分别喜欢

4561
03:11:57,479 --> 03:12:04,800
你先计算 a 乘以 b，嗯，然后把这个结果加到……

4562
03:12:01,479 --> 03:12:09,239
二和二的矩阵相乘，A 和

4563
03:12:04,800 --> 03:12:12,560
分别为 B，然后是三以及

4564
03:12:09,239 --> 03:12:14,319
三，你从这些开始，然后你

4565
03:12:12,560 --> 03:12:17,680
然后你把这些加进去，并且你再添加…… 

4566
03:12:14,319 --> 03:12:20,359
所以这些就好像

4567
03:12:17,680 --> 03:12:23,200
A1 A1 *

4568
03:12:20,359 --> 03:12:27,359
B1 你先把那些数相乘，然后再相加

4569
03:12:23,200 --> 03:12:30,000
将其计算为 A2 乘以 B2，然后将结果与 A3 乘以……相加

注：原英文文本似乎未完整表述，这里按已有内容进行了较为自然的翻译。 

4570
03:12:27,359 --> 03:12:33,520
B3，然后你最终会得到这个以及

4571
03:12:30,000 --> 03:12:34,920
这里的这个 C1，那就是输出，并且

4572
03:12:33,520 --> 03:12:37,200
这正是我所写出来的内容。（注：原文似乎不完整，可提供完整内容以获得更准确翻译） 

4573
03:12:34,920 --> 03:12:41,279
一种立方体格式就像你所拥有的那样

4574
03:12:37,200 --> 03:12:43,680
你已经在这里列出了某个矩阵 A

4575
03:12:41,279 --> 03:12:47,640
嗯，这就像是一排，然后你有…… 

4576
03:12:43,680 --> 03:12:49,000
在这里列出了一些 M 矩阵 B，嗯，并且

4577
03:12:47,640 --> 03:12:51,760
你只是 你只是

4578
03:12:49,000 --> 03:12:53,239
用这个乘以这个，然后加到……上

4579
03:12:51,760 --> 03:12:55,800
用这个乘以这个，然后再加上这个

4580
03:12:53,239 --> 03:12:58,040
乘以这个，嗯，然后就是你了 

4581
03:12:55,800 --> 03:13:00,560
最后只剩下 C1，那么你能……

4582
03:12:58,040 --> 03:13:03,399
处理像这之所以如此的原因这样的情况

4583
03:13:00,560 --> 03:13:05,520
有效是因为你能，你能

4584
03:13:03,399 --> 03:13:07,640
实际上把这些瓷砖放好，然后你就可以把它们弄出来了 

4585
03:13:05,520 --> 03:13:09,800
把它们转移到像……这样更快的存储器中

4586
03:13:07,640 --> 03:13:11,720
共享内存 呃 然后它们最终会

4587
03:13:09,800 --> 03:13:14,160
跑得快得离谱，而你

4588
03:13:11,720 --> 03:13:16,520
最终可能会进行像这样的计算

4589
03:13:14,160 --> 03:13:17,680
快得多，所以如果你把它分成

4590
03:13:16,520 --> 03:13:19,680
小瓷砖

4591
03:13:17,680 --> 03:13:21,600
让每一个小小的点赞如溪流般涌动 

4592
03:13:19,680 --> 03:13:23,960
芯片上的多处理器

4593
03:13:21,600 --> 03:13:27,359
实际上要照顾好每一个人，呃

4594
03:13:23,960 --> 03:13:29,880
单块瓷砖或多块瓷砖 嗯 然后你可以

4595
03:13:27,359 --> 03:13:33,080
实际上能获得更多有用的 呃 你

4596
03:13:29,880 --> 03:13:35,399
获得多得多、高得多的算力

4597
03:13:33,080 --> 03:13:37,160
你可以说吞吐量，嗯，但别说出来。 

4598
03:13:35,399 --> 03:13:39,399
过度担心这件事，这是

4599
03:13:37,160 --> 03:13:41,439
只是关于像这样平铺的直觉

4600
03:13:39,399 --> 03:13:42,840
这与……之间的差异

4601
03:13:41,439 --> 03:13:45,200
我们一直在做的普通版本，在那个版本里我们……

4602
03:13:42,840 --> 03:13:46,680
比如取一整行，然后我们再取一个

4603
03:13:45,200 --> 03:13:47,960
整列，然后我们进行点积运算

4604
03:13:46,680 --> 03:13:51,000
把它们放在一起

4605
03:13:47,960 --> 03:13:52,399
这和那不同，所以我

4606
03:13:51,000 --> 03:13:53,960
只是想把那个想法植入你的脑海，为了…… 

4607
03:13:52,399 --> 03:13:57,680
稍后，这样它就不是一个完整的

4608
03:13:53,960 --> 03:13:57,680
当我们试图做这件事时会有惊喜。

4609
03:13:58,600 --> 03:14:04,960
现在加快速度，我们来深入探讨我们如何能够……

4610
03:14:01,760 --> 03:14:07,680
实际上对性能指标进行分析

4611
03:14:04,960 --> 03:14:09,399
我们自己的内核，那么我们如何进行优化

4612
03:14:07,680 --> 03:14:12,239
这些是对的，而且我们打算使用

4613
03:14:09,399 --> 03:14:13,760
英伟达安第特计算，对于这个，嗯，如果

4614
03:14:12,239 --> 03:14:15,000
你用的是 Windows 系统，你可能，你可能

4615
03:14:13,760 --> 03:14:16,439
没有这个，它可能看起来有点……

4616
03:14:15,000 --> 03:14:18,239
不同的 我还没在 Windows 系统上试过它

4617
03:14:16,439 --> 03:14:20,640
不过，这就是我们要用的东西

4618
03:14:18,239 --> 03:14:22,359
我这里用的是 Linux 系统，所以情况大概就是这样

4619
03:14:20,640 --> 03:14:24,960
看起来在最后你可以看到一个

4620
03:14:22,359 --> 03:14:27,760
关于各种事情的一堆细节 嗯 这是

4621
03:14:24,960 --> 03:14:29,439
非常非常有趣，但我们要去……

4622
03:14:27,760 --> 03:14:32,120
马上深入探究这个问题，只是

4623
03:14:29,439 --> 03:14:35,239
把这些关掉，呃，然后我们就走

4624
03:14:32,120 --> 03:14:39,000
先开始吧，那我就不多说了。（这里结合语境意译，原英文表意不是特别清晰，“close”有结束等意思，这里推测是结束话语开启行动的意思） 

4625
03:14:35,239 --> 03:14:41,560
这些，我们会在这个，在这个，呃……里面看到。

4626
03:14:39,000 --> 03:14:43,239
第五章 内核性能分析

4627
03:14:41,560 --> 03:14:45,840
我们有一堆文件，所以我们打算……

4628
03:14:43,239 --> 03:14:48,800
首先来说说这个，微顶点探测器（MVTX） 

4629
03:14:45,840 --> 03:14:50,000
马特莫，那么到底什么是MVTX呢？ 

4630
03:14:48,800 --> 03:14:51,319
你们已经知道什么是矩阵了

注：这里原文“what matrix”表述不太准确，可能原句想表达“what the matrix is” ，若有更准确上下文可进一步完善翻译。 

4631
03:14:50,000 --> 03:14:56,160
乘法是……我不打算继续讲了

4632
03:14:51,319 --> 03:15:00,720
另外，NVX就像是那种惯例一样

4633
03:14:56,160 --> 03:15:02,520
针对呃，工藤内核的分析器，对吧，还有

4634
03:15:00,720 --> 03:15:03,680
这能让你做的是，它是…… 

4635
03:15:02,520 --> 03:15:06,120
实际上，如果你……的话，相当简单。

4636
03:15:03,680 --> 03:15:07,479
看看这里正在发生的事情，就好像它是

4637
03:15:06,120 --> 03:15:09,000
实际上这很有道理，什么……

4638
03:15:07,479 --> 03:15:10,760
事情正在发生，所以我们能够推动这件事

4639
03:15:09,000 --> 03:15:14,399
进入一个类似本质上的范围

4640
03:15:10,760 --> 03:15:16,200
时间线 嗯 推进矩阵乘法

4641
03:15:14,399 --> 03:15:18,359
推进内存分配，所以我们现在

4642
03:15:16,200 --> 03:15:20,920
正在做；进行着

注：“doing the”并不是完整有意义的表达，一般“doing”后会接具体动作内容。但按照你要求只做字面翻译和格式保留。 

4643
03:15:18,359 --> 03:15:23,199
嗯，这就是全部，这就是全部

4644
03:15:20,920 --> 03:15:26,600
从一开始的矩阵乘法相关内容

4645
03:15:23,199 --> 03:15:28,680
嗯，为了完成，我们把事情控制在一个范围内。 

4646
03:15:26,600 --> 03:15:34,000
所以进行内存分配，然后我们弹出

4647
03:15:28,680 --> 03:15:36,880
我们把那个弄出来，嗯，我们复制，把那个弄出来

4648
03:15:34,000 --> 03:15:38,800
出去，所以就像是有开始和结束，呃，还有

4649
03:15:36,880 --> 03:15:41,680
然后我们做我们的……我们的昏暗之事（这里“dim”这样翻译较难理解，可能原文存在表述不完整或不准确的情况） 

4650
03:15:38,800 --> 03:15:43,319
我们从执行内核开始，并且 

4651
03:15:41,680 --> 03:15:44,920
那么一旦我们……它就会停止

4652
03:15:43,319 --> 03:15:47,439
启动内核，运行它，然后

4653
03:15:44,920 --> 03:15:49,160
同步我们所有的，嗯，就像我们的…… 

4654
03:15:47,439 --> 03:15:53,319
我们的一切

4655
03:15:49,160 --> 03:15:54,880
网格，然后再复制回主机，对吧，呃

4656
03:15:53,319 --> 03:15:57,040
所以这非常直接明了。

4657
03:15:54,880 --> 03:15:59,399
实际上你所需要的一切，所以我是说要保留…… 

4658
03:15:57,040 --> 03:16:01,080
想想当我们开始做这件事的时候，我们……

4659
03:15:59,399 --> 03:16:02,800
之后再吃一个，所以这个（先吃）

4660
03:16:01,080 --> 03:16:04,239
只会针对最近的那个

4661
03:16:02,800 --> 03:16:06,279
那个放得很正，所以不会倒。

4662
03:16:04,239 --> 03:16:08,399
跳回到第一个，那是

4663
03:16:06,279 --> 03:16:10,120
曾经被推进去，情况会是这样的
（这里原文可能表述不太完整准确，这是根据字面进行的翻译） 

4664
03:16:08,399 --> 03:16:12,120
有点，呃，就像括号那样，对吧，所以你

4665
03:16:10,120 --> 03:16:14,160
在……上有一层括号

（这里原文似乎不完整，“on the”后面缺少内容） 

4666
03:16:12,120 --> 03:16:16,720
外面一个，然后里面还有一个，它是

4667
03:16:14,160 --> 03:16:20,600
嗯，有点……就是那种感觉有点…… 

4668
03:16:16,720 --> 03:16:23,880
这个NBTX工具的结构

4669
03:16:20,600 --> 03:16:28,359
嗯，所以当我们继续并

4670
03:16:23,880 --> 03:16:32,160
加拿大国家广播公司（NBCC），嗯，这个，我们想在……传递这个…… 

4671
03:16:28,359 --> 03:16:34,800
链接英伟达（NV）工具扩展，这就是移动顶点（mvtx）的含义

4672
03:16:32,160 --> 03:16:36,680
代表，所以是英伟达工具扩展

4673
03:16:34,800 --> 03:16:38,560
我们要进行汇编，这样我们就能继续了

4674
03:16:36,680 --> 03:16:41,439
向前，而且你知道运行这个，它会，它会

4675
03:16:38,560 --> 03:16:43,520
运行符合预期，很好，嗯，然后我们可以

4676
03:16:41,439 --> 03:16:47,439
实际上，如果我们回到这个说明文档

4677
03:16:43,520 --> 03:16:51,640
文件，嗯，我们可以做纽约州的资料简介。

4678
03:16:47,439 --> 03:16:56,160
呃，统计数据显示是真的，但其实并非如此。

4679
03:16:51,640 --> 03:16:56,160
哺乳动物，它是0，但如果我们继续运行

4680
03:16:57,600 --> 03:17:03,680
这时我们会注意到有一堆

4681
03:17:00,720 --> 03:17:06,080
如果你现在……就会弹出一些很酷的统计数据。

（由于原文不完整，此翻译仅供参考，需结合完整语境来理解其确切含义。） 

4682
03:17:03,680 --> 03:17:07,399
从远程机器运行，你可以

4683
03:17:06,080 --> 03:17:09,600
你可以用这个
你只需看看

4684
03:17:07,399 --> 03:17:13,040
直接从终端对此进行操作

注：由于原英文句子不太完整通顺，此翻译是根据字面意思尽量表意。 

4685
03:17:09,600 --> 03:17:14,399
然而，呃，英伟达IGHT计算应用程序

4686
03:17:13,040 --> 03:17:17,960
它本身实际上还要多一点

4687
03:17:14,399 --> 03:17:20,920
比这个更有信息量，所以

4688
03:17:17,960 --> 03:17:24,399
我们能做的就是输入你的Windows（此英文句子表述有误，推测更合理的表达可能是“What we can do is type in your Windows password之类的，按原文翻译逻辑较奇怪）

4689
03:17:20,920 --> 03:17:27,520
按下按键并打开“开始”菜单（原文“go windows”可能表述有误，推测是“go to the Start menu”之类意思），然后输入“ncu” ，接着

4690
03:17:24,399 --> 03:17:29,720
然后按下回车键，它应该会弹出

4691
03:17:27,520 --> 03:17:32,359
嗯，eni计算以及

4692
03:17:29,720 --> 03:17:34,239
它它它突然出现在我的第二台显示器上

4693
03:17:32,359 --> 03:17:36,720
我刚把它拿到这儿来，但这是

4694
03:17:34,239 --> 03:17:40,880
它应该是什么样子的，嗯，还有你…… 

4695
03:17:36,720 --> 03:17:42,760
从这里能做的就是，嗯，我打算……

4696
03:17:40,880 --> 03:17:47,920
把这个放到第二个上面，然后拖动

4697
03:17:42,760 --> 03:17:49,479
呃，是NIS报告文件，不是SQ文件

4698
03:17:47,920 --> 03:17:51,880
点亮 SQ 灯是为了……为了一个……

4699
03:17:49,479 --> 03:17:55,000
不同的事情，但我们把这个呃拖进了…… 

4700
03:17:51,880 --> 03:17:55,000
进入侧边栏

4701
03:17:55,640 --> 03:17:59,640
现在它在里面了，我们可以在……看到它。 

4702
03:17:58,120 --> 03:18:00,920
顶部，现在有一堆……

4703
03:17:59,640 --> 03:18:02,600
这里有一些有趣的东西，我们可以……

4704
03:18:00,920 --> 03:18:03,880
看，所以这段文本可能是一个

4705
03:18:02,600 --> 03:18:06,560
有点小，如果你是在手机上看的话，不过

4706
03:18:03,880 --> 03:18:09,319
请在这里耐心听我说，所以我们有一堆…… 

4707
03:18:06,560 --> 03:18:10,399
关于线程上的东西 嗯 你知道nbtx

4708
03:18:09,319 --> 03:18:12,439
这是什么情况，正在发生什么事

4709
03:18:10,399 --> 03:18:16,000
依次地，在这里我们实际上可以进行缩放。

4710
03:18:12,439 --> 03:18:17,560
进去看看，嗯，你知道那个记忆副本

4711
03:18:16,000 --> 03:18:19,640
内核执行大约需要 2（这里“2”后面应该有单位，如秒、毫秒等，但原文未给出）

4712
03:18:17,560 --> 03:18:21,040
毫秒之间，我们便能洞悉一切

4713
03:18:19,640 --> 03:18:22,319
对，所以实际上所有这些都被推动了。

4714
03:18:21,040 --> 03:18:25,279
进入这个范围，然后我们就能看到是什么情况了 

4715
03:18:22,319 --> 03:18:27,439
正在发生 嗯 然后当然还有你

4716
03:18:25,279 --> 03:18:28,840
要知道内存分配需要一些时间

4717
03:18:27,439 --> 03:18:30,359
呃，然后是矩阵乘法

4718
03:18:28,840 --> 03:18:32,640
从头到尾，就像我们强调的那样

4719
03:18:30,359 --> 03:18:34,160
在代码里，嗯，所以就是那样的方式

4720
03:18:32,640 --> 03:18:36,359
这就是MVTX的作用，你可以推动（这里“push”意思较模糊，需结合具体语境确定准确含义） 

4721
03:18:34,160 --> 03:18:38,120
将事物划分到一个范围，然后你就能明白如何（做）了 

4722
03:18:36,359 --> 03:18:40,199
实际上它需要多长时间，你可以看到就像

4723
03:18:38,120 --> 03:18:42,479
当事情在时间轴上发生时，以及

4724
03:18:40,199 --> 03:18:45,760
你可以更详细地查看，具体如下（注：原句“more more”表述有误，推测可能是想表达“more and more” ，这里按原句翻译）

4725
03:18:42,479 --> 03:18:50,160
去喜欢那里正在发生的事情，对吧，所以

4726
03:18:45,760 --> 03:18:53,080
嗯，不管怎样，如果我们看看英伟达CUDA硬件

4727
03:18:50,160 --> 03:18:55,239
在这儿的顶部，我们可以看到，呃，它

4728
03:18:53,080 --> 03:18:58,880
由内核和内存组成，所以

4729
03:18:55,239 --> 03:19:01,960
呃，有点像复制呢，那可以让 M 来复制

注：原句 “cud” 可能是 “could” 的拼写错误 。 

4730
03:18:58,880 --> 03:19:04,640
然后还有矩阵 M 内核

4731
03:19:01,960 --> 03:19:07,920
我们在这里可以看到，如果我们点击

4732
03:19:04,640 --> 03:19:10,760
现在我们在活动视图中展示，我们可以

4733
03:19:07,920 --> 03:19:11,600
点击下面这里
缩放至所选内容

4734
03:19:10,760 --> 03:19:15,000
在……上面；关于；在……时候

注：“on”有较多含义，需结合具体语境来确定最合适的释义，若你能提供更完整的文本，我可以给出更准确的翻译。 

4735
03:19:11,600 --> 03:19:17,239
时间线，我们可以右键点击，我们可以操作

4736
03:19:15,000 --> 03:19:18,319
分析内核；剖析内核

注：“profile kernel”常见表达的意思可能因具体语境不同而有所差异，这里“profile”有“分析、剖析”等意思，“kernel”指“内核” 。一般在计算机相关领域会出现这样的组合。 

4737
03:19:17,239 --> 03:19:20,000
而且有一堆有趣的

4738
03:19:18,319 --> 03:19:21,960
这里的情况，而且这可能有点……

4739
03:19:20,000 --> 03:19:25,399
一开始可能会有点让人应接不暇。

4740
03:19:21,960 --> 03:19:27,600
但有常见的过滤指标——颗粒物（PM）

4741
03:19:25,399 --> 03:19:29,920
采样 扭曲 采样 其他 所以我们正在

4742
03:19:27,600 --> 03:19:32,040
现在打算用颗粒物（PM）采样法。

4743
03:19:29,920 --> 03:19:33,600
嗯，性能指标（PM）采样就是一种性能度量方式。 

4744
03:19:32,040 --> 03:19:36,040
采样，所以它会给我们非常

4745
03:19:33,600 --> 03:19:39,080
关于各种事物的详细指标，并且我们将

4746
03:19:36,040 --> 03:19:41,960
能够从那方面进行优化，所以它是

4747
03:19:39,080 --> 03:19:44,479
打算使用我们的这个二进制 0 文件，这个文件我们

4748
03:19:41,960 --> 03:19:46,000
我们在编译期间之前所做的

4749
03:19:44,479 --> 03:19:47,840
嗯，它将引出这个新的

4750
03:19:46,000 --> 03:19:50,120
这里的菜单和那个（菜单）不同

4751
03:19:47,840 --> 03:19:53,239
时间线一 嗯，所以这个时间线视图

4752
03:19:50,120 --> 03:19:54,600
然后这就不同了，所以在这里，嗯

4753
03:19:53,239 --> 03:19:56,439
你知道我们可以看到我们所有的内核。

4754
03:19:54,600 --> 03:19:58,359
在顶部，所以万一我们是那种可能……

4755
03:19:56,439 --> 03:19:59,840
分析两个不同的矩阵

4756
03:19:58,359 --> 03:20:01,399
乘法核，它们，它们可能

4757
03:19:59,840 --> 03:20:03,760
两人都像……像……像这样出现在这里

4758
03:20:01,399 --> 03:20:05,560
运行时 我们程序的生命周期，即

4759
03:20:03,760 --> 03:20:09,040
那就是会在这里弹出来的东西，呃，诸如此类的。 

4760
03:20:05,560 --> 03:20:11,000
里面的果仁，所以呢，如果我们

4761
03:20:09,040 --> 03:20:12,239
去，你知道的，说总结，那里有…… 

4762
03:20:11,000 --> 03:20:13,880
这里有一些有趣的东西。

4763
03:20:12,239 --> 03:20:17,040
也许我们不会
也许我们不在乎

4764
03:20:13,880 --> 03:20:20,399
这太多了，有……有很多细节，嗯

4765
03:20:17,040 --> 03:20:21,880
所以你有，呃，吞吐量，那么关于……的概述

4766
03:20:20,399 --> 03:20:25,080
计算和内存的吞吐量

4767
03:20:21,880 --> 03:20:27,960
资源 嗯 颗粒物（PM）采样 所以 呃

4768
03:20:25,080 --> 03:20:29,880
绩效指标，我们可以做到这一点

4769
03:20:27,960 --> 03:20:34,120
向下，我们可以看到像SM这样的事物

4770
03:20:29,880 --> 03:20:36,120
吞吐量 呃 管道吞吐量 嗯 一大堆

4771
03:20:34,120 --> 03:20:38,800
在一堆指标里，我甚至都（不清楚……此处句子不完整） 

4772
03:20:36,120 --> 03:20:40,560
还没明白，但呃，我们有东西

4773
03:20:38,800 --> 03:20:43,960
比如缓存命中率，到底是什么样的（这里“which is really which”表述不太准确，推测意思可能是询问具体情况）

4774
03:20:40,560 --> 03:20:46,239
真的很有用，嗯，但如果我们去像……

4775
03:20:43,960 --> 03:20:47,560
例如，光速级的吞吐量，嗯

4776
03:20:46,239 --> 03:20:49,960
这就是这个，这是为了那段回忆

4777
03:20:47,560 --> 03:20:54,160
我们拥有计算吞吐量方面的资源

4778
03:20:49,960 --> 03:20:56,040
以百分比表示，那么大约是 90% - 97%

4779
03:20:54,160 --> 03:21:00,640
然后内存也大约在

4780
03:20:56,040 --> 03:21:02,239
97% 所以，嗯，你知道，我们……我们得以……

4781
03:21:00,640 --> 03:21:04,600
看到像这样很酷的东西，然后它会…… 

4782
03:21:02,239 --> 03:21:05,720
等会儿就更说得通了，开始吧

4783
03:21:04,600 --> 03:21:09,319
向下；在下面；倒下；下降；沿着……向下；向下游；在较低的位置；低于；向下地；朝下地；情绪低落的；沮丧的；向下的；下行的；向下移动；使倒下；吃下；喝下；打败；吞下；放下；减少；降低

4784
03:21:05,720 --> 03:21:11,960
呃，对于内存工作负载分析，我们可以

4785
03:21:09,319 --> 03:21:15,920
在它里面能看到内存吞吐量，非常（此处原英文表意不太完整通顺）

4786
03:21:11,960 --> 03:21:18,880
详细的记忆 呃，我猜是记忆

4787
03:21:15,920 --> 03:21:20,600
指标，比如每秒多少吉字节，是多少呢

4788
03:21:18,880 --> 03:21:24,800
我们能够转回多少？

4789
03:21:20,600 --> 03:21:27,680
来回，对，字节，嗯，每……达姆字节（注：“Dam”可能并非标准的字节相关术语，也许是拼写有误，推测可能是其他字节单位表述，但此处按原文直译）

4790
03:21:24,800 --> 03:21:31,080
其次，那么那块 GPU 的显存，它的速度有多快呢？ 

4791
03:21:27,680 --> 03:21:35,600
我们正在获取那个，嗯，还有那个速度

4792
03:21:31,080 --> 03:21:38,720
大约每秒 41 吉比特，嗯……

4793
03:21:35,600 --> 03:21:42,960
这并不是非常高，然后我们有

4794
03:21:38,720 --> 03:21:44,840
比如，呃，一级缓存命中率、二级缓存命中率，所有这些

4795
03:21:42,960 --> 03:21:45,960
这个，而且我们在这里可以看到一张内存图表

4796
03:21:44,840 --> 03:21:50,800
这里就像有一大堆……

4797
03:21:45,960 --> 03:21:53,439
我们能够获取的指标，嗯，所以

4798
03:21:50,800 --> 03:21:56,479
如果我们可以，我们可以，我们可以看看，我们可以

4799
03:21:53,439 --> 03:21:58,399
注意像这个数字41，嗯

4800
03:21:56,479 --> 03:22:02,319
我们会，我们会把这个号码记在脑子里

4801
03:21:58,399 --> 03:22:03,960
目前呢，嗯，这里也有一个来源呢，所以

4802
03:22:02,319 --> 03:22:06,000
呃，你可以看看实际的组装情况。

4803
03:22:03,960 --> 03:22:08,479
说明，然后看看，嗯，你知道该怎么做

4804
03:22:06,000 --> 03:22:11,600
它占用了很多寄存器啊，一堆呢。

4805
03:22:08,479 --> 03:22:15,239
非常底层的东西，嗯，这不是我所擅长的（此处结合语境可进一步完善表述，原句没说完推测可能有类似意思） 

4806
03:22:11,600 --> 03:22:16,359
马上就要深入探究了 嗯 不过 没错

4807
03:22:15,239 --> 03:22:18,120
那儿，那儿，有这么多设置。

4808
03:22:16,359 --> 03:22:23,319
不管怎样都要去挖掘，我们这就出发

4809
03:22:18,120 --> 03:22:23,319
为了把这个数字，嗯，41 保留在我们的…… 

4810
03:22:23,640 --> 03:22:25,800
头；头部

4811
03:22:24,720 --> 03:22:28,840
[音乐]

4812
03:22:25,800 --> 03:22:30,920
现在我们结束这个环节，我们就戴上（穿上、放上等，需结合具体语境确定“put on”含义）

4813
03:22:28,840 --> 03:22:33,520
为……的一方；对于……的一面

由于“the side for”不是完整句子，此翻译是根据短语进行的常见释义，可能需结合完整语境准确理解其意思。 

4814
03:22:30,920 --> 03:22:35,920
现在我们还有一些其他的，我们有一些

4815
03:22:33,520 --> 03:22:37,840
其他，呃，还有其他脚本，所以我有一个

4816
03:22:35,920 --> 03:22:39,960
天真的多媒体抽象层（MMAL），所以这就是我们要的那个

4817
03:22:37,840 --> 03:22:42,319
此前写过，这完全一样

4818
03:22:39,960 --> 03:22:44,239
只是我们直接复制粘贴，呃，还有

4819
03:22:42,319 --> 03:22:45,920
然后我们有一个分块的机器学习（模型），我打算…… 

4820
03:22:44,239 --> 03:22:48,800
稍后再稍微讲一下，这有点……

4821
03:22:45,920 --> 03:22:52,439
相对于嗯……来说更先进

4822
03:22:48,800 --> 03:22:54,760
但我们打算比较一下这些……（原句未完整） 

4823
03:22:52,439 --> 03:22:57,040
朴素方法与……的性能指标

4824
03:22:54,760 --> 03:23:00,120
直到机器学习

注：“the til ml” 表述不太准确，可能存在拼写等方面的小问题，这里 “til” 一般是 “until” 的口语化缩写，“ml” 常见指 “machine learning（机器学习）” ，如果有更准确的背景信息，翻译可能会更精准。 

4825
03:22:57,040 --> 03:23:01,359
所以如果我们继续进入这里，我们

4826
03:23:00,120 --> 03:23:07,359
走；去；出发

4827
03:23:01,359 --> 03:23:10,359
国家广播公司加拿大台呃01，然后是01，接着我们连接呃

4828
03:23:07,359 --> 03:23:10,359
嫉妒；羡慕

4829
03:23:13,439 --> 03:23:18,720
我们成功运行了工具，现在可以继续了。 

4830
03:23:16,080 --> 03:23:21,680
在这个配置文件里，然后输入 01，对吧

4831
03:23:18,720 --> 03:23:23,600
在那里，我要继续往前拖动

4832
03:23:21,680 --> 03:23:26,040
这样，我们再弹出一个，我要去……

4833
03:23:23,600 --> 03:23:27,680
把这个拖进洞察模块

4834
03:23:26,040 --> 03:23:32,239
计算；估算；推断；用计算机计算；为…作计算机运算

4835
03:23:27,680 --> 03:23:35,199
如果我们查看一下我们的呃 CUDA 硬件

4836
03:23:32,239 --> 03:23:37,800
转到内核
矩阵相乘
这是

4837
03:23:35,199 --> 03:23:40,640
夜间版本，记得，呃，展示一个

4838
03:23:37,800 --> 03:23:42,520
活动视图 缩放至

4839
03:23:40,640 --> 03:23:47,600
已选中；被挑选的

4840
03:23:42,520 --> 03:23:49,279
概况 呃，我们再次进行了颗粒物（PM）采样。

4841
03:23:47,600 --> 03:23:52,399
它将运行那个，然后我们接着做

4842
03:23:49,279 --> 03:23:53,680
看看我们的新统计数据 嗯 你 这是

4843
03:23:52,399 --> 03:23:57,920
这和没有……的情况完全一样

4844
03:23:53,680 --> 03:24:00,920
mvtx 但只是为了提供背景信息

4845
03:23:57,920 --> 03:24:03,399
细节 记忆 工作量 所以我们理解你

4846
03:24:00,920 --> 03:24:05,359
知道吗，30、37，这已经很接近……了

4847
03:24:03,399 --> 03:24:10,080
我们之前所拥有的，对吧，嗯，也许是一个

4848
03:24:05,359 --> 03:24:14,760
再低一点 嗯 但是当我们……当我们

4849
03:24:10,080 --> 03:24:14,760
编译直到MML

4850
03:24:24,600 --> 03:24:29,000
它如预期般正常工作，并且说

4851
03:24:27,120 --> 03:24:30,600
简介 我们会得到一个数字

4852
03:24:29,000 --> 03:24:32,720
三

4853
03:24:30,600 --> 03:24:34,880
在这里，我要去刺激并推动这件事

4854
03:24:32,720 --> 03:24:37,040
深入洞察

4855
03:24:34,880 --> 03:24:40,239
计算 我们打开这个

4856
03:24:37,040 --> 03:24:43,080
向上 突然到我们的……（这里文本似乎不完整） 

4857
03:24:40,239 --> 03:24:44,359
内核 矩阵乘法优化展示

4858
03:24:43,080 --> 03:24:46,880
在；在……内；在……期间；在……以后；穿着；处于……状态；在……方面；包含在……中；从事……；用；以；按照；关于；在……时候

4859
03:24:44,359 --> 03:24:48,439
事件假定在时间轴上选择它，所以

4860
03:24:46,880 --> 03:24:49,720
顺便说一下，我们可以看到这个的长度。

4861
03:24:48,439 --> 03:24:53,479
这就是所需的时长，它将会……

4862
03:24:49,720 --> 03:24:58,199
从你所知的430毫秒开始

4863
03:24:53,479 --> 03:24:58,199
43024毫秒，一直到

4864
03:25:05,240 --> 03:25:08,299
[音乐]

4865
03:25:15,319 --> 03:25:20,279
431.073 比它高得多。

4866
03:25:17,960 --> 03:25:21,720
之前是这样，所以这些就是……类型的

4867
03:25:20,279 --> 03:25:23,880
当你……的时候，你需要留意的事情

4868
03:25:21,720 --> 03:25:26,160
之后会看到你的内存吞吐量下降

4869
03:25:23,880 --> 03:25:28,560
你改变了某些东西，就好像，呃，也许

4870
03:25:26,160 --> 03:25:30,760
我们……也许我们不该那么做，嗯，你

4871
03:25:28,560 --> 03:25:33,680
从这里开始，情况从呃，那种天真的状态转变了

4872
03:25:30,760 --> 03:25:35,399
它当时是37，而这里现在是60，对吧

4873
03:25:33,680 --> 03:25:38,520
所以这是在更好地利用…… 

4874
03:25:35,399 --> 03:25:40,920
记忆，嗯，我们之后会看到更多的。

4875
03:25:38,520 --> 03:25:43,720
后续的优化，尤其是在……方面的优化 

4876
03:25:40,920 --> 03:25:45,800
在这个，嗯，更快的金属章节里，正如

4877
03:25:43,720 --> 03:25:47,399
关于我们如何才能切实达到这个数字

4878
03:25:45,800 --> 03:25:49,439
向上；起来；上升；在上面

4879
03:25:47,399 --> 03:25:51,239
嗯，不过没错，这就是你……的方式

4880
03:25:49,439 --> 03:25:53,279
个人资料 里面有很多很酷的东西

4881
03:25:51,239 --> 03:25:54,960
你在这里要留意一下，嗯，它

4882
03:25:53,279 --> 03:25:57,760
这真的取决于你使用的是哪种算法

4883
03:25:54,960 --> 03:25:59,680
处理矩阵乘法相关工作

4884
03:25:57,760 --> 03:26:02,800
呃，还有一些，就像还有一些

4885
03:25:59,680 --> 03:26:05,199
更多，嗯，更精细的优化措施，那些…… 

4886
03:26:02,800 --> 03:26:06,880
只是被证明是有效的，所以我们只是……我们

4887
03:26:05,199 --> 03:26:08,920
可以直接运行那些，然后有点……

4888
03:26:06,880 --> 03:26:10,560
比较差异 呃 但是你

4889
03:26:08,920 --> 03:26:12,640
你是否拥有所有可用的资源在你（这里原句可能表述有误，正确的或许是“Have you got all the resources at your disposal”之类的）

4890
03:26:10,560 --> 03:26:16,560
手在这儿，有超多的东西，那些……

（原句不太完整通顺，此为根据现有内容的翻译） 

4891
03:26:12,640 --> 03:26:19,880
你可以使用并从中学习，所以，呃，是的

4892
03:26:16,560 --> 03:26:22,160
这是，呃，这就是你分析Cuda的方式。

4893
03:26:19,880 --> 03:26:24,439
使用英伟达（Nvidia）和ite的内核

4894
03:26:22,160 --> 03:26:26,960
计算 我这里有一个自述文件，里面有

4895
03:26:24,439 --> 03:26:32,520
几乎就是我们讨论过的所有内容

4896
03:26:26,960 --> 03:26:32,520
那么，嗯，NS 配置文件命令

4897
03:26:33,199 --> 03:26:40,600
嗯，你也可以对 Python 进行性能分析，所以 NS

4898
03:26:36,720 --> 03:26:42,560
个人资料，然后嗯，你可以……你有……

4899
03:26:40,600 --> 03:26:46,439
你可以用 Python 编写一个类似 MLP（多层感知器）的脚本

4900
03:26:42,560 --> 03:26:48,279
说来有趣的是那个简介，而且它只会

4901
03:26:46,439 --> 03:26:50,600
使用随便什么英伟达产品

4902
03:26:48,279 --> 03:26:52,560
这句话存在语法错误，可能想表达的正确句子有多种情况，以下猜测几种可能并给出翻译：

### 猜测一：That is your Python file in libraries.
那是你在库中的 Python 文件。

### 猜测二：Your Python file is in libraries.
你的 Python 文件在库中。

如果这不是你想要的结果，请检查英文原文是否准确。 

4903
03:26:50,600 --> 03:26:55,560
使用；利用；运用；消耗；说，写，使用（词语、语言）

4904
03:26:52,560 --> 03:26:57,160
嗯，然后你就可以这样做了

4905
03:26:55,560 --> 03:26:58,520
在命令行上进行一些操作，比如

4906
03:26:57,160 --> 03:27:01,520
这；这个

4907
03:26:58,520 --> 03:27:04,760
那么，呃，NCU内核名称，你可以，你能做到。

4908
03:27:01,520 --> 03:27:06,319
通过命令行处理一些事情 嗯 不过没错

4909
03:27:04,760 --> 03:27:09,319
有 有一堆有用的工具

4910
03:27:06,319 --> 03:27:12,120
这里，呃，所以这个……这个可能会是

4911
03:27:09,319 --> 03:27:13,880
稍后更新 嗯 它不在那种……里面

4912
03:27:12,120 --> 03:27:15,319
这是目前最好的格式，所以这可能看起来像一个

4913
03:27:13,880 --> 03:27:17,439
当你看到它的时候，情况有点不同

4914
03:27:15,319 --> 03:27:19,880
但是，呃，这些算是主要的了

4915
03:27:17,439 --> 03:27:24,239
想法，然后我猜就只是……

4916
03:27:19,880 --> 03:27:27,760
让它在结束语那里结束，嗯，库普蒂（这里“cupti”可能是特定名称，不确定准确含义）或者

4917
03:27:24,239 --> 03:27:30,239
Cuda 一个 Cuda 性能分析工具接口

4918
03:27:27,760 --> 03:27:34,080
最终的巴基斯坦正义运动党，这是为了比如…… 

4919
03:27:30,239 --> 03:27:35,760
创作 创造你自己的 呃 那个

4920
03:27:34,080 --> 03:27:38,840
创建你自己的自定义分析和

4921
03:27:35,760 --> 03:27:41,479
针对特定 C 的追踪工具

4922
03:27:38,840 --> 03:27:43,359
应用程序，这样你就可以，你可以像……

4923
03:27:41,479 --> 03:27:45,160
用……设计你自己的分析工具

4924
03:27:43,359 --> 03:27:46,359
这个，嗯，如果有什么东西引起了（注意）…… 

4925
03:27:45,160 --> 03:27:49,160
根据你的兴趣，你可能想看看

4926
03:27:46,359 --> 03:27:50,479
更投入其中了，所以我就把这个放这儿了，呃

4927
03:27:49,160 --> 03:27:52,439
但那就是你分析库蒂奇的方式

4928
03:27:50,479 --> 03:27:54,880
内核，接下来我们有这个东西

4929
03:27:52,439 --> 03:27:56,840
称为原子操作，且是原子性的

4930
03:27:54,880 --> 03:27:58,600
操作被用于非常特定的

4931
03:27:56,840 --> 03:28:02,040
案例，所以我打算尽力涵盖这些

4932
03:27:58,600 --> 03:28:04,160
尽我所能地说，当我们提到“原子的”，我们指的是 

4933
03:28:02,040 --> 03:28:05,720
物理学中的不可分割性概念，其中

4934
03:28:04,160 --> 03:28:07,960
物质不能再进一步分解

4935
03:28:05,720 --> 03:28:09,279
对，所以你有一个原子，它就好像在说“哦，我”

4936
03:28:07,960 --> 03:28:10,439
严格来说，是存在夸克的，而且

4937
03:28:09,279 --> 03:28:11,640
杂物，但你不用担心那些

4938
03:28:10,439 --> 03:28:14,960
这就像那不可分割之物（注：“indivis”并非规范英文单词，可能是“indivisible”等词的不规范写法 ） 

4939
03:28:11,640 --> 03:28:16,520
你所说的这个事物的不可分割性概念

4940
03:28:14,960 --> 03:28:18,199
你不能就在那里把它切成两半。

4941
03:28:16,520 --> 03:28:19,840
也许它里面有一些部件，那些…… 

4942
03:28:18,199 --> 03:28:22,279
弥补它，但你做不到，你不能削减

4943
03:28:19,840 --> 03:28:24,680
把它切成两半，嗯，就是这样。 

4944
03:28:22,279 --> 03:28:26,600
这个原子操作是，并且它在运行

4945
03:28:24,680 --> 03:28:29,279
对我们来说是一种软件抽象，所以这个

4946
03:28:26,600 --> 03:28:33,520
硬件和 CUDA 编译器会处理好一切

4947
03:28:29,279 --> 03:28:35,520
这一切对我们来说，嗯，本质上是一个

4948
03:28:33,520 --> 03:28:37,040
原子操作确保了一个

4949
03:28:35,520 --> 03:28:39,520
对内存的特定操作

4950
03:28:37,040 --> 03:28:41,199
定位完全由一人完成

4951
03:28:39,520 --> 03:28:43,399
在另一个线程可以访问之前的线程

4952
03:28:41,199 --> 03:28:45,199
或者修改相同的内存位置，这个

4953
03:28:43,399 --> 03:28:46,720
防止出现不良状况，所以要记住

4954
03:28:45,199 --> 03:28:48,040
之前我们在谈论如何……

4955
03:28:46,720 --> 03:28:49,680
有好几个线索，它们…… （注：原句似乎未完整，这里按可能的理解补充说明语气）

如果原句不完整还有后续内容，请你继续提供，以便我给出更准确的翻译。目前给出的翻译是基于已有英文文本尽量通顺表达。 

4956
03:28:48,040 --> 03:28:52,160
就像其中一个最终可能会更快，而且

4957
03:28:49,680 --> 03:28:54,080
在这一个之前就进球了，而且它是

4958
03:28:52,160 --> 03:28:56,040
他们某种程度上需要不做修改。

4959
03:28:54,080 --> 03:28:58,239
彼此的 呃 他们不是 他们需要去……

4960
03:28:56,040 --> 03:29:00,000
比如不要乱动彼此的东西

4961
03:28:58,239 --> 03:29:03,279
所以，这就是这个想法的内容。

4962
03:29:00,000 --> 03:29:06,359
说到，嗯

4963
03:29:03,279 --> 03:29:07,880
因此无法访问或修改相同的内容

4964
03:29:06,359 --> 03:29:10,640
另一个线程的内存位置，那是

4965
03:29:07,880 --> 03:29:12,439
非常，这是一个非常关键的要点，对吧，嗯，而且

4966
03:29:10,640 --> 03:29:17,279
而且我们即将看到一个非常纯粹的（这里“Crystal”可能拼写有误，推测想表达“crystal - clear”之类意思，“crystal”本意是“水晶”，这里可灵活理解为“纯粹的”“清澈的”等 ）

4967
03:29:12,439 --> 03:29:19,840
马上给你举个清晰的例子，呃

4968
03:29:17,279 --> 03:29:22,239
我们可能会损失一些速度

4969
03:29:19,840 --> 03:29:24,120
所以如果我们限制所完成的工作量

4970
03:29:22,239 --> 03:29:25,840
每单位使用单块内存

4971
03:29:24,120 --> 03:29:27,160
时间经过 执行一个原子操作

4972
03:29:25,840 --> 03:29:29,080
我们 我们要损失一些速度了

4973
03:29:27,160 --> 03:29:32,680
从那方面来说，如果我们要锁定某些东西

4974
03:29:29,080 --> 03:29:34,600
向下并限制……的速度有多快（原英文文本似乎不完整）

4975
03:29:32,680 --> 03:29:36,359
程序只需通过拥有……就能完成

4976
03:29:34,600 --> 03:29:38,960
一切，就像等不及一切的到来

4977
03:29:36,359 --> 03:29:42,239
否则的话，它就会更快结束，对吧

4978
03:29:38,960 --> 03:29:44,520
那么，呃，当我们使用原子操作时，事情将会

4979
03:29:42,239 --> 03:29:46,520
慢下来，但它保证会是……

4980
03:29:44,520 --> 03:29:47,920
内存安全，嗯，那是…… 

4981
03:29:46,520 --> 03:29:49,560
最终你可能关心的是在……（这里句子似乎不完整） 

4982
03:29:47,920 --> 03:29:52,479
在某些情况下，最好还是拿到……（这里原文句子不完整） 

4983
03:29:49,560 --> 03:29:55,680
内存安全方面，而不是，而不是

4984
03:29:52,479 --> 03:29:57,000
性能提升，嗯，所以有一个

4985
03:29:55,680 --> 03:29:58,479
一系列不同的原子操作

4986
03:29:57,000 --> 03:30:01,800
我们所拥有的 我只是打算做这件事

4987
03:29:58,479 --> 03:30:04,120
稍微容易看清一些了，嗯，你有“原子”（Atomic） 

4988
03:30:01,800 --> 03:30:07,479
所以本质上这就是你所拥有的

4989
03:30:04,120 --> 03:30:09,239
你有一个指向整数的指针。 

4990
03:30:07,479 --> 03:30:13,279
一些 一些内存地址，并且你有一个

4991
03:30:09,239 --> 03:30:15,479
价值，而你所做的一切就是为……增添价值

4992
03:30:13,279 --> 03:30:17,720
地址处的值，所以当我们……当我们

4993
03:30:15,479 --> 03:30:19,600
例如，传入某个数字

4994
03:30:17,720 --> 03:30:21,640
四，然后我们得到内存地址

4995
03:30:19,600 --> 03:30:24,560
对于我们所输入的某个十六进制代码而言

4996
03:30:21,640 --> 03:30:27,040
我们把那个十六进制代码放在这里，并且

4997
03:30:24,560 --> 03:30:28,680
然后我们放一个值，比如说像 2 这样的值，并且

4998
03:30:27,040 --> 03:30:31,680
那么这样做的话，它会说“好的”。

4999
03:30:28,680 --> 03:30:33,359
嗯，我们有了内存地址，让我们，嗯……

5000
03:30:31,680 --> 03:30:35,080
让我们获取那块内存的值

5001
03:30:33,359 --> 03:30:37,199
地址是四号，然后我们就…… 

5002
03:30:35,080 --> 03:30:38,720
要给它加上这个值，这样它就会（呈现某种状态，这里原文没表述完整）

5003
03:30:37,199 --> 03:30:40,800
就像这个内存地址保持着（此处句子不完整，表意可能不清晰）

5004
03:30:38,720 --> 03:30:42,479
同样，没有任何新的东西被创造出来。

5005
03:30:40,800 --> 03:30:46,040
只是你在采用这个数值，并且

5006
03:30:42,479 --> 03:30:48,040
你把它加在上面，嗯，然后就是……

5007
03:30:46,040 --> 03:30:50,239
这在某种程度上就是……的整个理念

5008
03:30:48,040 --> 03:30:54,120
这里的一切都如此

5009
03:30:50,239 --> 03:30:56,760
替换 嗯 交换 以及 以及 那个

5010
03:30:54,120 --> 03:30:59,840
返回值将始终是旧值

5011
03:30:56,760 --> 03:31:02,120
值，所以当我们进行类似原子加法操作时以及

5012
03:30:59,840 --> 03:31:05,239
然后我们说，比如，将 int 赋值为 Atomic 

5013
03:31:02,120 --> 03:31:07,040
广告或者这里面不管是什么东西，它是……

5014
03:31:05,239 --> 03:31:09,279
将要返回……的旧值

5015
03:31:07,040 --> 03:31:11,960
不管这是什么，所以它将会

5016
03:31:09,279 --> 03:31:14,239
本质上返回，嗯，在……处的值

5017
03:31:11,960 --> 03:31:16,600
地址，对，嗯，所以我们某种程度上可以

5018
03:31:14,239 --> 03:31:18,479
比较并对比它，这让我们能够做到（这件事） 

5019
03:31:16,600 --> 03:31:20,160
那个，嗯，或者你也可以就是不喜欢

5020
03:31:18,479 --> 03:31:22,279
返回任何东西都行，你可以的

5021
03:31:20,160 --> 03:31:24,520
如果你只是想在那里面加上瓦尔的话

5022
03:31:22,279 --> 03:31:28,080
到该值，然后到地址值

5023
03:31:24,520 --> 03:31:30,239
那么你就可以那样做，嗯，但是这些

5024
03:31:28,080 --> 03:31:33,160
呃，这些都是……所有的都是这些……（因原文表意不完整，译文可能无法完整表意）

5025
03:31:30,239 --> 03:31:36,239
伴随原子特性的操作，呃

5026
03:31:33,160 --> 03:31:39,199
这些都是所有的原子操作。

5027
03:31:36,239 --> 03:31:40,920
嗯，还有浮点原子操作。

5028
03:31:39,199 --> 03:31:44,439
操作；手术；业务；作战行动

5029
03:31:40,920 --> 03:31:46,680
嗯，所以你可以想象一下原子的情况

5030
03:31:44,439 --> 03:31:50,199
就像非常快地

5031
03:31:46,680 --> 03:31:52,399
呃 硬件互斥操作

5032
03:31:50,199 --> 03:31:53,640
嗯，我接下来会深入探讨互斥锁。 

5033
03:31:52,399 --> 03:31:56,520
其次在这里，但本质上这是如何…… 

5034
03:31:53,640 --> 03:31:59,319
去做的是你锁定一个内存位置

5035
03:31:56,520 --> 03:32:02,160
嗯，你设置了旧值，那个“归来者”（注：“The Returned”不知具体所指，可结合具体语境调整）

5036
03:31:59,319 --> 03:32:03,800
值等于，嗯，就像 d 引用

5037
03:32:02,160 --> 03:32:05,319
那个内存地址，就像十六进制的那样

5038
03:32:03,800 --> 03:32:07,359
编码，然后你就能得到对应的值。

5039
03:32:05,319 --> 03:32:09,000
你设置了，你设置了这个旧值

5040
03:32:07,359 --> 03:32:13,720
你将会返还等同于……（这里句子似乎不完整）

5041
03:32:09,000 --> 03:32:17,040
那个，嗯，那个 D 参考值

5042
03:32:13,720 --> 03:32:19,880
嗯，然后我们设定

5043
03:32:17,040 --> 03:32:22,000
然后我们设置 D 引用的内存

5044
03:32:19,880 --> 03:32:25,560
位置，以便与之对应的那个值

5045
03:32:22,000 --> 03:32:27,640
那个十六进制代码对应旧的“超值版”（Value Plus）加上…… 

5046
03:32:25,560 --> 03:32:30,239
增量，也就是 Val，对吧

5047
03:32:27,640 --> 03:32:31,720
这是整型变量“Val” 嗯，然后我们解锁

5048
03:32:30,239 --> 03:32:34,160
我们返回的内存地址，所以它是

5049
03:32:31,720 --> 03:32:35,960
就像在我们处于的这一阶段时

5050
03:32:34,160 --> 03:32:37,760
递增，并且我们正在存储旧的（值）

5051
03:32:35,960 --> 03:32:39,199
数值 我们要把它锁定 所以

5052
03:32:37,760 --> 03:32:40,880
没有其他事情可以干扰到那一点。

5053
03:32:39,199 --> 03:32:43,399
只是这必须完成，这是…… 

5054
03:32:40,880 --> 03:32:45,680
优先级，并且那个优先级将会

5055
03:32:43,399 --> 03:32:47,439
通过任意数量的核心线程存在

5056
03:32:45,680 --> 03:32:49,239
我们，我们有权利，这样他们就不能（做某事）了

5057
03:32:47,439 --> 03:32:53,160
相互干扰，所以其中一方不得不

5058
03:32:49,239 --> 03:32:56,880
在另一个人访问它之前完成

5059
03:32:53,160 --> 03:33:00,800
嗯，然后我们就返回那个，对吧

5060
03:32:56,880 --> 03:33:02,399
那么，嗯，就互斥性而言

5061
03:33:00,800 --> 03:33:06,560
这里有一个不错的YouTube链接，它……（由于原文不完整，“that”引导的内容缺失，只能先翻译到这里） 

5062
03:33:02,399 --> 03:33:08,560
我发现那个非常好，嗯，“Mutual”是…… 

5063
03:33:06,560 --> 03:33:11,640
就像一种共享的关系

5064
03:33:08,560 --> 03:33:14,319
实体之间，所以我们所有这些线索，嗯

5065
03:33:11,640 --> 03:33:16,359
我们要付诸于坚持的行动中。

5066
03:33:14,319 --> 03:33:19,359
排除某些问题或预防急性接触性皮炎

注：这里的“ACD”如果没有更多背景信息，常见指“Acute Contact Dermatitis（急性接触性皮炎）” ，可根据实际情况调整。 

5067
03:33:16,359 --> 03:33:21,800
所以我们打算排除呃所有人

5068
03:33:19,359 --> 03:33:23,319
否则无法访问彼此的东西

5069
03:33:21,800 --> 03:33:25,160
我们打算让彼此把话说完

5070
03:33:23,319 --> 03:33:28,080
对，那就是，那就是相互的情况。 

5071
03:33:25,160 --> 03:33:30,680
排除，这适用于原子操作。

5072
03:33:28,080 --> 03:33:32,920
对，嗯，所以你没有多个

5073
03:33:30,680 --> 03:33:34,920
线程同时访问同一事物

注：原英文句子似乎未完整，推测后面可能还有内容，但根据现有内容给出了上述翻译。 

5074
03:33:32,920 --> 03:33:37,160
曾经，嗯，而且就好像有一个…… 

5075
03:33:34,920 --> 03:33:39,600
这里有一个直观的例子，关于这是怎样的…… 

5076
03:33:37,160 --> 03:33:42,880
可能会呃，在更低的层面上看看，什么……

5077
03:33:39,600 --> 03:33:47,720
实际上这正在起作用，呃，如果我们继续的话

5078
03:33:42,880 --> 03:33:52,000
切换到我们这边的原子广告

5079
03:33:47,720 --> 03:33:54,560
嗯，如果我用 nvcc 编译这个，嗯，我们会…… 

5080
03:33:52,000 --> 03:33:56,239
首先，我们先导入所有需要的东西

5081
03:33:54,560 --> 03:33:59,239
我们需要去库达尔（注：“cudar”可能拼写有误，若有更准确信息，翻译会更精准） 

5082
03:33:56,239 --> 03:34:01,239
运行时。嗯，我们有多个线程

5083
03:33:59,239 --> 03:34:03,560
所以每个线程块有 1000 个线程，然后一个（这里“a”后面似乎缺少内容）

5084
03:34:01,239 --> 03:34:05,800
网格中有th000个方块，嗯，这些是

5085
03:34:03,560 --> 03:34:07,960
这些是我们定义的宏，所以如果

5086
03:34:05,800 --> 03:34:09,359
有1000个块，每个块有1000个（这里原句“th000”可能是“thousand”的错误输入） 

5087
03:34:07,960 --> 03:34:11,080
它们内部的线程，然后我们就要开始了

5088
03:34:09,359 --> 03:34:13,399
总共拥有一百万个线程

5089
03:34:11,080 --> 03:34:15,720
对，嗯，然后我们有两个内核。

5090
03:34:13,399 --> 03:34:17,880
这里，所以有一个要对计数进行递增操作

5091
03:34:15,720 --> 03:34:21,000
非原子性地对计数器进行操作，所以它将会

5092
03:34:17,880 --> 03:34:23,199
拿一个柜台，呃，它会被存放到（某个地方）

5093
03:34:21,000 --> 03:34:26,520
所引用的 D 为那个旧值

5094
03:34:23,199 --> 03:34:28,160
计数器 CU，这是一个指针，对吧，嗯

5095
03:34:26,520 --> 03:34:29,720
我们要将新值设置为

5096
03:34:28,160 --> 03:34:31,840
不管这是什么，不管那究竟是什么

5097
03:34:29,720 --> 03:34:34,080
整数值加一，我们只是

5098
03:34:31,840 --> 03:34:36,760
将递增一，然后我们会

5099
03:34:34,080 --> 03:34:40,760
要……嗯，我们要进行更新

5100
03:34:36,760 --> 03:34:42,720
向右反击，嗯，然后有一个…… 

5101
03:34:40,760 --> 03:34:45,199
这个的原子版本，它能完成（此处“does the”后面内容缺失，语义不完整）

5102
03:34:42,720 --> 03:34:47,640
除了它会锁定之外，其他情况都一样，所以

5103
03:34:45,199 --> 03:34:51,840
这边这个部分，嗯，这实际上就像

5104
03:34:47,640 --> 03:34:51,840
你在添加
你实际上是在添加

5105
03:34:52,160 --> 03:34:55,880
呃，不是

5106
03:34:56,680 --> 03:35:00,399
锁着的，而这是

5107
03:35:01,640 --> 03:35:05,840
不是不

5108
03:35:04,000 --> 03:35:07,640
已解锁，那么你应该去……

5109
03:35:05,840 --> 03:35:11,120
在这里锁定，然后在那里解锁，并且

5110
03:35:07,640 --> 03:35:16,120
返回不管是什么的那个东西

5111
03:35:11,120 --> 03:35:18,880
所以我觉得如果那样的话，那是正确的。

5112
03:35:16,120 --> 03:35:21,720
是的

5113
03:35:18,880 --> 03:35:23,359
所以我们下去，这里的一切都是……

5114
03:35:21,720 --> 03:35:25,239
相当直观，我们有数字方块。

5115
03:35:23,359 --> 03:35:26,399
以及我们的线程数量，其理念是

5116
03:35:25,239 --> 03:35:28,359
我们将拥有一百万个线程

5117
03:35:26,399 --> 03:35:30,479
它们都在试图更新这同一个

5118
03:35:28,359 --> 03:35:33,319
同一个计数器，因为我们传递了这个

5119
03:35:30,479 --> 03:35:36,600
这个计数器，这是一个单一变量。

5120
03:35:33,319 --> 03:35:38,840
或者我们传入的一个单独的指针，嗯

5121
03:35:36,600 --> 03:35:42,600
并且所有这些线索都必须得……

5122
03:35:38,840 --> 03:35:44,359
修改同样的东西，对吧，所以当我们

5123
03:35:42,600 --> 03:35:46,760
实际上运行

5124
03:35:44,359 --> 03:35:49,720
这个，你将会看到

5125
03:35:46,760 --> 03:35:53,160
非原子计数器的值是 41，所以这个

5126
03:35:49,720 --> 03:35:55,359
意味着所有这些线程都是

5127
03:35:53,160 --> 03:35:56,520
攻击相同的、相同的内存

5128
03:35:55,359 --> 03:35:59,279
地址，而且它们都在运行着

5129
03:35:56,520 --> 03:36:01,239
同时对它进行修改，但是

5130
03:35:59,279 --> 03:36:02,600
原子级别的（处理）这需要花点时间

5131
03:36:01,239 --> 03:36:04,680
时间可能会更久，也许要一百万年

5132
03:36:02,600 --> 03:36:05,920
操作，而不是 41，但它正在进行

5133
03:36:04,680 --> 03:36:08,800
以确保我们能挺过这一关

5134
03:36:05,920 --> 03:36:10,239
没错，所以它会说“好吧”

5135
03:36:08,800 --> 03:36:12,439
这个线程想要访问它，所以我们

5136
03:36:10,239 --> 03:36:14,279
需要锁定，呃，只锁定这个线程

5137
03:36:12,439 --> 03:36:16,319
可以访问这个值，然后所有的

5138
03:36:14,279 --> 03:36:17,760
其他线程，而不是竞相争夺它

5139
03:36:16,319 --> 03:36:20,600
他们打算就等着，因为这是…… 

5140
03:36:17,760 --> 03:36:22,279
一个原子操作，对吧，所以这个

5141
03:36:20,600 --> 03:36:23,960
一个人先完成，然后

5142
03:36:22,279 --> 03:36:25,760
也许是这个家伙，然后是这个家伙，还有

5143
03:36:23,960 --> 03:36:28,000
然后这个家伙，还有他们，他们全都是一类人（此处“sort”表意较模糊，需结合语境确定更准确意思） 

5144
03:36:25,760 --> 03:36:30,120
完全的嗯，然后你最终会得到

5145
03:36:28,000 --> 03:36:32,720
实际的正确答案是，呃，1

5146
03:36:30,120 --> 03:36:35,239
百万，没错，因为它会递增，呃

5147
03:36:32,720 --> 03:36:38,040
它从……递增

5148
03:36:35,239 --> 03:36:41,279
呃，从……递增自……

5149
03:36:38,040 --> 03:36:42,960
零，所以基本上就是这样了。

5150
03:36:41,279 --> 03:36:46,399
原子性；原子操作；原子类型 （注：需结合具体语境确定最合适的含义） 

5151
03:36:42,960 --> 03:36:47,840
嗯，它们挺酷的，也许你可以

5152
03:36:46,399 --> 03:36:49,800
想一种你可以使用它们的方法

5153
03:36:47,840 --> 03:36:51,279
现在我也不知道，嗯，但那就是…… 

5154
03:36:49,800 --> 03:36:53,439
那只是超级棒的一件事。

5155
03:36:51,279 --> 03:36:55,399
很重要的是要涵盖，因为呃，那是

5156
03:36:53,439 --> 03:36:56,920
这就是……其中一个风险。

5157
03:36:55,399 --> 03:36:58,720
内核是指你有一堆的……

注：你提供的内容似乎不完整，语义不太清晰。 

5158
03:36:56,920 --> 03:37:00,479
这是一系列不同的线索

5159
03:36:58,720 --> 03:37:01,960
访问同样的东西，并且

5160
03:37:00,479 --> 03:37:04,520
做出一些也许你并不想做的改变

5161
03:37:01,960 --> 03:37:06,080
对它，嗯，而且不会出现任何错误

5162
03:37:04,520 --> 03:37:08,399
或者关于它的警告，对吧，就是……就是这样

5163
03:37:06,080 --> 03:37:10,800
你拥有如此多的原子武器是一种危险。（注：原句“so atomics”表述有误，推测可能想表达“so many atomic weapons” ） 

5164
03:37:08,399 --> 03:37:13,120
确保其安全并将其锁定，所以现在我们

5165
03:37:10,800 --> 03:37:14,760
深入了解CUDA流和CUDA流

5166
03:37:13,120 --> 03:37:17,439
是对……来说最有用的东西之一

5167
03:37:14,760 --> 03:37:19,840
性能优化 呃，也许在……

5168
03:37:17,439 --> 03:37:21,319
即使是大型系统，没错，所以这个

5169
03:37:19,840 --> 03:37:22,600
实际上，这尤其在大规模情况下有效。

5170
03:37:21,319 --> 03:37:25,000
系统，你马上就会明白为什么在某个（情况/方面等，需结合前文确定）会这样了 

5171
03:37:22,600 --> 03:37:27,040
第二，在这儿，嗯，所以你可以想象那个

5172
03:37:25,000 --> 03:37:30,359
直觉上，你可以想象一下流的概念

5173
03:37:27,040 --> 03:37:32,239
就像河流流淌，它的……方向是怎样的 

5174
03:37:30,359 --> 03:37:35,800
操作仅在时间上向前流动

5175
03:37:32,239 --> 03:37:39,199
所以你有这样一个时间线，并且这个

5176
03:37:35,800 --> 03:37:42,359
通常的想法是你会复制一些

5177
03:37:39,199 --> 03:37:44,000
数据从主机传输到设备，然后

5178
03:37:42,359 --> 03:37:46,080
你会用那些数据做些事情

5179
03:37:44,000 --> 03:37:48,840
就像一次内核启动，然后你

5180
03:37:46,080 --> 03:37:51,000
会将其从设备复制回主机

5181
03:37:48,840 --> 03:37:52,600
用它做些有用的事，嗯，还有

5182
03:37:51,000 --> 03:37:54,040
你这里有的是，你有这些

5183
03:37:52,600 --> 03:37:56,840
微小的依赖关系，就好像你……

5184
03:37:54,040 --> 03:37:58,199
得等数据出来

5185
03:37:56,840 --> 03:38:00,640
在你实际启动内核之前

5186
03:37:58,199 --> 03:38:02,080
发射 难道你不想一直成为（此处原文表意不太完整通顺，结合语境或许表意会更明确）

5187
03:38:00,640 --> 03:38:03,760
运行内核，而你不一直都是这样吗

5188
03:38:02,080 --> 03:38:05,239
想要把计算做好

5189
03:38:03,760 --> 03:38:07,520
流实际上为……解决了那个问题

5190
03:38:05,239 --> 03:38:09,640
是我们，而不只是一个小小的…… 

5191
03:38:07,520 --> 03:38:11,560
时间轴 你可以添加一个额外的图层

5192
03:38:09,640 --> 03:38:12,880
在它下面也是，甚至，甚至，甚至

5193
03:38:11,560 --> 03:38:17,080
你可以拥有任意多层

5194
03:38:12,880 --> 03:38:19,399
想要，而整个想法是你可以

5195
03:38:17,080 --> 03:38:21,720
复制一些
复制些东西过来
做个

5196
03:38:19,399 --> 03:38:23,800
内核启动，然后在那期间

5197
03:38:21,720 --> 03:38:26,120
内核启动，就像当……当那些事情发生的时候

5198
03:38:23,800 --> 03:38:29,239
被复制过来后，你就可以开始复制了

5199
03:38:26,120 --> 03:38:31,840
接下来的内容在另一个流里

5200
03:38:29,239 --> 03:38:33,720
好的，那么你可以……你要做一些……

5201
03:38:31,840 --> 03:38:35,800
在你复制东西的时候进行计算

5202
03:38:33,720 --> 03:38:39,040
结束，然后当这些内容被复制时

5203
03:38:35,800 --> 03:38:40,439
呃，接下来你可以处理下一个内核了，所以

5204
03:38:39,040 --> 03:38:43,560
它会 它会看起来有点像一个

5205
03:38:40,439 --> 03:38:48,000
楼梯，而且我有这方面的一个例子

5206
03:38:43,560 --> 03:38:51,040
在呃，英伟达的这份文档里，这个

5207
03:38:48,000 --> 03:38:53,960
英伟达流与并发

5208
03:38:51,040 --> 03:38:57,800
幻灯片，嗯，基本上看起来像

5209
03:38:53,960 --> 03:39:00,120
所以你有个，嗯，这东西叫

5210
03:38:57,800 --> 03:39:03,680
异步 CUDA 内存复制，它是

5211
03:39:00,120 --> 03:39:05,160
异步的，嗯，通常情况下如果你是……

5212
03:39:03,680 --> 03:39:07,239
正在做一个串行程序，那是什么

5213
03:39:05,160 --> 03:39:08,720
到目前为止我们合作过的那些，你会去做的

5214
03:39:07,239 --> 03:39:10,760
你会以这种方式前行，在那里

5215
03:39:08,720 --> 03:39:13,800
你 你并不总是在做你想做的事

5216
03:39:10,760 --> 03:39:15,760
就像C语言那样，复制一些东西，然后做些事情

5217
03:39:13,800 --> 03:39:17,960
用它把它复制回来，复制些东西过去

5218
03:39:15,760 --> 03:39:19,880
对背部做些处理，然后在这（种情况下）

5219
03:39:17,960 --> 03:39:24,479
例如，你喜欢复制一堆东西

5220
03:39:19,880 --> 03:39:26,000
通过主机到设备，然后你要做，嗯

5221
03:39:24,479 --> 03:39:28,800
也许

5222
03:39:26,000 --> 03:39:32,840
呃，也许用这个能更好地说明。

5223
03:39:28,800 --> 03:39:35,399
例子就像你，你，你复制了一些 

5224
03:39:32,840 --> 03:39:38,600
在你身上发生的事情，你知道你喜欢做这样的事吗？ 

5225
03:39:35,399 --> 03:39:40,560
比如说连续三颗玉米粒，嗯，还有

5226
03:39:38,600 --> 03:39:42,399
然后，当一个内核正在运行时，你会

5227
03:39:40,560 --> 03:39:44,239
总是在复制新的东西，所以你是

5228
03:39:42,399 --> 03:39:45,920
不是说你不是，你总是在做

5229
03:39:44,239 --> 03:39:48,640
在所有流中开展工作

5230
03:39:45,920 --> 03:39:51,920
对，呃，这非常有用。

5231
03:39:48,640 --> 03:39:55,680
尤其是当你有类似……这样的东西时

5232
03:39:51,920 --> 03:39:57,520
嗯，当你有像训练……这样的事情时

5233
03:39:55,680 --> 03:39:59,760
大型语言模型，就在你……的时候

5234
03:39:57,520 --> 03:40:01,720
当你有这个数据加载器时尝试（去做某事）

5235
03:39:59,760 --> 03:40:04,040
那就像是一直在加载大量内容

5236
03:40:01,720 --> 03:40:05,640
你不想身处其中的大段文字

5237
03:40:04,040 --> 03:40:07,760
只是在等待着你并不想要的东西

5238
03:40:05,640 --> 03:40:09,560
进行你的你的你的训练，然后向前

（注：原英文句子表述不太符合常规语法逻辑） 

5239
03:40:07,760 --> 03:40:11,319
反向传播，然后，然后等待

5240
03:40:09,560 --> 03:40:12,840
再次，你想要，就像你希望它成为的那样

5241
03:40:11,319 --> 03:40:14,120
在你做你的事情的时候加载好了

5242
03:40:12,840 --> 03:40:16,160
像你希望的那样进行前向和反向传播

5243
03:40:14,120 --> 03:40:17,800
把它准备好给你，这样一来你

5244
03:40:16,160 --> 03:40:20,600
你可以直接开始
你可以再做一遍

5245
03:40:17,800 --> 03:40:22,359
所以就像是不停地向前、向后或者向右

5246
03:40:20,600 --> 03:40:24,199
只是你永远都不想停止做那件事

5247
03:40:22,359 --> 03:40:25,600
而且那将会，那将会大幅增加

5248
03:40:24,199 --> 03:40:29,520
性能，所以这就是CUDA的用武之地

5249
03:40:25,600 --> 03:40:31,160
溪流正好流进来，嗯，所以这个，这个

5250
03:40:29,520 --> 03:40:33,439
我正在谈论的整个想法与…… 

5251
03:40:31,160 --> 03:40:35,080
就像在你（做某事）之前获取数据，嗯

5252
03:40:33,439 --> 03:40:36,800
实际上真的需要它，千真万确。

5253
03:40:35,080 --> 03:40:39,120
称为预取软件抽象

5254
03:40:36,800 --> 03:40:41,160
叫做预蚀刻，嗯，所以你移动数据

5255
03:40:39,120 --> 03:40:43,160
根据需要在它周围活动，并且这个

5256
03:40:41,160 --> 03:40:46,920
隐藏数据移动过程中的延迟

5257
03:40:43,160 --> 03:40:49,600
就像CUDA M版权 嗯

5258
03:40:46,920 --> 03:40:52,720
所以我们有这个，我们有这个内核

5259
03:40:49,600 --> 03:40:55,239
启动配置，我们之前见过这个

5260
03:40:52,720 --> 03:40:56,960
有一个网格大小
我们有一个块大小

5261
03:40:55,239 --> 03:40:59,000
对，然后还有另外两个

5262
03:40:56,960 --> 03:41:02,760
我所谈论的事情，它们是

5263
03:40:59,000 --> 03:41:04,840
现在这里显示的是字节数

5264
03:41:02,760 --> 03:41:06,600
在共享内存中，没错，所以你……你……

5265
03:41:04,840 --> 03:41:08,080
用共享内存做一些事情，这些事情…… （这里“which”后面内容缺失，句子不完整）

5266
03:41:06,600 --> 03:41:10,160
现在甚至都别去担心那个。

5267
03:41:08,080 --> 03:41:13,279
然后还有另外一个，它……

5268
03:41:10,160 --> 03:41:15,800
关联的流是否正确，所以你

5269
03:41:13,279 --> 03:41:20,120
实际上可以给一个……施加特定的电流

5270
03:41:15,800 --> 03:41:21,479
就像我们在这里展示的那样进行流式传输，嗯，你

5271
03:41:20,120 --> 03:41:22,920
可以拥有，这些都是不同的

5272
03:41:21,479 --> 03:41:25,359
流 流一 流二 流

5273
03:41:22,920 --> 03:41:27,439
三流四流，所以你有……你……你

5274
03:41:25,359 --> 03:41:28,760
在流一上启动这个，以此类推

5275
03:41:27,439 --> 03:41:31,000
对，所以那就是整个想法。

5276
03:41:28,760 --> 03:41:34,120
那里；那儿

5277
03:41:31,000 --> 03:41:36,000
嗯，而且这个，这个，这简直太棒了

5278
03:41:34,120 --> 03:41:38,520
与流进行交互的简单方法

5279
03:41:36,000 --> 03:41:39,600
当我们进行我们上校发起的行动时，就在那里

5280
03:41:38,520 --> 03:41:41,040
有很多事情接踵而至

5281
03:41:39,600 --> 03:41:44,319
在这里，当我们处理流的时候，所以

5282
03:41:41,040 --> 03:41:45,760
你会遇到这种关于，呃，优先级的问题

5283
03:41:44,319 --> 03:41:48,690
所以创建具有不同（特点）的流

注：由于原文未完整，这里的“特点”是根据常见情况推测补充，以让句子表意更完整。 

5284
03:41:45,760 --> 03:41:51,000
优先事项，如果我们深入探讨

5285
03:41:48,690 --> 03:41:53,520
[音乐]

5286
03:41:51,000 --> 03:41:56,720
嗯，我不知道它是否在这个里面。

5287
03:41:53,520 --> 03:41:59,880
也许这个脚本，如果我们看一下……

5288
03:41:56,720 --> 03:42:02,680
获取优先级范围
在这里我们可以看到，嗯

5289
03:41:59,880 --> 03:42:04,960
这至少接受一个指向……的指针

5290
03:42:02,680 --> 03:42:07,920
优先级 整型 只是一个变量，然后一个

5291
03:42:04,960 --> 03:42:09,279
最大的优先级整数，所以就好像

5292
03:42:07,920 --> 03:42:11,880
这是我们最不优先考虑的事情
我们要去做的事里，这是优先级最低的 

5293
03:42:09,279 --> 03:42:13,800
所以我们要把这个插在这里，呃

5294
03:42:11,880 --> 03:42:15,399
然后我们有一个最优先事项

5295
03:42:13,800 --> 03:42:18,159
我们把哪个（值）插在这里，对吧，然后

5296
03:42:15,399 --> 03:42:22,239
那就是我们的范围，并且

5297
03:42:18,159 --> 03:42:24,600
所以我们可以把这些数据输入进去，这样就能让英伟达CUDA（计算统一设备架构）…… 

5298
03:42:22,239 --> 03:42:27,120
实际上会管理哪些能获得更多

5299
03:42:24,600 --> 03:42:28,720
比其他的更优先，所以如果你想

5300
03:42:27,120 --> 03:42:30,520
呃，先导入大量数据，然后

5301
03:42:28,720 --> 03:42:32,479
那是你最初的优先事项，你想

5302
03:42:30,520 --> 03:42:34,239
比如尽快把那部分做完

5303
03:42:32,479 --> 03:42:36,479
也许你实际上可以进行优先级排序

5304
03:42:34,239 --> 03:42:39,040
呃，就是关于最小和最大的方面

5305
03:42:36,479 --> 03:42:42,840
优先权

5306
03:42:39,040 --> 03:42:46,399
嗯，然后我们再稍微……

5307
03:42:42,840 --> 03:42:49,080
再往下一点儿

5308
03:42:46,399 --> 03:42:54,479
并且我们这里有一些例子，所以让我

5309
03:42:49,080 --> 03:42:55,960
这里只涉及一些基础知识，所以会有

5310
03:42:54,479 --> 03:42:58,080
一些你可能没见过的东西

5311
03:42:55,960 --> 03:43:00,720
在那之前，我可能之前就用过了，但是

5312
03:42:58,080 --> 03:43:02,800
我确实提到过，这些是宏，呃

5313
03:43:00,720 --> 03:43:05,239
这些是错误检查宏，它们

5314
03:43:02,800 --> 03:43:08,760
我们必须从根本上确保

5315
03:43:05,239 --> 03:43:11,359
操作顺利进行，所以

5316
03:43:08,760 --> 03:43:13,080
当 当我们像库达·马利克那样做的时候 我们

5317
03:43:11,359 --> 03:43:15,279
想确保那个那个那个那个

5318
03:43:13,080 --> 03:43:17,080
顺利地向右进行了，然后那就只会

5319
03:43:15,279 --> 03:43:20,040
这将会

5320
03:43:17,080 --> 03:43:22,520
嗯，这将返回一个CUDA错误类型

5321
03:43:20,040 --> 03:43:24,439
意味着要么成功，要么出错，比如

5322
03:43:22,520 --> 03:43:26,359
失败 正好 表明是否那个

5323
03:43:24,439 --> 03:43:29,399
是否经历过 嗯 所以 就是那样

5324
03:43:26,359 --> 03:43:31,880
那是什么以及

5325
03:43:29,399 --> 03:43:33,479
然后如果我们再往下滚动一点

5326
03:43:31,880 --> 03:43:36,760
看看实际的溪流在哪里

5327
03:43:33,479 --> 03:43:40,479
正在发生 嗯 保持在……里

5328
03:43:36,760 --> 03:43:43,960
注意一下，在这里我们使用这个 CUDA 流

5329
03:43:40,479 --> 03:43:45,720
类型，没错，这是一个 CUDA 流类型

5330
03:43:43,960 --> 03:43:47,359
并且我们定义两个流，即流 1

5331
03:43:45,720 --> 03:43:51,159
和；并且；然后；又

5332
03:43:47,359 --> 03:43:53,479
二、我们创建流 所以实际上我们

5333
03:43:51,159 --> 03:43:55,120
必须为此设置自定义的呃处理程序

5334
03:43:53,479 --> 03:43:56,600
就说“好吧，你做了这个，你做了”

5335
03:43:55,120 --> 03:43:58,199
你已经定义了它，就好像现在你必须要…… 

5336
03:43:56,600 --> 03:44:00,239
实际上把这东西做出来 这是一个 这是一个

5337
03:43:58,199 --> 03:44:02,800
英伟达有个奇怪的语境相关的东西，但它…… 

5338
03:44:00,239 --> 03:44:04,880
它能确保一切都是安全的，嗯，还有

5339
03:44:02,800 --> 03:44:06,560
由……妥善处理

5340
03:44:04,880 --> 03:44:09,439
编译器

5341
03:44:06,560 --> 03:44:11,120
所以我们得到了另一个术语“库达姆·妈妈拷贝”

5342
03:44:09,439 --> 03:44:13,680
异步，并且从本质上来说，这仅仅是允许

5343
03:44:11,120 --> 03:44:15,359
让我们，呃，有这种异步的…… 

5344
03:44:13,680 --> 03:44:18,239
副本 我是说当你有这些的时候

5345
03:44:15,359 --> 03:44:21,040
如果按顺序排列，就像你去进行相机复制异步操作那样

5346
03:44:18,239 --> 03:44:23,239
在第一条流上，然后稍后你会有

5347
03:44:21,040 --> 03:44:25,399
像，像，像一次内核启动，像

5348
03:44:23,239 --> 03:44:28,040
就在它的正下方，嗯，它实际上会过去

5349
03:44:25,399 --> 03:44:29,520
按照那个顺序，所以它不会，仅仅是它不会

5350
03:44:28,040 --> 03:44:31,680
嗯，它不会尝试像内核那样去做。

5351
03:44:29,520 --> 03:44:33,720
提前启动，因为这是异步的。

5352
03:44:31,680 --> 03:44:35,720
嗯，它只会是异步的，意思是在…… 

5353
03:44:33,720 --> 03:44:39,239
流的上下文，这样你就可以拥有

5354
03:44:35,720 --> 03:44:41,279
我猜事情有点，嗯，正在发生

5355
03:44:39,239 --> 03:44:43,199
同时，嗯，但它仍然会遵循

5356
03:44:41,279 --> 03:44:46,080
该信息流中的先后顺序

5357
03:44:43,199 --> 03:44:48,319
只要你把它们分配到同一个（地方/类别等，需结合上下文确定具体含义）

5358
03:44:46,080 --> 03:44:50,520
呃，那么接下来我们有用于……的线了 

5359
03:44:48,319 --> 03:44:53,080
块和每个网格的块配置

5360
03:44:50,520 --> 03:44:56,680
我们在第一频道上推出这个，而且我们有

5361
03:44:53,080 --> 03:44:58,159
这个 这个 B 这个 呃 这个 B 呃 数组开启

5362
03:44:56,680 --> 03:45:01,319
在直播中

5363
03:44:58,159 --> 03:45:03,080
2 而且我们也可以用它来做些事情

5364
03:45:01,319 --> 03:45:04,720
那么，然后注意我们是如何拥有这个……（这里“the”后面内容缺失，表述不完整） 

5365
03:45:03,080 --> 03:45:06,560
注释 复制 输入设备

5366
03:45:04,720 --> 03:45:08,359
异步地，所以这只是一小点

5367
03:45:06,560 --> 03:45:11,040
作弊，在本该……而不是……的地方

5368
03:45:08,359 --> 03:45:13,680
正在复制，正在复制，呃，从托管设备复制

5369
03:45:11,040 --> 03:45:16,560
然后将 B 从托管设备复制到……呃

5370
03:45:13,680 --> 03:45:18,319
顺序上你是依次进行，但同时你也在这么做

注：原英文句子表述不太符合常见语法习惯，此翻译尽量贴近原文表意。 

5371
03:45:16,560 --> 03:45:19,720
A 被复制，并且 B 在……时被复制

5372
03:45:18,319 --> 03:45:21,600
同一时间，然后你就不会有这个情况了

5373
03:45:19,720 --> 03:45:23,080
这里有额外的障碍，就好像什么都没有，不……

5374
03:45:21,600 --> 03:45:26,880
工作正在进行，你可以直接获取

5375
03:45:23,080 --> 03:45:28,520
对，呃，内核计算的权利，对，嗯

5376
03:45:26,880 --> 03:45:30,800
所以我们看到这里有一条小溪

5377
03:45:28,520 --> 03:45:32,720
一，开始
二，然后这就全部完成了

5378
03:45:30,800 --> 03:45:36,680
在第一流上 所以这一切 这一切

5379
03:45:32,720 --> 03:45:39,600
内存将会被共享，嗯

5380
03:45:36,680 --> 03:45:41,880
呃，然后我们再往这下面看，你（这里原文“this you”表述不太符合常见规范，翻译可能需要结合具体语境进一步准确理解） 

5381
03:45:39,600 --> 03:45:43,600
知道，我们重复，我们重复 C 内容

5382
03:45:41,880 --> 03:45:44,720
异步地，但只有一个，所以

5383
03:45:43,600 --> 03:45:47,080
选择哪条溪流其实并不重要

5384
03:45:44,720 --> 03:45:50,520
嗯，那是因为我们只进行异步操作。 

5385
03:45:47,080 --> 03:45:51,960
为什么不，然后让数据流同步

5386
03:45:50,520 --> 03:45:54,040
所以我们要确保所有的

5387
03:45:51,960 --> 03:45:56,560
水流随后被卷入，然后我们

5388
03:45:54,040 --> 03:45:58,040
呃……然后我们可以用……做点什么

5389
03:45:56,560 --> 03:46:02,080
没错，所以我们接下来要，你知道的

5390
03:45:58,040 --> 03:46:04,319
释放设备，从公元前（这里“viice”可能是拼写错误，推测想说“vice”，但结合整体语义不太能确定准确含义），然后

5391
03:46:02,080 --> 03:46:05,920
摧毁这两条溪流，呃，然后

5392
03:46:04,319 --> 03:46:09,199
然后就完成了，所以如果我继续进行

5393
03:46:05,920 --> 03:46:09,199
并且实际进行编译和运行

5394
03:46:13,239 --> 03:46:17,680
这次测试通过了，我们得到了一切

5395
03:46:15,920 --> 03:46:20,040
正确地，而且我们完成了这个向量

5396
03:46:17,680 --> 03:46:22,680
此外，嗯，所以这有点像是……是什么情况呢 

5397
03:46:20,040 --> 03:46:24,120
我们所有人在这里真正做的只是

5398
03:46:22,680 --> 03:46:26,680
呃，这就是奇迹发生的地方。

5399
03:46:24,120 --> 03:46:29,600
我们不是先加载 A 然后加载 B，而是加载…… 

5400
03:46:26,680 --> 03:46:32,359
同时按下 A 和 B 嗯 然后我们继续

5401
03:46:29,600 --> 03:46:34,199
嗯，那是什么？

5402
03:46:32,359 --> 03:46:37,239
被称为；叫做；打电话

（注：“called”是“call”的过去式和过去分词形式，具体意思需结合语境确定，这里列出常见释义。） 

5403
03:46:34,199 --> 03:46:39,840
先进的，所以要把这个调低一点

5404
03:46:37,239 --> 03:46:41,399
所以你能看到，当我们进入……的时候 

5405
03:46:39,840 --> 03:46:43,920
高级流，事情变得有点

5406
03:46:41,399 --> 03:46:45,319
有点怪异，呃，但也没那么离谱，所以

5407
03:46:43,920 --> 03:46:48,399
有几件事是我想做的（这里原句不完整，推测可能表达“有几件事是我想……” ）

5408
03:46:45,319 --> 03:46:52,520
介绍一下，在这里我们有固定内存，所以

5409
03:46:48,399 --> 03:46:56,439
从本质上来说，它是在说在 CPU 上，呃

5410
03:46:52,520 --> 03:46:57,760
环球医生 它要把这个保留下来

5411
03:46:56,439 --> 03:47:01,439
一段我们即将面对的回忆 我们要……

5412
03:46:57,760 --> 03:47:02,800
打算用库达·马利克主机来固定它 嗯

5413
03:47:01,439 --> 03:47:05,279
发送它，就说你知道这是一个

5414
03:47:02,800 --> 03:47:07,159
Cuda的一部分是预留用于，呃，那个…… 

5415
03:47:05,279 --> 03:47:08,880
稍后要使用的GPU，所以我们不会……

5416
03:47:07,159 --> 03:47:11,000
修改一下，我们不会让那个……

5417
03:47:08,880 --> 03:47:12,640
操作系统或者任何可以与之交互的东西

5418
03:47:11,000 --> 03:47:13,960
这个，我们就把它固定一下，没别的事

5419
03:47:12,640 --> 03:47:15,680
可以触摸它，然后我们要去……

5420
03:47:13,960 --> 03:47:16,840
把那个拖到别的地方留着以后用

5421
03:47:15,680 --> 03:47:19,120
而且我们就打算先预留着

5422
03:47:16,840 --> 03:47:20,080
没错，嗯，所以我们打算用这个

5423
03:47:19,120 --> 03:47:21,520
我们待会儿会用到这个，所以

5424
03:47:20,080 --> 03:47:23,880
不玩它是一种很好的方式来……（原文句子似乎不完整）

5425
03:47:21,520 --> 03:47:27,600
想想这个

5426
03:47:23,880 --> 03:47:31,399
嗯，事件是使用过程中的关键部分。

5427
03:47:27,600 --> 03:47:34,520
流，这样我们就可以测量内核

5428
03:47:31,399 --> 03:47:37,520
执行时间，鉴于这个，呃，鉴于这个

5429
03:47:34,520 --> 03:47:39,960
这里是个例子，所以我们有一个事件类型

5430
03:47:37,520 --> 03:47:42,720
开始和停止，所以这些不（这么做） 

5431
03:47:39,960 --> 03:47:46,399
实际上，时间……但他们是，嗯……

5432
03:47:42,720 --> 03:47:49,080
它们是这些……输入的一部分

5433
03:47:46,399 --> 03:47:50,520
事件 事件记录功能，所以我们开始

5434
03:47:49,080 --> 03:47:52,880
并带着这份记忆去创造这些东西

5435
03:47:50,520 --> 03:47:54,520
起始地址和终止地址，然后我们

5436
03:47:52,880 --> 03:47:57,199
例如，可以接入任何流。

5437
03:47:54,520 --> 03:47:59,560
只播放直播流，或者选择直播流一，或者选择直播流二

5438
03:47:57,199 --> 03:48:03,080
我们 我们举办一场活动

5439
03:47:59,560 --> 03:48:05,680
记录，我们确实……呃，我们在……上启动我们的内核。

5440
03:48:03,080 --> 03:48:08,239
这次直播，然后我们再举办一场活动

5441
03:48:05,680 --> 03:48:11,760
记录，嗯，在这个里面

5442
03:48:08,239 --> 03:48:14,920
流式传输，并且我们可以获取这些值

5443
03:48:11,760 --> 03:48:16,960
开始和停止，而且它们可能会承载

5444
03:48:14,920 --> 03:48:20,279
元数据 我不太清楚具体如何使用CUDA

5445
03:48:16,960 --> 03:48:23,040
处理这个，但开始和停止我们可以做到

5446
03:48:20,279 --> 03:48:24,840
呃，同步，我们可以进行同步，呃

5447
03:48:23,040 --> 03:48:28,239
所有内容，然后我们就可以把它代入到……中

5448
03:48:24,840 --> 03:48:30,520
采用此方法时的 CUDA 事件间隔时间

5449
03:48:28,239 --> 03:48:31,840
毫秒（浮点数）呃，这将会……

5450
03:48:30,520 --> 03:48:33,439
就几毫秒，然后你就有你的（东西/成果等，需结合上下文明确指代）

5451
03:48:31,840 --> 03:48:35,880
开始和停止，那将表明

5452
03:48:33,439 --> 03:48:38,359
你（这里原句可能表述有误，推测可能是“请问”之类的意思）你的内核运行了多长时间

5453
03:48:35,880 --> 03:48:41,080
好的，所以不要在……里启动它

5454
03:48:38,359 --> 03:48:43,520
而不是进入国立中央大学

注：“ncu”一般指“National Central University（国立中央大学）” ，如果这里 “ncu” 有其他所指，请结合具体语境调整。 

5455
03:48:41,080 --> 03:48:45,840
侧写师 如果你愿意的话，你可以这样做 

5456
03:48:43,520 --> 03:48:47,920
你想这么做，而这不会（成功/起作用等，需结合语境确定准确含义） 

5457
03:48:45,840 --> 03:48:49,720
有任何计算开销吗，还是它是……

5458
03:48:47,920 --> 03:48:51,080
非常简约，所以这个可以在类似的（环境）中运行

5459
03:48:49,720 --> 03:48:54,080
生产环境，实际上并非如此

5460
03:48:51,080 --> 03:48:56,319
不会让你花任何钱，嗯，然后

5461
03:48:54,080 --> 03:49:01,600
你拥有……之间的同步

5462
03:48:56,319 --> 03:49:05,080
溪流 所以 嗯 从本质上来说 这些事件

5463
03:49:01,600 --> 03:49:06,960
将同步 它们将被放置在

5464
03:49:05,080 --> 03:49:09,560
单独的数据流，所以，与其采用……

5465
03:49:06,960 --> 03:49:11,520
整个设备或所有流

5466
03:49:09,560 --> 03:49:13,479
那只是一条特定的水流，对吧？

5467
03:49:11,520 --> 03:49:16,159
这就是关于这些……嗯……以及……的整体想法。

5468
03:49:13,479 --> 03:49:18,800
那么当然，你可以进行重叠，呃

5469
03:49:16,159 --> 03:49:21,239
计算、数据传输以及，呃，与……（这里文本似乎不完整） 

5470
03:49:18,800 --> 03:49:23,040
我们之前讨论过的预取理念

5471
03:49:21,239 --> 03:49:27,880
呃，在那之前，我

5472
03:49:23,040 --> 03:49:29,720
相信预取，是的，所以事件是

5473
03:49:27,880 --> 03:49:31,040
这很棒，嗯，然后我们有

5474
03:49:29,720 --> 03:49:32,960
稍微被使用的回调函数

5475
03:49:31,040 --> 03:49:34,840
不同地，你 你基本上可以设置

5476
03:49:32,960 --> 03:49:37,319
搭建一条管道，在这条管道中，当……完成时（此处“the completion of”后面内容缺失）

5477
03:49:34,840 --> 03:49:39,319
在图形处理器（GPU）上的一次操作触发了

5478
03:49:37,319 --> 03:49:42,159
在CPU上另一个（进程等）的开始，所以这是

5479
03:49:39,319 --> 03:49:44,279
会有更多的额外开销，但如果

5480
03:49:42,159 --> 03:49:45,479
当某件事情发生时，你想进行记录。

5481
03:49:44,279 --> 03:49:48,120
当你想在某事发生时进行记录

5482
03:49:45,479 --> 03:49:50,680
如果这发生在你的图形处理器（GPU）上，那么你可以使用一个

5483
03:49:48,120 --> 03:49:53,920
回电 嗯，所以在这种情况下我们

5484
03:49:50,680 --> 03:49:55,680
有一个内核，呃，然后你知道在……

5485
03:49:53,920 --> 03:49:58,399
就像我们有，我们有一个，比如说，就像

5486
03:49:55,680 --> 03:50:00,720
一些流，比如一号流，然后我们

5487
03:49:58,399 --> 03:50:03,120
在……之后马上回这个电话

5488
03:50:00,720 --> 03:50:05,399
内核，所以在时间线里它将会

5489
03:50:03,120 --> 03:50:06,880
显示为内核和 CUDA 流于

5490
03:50:05,399 --> 03:50:09,760
回调就按照它们原本的方式进行

5491
03:50:06,880 --> 03:50:12,680
就像代码里从上到下那样，如果

5492
03:50:09,760 --> 03:50:14,720
他们在同一条溪流里，嗯，然后我们把…… 

5493
03:50:12,680 --> 03:50:17,199
这个，这个回电，然后那就是……

5494
03:50:14,720 --> 03:50:19,319
当这件事结束时，究竟要说什么呢（注：原英文“entally”疑似拼写错误，可能是“eventually” ）

5495
03:50:17,199 --> 03:50:22,199
当 当这结束后，我们要去……

5496
03:50:19,319 --> 03:50:25,199
调用这个函数

5497
03:50:22,199 --> 03:50:29,239
嗯，它只是要打印“GPU”。

5498
03:50:25,199 --> 03:50:30,680
操作已完成
没错，所以那是，呃

5499
03:50:29,239 --> 03:50:31,880
那那只是……的一种应用场景

5500
03:50:30,680 --> 03:50:33,080
回调函数，你可能不会全部用到它们

5501
03:50:31,880 --> 03:50:34,319
届时你可能会用到事件

5502
03:50:33,080 --> 03:50:36,000
如果你真的想得到，还会更多

5503
03:50:34,319 --> 03:50:38,080
把那些优化方案先放一边，咱们继续吧

5504
03:50:36,000 --> 03:50:41,199
往前看，然后看看那个，呃，高级的（东西）

5505
03:50:38,080 --> 03:50:44,840
所以这里是部分内容

5506
03:50:41,199 --> 03:50:46,840
嗯，我们有，我们有内核一，它是

5507
03:50:44,840 --> 03:50:48,399
将乘以二，然后我们得到

5508
03:50:46,840 --> 03:50:50,760
内核 2，它将全部加 1

5509
03:50:48,399 --> 03:50:52,600
没错，非常简单的操作，我们有我们的

5510
03:50:50,760 --> 03:50:54,359
回电到这里
流媒体回电

5511
03:50:52,600 --> 03:50:57,000
操作已完成
只需打印
打印出来

5512
03:50:54,359 --> 03:50:58,720
当某件事发生了，对，嗯，还有

5513
03:50:57,000 --> 03:51:01,359
然后就有点像从顶部流淌下来

5514
03:50:58,720 --> 03:51:03,840
到底部这里，我们进行我们的 CUDA 流操作

5515
03:51:01,359 --> 03:51:05,800
类型 所以我们只是声明一些流 我们

5516
03:51:03,840 --> 03:51:08,680
有我们的CUDA事件类型，我们只是

5517
03:51:05,800 --> 03:51:10,120
打算初始化一个事件，嗯，我们可以

5518
03:51:08,680 --> 03:51:11,640
打印出不管那是什么事件，我当时是……

5519
03:51:10,120 --> 03:51:14,159
早些时候在测试，所以才这样，这就是原因

5520
03:51:11,640 --> 03:51:18,040
还在这儿呢 嗯 我们做我们的库达玛利克（注：“Cuda malic”可能是特定的名称或表述，不太明确其准确含义，需结合更多语境） 

5521
03:51:14,159 --> 03:51:21,479
那个固定内存的主机，嗯，我们可以

5522
03:51:18,040 --> 03:51:24,520
阿马利克，我们的……我们的设备

5523
03:51:21,479 --> 03:51:27,159
数据 我们尽我们最大的努力 也承受我们最小的能力（此句英文表意不太清晰，可能存在表述问题，这只是大致按照字面的翻译） 

5524
03:51:24,520 --> 03:51:30,239
就像我之前说的那些优先事项

5525
03:51:27,159 --> 03:51:32,680
在呃，我们真正开始创作之前

5526
03:51:30,239 --> 03:51:35,560
使用之前的内容来描述这个事件本身

5527
03:51:32,680 --> 03:51:40,120
我们在这里初始化的事件类型以及

5528
03:51:35,560 --> 03:51:43,399
然后我们，嗯，我们会做我们的，你知道的，呃，CUDA（计算统一设备架构）相关的事。 

5529
03:51:40,120 --> 03:51:44,880
CUDA 内存复制异步操作 呃 我们 我们启动一个

5530
03:51:43,399 --> 03:51:46,680
内核，然后事情就到这里了

5531
03:51:44,880 --> 03:51:49,399
开始变得有点棘手了，我会做的

5532
03:51:46,680 --> 03:51:51,840
我尽力解释，所以当我们使用CUDA时

5533
03:51:49,399 --> 03:51:53,760
事件记录，它将会放置一个……（原句似乎不完整） 

5534
03:51:51,840 --> 03:51:55,560
像一个小对勾那样的小标记，对吧

5535
03:51:53,760 --> 03:51:57,720
在那条溪流里，所以我们有溪流一号。

5536
03:51:55,560 --> 03:51:59,120
嗯，你知道的，这是在直播呢。 

5537
03:51:57,720 --> 03:52:01,399
这个在直播中
这个在直播中

5538
03:51:59,120 --> 03:52:03,319
其一，所以你要去做你的文案了

5539
03:52:01,399 --> 03:52:04,960
从托管设备，然后你要去

5540
03:52:03,319 --> 03:52:07,479
先处理核心部分，然后你就可以继续了

5541
03:52:04,960 --> 03:52:11,279
在这里画一个小对勾，嗯

5542
03:52:07,479 --> 03:52:14,960
而这所表明的是

5543
03:52:11,279 --> 03:52:16,760
嗯，我们可能想在某个时候做点什么。

5544
03:52:14,960 --> 03:52:18,680
当达到这个程度时，注意观察是怎样的情况

5545
03:52:16,760 --> 03:52:21,680
这就在我们的内核正下方，所以当……

5546
03:52:18,680 --> 03:52:23,920
内核完成时，它就结束了。

5547
03:52:21,680 --> 03:52:26,040
呃，这将会……这是……这是……

5548
03:52:23,920 --> 03:52:27,880
马上要触发了，然后我们会有

5549
03:52:26,040 --> 03:52:29,800
这场流重赛事规模有点小

注：你提供的英文表述不太符合常见规范，“stream weight”可能不是常见搭配或存在拼写错误，以上是根据字面进行的大致翻译。 

5550
03:52:27,880 --> 03:52:32,840
依赖关系，所以从本质上来说它将会

5551
03:52:29,800 --> 03:52:34,720
等所有事情，呃，直到直播的时候再说

5552
03:52:32,840 --> 03:52:37,439
完成第一阶段的直播，然后就接着进行下去

5553
03:52:34,720 --> 03:52:39,880
从第二环节开始，那么就是第二环节

5554
03:52:37,439 --> 03:52:43,080
实际上必须等待这种情况发生

5555
03:52:39,880 --> 03:52:45,000
注意看我们是如何传入呃 一个流的，我们

5556
03:52:43,080 --> 03:52:46,800
这是第二流，所以是流 2

5557
03:52:45,000 --> 03:52:49,520
会像上校那样开始行动起来

5558
03:52:46,800 --> 03:52:51,840
执行以及回调，嗯，我们

5559
03:52:49,520 --> 03:52:55,399
不得不等待

5560
03:52:51,840 --> 03:52:57,120
因为它去了哪里，我们必须等待

5561
03:52:55,399 --> 03:52:58,600
这个事件要先触发，而且那是……

5562
03:52:57,120 --> 03:53:01,000
本质上，这一切就是它只是在等待

5563
03:52:58,600 --> 03:53:03,120
为它做准备，然后它在直播中开始……（这里“to”后面内容缺失，译文表意可能不完整） 

5564
03:53:01,000 --> 03:53:04,640
当所有这些之前的…… 

5565
03:53:03,120 --> 03:53:08,159
已完成

5566
03:53:04,640 --> 03:53:10,479
对，或者至少呃，其他所有的事情

5567
03:53:08,159 --> 03:53:14,120
其他所有内容都在流 一流 一中 所以

5568
03:53:10,479 --> 03:53:16,239
那么这两个，接着第二条数据流出现了

5569
03:53:14,120 --> 03:53:19,680
此事完成之后，在我们真正……之后

5570
03:53:16,239 --> 03:53:22,680
完成了我们的内核

5571
03:53:19,680 --> 03:53:24,800
执行，然后流 2 正在运行

5572
03:53:22,680 --> 03:53:26,319
来运行这个第二个内核，所以它只是

5573
03:53:24,800 --> 03:53:29,800
它只是以那种方式进行了某种排序，所以

5574
03:53:26,319 --> 03:53:30,840
你有异步 CM 复制内核这一个

5575
03:53:29,800 --> 03:53:33,000
然后它将等待那件事的发生（此处“that”指代不明，可结合上下文理解）

5576
03:53:30,840 --> 03:53:35,199
完成后进入第二流程

5577
03:53:33,000 --> 03:53:37,439
它要开始了，嗯，它要……

5578
03:53:35,199 --> 03:53:41,199
启动第二次内核执行，并且

5579
03:53:37,439 --> 03:53:43,080
那么，当这件事完成后，所以，当……嗯

5580
03:53:41,199 --> 03:53:44,960
一旦我们完成这一点，这就像

5581
03:53:43,080 --> 03:53:46,520
时间轴上的另一个标记

5582
03:53:44,960 --> 03:53:49,040
它要等所有那些事情都…… 

5583
03:53:46,520 --> 03:53:50,800
完成，然后它会说“好的”

5584
03:53:49,040 --> 03:53:52,000
太棒了，我们现在可以回拨，然后

5585
03:53:50,800 --> 03:53:53,439
然后它将上升到这个程度

5586
03:53:52,000 --> 03:53:56,800
函数在这里，它将要并且它会

5587
03:53:53,439 --> 03:53:59,479
打算去做那个，嗯，所以那只是一种（情况/方式等，需结合上下文确定“kind”具体含义）

5588
03:53:56,800 --> 03:54:02,319
就像一个接一个地走过呃

5589
03:53:59,479 --> 03:54:05,479
那里发生了什么事

5590
03:54:02,319 --> 03:54:08,399
嗯，然后我们就把内容复制回帖子里。

5591
03:54:05,479 --> 03:54:11,239
使用CUDA 进行CUDA内存异步复制 呃 以及

5592
03:54:08,399 --> 03:54:13,000
然后，最后我们总是想呃

5593
03:54:11,239 --> 03:54:14,199
同步我们的数据流，这样我们就能拥有全部

5594
03:54:13,000 --> 03:54:16,199
这些正在发生的溪流，我们已经

5595
03:54:14,199 --> 03:54:17,920
只是又增添了一层复杂性

5596
03:54:16,199 --> 03:54:19,640
我们也需要把那些同步好。

5597
03:54:17,920 --> 03:54:20,680
没错，这就是整个设备

5598
03:54:19,640 --> 03:54:22,439
同步的，就像你一样

5599
03:54:20,680 --> 03:54:24,159
同步其中的所有线程

5600
03:54:22,439 --> 03:54:25,680
设备，然后有这么一个，它…… 

5601
03:54:24,159 --> 03:54:27,479
处于溪流的层面，所以你有

5602
03:54:25,680 --> 03:54:29,880
比如也许直播一、二、三、四，还有你

5603
03:54:27,479 --> 03:54:32,239
就等着他们所有人都结束

5604
03:54:29,880 --> 03:54:33,560
嗯，在你……在你继续之前，对吧

5605
03:54:32,239 --> 03:54:37,159
你等他们所有人都追上来，通过……（这里“by”之后原文不完整，所以“通过……”表述暂不准确） 

5606
03:54:33,560 --> 03:54:38,239
加一个小障碍物，挡住，嗯，还有

5607
03:54:37,159 --> 03:54:40,000
而这就是这里正在发生的事情，并且

5608
03:54:38,239 --> 03:54:41,359
然后我们就把所有这些都毁掉，我们

5609
03:54:40,000 --> 03:54:43,359
基本上就是把所有这些都移除掉

5610
03:54:41,359 --> 03:54:45,279
背景信息，然后我们就可以开始了，所以

5611
03:54:43,359 --> 03:54:47,159
呃，这就是直播的运作方式，这就是

5612
03:54:45,279 --> 03:54:51,600
这个高级的东西在……下面是如何运作的

5613
03:54:47,159 --> 03:54:51,600
嘿，嗯，如果我继续往前跑的话

5614
03:54:56,239 --> 03:55:01,720
所以我们注意到当我们……的时候，我们是怎样……

5615
03:54:58,880 --> 03:55:03,319
正在打印，呃，它（打印内容）去哪里了，什么时候（消失的）

5616
03:55:01,720 --> 03:55:05,600
我们正在打印活动 活动

5617
03:55:03,319 --> 03:55:07,600
只是一个指针，所以它就像一个……它是

5618
03:55:05,600 --> 03:55:11,920
就像一个内存地址之类的东西，并且

5619
03:55:07,600 --> 03:55:14,560
然后我们完成了我们的手术。 

5620
03:55:11,920 --> 03:55:16,560
所以当我们和……一起的时候，就是我们做这件事的时候

5621
03:55:14,560 --> 03:55:19,640
回这个电话，然后我们就结束

5622
03:55:16,560 --> 03:55:20,960
之后测试也通过了，所以，呃

5623
03:55:19,640 --> 03:55:22,920
你知道，只是回溯到那件事上

5624
03:55:20,960 --> 03:55:24,159
英伟达图表，包含所有的……（这里原文“all the all the”表述有误或不完整） 

5625
03:55:22,920 --> 03:55:26,880
像那样不同的流派，那就是

5626
03:55:24,159 --> 03:55:29,279
本质上你所关心的事情

5627
03:55:26,880 --> 03:55:30,760
好啦，我希望上一部分不会太……

5628
03:55:29,279 --> 03:55:33,159
从概念上来说，对你而言那是……

（原句不完整，可能影响语义的准确传达） 

5629
03:55:30,760 --> 03:55:35,880
通常情况下，呃，人们会在某种程度上……

5630
03:55:33,159 --> 03:55:38,560
分解并质疑很多的……（此处原文“and and”可能有误，正确的可能是“and” ）

5631
03:55:35,880 --> 03:55:40,000
事情 这可能很难，但是

5632
03:55:38,560 --> 03:55:41,960
不管怎样，我很高兴你挺过来了。

5633
03:55:40,000 --> 03:55:43,439
可以随时重新观看某些部分，也就是说

5634
03:55:41,960 --> 03:55:46,040
这其中最具挑战性的部分之一

5635
03:55:43,439 --> 03:55:48,640
当然，有很多内容需要剖析，这非常…… 

5636
03:55:46,040 --> 03:55:50,279
在空间上具有直观性，但这部分是

5637
03:55:48,640 --> 03:55:53,080
按理说在空间方面不是很…… （注：原英文表述不太完整和清晰，此翻译只能基于现有内容尽量处理）

5638
03:55:50,279 --> 03:55:55,199
按理说它应该是直观易懂的，就像

5639
03:55:53,080 --> 03:55:56,880
教科书上的例子 呃，这就是你……的方式

5640
03:55:55,199 --> 03:55:59,720
处理事情，这并不是应该有的情况

5641
03:55:56,880 --> 03:56:03,520
在数学和空间层面上非常困难

5642
03:55:59,720 --> 03:56:07,840
不管怎样，这一章节讲的是关于……（原文句子不完整）

5643
03:56:03,520 --> 03:56:10,040
CUDA应用程序编程接口，所以这是第六章，CUDA

5644
03:56:07,840 --> 03:56:13,560
应用程序编程接口（APIs）嗯，我们还有几个要过一遍。

5645
03:56:10,040 --> 03:56:16,279
库布罗斯、美国有线电视新闻网（CNN）等等，但我希望你能…… 

5646
03:56:13,560 --> 03:56:20,960
导航到 docs.nvidia.com

5647
03:56:16,279 --> 03:56:23,040
库达，所以在这里我们有很多资源

5648
03:56:20,960 --> 03:56:25,479
我们有很多很酷的东西可以看。

5649
03:56:23,040 --> 03:56:28,520
嗯，我只是想指出这一点

5650
03:56:25,479 --> 03:56:30,520
说出来，倒不是说这跟呃反刍动物有什么特别的关系

5651
03:56:28,520 --> 03:56:32,279
API 部分，但因为有很多

5652
03:56:30,520 --> 03:56:34,399
这里有很多有用的东西，所以

5653
03:56:32,279 --> 03:56:36,239
你有关于……的安装指南

（注：原句似乎不完整，“for”后面可能缺少内容） 

5654
03:56:34,399 --> 03:56:38,040
就像 Windows 和 Linux 一样，就像这样

5655
03:56:36,239 --> 03:56:40,359
就像你需要得到的一切

5656
03:56:38,040 --> 03:56:42,199
开始 嗯 编程指南 最佳

5657
03:56:40,359 --> 03:56:44,960
实践所有不同的，你知道的

5658
03:56:42,199 --> 03:56:47,680
麦克斯韦 帕斯卡 VTA 图灵 我在这儿 霍珀

5659
03:56:44,960 --> 03:56:50,520
艾达·麦克斯韦，嗯，所有这些不同的…… 

5660
03:56:47,680 --> 03:56:52,600
兼容性指南和调优指南

5661
03:56:50,520 --> 03:56:54,680
呃，针对不同的架构，然后

5662
03:56:52,600 --> 03:56:56,760
你有像你的五声音阶合唱团（Pentatonix，简称PTX），它是 

5663
03:56:54,680 --> 03:56:59,120
针对CUDA的组装说明，那是……

5664
03:56:56,760 --> 03:57:01,399
它编译成了什么，呃，然后呢

5665
03:56:59,120 --> 03:57:05,479
就像 API 参考资料一样，都是杂七杂八的内容。

注：由于原文表意不是特别明确，“miscellaneous”本意是“混杂的；各种各样的” ，这里结合语境这样翻译更通顺一些。如果这与你原文的意思不符，请提供更多上下文。 

5666
03:57:01,399 --> 03:57:07,680
东西，嗯，还有像 nbcc 这样的工具，呃，还有用于……的 GDB 

5667
03:57:05,479 --> 03:57:09,960
Cuda 那么当我们之前讲到 GDB 时在…… （这里句子似乎未完整）

5668
03:57:07,680 --> 03:57:11,239
C+加评论区，这是

5669
03:57:09,960 --> 03:57:13,479
对于CUDA的等效物，所以当你在……的时候

5670
03:57:11,239 --> 03:57:15,359
调试 CUDA 程序时你会用到那个

5671
03:57:13,479 --> 03:57:18,520
呃，然后就有类似“洞察计算”这样的东西。 

5672
03:57:15,359 --> 03:57:21,080
我们之前用过的那个，嗯，就是那个。 

5673
03:57:18,520 --> 03:57:23,760
只是有很多非常有用的信息工具

5674
03:57:21,080 --> 03:57:26,560
在这里，我们主要关心的是 C

5675
03:57:23,760 --> 03:57:29,000
API 参考，所以在这里我们有

5676
03:57:26,560 --> 03:57:30,920
运行时 API
驱动程序 API
数学 API
你可以

5677
03:57:29,000 --> 03:57:33,760
如果你想的话可以看看那些，但主要是

5678
03:57:30,920 --> 03:57:36,399
我接下来要讲的是库布罗什以及

5679
03:57:33,760 --> 03:57:39,760
CDNN（可能是某个特定名称），如果你前往这里的话，它就在这边。

5680
03:57:36,399 --> 03:57:42,720
video.com文档 深度学习 卷积神经网络 你可以

5681
03:57:39,760 --> 03:57:45,840
找到这个，而这些是主要的。

5682
03:57:42,720 --> 03:57:49,680
我期望在这部分内容中涵盖的内容

5683
03:57:45,840 --> 03:57:52,239
所以你可以把这些，呃，想象成忽必烈（这里“kublos”可能是“Kublai”的错误表述，一般指忽必烈）相关的东西 

5684
03:57:49,680 --> 03:57:54,399
还有美国有线电视新闻网（CNN），因为他们不是……你也不是…… 

5685
03:57:52,239 --> 03:57:55,800
实际上在写作，可你却没在写。

5686
03:57:54,399 --> 03:57:58,080
把事情弄清楚；解决问题（需结合上下文准确理解，“things out”单独并非完整表达，常见搭配如“work things out”等） 

5687
03:57:55,800 --> 03:58:01,439
手动操作时，你并非在自行书写你自己的（内容） 

5688
03:57:58,080 --> 03:58:04,159
内核，这里的核心思想是

5689
03:58:01,439 --> 03:58:06,080
你有像这样的一个黑匣子

5690
03:58:04,159 --> 03:58:08,520
你调用的函数，或者就像它是一个……（原英文表述不太符合正常语法规范，翻译只能尽量贴近语义） 

5691
03:58:06,080 --> 03:58:12,479
绑定到一个共享对象文件，就像一个

5692
03:58:08,520 --> 03:58:14,520
所以，而且它是不透明的，所以他们用这些

5693
03:58:12,479 --> 03:58:16,399
这些，这个词叫做不透明结构体

5694
03:58:14,520 --> 03:58:18,600
类型，而那是什么呢，就是你仅仅是

5695
03:58:16,399 --> 03:58:21,000
调用被编译后的东西

5696
03:58:18,600 --> 03:58:23,600
要在你没有的硬件上运行

5697
03:58:21,000 --> 03:58:25,720
去看它，因为你知道在……里面

5698
03:58:23,600 --> 03:58:28,600
以某种二进制格式编码，而你

5699
03:58:25,720 --> 03:58:30,479
作为人类真的看不懂，所以你

5700
03:58:28,600 --> 03:58:32,720
必须引用这些不透明结构体

5701
03:58:30,479 --> 03:58:34,479
能够调用那些的类型，这些就是

5702
03:58:32,720 --> 03:58:37,520
经过高度优化，所以就像那…… （由于原句不完整，这里的翻译也只能根据已有内容尽量表达） 

5703
03:58:34,479 --> 03:58:39,000
世界上最先进的算法

5704
03:58:37,520 --> 03:58:40,920
呃，为了运行深度学习，你知道的

5705
03:58:39,000 --> 03:58:43,279
这些是最快的算法

5706
03:58:40,920 --> 03:58:44,800
嗯，有时候你可能会

5707
03:58:43,279 --> 03:58:46,680
更快的东西，具体取决于用途

5708
03:58:44,800 --> 03:58:48,399
情况，但我们通常会假设那…… 

5709
03:58:46,680 --> 03:58:52,960
这些是 CUDA API 所提供的

5710
03:58:48,399 --> 03:58:55,560
最快的函数，呃，一般来说

5711
03:58:52,960 --> 03:58:57,960
所以当你试图弄清楚如何

5712
03:58:55,560 --> 03:58:59,920
为了获得尽可能快的推理以

5713
03:58:57,960 --> 03:59:05,199
在你的图形处理器（GPU）上运行
或
在你的图形处理器（GPU）上工作
注：“work on”根据语境有不同理解，以上两种较常见，你可按需选用。 

5714
03:58:59,920 --> 03:59:08,080
集群 呃，你可能想 呃，你知道的

5715
03:59:05,199 --> 03:59:11,560
使用类似 CUDA API 的东西，嗯，然后

5716
03:59:08,080 --> 03:59:13,080
经历着，呃，你懂的，就是在经历着

5717
03:59:11,560 --> 03:59:14,880
通过、研究并弄清楚

5718
03:59:13,080 --> 03:59:18,239
怎样通过去类似……的方式把它完成

5719
03:59:14,880 --> 03:59:20,040
谷歌搜索 困惑度 查德GPT 嗯 你

5720
03:59:18,239 --> 03:59:22,279
知道，也许是人类相关的（这里“anthropic”常见意思是“人类的、有关人类的” ，结合文本可能需根据具体语境调整表述）

5721
03:59:20,040 --> 03:59:25,359
模型，然后在……中进行关键词搜索

5722
03:59:22,279 --> 03:59:28,040
英伟达文档就像那样只有一个回车换行符

5723
03:59:25,359 --> 03:59:31,040
嗯，但是 C 应用程序编程接口（API）将会提供

5724
03:59:28,040 --> 03:59:32,640
你就是最快的家伙，对吧，嗯 你也许

5725
03:59:31,040 --> 03:59:35,720
以前见过我们是怎么做到这一点的

5726
03:59:32,640 --> 03:59:37,720
这些，比如错误检查，嗯，还有这些

5727
03:59:35,720 --> 03:59:41,600
本质上，就是说，就像当你……

5728
03:59:37,720 --> 03:59:43,680
调用一个函数，然后说类似“库布罗斯，嗯”这样的话

5729
03:59:41,600 --> 03:59:45,279
你 你要去检查一下是否 那个

5730
03:59:43,680 --> 03:59:46,880
是否返回错误，如果返回的话

5731
03:59:45,279 --> 03:59:48,520
你要打印出错误以及……

5732
03:59:46,880 --> 03:59:50,479
行，当时是正确的，所以这些仅仅是

5733
03:59:48,520 --> 03:59:51,760
打印错误信息的自定义方式

5734
03:59:50,479 --> 03:59:54,840
当事情没有按照（预期）发展时

5735
03:59:51,760 --> 03:59:56,840
计划 所以我这两个都是为了，嗯，kblast（这个不太明确“kblast”具体所指，可能是特定名称） 

5736
03:59:54,840 --> 03:59:59,840
然后量子神经网络（QNN），所以它只是检查这个函数

5737
03:59:56,840 --> 04:00:02,159
确保它顺利通过了。

5738
03:59:59,840 --> 04:00:07,199
嗯

5739
04:00:02,159 --> 04:00:10,680
现在，Kuas 是 Cuda 的缩写，所以“CU”指的是

5740
04:00:07,199 --> 04:00:12,720
对于CUDA基础线性代数子程序

5741
04:00:10,680 --> 04:00:15,359
程序或子系统，我记不清了

5742
04:00:12,720 --> 04:00:16,880
哪一个 但它 它是为了 它是为了

5743
04:00:15,359 --> 04:00:19,960
线性代数相关内容，比如矩阵

5744
04:00:16,880 --> 04:00:22,000
乘法运算正确，以及单精度通用矩阵乘法（SGEM），它是一种 

5745
04:00:19,960 --> 04:00:23,080
单精度通用的缩写

5746
04:00:22,000 --> 04:00:25,120
矩阵；母体；子宫；基质；模型；电路板；电影《黑客帝国》

5747
04:00:23,080 --> 04:00:27,680
乘法

5748
04:00:25,120 --> 04:00:29,319
嗯，就是这样，那还挺……

5749
04:00:27,680 --> 04:00:30,800
这整个像GRE文件之类的大部分内容是……

说明：原英文句子不太符合常见的语法规则，可能表述不太完整或准确，以上翻译是尽量贴近字面意思进行的。 

5750
04:00:29,319 --> 04:00:33,080
关于 我有点像是在边看边背诵它呢

5751
04:00:30,800 --> 04:00:34,640
下去，不过，你知道，有……

5752
04:00:33,080 --> 04:00:37,720
关于这个的资源，比如恰当的错误

5753
04:00:34,640 --> 04:00:39,920
检查库样本 嗯，如果我们当时……

5754
04:00:37,720 --> 04:00:41,359
要去这个地方，那里就像有个图书馆

5755
04:00:39,920 --> 04:00:44,359
你可以对其中每一个进行测试的样本

5756
04:00:41,359 --> 04:00:46,640
这些，嗯

5757
04:00:44,359 --> 04:00:48,120
但关于库布洛斯的整个想法以及

5758
04:00:46,640 --> 04:00:51,239
以及它对深度学习有多重要

5759
04:00:48,120 --> 04:00:53,800
是在类似变压器的东西里面

5760
04:00:51,239 --> 04:00:54,880
或者在 Transformer 本身中使用多层感知机（MLP）

5761
04:00:53,800 --> 04:00:56,640
你将使用这个算法

5762
04:00:54,880 --> 04:00:58,640
称为矩阵乘法，并且当

5763
04:00:56,640 --> 04:00:59,880
你想让多层感知机（MLP）运行得非常快，还是……

5764
04:00:58,640 --> 04:01:01,880
你希望这个语言模型具备

5765
04:00:59,880 --> 04:01:04,760
非常非常快的推理时间，你

5766
04:01:01,880 --> 04:01:06,159
希望这些算法实际上并不具备（此处句子不完整，表意不太明确）

5767
04:01:04,760 --> 04:01:08,680
瓶颈，没错，你希望它们运转起来

5768
04:01:06,159 --> 04:01:11,760
在硬件上尽可能快地，并且

5769
04:01:08,680 --> 04:01:14,080
所以在昆山科技大学（Kuas 推测可能是昆山科技大学，英文为 Kun Shan University）使用子程序，你

5770
04:01:11,760 --> 04:01:15,720
实际上可以得到那个 嗯 还有其他的

5771
04:01:14,080 --> 04:01:17,560
你可以进行组合和调配的方式

5772
04:01:15,720 --> 04:01:20,120
把事情整合在一起，但那更高级了。

5773
04:01:17,560 --> 04:01:22,560
目前我们只是假设那个

5774
04:01:20,120 --> 04:01:27,080
最快的算法存在于库布洛斯（Kublos）中，并且

5775
04:01:22,560 --> 04:01:28,399
用于深度学习目的的卷积神经网络（CNN），嗯，所以

5776
04:01:27,080 --> 04:01:30,080
我们接下来要在这里开始了

5777
04:01:28,399 --> 04:01:33,080
呃，和…… 

5778
04:01:30,080 --> 04:01:33,080
库布罗斯

5779
04:01:34,120 --> 04:01:42,680
现在是基础线性代数子程序

5780
04:01:39,000 --> 04:01:46,000
嗯，用于加速人工智能的高性能

5781
04:01:42,680 --> 04:01:49,720
就像我之前说的那样，应用程序

5782
04:01:46,000 --> 04:01:52,040
嗯，行业标准的爆炸式应用程序编程接口（APIs）和宝石

5783
04:01:49,720 --> 04:01:53,479
API，即通用矩阵乘法

5784
04:01:52,040 --> 04:01:55,520
高度支持融合操作

5785
04:01:53,479 --> 04:01:56,800
针对英伟达显卡进行了优化，我会深入研究。 

5786
04:01:55,520 --> 04:01:59,760
马上就会有融合反应了，别担心

5787
04:01:56,800 --> 04:02:02,000
关于那个，嗯，但是……我所……

5788
04:01:59,760 --> 04:02:04,399
本质上，对这些每一个所做的是

5789
04:02:02,000 --> 04:02:06,560
所以我已经把它们安排去进行测试了

5790
04:02:04,399 --> 04:02:08,120
在我真正开始说……之前

5791
04:02:06,560 --> 04:02:10,920
打印出结果是什么以及

5792
04:02:08,120 --> 04:02:12,800
以及这些效果如何，嗯，还有……是什么（这里“what the”后面内容缺失，只能这样不完整地翻译）

5793
04:02:10,920 --> 04:02:14,880
差异是需要着重关注的要点。 

5794
04:02:12,800 --> 04:02:18,720
他们实际上做了什么 什么是……

5795
04:02:14,880 --> 04:02:23,000
这些库巴拉斯之间的区别

5796
04:02:18,720 --> 04:02:25,199
它本身只是那种超级兴奋的感觉 它就是……

5797
04:02:23,000 --> 04:02:27,000
这实际上是最容易做的一个。

5798
04:02:25,199 --> 04:02:28,479
使用并让它运转起来，这就像……（由于原文未完整表述，只能翻译到这里） 

5799
04:02:27,000 --> 04:02:31,359
你通常开始时所遵循的标准

5800
04:02:28,479 --> 04:02:34,399
嗯，它将支持呃

5801
04:02:31,359 --> 04:02:35,560
你所熟知的基础的，呃，单精度

5802
04:02:34,399 --> 04:02:40,080
所以；那么

5803
04:02:35,560 --> 04:02:44,560
32位浮点（fp32） 嗯 还有 呃 16位浮点（fp16）矩阵

5804
04:02:40,080 --> 04:02:47,080
乘法，对，嗯，库阿斯 LT 是一个

5805
04:02:44,560 --> 04:02:50,120
库阿斯（Kuas）的轻量级扩展，其（扩展内容可指代前文，这里根据文本无法明确具体指代） 

5806
04:02:47,080 --> 04:02:51,800
主要提供一个更灵活的应用程序编程接口

5807
04:02:50,120 --> 04:02:54,680
旨在为……提高性能

5808
04:02:51,800 --> 04:02:58,239
特定工作负载

5809
04:02:54,680 --> 04:03:02,159
嗯，只不过这个更多是围绕……展开的

5810
04:02:58,239 --> 04:03:03,800
更大的矩阵，因此Kuas LT（此处可能是特定术语，需结合上下文确定准确含义）经过了优化

5811
04:03:02,159 --> 04:03:06,960
稍有不同，而且它可以是

5812
04:03:03,800 --> 04:03:10,359
比普通的夸斯更快，在……方面 

5813
04:03:06,960 --> 04:03:12,199
案例 所以当你有 当你有

5814
04:03:10,359 --> 04:03:14,080
理想情况下是轻便的东西

5815
04:03:12,199 --> 04:03:15,319
它的精度会更低，对吧

5816
04:03:14,080 --> 04:03:17,040
你可以把这个“L”想象成 

5817
04:03:15,319 --> 04:03:19,159
轻量级的，或者低精度的，随便哪种都行

5818
04:03:17,040 --> 04:03:21,159
你想要，而且从本质上来说这……

注：原文 “and and” 可能存在表述错误，但按要求保留原文格式进行了翻译。 

5819
04:03:19,159 --> 04:03:23,399
意思是 它和库布罗斯是一样的吗

5820
04:03:21,159 --> 04:03:27,040
除了，呃，当你使用较低精度的时候

5821
04:03:23,399 --> 04:03:28,880
像FP16、FP8和8，嗯，它们……它们……

5822
04:03:27,040 --> 04:03:32,319
要跑得快得多得多，而且那就是……

5823
04:03:28,880 --> 04:03:35,439
LT为同样的想法设计了什么

5824
04:03:32,319 --> 04:03:37,080
只是降低精度，处理更大的矩阵，嗯

5825
04:03:35,439 --> 04:03:40,279
不同种类的

5826
04:03:37,080 --> 04:03:42,239
工作负载，然后你有 XT，它是

5827
04:03:40,279 --> 04:03:44,279
实际上我并不推荐这样做，因为

5828
04:03:42,239 --> 04:03:47,399
这慢得离谱。

5829
04:03:44,279 --> 04:03:50,040
嗯，但你可以，你可以进行互连。

5830
04:03:47,399 --> 04:03:52,120
多个GPU和CPU协同解决

5831
04:03:50,040 --> 04:03:54,720
一个问题，所以如果你有一个巨大的…… 

5832
04:03:52,120 --> 04:03:56,880
矩阵，呃，你有一个巨大的矩阵

5833
04:03:54,720 --> 04:03:59,680
要做乘法，你实际上可以

5834
04:03:56,880 --> 04:04:01,680
将这个任务在 CPU 和 GPU 之间进行拆分，并且

5835
04:03:59,680 --> 04:04:05,159
他们会互相交谈并获取

5836
04:04:01,680 --> 04:04:09,000
事情已完成 嗯 然而 那 那段记忆

5837
04:04:05,159 --> 04:04:10,040
带宽瓶颈，嗯，确实会限制（某些方面）。 

5838
04:04:09,000 --> 04:04:12,640
这；那

5839
04:04:10,040 --> 04:04:15,000
进行计算，因为你不只是拥有这个

5840
04:04:12,640 --> 04:04:16,479
超级快，就像，呃，这种高内存（的情况）

5841
04:04:15,000 --> 04:04:18,920
GPU 上的带宽，你仅仅可以

5842
04:04:16,479 --> 04:04:20,960
像回忆一样来来回回

5843
04:04:18,920 --> 04:04:23,000
CPU和GPU之间的带宽是

5844
04:04:20,960 --> 04:04:25,159
真的很低
这就是为什么要花这么长时间

5845
04:04:23,000 --> 04:04:27,520
把东西复制过来，这样你就得操心了

5846
04:04:25,159 --> 04:04:30,159
关于那个，呃，你的解题速度

5847
04:04:27,520 --> 04:04:32,920
实际上会慢很多，嗯，而且

5848
04:04:30,159 --> 04:04:35,800
这是XT的一个阻碍因素之一。

5849
04:04:32,920 --> 04:04:37,920
嗯，但你可以运行多个图形处理器，这是……（此处原英文未完整表达意思）

5850
04:04:35,800 --> 04:04:40,080
设计为线程安全，非常适合于

5851
04:04:37,920 --> 04:04:43,920
大规模计算，你知道的

5852
04:04:40,080 --> 04:04:46,319
在分布式工作负载方面，嗯，大规模的 

5853
04:04:43,920 --> 04:04:48,800
超出 GPU 内存的代数运算，所以如果

5854
04:04:46,319 --> 04:04:50,800
你有……呃，如果你有巨大的…… 

5855
04:04:48,800 --> 04:04:54,120
就好像是矩阵

5856
04:04:50,800 --> 04:04:56,840
16384乘以16384，然后你把它们相乘 

5857
04:04:54,120 --> 04:05:00,080
就其本身而言，呃，那可能无法全部装得下。

5858
04:04:56,840 --> 04:05:06,080
就像一张 8GB 的存储卡，你知道的，如果我要做，我就会去做

5859
04:05:00,080 --> 04:05:08,760
我用 Python 计算 16384 的平方，那就是，呃

5860
04:05:06,080 --> 04:05:12,080
什么，8米，那就像是

5861
04:05:08,760 --> 04:05:14,000
268，那就像是2.68亿个数字

5862
04:05:12,080 --> 04:05:15,800
那有很多数字呢，嗯，而且如果你

5863
04:05:14,000 --> 04:05:19,760
如果你有一个 A 和一个 B，就会有三个这样的（东西） 

5864
04:05:15,800 --> 04:05:23,000
然后分配了一个调用，那就像

5865
04:05:19,760 --> 04:05:25,159
700，那差不多是8亿个数字，而且

5866
04:05:23,000 --> 04:05:28,600
那么，如果你，你知道的，把这个提升到……

5867
04:05:25,159 --> 04:05:32,359
就像，呃，FP32（单精度浮点数），你用这个数去相乘

5868
04:05:28,600 --> 04:05:34,840
嗯，你乘以四，那就是……

5869
04:05:32,359 --> 04:05:37,920
那就是那个尺寸
那就是那个尺寸

5870
04:05:34,840 --> 04:05:40,960
一个浮点数的，所以是四个字节，并且你

5871
04:05:37,920 --> 04:05:43,439
得到像 3.2GB 这样荒谬的数字

5872
04:05:40,960 --> 04:05:45,199
空间 所以如果你有一张2GB的存储卡，或者它是……

5873
04:05:43,439 --> 04:05:47,800
就像一个嵌入式系统，它不会（这里文本不完整，推测意思可能是“它不会怎样” ）

5874
04:05:45,199 --> 04:05:50,720
来装下所有那些嗯，或者如果你打算……

5875
04:05:47,800 --> 04:05:52,640
把这个提升到，比如说

5876
04:05:50,720 --> 04:05:54,239
10万，那可放不下

5877
04:05:52,640 --> 04:05:56,120
对，像这类数字如此……

5878
04:05:54,239 --> 04:05:58,479
大量的，你只需要使用

5879
04:05:56,120 --> 04:06:00,680
外部CPU动态随机存取存储器，以便实际地

5880
04:05:58,479 --> 04:06:02,319
把它们放好，嗯，这样你就可以……有…… 

5881
04:06:00,680 --> 04:06:07,159
显然，还有其他优化它的方法

5882
04:06:02,319 --> 04:06:12,560
但XT允许你这么做，嗯，所以我就这么做了

5883
04:06:07,159 --> 04:06:15,279
一连串这样的，呃，尺寸为 16 的情况

5884
04:06:12,560 --> 04:06:17,319
384 而且这些实际上都能装在我的卡上

5885
04:06:15,279 --> 04:06:23,279
因为，嗯，你

5886
04:06:17,319 --> 04:06:26,920
知道我有，呃，8GB的GPU显存，这是

5887
04:06:23,279 --> 04:06:30,439
低，但在某些情况下高

5888
04:06:26,920 --> 04:06:33,479
嗯，库布罗斯（Kublos）与库布罗斯XT（Kublos XT）对比，所以我做了五次

5889
04:06:30,439 --> 04:06:35,800
每次运行大约需要 0.59 秒于（此处“on”后面内容缺失，翻译可能不太完整准确）

5890
04:06:33,479 --> 04:06:39,000
平均值，然后这大概花了3.5（这里缺少具体单位，如小时、分钟等）

5891
04:06:35,800 --> 04:06:41,279
平均用时几秒，所以结果出来了

5892
04:06:39,000 --> 04:06:44,239
向上匹配，所以他们当时是这样的感觉，就好像…… 

5893
04:06:41,279 --> 04:06:46,199
几乎完全一样，呃，然后，是的

5894
04:06:44,239 --> 04:06:48,159
这这这简直太疯狂了，程度简直难以想象
（注：原英文表述不太规范且语义在脱离语境下较难精准把握，此翻译是尽量贴合语义的一种处理） 

5895
04:06:46,199 --> 04:06:52,359
当你仅仅……时所获得的加速效果

5896
04:06:48,159 --> 04:06:53,760
坚持正确使用 GPU，所以……

5897
04:06:52,359 --> 04:06:55,080
这就像是一个能解释你为什么……的例子

注：原英文句子不完整，所以译文会感觉表述未结束。 

5898
04:06:53,760 --> 04:06:59,920
使用物品时要小心

5899
04:06:55,080 --> 04:07:00,880
就像高雄应用科技大学XT（可能表述有误，推测是指高雄应用科技大学的某个项目或设备等）嗯，高雄应用科技大学DX 我们不是…… 

5900
04:06:59,920 --> 04:07:02,720
打算去做那件事，但我们不会去做

5901
04:07:00,880 --> 04:07:05,159
在这门课程中使用那个 嗯 但是

5902
04:07:02,720 --> 04:07:08,000
你可以在这里借助这个进一步深入了解它。

5903
04:07:05,159 --> 04:07:09,600
文档，嗯，现在无轴套的是

5904
04:07:08,000 --> 04:07:11,080
有些事，你知道的，我会在……里讲到

5905
04:07:09,600 --> 04:07:14,399
在额外的部分里 有一点点

5906
04:07:11,080 --> 04:07:16,840
更多，但是，嗯

5907
04:07:14,399 --> 04:07:20,800
库布罗斯及其变体仍在继续运行

注：“kublos”可能是特定的专业术语、品牌名、地名等，如果有更具体的背景信息，翻译可能会更准确。 

5908
04:07:16,840 --> 04:07:24,920
无论库布罗斯DX带来什么，主人都不会……

5909
04:07:20,800 --> 04:07:27,399
嗯，有很完善的文档记录或者经过了优化，嗯

5910
04:07:24,920 --> 04:07:29,960
而当我们试图去做像这样的事情时

5911
04:07:27,399 --> 04:07:31,800
Transformer中的矩阵乘法

5912
04:07:29,960 --> 04:07:33,359
我们可能不想依赖某样东西。

5913
04:07:31,800 --> 04:07:35,159
那些操作在哪里 那些操作在哪里（注：此英文表述不太符合常见规范，推测这里重复可能是强调或表述时的口误等情况） 

5914
04:07:33,359 --> 04:07:37,479
当我们……的时候，由主机进行调度（此句英文可能表述不完整，译文仅供参考）

5915
04:07:35,159 --> 04:07:39,760
想把它称作像科斯式的操作那样的……

注：原英文文本似乎不完整且表述有些奇怪，但已按照要求进行翻译。 

5916
04:07:37,479 --> 04:07:41,319
CPU 会指示它那样做，而在……方面（此处“whereas on”后面内容缺失，句子未完整） 

5917
04:07:39,760 --> 04:07:43,159
GPU 它就像一个内核，那个…… 

5918
04:07:41,319 --> 04:07:44,600
已启动，并且所有操作都……

注：原英文句子似乎表述不完整。 

5919
04:07:43,159 --> 04:07:46,720
完成了，所以它们有点不同

5920
04:07:44,600 --> 04:07:50,080
在这方面

5921
04:07:46,720 --> 04:07:52,640
嗯，当我们进行像矩阵乘法这样的运算时

5922
04:07:50,080 --> 04:07:54,239
连同类似 r 激活，然后

5923
04:07:52,640 --> 04:07:55,439
另一次矩阵乘法，然后

5924
04:07:54,239 --> 04:07:58,479
另一个值，然后就像一个

5925
04:07:55,439 --> 04:08:00,439
卷积层 就好像你 你

5926
04:07:58,479 --> 04:08:02,960
通常在单一的情况下不会有那个。

5927
04:08:00,439 --> 04:08:04,600
操作中你把它们融合在一起，然后

5928
04:08:02,960 --> 04:08:05,720
这就是我们所说的融合的概念

5929
04:08:04,600 --> 04:08:09,960
谈到；谈论；说起

5930
04:08:05,720 --> 04:08:11,800
在嗯……还有当你，当你……的时候

5931
04:08:09,960 --> 04:08:13,720
有类似无刀装置这样的东西，它是一种

5932
04:08:11,800 --> 04:08:17,720
能够使用的模板库

5933
04:08:13,720 --> 04:08:22,239
把东西放在一起 嗯 你知道 你可以呃

5934
04:08:17,720 --> 04:08:25,920
你可以获得更高的性能

5935
04:08:22,239 --> 04:08:27,720
所以，举个例子，嗯，就像快速注意力机制

5936
04:08:25,920 --> 04:08:30,399
它实际上并不使用无切口装置，但它是

5937
04:08:27,720 --> 04:08:33,119
融合CUDA内核的一个示例

5938
04:08:30,399 --> 04:08:35,000
看起来《闪现注意力》是一篇论文

5939
04:08:33,119 --> 04:08:37,040
那句话说出来了，你知道的，我觉得是两三年前（这里“two three”表述不太完整准确，推测可能是两三年的意思） 

5940
04:08:35,000 --> 04:08:41,560
几年前，如果我们只是拉动这个（东西）的话，会有某件事（发生） 

5941
04:08:37,040 --> 04:08:43,439
呃，你知道，它本质上是用于……

5942
04:08:41,560 --> 04:08:46,399
Transformer中的注意力机制

5943
04:08:43,439 --> 04:08:48,279
而且它有一整套内容，其理念是

5944
04:08:46,399 --> 04:08:50,720
嗯，你有这个，这个，这个，这个

5945
04:08:48,279 --> 04:08:53,359
GPT中的注意力层，它就像

5946
04:08:50,720 --> 04:08:55,600
失活、软最大值、掩码以及其他

5947
04:08:53,359 --> 04:08:57,439
嗯哼，如果把这些和……一起投喂

5948
04:08:55,600 --> 04:08:59,159
定制手写，高度优化

5949
04:08:57,439 --> 04:09:01,560
内核，你真的真的可以做到这一点

5950
04:08:59,159 --> 04:09:04,439
速度很快，而且你可以把速度再提高大概5倍 

5951
04:09:01,560 --> 04:09:07,000
在某些硬件上实现 10 倍提升，而且那是

5952
04:09:04,439 --> 04:09:08,960
无冲突的融合理念将被允许

5953
04:09:07,000 --> 04:09:12,920
你去开发你所知道的更快的矩阵

5954
04:09:08,960 --> 04:09:14,600
乘法算法，嗯，然后

5955
04:09:12,920 --> 04:09:16,159
你会考虑像核聚变这样的技术，并且

5956
04:09:14,600 --> 04:09:17,600
你可能会把你所拥有的东西结合起来

5957
04:09:16,159 --> 04:09:19,239
用短剑字体书写，而你会……你会……

5958
04:09:17,600 --> 04:09:20,960
会把所有东西都合并起来，这样

5959
04:09:19,239 --> 04:09:22,560
你不必依赖任何东西

5960
04:09:20,960 --> 04:09:24,279
英伟达提供，而你只需做你自己的（事）

5961
04:09:22,560 --> 04:09:26,439
自己的事情，没错，那就是，那有点……

5962
04:09:24,279 --> 04:09:29,600
我们开展像核聚变这类研究的原因

5963
04:09:26,439 --> 04:09:32,439
呃，而且我们使用无轴封（装置），所以

5964
04:09:29,600 --> 04:09:35,520
模板 呃 模板 线性代数 下标

5965
04:09:32,439 --> 04:09:36,920
日常安排 嗯 但别太担心

5966
04:09:35,520 --> 04:09:38,800
关于无割刀的情况，我们不会再讨论了。

5967
04:09:36,920 --> 04:09:41,760
本课程的剪辑清单 呃，有很多

5968
04:09:38,800 --> 04:09:43,920
去覆盖那里呃，但不管怎样，那是

5969
04:09:41,760 --> 04:09:44,800
就像那个的整个概念，那就是全部

5970
04:09:43,920 --> 04:09:48,960
……的想法；……的概念

5971
04:09:44,800 --> 04:09:50,600
夸斯，现在我们来深入研究这些，我打算

5972
04:09:48,960 --> 04:09:53,399
尽我所能地去经历这一切以…… 

5973
04:09:50,600 --> 04:09:57,520
说明正在发生的事情，所以我们需要

5974
04:09:53,399 --> 04:09:58,960
要导入这个，呃，库布罗斯V2，对吧，所以

5975
04:09:57,520 --> 04:10:01,199
这是 这是一件我们要去做的新事情

5976
04:09:58,960 --> 04:10:04,279
要相加，我们要把 F 加进来。

5977
04:10:01,199 --> 04:10:06,800
FP16 呃，包含项，然后就是一些……

5978
04:10:04,279 --> 04:10:09,119
将矩阵大小定义为宏，然后我们就可以……

5979
04:10:06,800 --> 04:10:11,319
打算把这些浸液（或研磨物，需结合具体语境）包括进来，那些浸液（或研磨物，需结合具体语境）…… 

5980
04:10:09,119 --> 04:10:13,600
检查错误，所以我们将它们包裹起来

5981
04:10:11,319 --> 04:10:15,720
比如说在这里，当我们……当我们做的时候

5982
04:10:13,600 --> 04:10:17,239
一个CUDA（计算统一设备架构），马利克（可能是人名），它在CUDA上运行

5983
04:10:15,720 --> 04:10:19,319
所以我们必须确保那不会（发生）

5984
04:10:17,239 --> 04:10:20,840
返回一个错误 呃 我们就这么做

5985
04:10:19,319 --> 04:10:23,359
始终确保一切万无一失

5986
04:10:20,840 --> 04:10:26,920
没什么，呃，只是把一切都毁了

5987
04:10:23,359 --> 04:10:29,520
如果一切按计划进行，嗯，那么

5988
04:10:26,920 --> 04:10:31,720
在这个例子中

5989
04:10:29,520 --> 04:10:33,159
嗯，实际上我打算回到一个……（这里句子未完整，“a”后面应该还有内容） 

5990
04:10:31,720 --> 04:10:36,040
在某一部分，有那么一个时刻，我……

注：原英文句子表述不完整，以上翻译尽量结合已有内容处理。 

5991
04:10:33,159 --> 04:10:36,040
错过；想念；未击中；未见到（“missed”有多种含义，需根据具体语境确定最合适的意思）

5992
04:10:37,239 --> 04:10:43,359
嗯，正如我们在剧本里看到的，我制作了这些东西。 

5993
04:10:41,760 --> 04:10:45,040
数组

5994
04:10:43,359 --> 04:10:46,560
注意看这些是不是很小，对吧

5995
04:10:45,040 --> 04:10:48,439
那里有几个……那里……那里有几个

5996
04:10:46,560 --> 04:10:50,279
其他像这样你想要的东西

5997
04:10:48,439 --> 04:10:52,720
比较的时候要留意

5998
04:10:50,279 --> 04:10:55,439
事情，因为我们在这里所做的是

5999
04:10:52,720 --> 04:10:58,399
我们实际上是在比较速度。

6000
04:10:55,439 --> 04:10:59,880
还有，呃，相似的事物是如何组合在一起的

6001
04:10:58,399 --> 04:11:02,840
我们想 我们想比较像……这样的 

6002
04:10:59,880 --> 04:11:05,640
使用 FP16 的情况下对比 FP32，看看它们的表现如何

6003
04:11:02,840 --> 04:11:06,600
确保它们最终能匹配上 嗯

6004
04:11:05,640 --> 04:11:10,040
所以你有很多东西

6005
04:11:06,600 --> 04:11:13,359
要留意，所以要进行热身跑

6006
04:11:10,040 --> 04:11:14,880
这很好，因为呃，CUDA可能会鼓（这里“encour”不完整，推测是“encourage”）

6007
04:11:13,359 --> 04:11:17,000
当你这么做的时候会有一些额外的开销

6008
04:11:14,880 --> 04:11:21,279
就像前几次尝试那样，所以你想……

6009
04:11:17,000 --> 04:11:22,760
把那些事情做完，嗯，然后接着做别的。 

6010
04:11:21,279 --> 04:11:24,560
通过基准测试运行，所以要确保

6011
04:11:22,760 --> 04:11:26,319
那种管理费用之类的东西就变得像……

6012
04:11:24,560 --> 04:11:28,640
移除了 你希望它就像简单地分类那样

6013
04:11:26,319 --> 04:11:30,119
让它独自运行个几次

6014
04:11:28,640 --> 04:11:31,920
然后你进行一次 100 次重复的基准测试

6015
04:11:30,119 --> 04:11:33,760
跑步，然后你取……的平均时间

6016
04:11:31,920 --> 04:11:35,520
那些，这就是你得到一个准确结果的方式

注：原英文文本表述可能不太完整或准确，推测这里可能想说 “and that's the way”  。 

6017
04:11:33,760 --> 04:11:38,600
测量完成某事所需的时间（注：原文未完整表述“做什么”，此处为根据语境补充说明）
测量……需要多长时间 

6018
04:11:35,520 --> 04:11:40,399
执行一个函数或一个内核，对，嗯

6019
04:11:38,600 --> 04:11:42,600
不进行任何试跑的话，你可能

6020
04:11:40,399 --> 04:11:44,000
比如说，第一件事要拿出大概50（这里“50”后面应该有单位，原文未明确，比如“50块钱”“50分钟”等）

6021
04:11:42,600 --> 04:11:46,239
几毫秒，然后下一个需要

6022
04:11:44,000 --> 04:11:47,279
2毫秒，然后就感觉哇，怎么回事

6023
04:11:46,239 --> 04:11:49,720
那里发生了什么 嗯 那是……

6024
04:11:47,279 --> 04:11:51,720
你所需要的那些开销，那个郭（这里“kuo”推测是姓氏“郭”的拼音，但表述整体不太清晰合理）

6025
04:11:49,720 --> 04:11:53,439
实际上接管了并要求如此

6026
04:11:51,720 --> 04:11:58,000
这就是你做热身运动的原因

6027
04:11:53,439 --> 04:12:00,319
运行，嗯，所以是热身运行和基准测试运行

6028
04:11:58,000 --> 04:12:06,399
你想验证你所有的结果

6029
04:12:00,319 --> 04:12:06,399
那么，呃，在这里，（东西）在哪里呢

6030
04:12:07,600 --> 04:12:11,359
也许我们没有，也许我们没有

6031
04:12:09,800 --> 04:12:14,040
在这里比较结果，但我们确实…… 

6032
04:12:11,359 --> 04:12:15,479
别的地方 嗯

6033
04:12:14,040 --> 04:12:18,399
你想核实所有事情，以便它

6034
04:12:15,479 --> 04:12:20,760
所有内容都匹配上了，然后最后一个是

6035
04:12:18,399 --> 04:12:22,920
当你从头开始测试东西时

6036
04:12:20,760 --> 04:12:25,080
而不是像随机初始化那样

6037
04:12:22,920 --> 04:12:27,119
大量的矩阵，而不是像

6038
04:12:25,080 --> 04:12:29,520
一个又一个一千，就像

6039
04:12:27,119 --> 04:12:31,359
你想填充的随机分布

6040
04:12:29,520 --> 04:12:32,800
用你实际上能够……的值来处理它（注：原句不完整）

6041
04:12:31,359 --> 04:12:34,760
自己计算类似的东西

6042
04:12:32,800 --> 04:12:36,920
你可以把它带到你的白板上

6043
04:12:34,760 --> 04:12:38,359
或者直接在脑子里算，对吧，呃，那么当……的时候

6044
04:12:36,920 --> 04:12:40,000
你有一些像这样排列的东西

6045
04:12:38,359 --> 04:12:42,199
你可以接着把它写出来，好吗

6046
04:12:40,000 --> 04:12:44,119
嗯，那为什么当时它没起作用呢，它是……

6047
04:12:42,199 --> 04:12:46,040
更容易拆解问题

6048
04:12:44,119 --> 04:12:48,399
并且弄清楚那里出了什么问题，同时 

6049
04:12:46,040 --> 04:12:51,319
反对拆解一个

6050
04:12:48,399 --> 04:12:54,040
不可重现的 1.00 乘 1000 矩阵 你

注：这里“你”单独出现似乎不太符合常见表达逻辑，原文可能存在信息不完整或表述有误的情况。 

6051
04:12:51,319 --> 04:12:56,880
就是不能那么做，嗯，但不管怎样，继续

6052
04:12:54,040 --> 04:13:02,040
回到正题，我们初始化了吗？

6053
04:12:56,880 --> 04:13:03,479
一些矩阵，所以有一个 3 行 4 列的矩阵，然后还有一个 4 行 2 列的矩阵

6054
04:13:02,040 --> 04:13:07,159
所以他们应该有12个

6055
04:13:03,479 --> 04:13:09,800
元素 没错 我们把这个往上滚动回去

6056
04:13:07,159 --> 04:13:13,720
上升到 12，然后这个上升到

6057
04:13:09,800 --> 04:13:13,720
八，那是一块 2×4（规格）的（木板等，需结合语境确定具体物品）

6058
04:13:13,960 --> 04:13:21,199
我们在 CPU 上初始化这些，所以 C

6059
04:13:18,119 --> 04:13:22,680
在CPU上的单精度CU损失

6060
04:13:21,199 --> 04:13:28,920
在……上的输出

6061
04:13:22,680 --> 04:13:31,399
CPU，然后呃，那个CQ损耗输出

6062
04:13:28,920 --> 04:13:34,720
呃，就那一半而言

6063
04:13:31,399 --> 04:13:36,840
精度，呃，然后我们进行一次 CPU 映射

6064
04:13:34,720 --> 04:13:39,359
只是为了 只是为了测试结果 只是为了

6065
04:13:36,840 --> 04:13:41,000
填充，嗯，因为同样地，CPU可能会

6066
04:13:39,359 --> 04:13:42,720
实际上是最容易写出来的一个

6067
04:13:41,000 --> 04:13:44,680
对我们来说，如果我们要把这个从……转移过来

6068
04:13:42,720 --> 04:13:47,439
Python 我们的 NumPy 我们直接把它写出来

6069
04:13:44,680 --> 04:13:50,399
CPU 所有事情都会变得超级简单，呃

6070
04:13:47,439 --> 04:13:53,920
与它进行对比，嗯，所以我们只是，我们只是

6071
04:13:50,399 --> 04:13:56,080
首先要做的是，我们有这个库布罗斯手柄

6072
04:13:53,920 --> 04:13:58,359
我接下来要深入探讨的事情

注：原英文表述“go in into”有误，可能正确的是“go into” 。 

6073
04:13:56,080 --> 04:14:00,479
第二，在这里，嗯，就像所有这些都是……

6074
04:13:58,359 --> 04:14:03,239
这些……所有这些是如何运作的

6075
04:14:00,479 --> 04:14:05,080
在一起，但你有这个库布罗斯手柄

6076
04:14:03,239 --> 04:14:06,560
嗯，这就有点像库布罗斯（注：“kublos”可能不是常见词汇，这里暂音译）的感觉

6077
04:14:05,080 --> 04:14:08,600
关于你正在做的事情的背景信息 你

6078
04:14:06,560 --> 04:14:11,640
为了安全起见，只需初始化这个就行。

6079
04:14:08,600 --> 04:14:15,159
我们用一个单独的函数来创建那个。

6080
04:14:11,640 --> 04:14:16,600
嗯，我们完成了所有的……我们的马尔克斯（这里“malx”可能拼写有误，推测你可能想表达其他内容），然后我们

6081
04:14:15,159 --> 04:14:18,359
这里有这个新功能，它…… 

6082
04:14:16,600 --> 04:14:22,560
你之前没见过，这叫做

6083
04:14:18,359 --> 04:14:25,880
这被称为单精度指令集（SSE），即单精度

注：这里“sjem”可能是拼写错误，推测你想说的是“SSE”（Streaming SIMD Extensions，单指令多数据流扩展指令集） 。 

6084
04:14:22,560 --> 04:14:30,199
通用（General） 通用（General）与通用电气矩阵（GE matrix）

6085
04:14:25,880 --> 04:14:33,159
乘法，并且在这儿里面，如果我

6086
04:14:30,199 --> 04:14:34,680
在 VS Code 中按住 Control 键点击这个，我们可以

6087
04:14:33,159 --> 04:14:36,040
看看这是从哪里来的，我们可以看到

6088
04:14:34,680 --> 04:14:38,560
这是从哪里来的，而且我可以（做到/正确地…… 这里“right”根据语境表意不明确）

6089
04:14:36,040 --> 04:14:40,080
点击这个，看看……的根源在哪里

6090
04:14:38,560 --> 04:14:42,680
这实际上是

6091
04:14:40,080 --> 04:14:47,040
好的，那么我们按顺序看看所有的……

6092
04:14:42,680 --> 04:14:49,359
这些是，所以我们有那个把手，那个…… 

6093
04:14:47,040 --> 04:14:50,520
操作 这些操作 实际上我是

6094
04:14:49,359 --> 04:14:52,680
我马上把这些调出来，所以

6095
04:14:50,520 --> 04:14:55,640
这更说得通了，我们有了形状

6096
04:14:52,680 --> 04:14:58,479
所以 M 和 K，即阿尔法项，它将

6097
04:14:55,640 --> 04:15:00,600
马上就说得通了，我们有一个……那个

6098
04:14:58,479 --> 04:15:03,520
在这种情况下，a 的主维数

6099
04:15:00,600 --> 04:15:06,560
这将会……这……这将会是 M

6100
04:15:03,520 --> 04:15:09,359
嗯，B 的 leading dimension（主维数），这个在……中

6101
04:15:06,560 --> 04:15:13,159
这种情况应该是 n，因为它是一个 MN

6102
04:15:09,359 --> 04:15:14,840
时间乘以K，所以第一个开始…… 

6103
04:15:13,159 --> 04:15:17,080
有领先的 M，然后是第二个

6104
04:15:14,840 --> 04:15:20,840
有人要领先了，呃，抱歉

6105
04:15:17,080 --> 04:15:22,560
前导 K，我的意思是前导 k，嗯，B 要……

6106
04:15:20,840 --> 04:15:24,560
拥有一个领先的 K 领先的

6107
04:15:22,560 --> 04:15:27,239
维度将是一个 k，然后我们

6108
04:15:24,560 --> 04:15:29,199
有这个β和一个c，我们呃

6109
04:15:27,239 --> 04:15:30,640
逐元素相乘，然后

6110
04:15:29,199 --> 04:15:32,560
C 的领先维度，所以有很多

6111
04:15:30,640 --> 04:15:35,920
你必须添加到这个里面的东西，而且它

6112
04:15:32,560 --> 04:15:38,119
它很快就会变得相当臃肿，嗯，所以我

6113
04:15:35,920 --> 04:15:39,520
我猜只是为了某种程度上说明一下什么

6114
04:15:38,119 --> 04:15:43,960
所有这些都意味着有很多事情要…… 

6115
04:15:39,520 --> 04:15:46,920
如果我们向下滚动到这里就进行解包

6116
04:15:43,960 --> 04:15:49,920
嗯

6117
04:15:46,920 --> 04:15:49,920
此词可能并不是一个常见英文单词，可能是人名、地名、特定缩写等，由于缺乏更多背景信息，暂时直译为“西耶姆”。 

6118
04:15:54,640 --> 04:16:03,119
（“sjem kuas sjem”可能是无意义或拼写错误的内容）太棒了，所以这是一个

6119
04:15:59,439 --> 04:16:04,159
非常重要的部分 嗯 这正是

6120
04:16:03,119 --> 04:16:07,439
我们刚刚

请注意，“what we just”并不是一个完整的句子，这样的短语单独存在可能表意不完整。如果这是从一段更大的文本中截取的，请提供更完整的内容，以便获得更准确合适的翻译。 

6121
04:16:04,159 --> 04:16:09,439
看呐，瞧瞧这个，所以这就是，这就是

6122
04:16:07,439 --> 04:16:12,520
什么是矩阵 矩阵乘法

6123
04:16:09,439 --> 04:16:15,520
看起来我们有一个 C ，而且我们要这么做

6124
04:16:12,520 --> 04:16:16,760
阿尔法乘以一个OP（无论是什么运算）

6125
04:16:15,520 --> 04:16:20,119
这可能会有点像……（注：原句不完整，这样的翻译只能尽量呈现大概意思）

6126
04:16:16,760 --> 04:16:22,560
对一个矩阵进行转置，然后进行矩阵乘法运算

6127
04:16:20,119 --> 04:16:25,880
对 B 进行一些操作，这些操作可能是

6128
04:16:22,560 --> 04:16:31,479
a的转置，然后加上，呃，β

6129
04:16:25,880 --> 04:16:31,479
β所属的术语是一个……

（注：原英文表述不太完整和准确，此翻译是尽量按字面意思呈现） 

6130
04:16:33,880 --> 04:16:39,359
嗯，贝塔只是一个常数。

6131
04:16:36,880 --> 04:16:43,119
浮点数，所以在这种情况下你

6132
04:16:39,359 --> 04:16:46,880
可能想把 A 设为 1.0，把 B 设为 0.0

6133
04:16:43,119 --> 04:16:49,920
只是为了让你只做 a 乘以 b 的运算

6134
04:16:46,880 --> 04:16:52,040
等于 c，对吧，嗯，但它确实会生成它

6135
04:16:49,920 --> 04:16:53,920
确实为……提供了这种抽象概念

注：原文“this this”可能存在表述错误，推测可能是“this”重复了。 

6136
04:16:52,040 --> 04:16:55,800
你，这样如果你……就能用它做更多的事

6137
04:16:53,920 --> 04:16:59,359
你想之后再添加点东西吗

6138
04:16:55,800 --> 04:17:01,600
就好像，可能有，可能存在某种偏见，对吧

6139
04:16:59,359 --> 04:17:04,960
嗯，然后我们还有所有这些其他的

6140
04:17:01,600 --> 04:17:08,640
操作，所以库布洛斯操作 n，库布洛斯操作 T

6141
04:17:04,960 --> 04:17:11,040
并且库布罗斯的C选项 所以（注：“kublos”可能是特定名称，若有更准确信息可替换；“op C”表意不太明确，可能是“option C”的简略说法） 

6142
04:17:08,640 --> 04:17:13,680
嗯，我们想……我们想关注这个……

6143
04:17:11,040 --> 04:17:15,840
n 以及这里的 T，所以这个 n 是

6144
04:17:13,680 --> 04:17:18,399
好像不是；好像没有

注：“like no”单独看语义不太明确，具体含义要结合语境确定，以上是较为常见的理解。 

6145
04:17:15,840 --> 04:17:21,399
操作 这个 t 是一个

6146
04:17:18,399 --> 04:17:21,399
转置；使变换位置；使颠倒顺序；调换；改变

6147
04:17:23,720 --> 04:17:30,279
嗯，然后你就有了这个按列优先的（排列方式） 

6148
04:17:26,520 --> 04:17:31,880
格式为列主序会引发很多（问题）

注：由于原文表意不太完整，“throws a lot of”后面可能省略了某些内容，此翻译根据现有文本尽力处理。 

6149
04:17:30,279 --> 04:17:34,680
把这个关掉，所以为了说明这一点

6150
04:17:31,880 --> 04:17:38,159
列主序与行主序的区别如下

6151
04:17:34,680 --> 04:17:40,800
正如我们在这里看到的，所以矩阵

6152
04:17:38,159 --> 04:17:44,920
以列主序格式存储，且（这里原句未完整，with后面应该还有内容）

6153
04:17:40,800 --> 04:17:48,479
这些，嗯，这些尺寸是毫米乘以千（这里“K”推测可能是代表千，也可能需要结合具体语境确定更准确含义） 

6154
04:17:44,920 --> 04:17:50,520
然后是 K 拜恩（K byn）和 C M 拜恩（C M byn），嗯，列

6155
04:17:48,479 --> 04:17:53,040
列主序与行主序非常重要

6156
04:17:50,520 --> 04:17:55,560
所以实际上这要稍微难一些，因为

6157
04:17:53,040 --> 04:18:00,080
它是按列主序排列的，但我们会想办法解决的

6158
04:17:55,560 --> 04:18:00,080
不管怎样，按列主序

6159
04:18:01,080 --> 04:18:07,760
矩阵，我们只会有

6160
04:18:05,199 --> 04:18:09,520
实际上，我们把它做成按行优先的形式。

6161
04:18:07,760 --> 04:18:14,760
首先，那很不错。

6162
04:18:09,520 --> 04:18:14,760
想法R 主 a 等于

6163
04:18:22,040 --> 04:18:27,479
呃，然后打电话

6164
04:18:24,479 --> 04:18:27,479
主要的；重要的；重大的；主修的；较多的；大部分的
专业；主修科目；少校；成年人
主修；专攻

6165
04:18:33,279 --> 04:18:38,199
a 然后是内存布局

6166
04:18:45,680 --> 04:18:50,560
所以注意这里的区别，所以我们有

6167
04:18:48,479 --> 04:18:54,760
a 我们有一个

6168
04:18:50,560 --> 04:18:58,399
呃，一个 2×4 的矩阵，对吧，它是 1、2、3、4、5 

6169
04:18:54,760 --> 04:18:59,880
6 7 8 然后这里我们有 1 5 2 6 3 7 4 8

6170
04:18:58,399 --> 04:19:03,800
对，所以这里的整个想法是我们

6171
04:18:59,880 --> 04:19:03,800
基本上对它进行了转置

6172
04:19:04,800 --> 04:19:09,760
我们，这一排从左到……（原文“from left to”后面内容缺失，翻译不太完整准确） 

6173
04:19:07,439 --> 04:19:13,080
对，它现在正从顶部向……（原文未完整）

6174
04:19:09,760 --> 04:19:14,640
最下面了，现在我们得处理这个问题了。

6175
04:19:13,080 --> 04:19:16,239
所以如果我们有像我这样的东西

6176
04:19:14,640 --> 04:19:19,319
通常意味着当你要去喂食的时候

6177
04:19:16,239 --> 04:19:22,479
一个矩阵转化为矩阵乘法

6178
04:19:19,319 --> 04:19:25,600
你期望它是按行优先顺序排列的，并且

6179
04:19:22,479 --> 04:19:28,520
库布罗斯 库布罗斯 谢姆预计它会在

6180
04:19:25,600 --> 04:19:30,760
列主序，所以有一种方法可以得到

6181
04:19:28,520 --> 04:19:31,960
围绕着这个，注意这并非由……（此处英文句子似乎不完整） 

6182
04:19:30,760 --> 04:19:33,720
注意看这个是如何布局的在……（此处英文句子不完整，翻译可能不太准确） 

6183
04:19:31,960 --> 04:19:36,279
记忆 这是一种非常简单的方式来……（原句似乎不完整）

6184
04:19:33,720 --> 04:19:37,560
看着它，然后就觉得，嗯，还行吧。 

6185
04:19:36,279 --> 04:19:39,119
我想是这样，但只是有一点。

6186
04:19:37,560 --> 04:19:45,119
有意思，因为你知道，这是……

6187
04:19:39,119 --> 04:19:47,319
就像1526、1526，就是那个顺序，但是

6188
04:19:45,119 --> 04:19:50,880
呃，有一篇有趣的文章，我

6189
04:19:47,319 --> 04:19:52,319
找到关于如何，呃，如何处理这个问题的方法

6190
04:19:50,880 --> 04:19:56,880
所以这就是为什么你能看到我们的维度

6191
04:19:52,319 --> 04:19:58,960
有点混乱了，嗯，但在这方面

6192
04:19:56,880 --> 04:20:01,119
注意你从堆叠开始的塑形过程

6193
04:19:58,960 --> 04:20:03,399
溢出 我找到了这个问题的答案，并且

6194
04:20:01,119 --> 04:20:06,399
如何让它真正对你起作用

6195
04:20:03,399 --> 04:20:06,399
恩惠；偏爱；赞同；善行
有利于；赞同；喜爱；容貌像；偏袒

6196
04:20:07,800 --> 04:20:14,279
那么……在哪里呢？

注：原英文文本不完整，这样的翻译是在常见语境下推测的较自然表述。 

6197
04:20:10,319 --> 04:20:17,000
这个家伙差不多是这么说的

6198
04:20:14,279 --> 04:20:19,680
嗯，库阿斯（Kuas）将矩阵解释为列

6199
04:20:17,000 --> 04:20:21,840
已排序，所以当你执行这个操作时，你是

6200
04:20:19,680 --> 04:20:24,080
正确地转调，呃，因为你是

6201
04:20:21,840 --> 04:20:26,520
进行一个将要进行转置的操作

6202
04:20:24,080 --> 04:20:29,479
然后一个操作将会进行转置

6203
04:20:26,520 --> 04:20:32,000
呃，B，你正在正确地对每个进行转置。

6204
04:20:29,479 --> 04:20:33,680
输入 嗯，但是堪萨斯大学（KU）的三柱门被击倒是会导致…… 

6205
04:20:32,000 --> 04:20:35,520
列主序，所以你希望它是…… 

6206
04:20:33,680 --> 04:20:37,560
按行优先顺序返回，这样你就可以

6207
04:20:35,520 --> 04:20:39,279
可以用它来做别的事情，那又怎样

6208
04:20:37,560 --> 04:20:43,279
为避免这种情况，你最终不得不去做的事情

6209
04:20:39,279 --> 04:20:46,720
整个按列主序排列的混乱局面是要哄骗堪萨斯大学（Trick KU，这里 KU 可能指堪萨斯大学，需结合具体语境确定）去…… 

6210
04:20:43,279 --> 04:20:48,680
以不同的方式进行计算，嗯，所以这种方式

6211
04:20:46,720 --> 04:20:52,680
你把这个称作……的方式是

6212
04:20:48,680 --> 04:20:54,279
你说处理操作编号OPN，然后你接着处理编号MK

6213
04:20:52,680 --> 04:20:59,040
而不是

6214
04:20:54,279 --> 04:21:02,640
姆克恩，呃，然后你说，嗯，阿尔法，接着…… 

6215
04:20:59,040 --> 04:21:04,159
你的 你的 B 矩阵，而不是一个，嗯

6216
04:21:02,640 --> 04:21:06,199
因为通常你会在这里做一个（某件事），但

6217
04:21:04,159 --> 04:21:10,239
相反，你却这样做

6218
04:21:06,199 --> 04:21:12,640
呃，然后你在引导一场……

需要说明的是，原文“B um”可能存在拼写错误，推测可能是“Um” ；“you do you're”表述有误，可能影响了整体语义的准确传达。 

6219
04:21:10,239 --> 04:21:15,840
维度，所以记住，n，n 是主导的

6220
04:21:12,640 --> 04:21:17,720
时不时会有一个维度，嗯

6221
04:21:15,840 --> 04:21:20,239
然后你有你的 a 以及首项（这里“leading”单独看有“领先的、主要的”等意思，结合数学语境常可理解为首项，但因缺乏更多上下文，也可能有其他准确含义） 

6222
04:21:17,720 --> 04:21:22,840
那个的尺寸将会是，嗯

6223
04:21:20,239 --> 04:21:24,479
会是K
我知道这让人困惑

6224
04:21:22,840 --> 04:21:27,239
但请耐心听我说，然后你就会（有……） 

6225
04:21:24,479 --> 04:21:30,319
那个测试版，就像那样的测试版

6226
04:21:27,239 --> 04:21:31,960
你要将 C 与之相乘的数字以及

6227
04:21:30,319 --> 04:21:34,439
那么 C 的主维数是

6228
04:21:31,960 --> 04:21:35,560
将会是n，所以有很多，有一个……（原英文表述不太完整和清晰，翻译可能不太能精准表意） 

6229
04:21:34,439 --> 04:21:38,680
有很多不同的 有很多奇怪的

6230
04:21:35,560 --> 04:21:39,920
那里有变化，但本质上那是

6231
04:21:38,680 --> 04:21:42,880
去……那将避免……

6232
04:21:39,920 --> 04:21:47,920
按列优先的问题，所以当我们在……中做这件事时

6233
04:21:42,880 --> 04:21:51,479
从DS代码中你可以看到我调用了，呃，科斯（这里“Kos”可能是特定名称，需结合上下文确定准确意思 ） 

6234
04:21:47,920 --> 04:21:55,000
和那个相同的想法，所以……然后

6235
04:21:51,479 --> 04:21:59,319
当我们把……当我们放……

注：原文 “go n MK” 表述不太清晰，可能存在拼写错误或不规范表达，这里仅对能理解的部分进行了翻译。 

6236
04:21:55,000 --> 04:22:02,479
设备B矩阵，我们放置n个设备A矩阵

6237
04:21:59,319 --> 04:22:04,159
K β 设备
C 矩阵
然后又是 n
所以

6238
04:22:02,479 --> 04:22:06,239
就好像是从……复制粘贴过来的

6239
04:22:04,159 --> 04:22:09,239
那个，嗯，还有这个

6240
04:22:06,239 --> 04:22:09,239
作品；工作；起作用（根据语境，“works”可能有不同释义，这里给出常见几种） 

6241
04:22:10,520 --> 04:22:17,760
所以这个这个这个概念适用于 H

6242
04:22:14,800 --> 04:22:20,199
宝石也是，这就是我们下面所拥有的东西。

6243
04:22:17,760 --> 04:22:22,239
所以我已经完成了单精度的，以及一个

6244
04:22:20,199 --> 04:22:24,040
半精度也是，嗯，而且还有

6245
04:22:22,239 --> 04:22:26,119
就像一个小小的选角操作，而你

6246
04:22:24,040 --> 04:22:30,000
在这里，它就像一种流到一半的状态

6247
04:22:26,119 --> 04:22:32,040
函数，嗯，我们初始化这些

6248
04:22:30,000 --> 04:22:34,000
作为半精度矩阵，然后

6249
04:22:32,040 --> 04:22:36,000
我们进行浮点运算以实现转换，并且

6250
04:22:34,000 --> 04:22:38,159
将结果存储在基于我们（情况）的那些（容器、位置等，需结合上下文确定）之中

6251
04:22:36,000 --> 04:22:40,600
索引；目录；指数；指标；索引符号；食指；下标；根指数；（刻度盘上的）指针
把…编入索引；为…编索引；使（工资、价格等）与（物价指数等）挂钩；指示；表明；列出（款项等）与物价指数挂钩的比率

6252
04:22:38,159 --> 04:22:43,119
嗯，卡姆

6253
04:22:40,600 --> 04:22:46,640
将高精度数据复制到设备

6254
04:22:43,119 --> 04:22:49,319
那么主持人，没错，这是一位主持人，抱歉，一位…… 

6255
04:22:46,640 --> 04:22:53,720
一半；半个

6256
04:22:49,319 --> 04:22:56,479
嗯，然后我们再复制回来，我们照做就是了。 

6257
04:22:53,720 --> 04:23:00,880
hgem，也就是半精度，呃

6258
04:22:56,479 --> 04:23:03,399
这个的版本，然后我们再复制回来

6259
04:23:00,880 --> 04:23:04,960
嗯，然后我们……我们可以直接把……打印出来

6260
04:23:03,399 --> 04:23:08,439
查看结果以确保一切都匹配

6261
04:23:04,960 --> 04:23:11,359
那么当我离开的时候

6262
04:23:08,439 --> 04:23:13,239
加拿大国家广播公司（NBCC），而且我们得加上这个小写的“l”

6263
04:23:11,359 --> 04:23:14,920
像这样，这是给林克（Link，也可能是“链接”，需结合具体语境）的，然后我们

6264
04:23:13,239 --> 04:23:17,119
在它的末尾加上库布罗斯，就是这样。

6265
04:23:14,920 --> 04:23:18,319
那意味着，因为CUOS（这里“cuos”可能是特定名称，需结合语境确定准确含义）不只是突然出现

6266
04:23:17,119 --> 04:23:20,319
刚从B出来，你实际上得……

6267
04:23:18,319 --> 04:23:22,640
手动将其关联，因为它必须具备 

6268
04:23:20,319 --> 04:23:25,560
要单独处理那部分，我们只需去做

6269
04:23:22,640 --> 04:23:29,399
向前跑，当我们这么做的时候，我们就能看到我们的……

注：原文“ahead and run this”表述不太符合常规英语表达习惯，推测可能是“run ahead”之类的常见表达，以上翻译是尽量结合语义给出的通顺译文。你可以检查原文是否准确。 

6270
04:23:25,560 --> 04:23:33,640
矩阵，所以当我们往上看时，这是……行

6271
04:23:29,399 --> 04:23:36,319
主要右方 1 2 3 4 1 2 3 4 5 6 7 8 9 10

6272
04:23:33,640 --> 04:23:39,800
11 12，这个也是同样的情况，同样的想法

6273
04:23:36,319 --> 04:23:42,119
其一，你知道这是一个4乘以2，所以它是

6274
04:23:39,800 --> 04:23:44,439
将会是四个高，然后两个一组，共两组 

6275
04:23:42,119 --> 04:23:44,439
宽的；宽阔的；广阔的；范围大的；广泛的；渊博的；远离目标的；偏离的

6276
04:23:46,080 --> 04:23:54,359
嗯，所以这两个，这两个，呃，宽度是一。

6277
04:23:50,960 --> 04:23:56,880
两个，然后 1、2、3、4、5、6、7、8，对吧

6278
04:23:54,359 --> 04:23:59,920
一切都如我们所愿地安排好了

6279
04:23:56,880 --> 04:24:02,279
嗯，当我们处理一个按行优先存储的矩阵时

6280
04:23:59,920 --> 04:24:03,560
在 CPU 上进行乘法运算，我们最终得到

6281
04:24:02,279 --> 04:24:05,520
我们应该得到的东西，所以这些

6282
04:24:03,560 --> 04:24:07,760
内维度相互抵消，然后我们得到…… 

6283
04:24:05,520 --> 04:24:09,479
像我们曾经那样，以三比二领先

6284
04:24:07,760 --> 04:24:11,279
我们之前一直在练习，对吧，而且我们

6285
04:24:09,479 --> 04:24:12,760
最后得到这里的三和二，这些

6286
04:24:11,279 --> 04:24:16,800
结果 这些就是 这些是我们的

6287
04:24:12,760 --> 04:24:19,319
验证结果 50 60 114 140 等等

6288
04:24:16,800 --> 04:24:23,760
我们进行了夸斯·杰姆（这里“kuas sjem”可能是特定名称，需结合更多背景确认）的结果查询，我们得到了……

6289
04:24:19,319 --> 04:24:26,479
同样的形状，嗯，同样的

6290
04:24:23,760 --> 04:24:28,199
数字，然后是我们之后的高清结果

6291
04:24:26,479 --> 04:24:31,880
追溯到单身时期

6292
04:24:28,199 --> 04:24:36,119
精度3倍 砰砰砰砰砰

6293
04:24:31,880 --> 04:24:38,600
砰砰，没错，那只是一个非常

6294
04:24:36,119 --> 04:24:40,560
呃，关于如何……的清晰简洁的例子

6295
04:24:38,600 --> 04:24:42,520
就像库布罗斯（Kublos ，可能为特定名称）与谢姆（Sjem ，可能为特定名称）之间的差异一样

6296
04:24:40,560 --> 04:24:45,439
而且 H 宝石那里全都是差异

6297
04:24:42,520 --> 04:24:49,880
仅仅是半单精度与半精度的对比

6298
04:24:45,439 --> 04:24:51,840
而改变你……的方式的关键在于

6299
04:24:49,880 --> 04:24:53,920
呃，把这个弄好，这是最……

6300
04:24:51,840 --> 04:24:56,479
整个剧本的重要部分是

6301
04:24:53,920 --> 04:24:59,119
就是它是什么，它是怎样的，它有什么作用，以及

6302
04:24:56,479 --> 04:25:01,080
然后介于两者之间的所有东西，呃，就是我们…… 

6303
04:24:59,119 --> 04:25:03,080
为了……需要注意

6304
04:25:01,080 --> 04:25:07,640
把所有东西排成一排

6305
04:25:03,080 --> 04:25:11,479
马朱尔，那么现在我们接着来看夸斯LT

6306
04:25:07,640 --> 04:25:13,640
所以如果我们直接跳到，嗯，就在这里

6307
04:25:11,479 --> 04:25:16,439
科斯 立陶宛语（此处“LT”可能是指立陶宛（Lithuania）的缩写，推测相关背景下表示立陶宛语，若有其他背景请提供更多信息） 

6308
04:25:13,640 --> 04:25:18,520
所以夸斯 LT 是轻量版

6309
04:25:16,439 --> 04:25:21,159
而且它的设计是为了容纳更大的东西

6310
04:25:18,520 --> 04:25:22,399
矩阵，所以我觉得没什么大不了的（这里“little”表意较模糊，可根据具体语境灵活调整，若没有更多背景信息，这种理解比较通用）

6311
04:25:21,159 --> 04:25:25,800
与艰难地解决那件事有关

6312
04:25:22,399 --> 04:25:29,319
顺便说一下，我当时在瞎玩，嗯，你

6313
04:25:25,800 --> 04:25:32,720
没有倍数就无法有矩阵

6314
04:25:29,319 --> 04:25:34,520
四的情况，所以如果你有类似一个 3×4 的，嗯

6315
04:25:32,720 --> 04:25:36,600
就像三不是四的倍数，或者

6316
04:25:34,520 --> 04:25:38,920
一根 2×4 的（材料），它们两者都不是……的倍数

6317
04:25:36,600 --> 04:25:40,119
四个 呃 那些不起作用的那个

6318
04:25:38,920 --> 04:25:41,600
不会 那不会回来

6319
04:25:40,119 --> 04:25:45,560
成功地，但如果你确实有像一个…… 

6320
04:25:41,600 --> 04:25:48,760
4英尺×4英尺，或者4英尺×8英尺，又或者像12英尺×16英尺这样的，或者

6321
04:25:45,560 --> 04:25:51,840
那样的东西会很管用，所以如果

6322
04:25:48,760 --> 04:25:54,040
我们像我这样右键点击这个

6323
04:25:51,840 --> 04:25:55,560
在库布罗斯发现了这个，呃

6324
04:25:54,040 --> 04:25:58,920
文档；文件；文献资料；证明文件；说明书

6325
04:25:55,560 --> 04:26:03,000
嗯，它……它在哪里呢？ 

6326
04:25:58,920 --> 04:26:03,000
走，咱们来搜索这个。

6327
04:26:04,000 --> 04:26:10,960
哦，也许我应该复制这部分。嗯

6328
04:26:08,960 --> 04:26:14,680
但是，是的，所以如果你插入，如果你插入那个

6329
04:26:10,960 --> 04:26:18,920
把字符串输入到这里，你会看到，嗯，在这个…… 

6330
04:26:14,680 --> 04:26:21,960
夸斯 LT 麦德姆嗯，它会滚动的 

6331
04:26:18,920 --> 04:26:23,960
向下数据排序，因此每行四个

6332
04:26:21,960 --> 04:26:26,520
主导维度 主导维度必须

6333
04:26:23,960 --> 04:26:28,560
是四的倍数 嗯 尺寸M

6334
04:26:26,520 --> 04:26:30,600
并且 k 必须是 4 的倍数，对吧，所以

6335
04:26:28,560 --> 04:26:32,319
当……的时候，这在普遍意义上是个好主意。

6336
04:26:30,600 --> 04:26:36,840
你在和大型企业合作，别这么做

6337
04:26:32,319 --> 04:26:40,479
就像4091除以496一样，这有点像…… 

6338
04:26:36,840 --> 04:26:42,600
这么做合乎逻辑，所以，呃

6339
04:26:40,479 --> 04:26:45,159
那 那就是我大致想说的了

6340
04:26:42,600 --> 04:26:46,600
这么说的话，就是要小心外面，嗯

6341
04:26:45,159 --> 04:26:49,880
但让我们直接开始深入探讨吧

6342
04:26:46,600 --> 04:26:54,479
就像实际的 LT MCO 正在做的那样，所以

6343
04:26:49,880 --> 04:26:56,239
我们有这个新的包含头文件，或者，呃

6344
04:26:54,479 --> 04:26:59,040
这个新情况表明我们必须这样做

注：你提供的内容可能表述不太准确，“include”一般不这么用，推测可能想说“indicate” 。 

6345
04:26:56,239 --> 04:27:01,080
科斯有限公司。然后我们有常规的（产品/情况等，需结合上下文确定“regular”具体所指）

6346
04:26:59,040 --> 04:27:04,040
用于检查CUDA以及检查呃……的宏

6347
04:27:01,080 --> 04:27:07,000
对于错误，我们有 CPU 实现

6348
04:27:04,040 --> 04:27:08,399
用于进行对比的实现，嗯，我们

6349
04:27:07,000 --> 04:27:09,760
有打印矩阵，所以那仅仅是

6350
04:27:08,399 --> 04:27:11,159
打算很方便地打印东西

6351
04:27:09,760 --> 04:27:13,040
对于我们来说，我们可以看着它们并进行（此处“make”后缺少内容，表意不完整） 

6352
04:27:11,159 --> 04:27:15,880
当然，一切都对上了。

6353
04:27:13,040 --> 04:27:18,600
嗯，然后注意我是如何确定尺寸的

6354
04:27:15,880 --> 04:27:20,640
四个四，没错，所以不能更少了

6355
04:27:18,600 --> 04:27:23,239
比那个，仅仅是方阵，正方形 

6356
04:27:20,640 --> 04:27:25,840
矩阵，嗯，我也确实会确保去制作……

6357
04:27:23,239 --> 04:27:28,159
这些，呃，这些不同的元素

6358
04:27:25,840 --> 04:27:31,520
所以如果这些是克隆体，那就好像是

6359
04:27:28,159 --> 04:27:32,880
一，从1到16，然后再像你一样从1到16

6360
04:27:31,520 --> 04:27:34,000
可能无法得到你想要的结果，所以

6361
04:27:32,880 --> 04:27:36,239
你想让它们稍微……

6362
04:27:34,000 --> 04:27:38,439
独一无二的，这样你就不会遇到像……这样的情况

6363
04:27:36,239 --> 04:27:41,119
有没有你觉得自己遇到过的奇怪案例呢

6364
04:27:38,439 --> 04:27:43,800
正确答案，但你没有这么做，所以我…… 

6365
04:27:41,119 --> 04:27:45,560
把这里的三个改成了四个

6366
04:27:43,800 --> 04:27:49,359
所以先是四个，然后又是四个，接着……

6367
04:27:45,560 --> 04:27:50,640
我做的是17到20，而不是13到16，嗯

6368
04:27:49,359 --> 04:27:54,960
只是为了稍微改变一下它

6369
04:27:50,640 --> 04:27:57,199
但现在真正的魔法来了，我的意思是我们有

6370
04:27:54,960 --> 04:27:59,319
这里发生了很多事情，就在我们这儿

6371
04:27:57,199 --> 04:28:02,880
嗯，我们实际上在哪里，我们……（此处原文表述不完整且有重复语病，但按要求翻译呈现） 

6372
04:27:59,319 --> 04:28:05,520
本质上，呃，制作一个类似 FP32 的东西

6373
04:28:02,880 --> 04:28:07,520
矩阵，我们能制造它，而且我们会填充它

6374
04:28:05,520 --> 04:28:11,199
那些，而且我们还有一半，所以这是

6375
04:28:07,520 --> 04:28:14,000
只是一个浮点数的一半，所以它的半精度浮点数（fp16）是

6376
04:28:11,199 --> 04:28:18,000
这是什么，嗯，然后我们就……

6377
04:28:14,000 --> 04:28:18,000
用……填充那些

6378
04:28:18,720 --> 04:28:26,880
呃，我们……我们填充这些，这些在哪里呢

6379
04:28:22,800 --> 04:28:29,000
我想我们正在填充它

6380
04:28:26,880 --> 04:28:30,600
哦不，我们已经把它们填充好了。

6381
04:28:29,000 --> 04:28:33,880
在这里，我正处于……（此处英文表述不太完整，语义不太明确，只能大致翻译） 

6382
04:28:30,600 --> 04:28:35,880
有点傻，但在我们像这样之后就会失败

6383
04:28:33,880 --> 04:28:39,840
CMM抄袭了一切，这全怪……（这里“this is all on the”后面似乎句子不完整） 

6384
04:28:35,880 --> 04:28:41,600
设备 现在 嗯 我们有这个库布洛斯 LT

6385
04:28:39,840 --> 04:28:43,399
手柄 所以这就是这个 就只是个手柄

6386
04:28:41,600 --> 04:28:46,040
我们需要营造我们前进所需的环境

6387
04:28:43,399 --> 04:28:48,800
然后创建那个，嗯，然后我们就有这个了

6388
04:28:46,040 --> 04:28:51,080
一个名为库阿斯（Kuas）LT矩阵布局的新术语

6389
04:28:48,800 --> 04:28:52,640
呃，所以说，这里就只有那么几个

6390
04:28:51,080 --> 04:28:54,439
类型 我们需要确保这一切顺利进行

6391
04:28:52,640 --> 04:28:57,159
正确地处理，而这就是其中之一，所以

6392
04:28:54,439 --> 04:28:58,479
本质上就是那些形状，嗯，还有那些

6393
04:28:57,159 --> 04:29:00,399
我们接下来要使用的数据类型，所以

6394
04:28:58,479 --> 04:29:03,359
CUDA数据类型

6395
04:29:00,399 --> 04:29:06,439
呃，然后这种情况就随之而来了。

6396
04:29:03,359 --> 04:29:10,560
与整个按列优先相同的理念

6397
04:29:06,439 --> 04:29:13,680
事情，所以如果我们……我不知道在哪里

6398
04:29:10,560 --> 04:29:16,600
确切地说，这个就在盒子里，但如果我们走的话

6399
04:29:13,680 --> 04:29:20,080
呃

6400
04:29:16,600 --> 04:29:23,720
夸斯，那是什么？那是《黑客帝国》，夸斯

6401
04:29:20,080 --> 04:29:24,960
LT矩阵布局创建，如果我们只是输入

6402
04:29:23,720 --> 04:29:28,920
这；这个

6403
04:29:24,960 --> 04:29:31,960
在这儿我们看到它在下面，并且如果我们拿…… 

6404
04:29:28,920 --> 04:29:33,479
看一下行号和列号

6405
04:29:31,960 --> 04:29:35,319
以及矩阵的行和列，并且

6406
04:29:33,479 --> 04:29:37,680
然后是主维度 主维度

6407
04:29:35,319 --> 04:29:39,560
矩阵按列主序布局，所以

6408
04:29:37,680 --> 04:29:41,119
这是同样的想法，嗯，而且我打算…… 

6409
04:29:39,560 --> 04:29:42,359
给你展示如何度过难关（或克服那个情况，根据语境确定更合适的表达）

6410
04:29:41,119 --> 04:29:44,680
这 这稍微容易了一点

6411
04:29:42,359 --> 04:29:47,159
直观地去大致了解那是如何……怎样…… 

6412
04:29:44,680 --> 04:29:50,920
如果事情能成的话，但没错，呃，我们确实需要这么做。 

6413
04:29:47,159 --> 04:29:54,159
所以要遵守那里的列主序规则

6414
04:29:50,920 --> 04:29:57,399
回到这里，嗯，对于FP32我们

6415
04:29:54,159 --> 04:29:59,960
只用实数“um”，然后是32华氏度，所以如果我们

6416
04:29:57,399 --> 04:30:01,399
实际上，看看这种特定类型，比如

6417
04:29:59,960 --> 04:30:02,880
这是从哪里来的，是 CUDA 数据吗？

6418
04:30:01,399 --> 04:30:05,920
你实际上可以看到一个……的列表

6419
04:30:02,880 --> 04:30:09,239
所以我们这里从，嗯，任何地方都可能有…… 

6420
04:30:05,920 --> 04:30:11,560
就像实数，所以 R 代表实数，C 代表复数

6421
04:30:09,239 --> 04:30:14,000
然后这个数字就是精确率，所以

6422
04:30:11,560 --> 04:30:16,199
16 是一半，然后 32 是完整的一个，并且

6423
04:30:14,000 --> 04:30:18,159
然后64就满了，接着你会有像

6424
04:30:16,199 --> 04:30:21,040
另外，你知道那些更小的类型，即

6425
04:30:18,159 --> 04:30:23,840
你可以使用呃，然后就像平常那样使用就行

6426
04:30:21,040 --> 04:30:27,040
f 呃，本质上就是那个……

6427
04:30:23,840 --> 04:30:29,279
区别在于，就像普通的FP16会

6428
04:30:27,040 --> 04:30:31,040
有一个，就像它会有一个符号位，那个（符号位）是…… 

6429
04:30:29,279 --> 04:30:32,720
无论是积极的还是消极的，然后

6430
04:30:31,040 --> 04:30:35,800
它会有一定数量的指数

6431
04:30:32,720 --> 04:30:37,600
比特，那么整数有多大呢

6432
04:30:35,800 --> 04:30:40,680
小数点前的部分和之前一样 

6433
04:30:37,600 --> 04:30:42,640
位置，然后是尾数部分，也就是

6434
04:30:40,680 --> 04:30:46,199
呃，它在小数位上能有多精确呢？

6435
04:30:42,640 --> 04:30:48,720
好的，那么FP16会更……
（注：原英文句子似乎未表述完整） 

6436
04:30:46,199 --> 04:30:50,920
在小数上精确，然后是BF16或

6437
04:30:48,720 --> 04:30:52,239
脑浮点16 它之所以被称为

6438
04:30:50,920 --> 04:30:55,199
脑电波（此处“brain flow”可能表述不太准确，常见是“brain wave”，按原文翻译为“脑流”不太符合常见说法，推测是“脑电波” ）是因为它来自于

6439
04:30:52,239 --> 04:30:57,920
谷歌大脑，嗯，那将会……

6440
04:30:55,199 --> 04:31:00,920
减少尾数部分，并且更多地……（注：“more”后缺失内容，这里翻译不完整） 

6441
04:30:57,920 --> 04:31:03,239
指数 指数位 所以就是这样

6442
04:31:00,920 --> 04:31:04,720
那种命名方案是，呃，但是

6443
04:31:03,239 --> 04:31:08,960
在这种情况下，我们所需要担心的一切

6444
04:31:04,720 --> 04:31:11,720
这是真正的32位浮点数吗？

6445
04:31:08,960 --> 04:31:13,800
然后是呃真正的16位浮点

6446
04:31:11,720 --> 04:31:16,760
点 点

6447
04:31:13,800 --> 04:31:19,239
嗯，所以我们可以看到我们在这里用到了那些。

6448
04:31:16,760 --> 04:31:21,720
呃，只是针对 32 位系统我们会用到那个，并且

6449
04:31:19,239 --> 04:31:24,479
那么当我们订购这个的时候，我们想

6450
04:31:21,720 --> 04:31:28,279
那么，第一个矩阵A将会

6451
04:31:24,479 --> 04:31:30,840
形状为 n 乘 m 再乘 m ，由 K 决定，所以我们想

6452
04:31:28,279 --> 04:31:32,920
把它翻转一下，这样就会变成 K 除以 m，并且

6453
04:31:30,840 --> 04:31:34,800
然后因为我们把它翻转了，呃，我们需要

6454
04:31:32,920 --> 04:31:39,439
把主维度放在这里，对吧

6455
04:31:34,800 --> 04:31:42,399
所以，呃，主维度在末尾，嗯

6456
04:31:39,439 --> 04:31:44,920
就这样，事情就是这样，所以

6457
04:31:42,399 --> 04:31:47,520
矩阵 B，同样的思路，通常情况下我们有…… 

6458
04:31:44,920 --> 04:31:50,199
所以我们把它翻转过来，然后放上那个

6459
04:31:47,520 --> 04:31:53,159
将新的 n 作为主维度

6460
04:31:50,199 --> 04:31:56,080
然后这里也是同样的想法，嗯，接着

6461
04:31:53,159 --> 04:31:59,199
我们前往FP6，实际上仅仅是……

6462
04:31:56,080 --> 04:32:00,640
使用实数，但我们把32替换成16

6463
04:31:59,199 --> 04:32:03,800
我们对……做着完全相同的事情

6464
04:32:00,640 --> 04:32:06,119
形状，嗯，然后我们往下到那个，呃

6465
04:32:03,800 --> 04:32:08,040
我们刚刚提到的地图描述类型

6466
04:32:06,119 --> 04:32:11,399
必须创造
我们只需要去创造

6467
04:32:08,040 --> 04:32:13,800
那个，而且本质上我们把这个传了进去

6468
04:32:11,399 --> 04:32:16,319
这种我们用来定义内存的类型

注：原句 “this typ type” 可能存在拼写错误，推测正确的可能是 “this type” 。 

6469
04:32:13,800 --> 04:32:19,159
针对那个……计算类型……

6470
04:32:16,319 --> 04:32:21,199
我们正在做的事情，然后是数据类型，所以我们

6471
04:32:19,159 --> 04:32:23,720
看这个，它将是地图M

6472
04:32:21,199 --> 04:32:26,319
搭配库布罗斯LT地图M的说明

6473
04:32:23,720 --> 04:32:28,680
像我们这里有的那种描述类型，以及

6474
04:32:26,319 --> 04:32:30,199
然后是库布勒斯（Kublos）计算类型，我将……

6475
04:32:28,680 --> 04:32:31,600
马上给你展示，然后这个

6476
04:32:30,199 --> 04:32:35,159
我们之前正在处理的数据类型

6477
04:32:31,600 --> 04:32:36,680
这将是，嗯，FP32，所以我们

6478
04:32:35,159 --> 04:32:38,960
去这台电脑那里

6479
04:32:36,680 --> 04:32:40,840
实际上我们看到有一些……的类型

6480
04:32:38,960 --> 04:32:43,319
这些，呃，你只需按住 Ctrl 键再点击就行。

6481
04:32:40,840 --> 04:32:46,239
去看看那些嗯，但有几个

6482
04:32:43,319 --> 04:32:48,000
在这里，所以我们有类似华沙科技大学（Kuas可能是“K Warsaw University of Technology”等类似表述的误写，推测是举例的一个计算主体）的计算，嗯，16

6483
04:32:46,239 --> 04:32:49,520
F 这就是我们接下来要做的事情（此处原英文表述可能不完整，翻译尽量符合语义逻辑）

6484
04:32:48,000 --> 04:32:52,960
想要下一个，但我们是……

注：原文 “the the” 可能存在拼写错误，正常情况下不会这样连续使用两个 “the” 。 

6485
04:32:49,520 --> 04:32:56,000
我现在正在用这个 嗯 你可以这么做

6486
04:32:52,960 --> 04:32:57,720
像这样快速，你可以做得像这样快速，所以它会

6487
04:32:56,000 --> 04:33:00,319
这就好像会改变，我记不得了

6488
04:32:57,720 --> 04:33:02,119
它究竟是如何改变内部的那些人的，但是

6489
04:33:00,319 --> 04:33:06,119
这是类似范畴内的某样东西

6490
04:33:02,119 --> 04:33:08,920
积累着这个那个，嗯，但是

6491
04:33:06,119 --> 04:33:10,439
是啊，所以这些可以是，呃，你，有点……

6492
04:33:08,920 --> 04:33:12,199
这仅仅取决于你在做什么。

6493
04:33:10,439 --> 04:33:13,520
如果你坚持选择“脑漂”（Brain Float，需根据具体情境确定更合适译法）的话，那么

6494
04:33:12,199 --> 04:33:17,920
你可以，你能选那种类型，你

6495
04:33:13,520 --> 04:33:22,080
可以像“快速”那样做，嗯，这取决于你，不过，嗯

6496
04:33:17,920 --> 04:33:22,080
是啊，那就是那里的整体思路。

6497
04:33:22,520 --> 04:33:28,039
所以如果我们回到这一个，你会注意到

6498
04:33:25,920 --> 04:33:30,840
我们只是在使用16位浮点计算

6499
04:33:28,039 --> 04:33:34,561
然后，16的数据类型，呃

6500
04:33:30,840 --> 04:33:37,119
16位浮点数，嗯，然后我们要……

6501
04:33:34,561 --> 04:33:39,039
我们打算设置一个属性

6502
04:33:37,119 --> 04:33:40,760
而这个属性的那些部分，它们……（原句似乎不完整） 

6503
04:33:39,039 --> 04:33:43,160
我们需要的是 M

6504
04:33:40,760 --> 04:33:46,279
我们之前找到的描述类型

6505
04:33:43,160 --> 04:33:50,600
嗯，我们需要一份描述。

6506
04:33:46,279 --> 04:33:54,680
属性，呃，也就是如果你……

6507
04:33:50,600 --> 04:33:58,039
真的可以去这些，呃，还有这些地方

6508
04:33:54,680 --> 04:33:59,439
这些本质上只是，嗯，我……

6509
04:33:58,039 --> 04:34:01,160
记不太清这到底是什么了，但

6510
04:33:59,439 --> 04:34:03,879
这可能就像某种转置之类的情况

6511
04:34:01,160 --> 04:34:05,799
先对 a 进行转置，然后对 b 进行转置，或者

6512
04:34:03,879 --> 04:34:07,279
不管那是什么，嗯，那就是，就是那样

6513
04:34:05,799 --> 04:34:10,920
我猜这是什么，不过我还没看呢

6514
04:34:07,279 --> 04:34:13,000
深入探讨这个问题，但是，嗯，然后就是这个

6515
04:34:10,920 --> 04:34:15,160
其中一个只会是夸斯

6516
04:34:13,000 --> 04:34:18,039
行动
所以，是的，基本上就是

6517
04:34:15,160 --> 04:34:21,879
比如是否进行转置，然后是那个…… 

6518
04:34:18,039 --> 04:34:24,561
呃，这个编码单元（CU）损失操作类型的大小

6519
04:34:21,879 --> 04:34:26,799
所以，呃，本质上就是这样。

6520
04:34:24,561 --> 04:34:28,799
所以我们现在要对这个进行转置操作

6521
04:34:26,799 --> 04:34:30,799
行动，嗯，而且我们只是

6522
04:34:28,799 --> 04:34:33,799
设定那个……那个原帖主（OP）是这样的，那么当它……

注：原文“setting what that that op is so when it”表述不太符合正常语法逻辑，翻译可能不太能完整准确传达意思。 

6523
04:34:30,799 --> 04:34:35,840
是否点赞，然后在括号里写一个“赞”

6524
04:34:33,799 --> 04:34:38,719
这就是它的本质
（注：“that's what this is”常见表达的意思比较灵活，“这就是它的本质”“这就是它的情况”“这就是它的意义所在”等都可能符合语境，需根据上下文灵活调整。以上译文仅为常见理解的一种呈现。）

6525
04:34:35,840 --> 04:34:42,799
嗯，然后我们接着去做夸斯（注：“kuas”可能是特定术语，若有更准确信息可精准翻译）

6526
04:34:38,719 --> 04:34:46,920
长时记忆，呃，你知道的，它本身会接收一种…… （这里原英文似乎未完整表述） 

6527
04:34:42,799 --> 04:34:52,760
处理 嗯 地图 呃 M 描述

6528
04:34:46,920 --> 04:34:57,000
输入 嗯 一个α 一个矩阵布局 B

6529
04:34:52,760 --> 04:35:02,080
BβC呃……C矩阵的矩阵布局

6530
04:34:57,000 --> 04:35:02,080
布局，呃，D 以及诸如此类，对吧

6531
04:35:02,199 --> 04:35:06,160
嗯，你几乎可以直接

6532
04:35:04,840 --> 04:35:07,359
把这些都粘贴过来，这类东西有很多呢

6533
04:35:06,160 --> 04:35:08,959
我们实际上并不需要，我们可以

6534
04:35:07,359 --> 04:35:10,799
只需设置为 null，并且实际上并非……

6535
04:35:08,959 --> 04:35:12,160
是必需的，所以别太担心……

6536
04:35:10,799 --> 04:35:14,799
你只是有点希望事情能变成那样

6537
04:35:12,160 --> 04:35:16,920
按正确的顺序，并且与……的方式如此相似

6538
04:35:14,799 --> 04:35:21,639
我们为普通的夸斯人（Kuas，可能是特定名称，需结合上下文确定准确译法）做了（某事），你打算……

6539
04:35:16,920 --> 04:35:22,959
先处理 B 矩阵，然后呃，还有

6540
04:35:21,639 --> 04:35:24,400
然后你要去处理 A 矩阵

6541
04:35:22,959 --> 04:35:26,680
在……之后；在……后面

注：“after”含义较丰富，需结合具体语境准确理解，这里给出常见释义。如果有上下文，请提供以便给出更精准的翻译。 

6542
04:35:24,400 --> 04:35:28,400
对，所以大致就是那样了。 

6543
04:35:26,680 --> 04:35:30,719
然后我们就进行检查，KU 爆破

6544
04:35:28,400 --> 04:35:32,160
确保一切进展顺利，嗯

6545
04:35:30,719 --> 04:35:33,400
然后，然后有一个……有一个……

6546
04:35:32,160 --> 04:35:35,400
我有点喜欢的重要部分

6547
04:35:33,400 --> 04:35:39,080
这里搞砸了，而且有点蠢。

6548
04:35:35,400 --> 04:35:43,240
但我当时正试图做这个，呃，这个，呃

6549
04:35:39,080 --> 04:35:47,561
16位浮点库阿斯（kuas）LT（可能是特定术语）机器学习（ml）与呃

6550
04:35:43,240 --> 04:35:49,279
和常规的阿尔法类型在一起，所以，嗯，你

6551
04:35:47,561 --> 04:35:51,080
知道 留意一下这是如何像这样那样的

6552
04:35:49,279 --> 04:35:53,760
这无效，它并没有明确说明

6553
04:35:51,080 --> 04:35:56,039
所以我看了看，我看着那个，然后我

6554
04:35:53,760 --> 04:35:58,080
就好像嗯，也许，也许就像我们

6555
04:35:56,039 --> 04:36:00,480
不应该使用 32 位数字，并且

6556
04:35:58,080 --> 04:36:02,719
将其乘以一个16位浮点数

6557
04:36:00,480 --> 04:36:06,160
数字，也许事情并非如此发展

6558
04:36:02,719 --> 04:36:07,760
所以我当时就想，好吧，嗯，我，而且那时候

6559
04:36:06,160 --> 04:36:09,320
我得到了一堆零输出，所以

6560
04:36:07,760 --> 04:36:11,719
我觉得这可能是个不错的解决办法，而且

6561
04:36:09,320 --> 04:36:14,240
结果还挺管用的，所以，呃，你真漂亮

6562
04:36:11,719 --> 04:36:16,799
很多时候只需要，呃，对这个进行类型界定，所以

6563
04:36:14,240 --> 04:36:18,160
从浮点转换为半精度（um可能是有误表述，推测可能是一些特定语境里的单位等但不影响整体理解），然后你只需设置

6564
04:36:16,799 --> 04:36:19,320
你知道你的首领将会是其中之一

6565
04:36:18,160 --> 04:36:20,680
你的贝塔值将为零，你只需

6566
04:36:19,320 --> 04:36:22,160
想做一张地图，这就是你的全部需求了

6567
04:36:20,680 --> 04:36:24,039
关心，所以那就是你打算去做……的方式

6568
04:36:22,160 --> 04:36:25,959
设定好它们，然后只要一半的阿尔法量

6569
04:36:24,039 --> 04:36:28,279
以及β的一半，然后设定这些

6570
04:36:25,959 --> 04:36:30,400
因此，嗯，一切都会顺利的。

6571
04:36:28,279 --> 04:36:34,359
按照计划

6572
04:36:30,400 --> 04:36:38,520
所以事情就是这样发展的，嗯，一旦我们……一旦

6573
04:36:34,359 --> 04:36:41,000
我们完成了那些，然后我们复制这些……结果

6574
04:36:38,520 --> 04:36:42,480
回到主持人这里，呃，我们没在做任何……任何（事）

6575
04:36:41,000 --> 04:36:43,600
就像这里的基准，我们不用担心

6576
04:36:42,480 --> 04:36:47,840
我们只是想确保我们拥有

6577
04:36:43,600 --> 04:36:52,000
正确的结果，嗯，对于这两个“华科大”（注：Kuas可能是“Kao Yuan University of Science and Technology”等类似“华科大”的缩写，需结合具体语境确定）来说

6578
04:36:47,840 --> 04:36:53,799
LT，呃，单精度和半精度，嗯

6579
04:36:52,000 --> 04:36:57,439
所以实际上我们只是复制了这些

6580
04:36:53,799 --> 04:37:00,080
我们回去做一个 CPU 机器学习，呃，你懂的。

6581
04:36:57,439 --> 04:37:03,639
本质上是要获得一个……一个验证，呃

6582
04:37:00,080 --> 04:37:06,000
输出结果，以便我们将其与……进行比较

6583
04:37:03,639 --> 04:37:07,480
嗯，然后我们进行实际的……

6584
04:37:06,000 --> 04:37:10,199
比较本身，所以我们使用一个标准

6585
04:37:07,480 --> 04:37:11,879
库 绝对值 我们进行 这个 减去

6586
04:37:10,199 --> 04:37:14,439
它会给我们一些东西

6587
04:37:11,879 --> 04:37:16,719
价值，那有点像，嗯，你知道的，希望如此

6588
04:37:14,439 --> 04:37:20,760
小于 1 * 10

6589
04:37:16,719 --> 04:37:23,080
^5 嗯，如果那是假的，或者，抱歉，如果……

6590
04:37:20,760 --> 04:37:25,520
如果这个比那个数字大 如果 如果

6591
04:37:23,080 --> 04:37:28,080
它比它所能承受的要大。

6592
04:37:25,520 --> 04:37:29,760
容忍，然后，嗯，上面说他们

6593
04:37:28,080 --> 04:37:32,039
不匹配，最后我们只能返回呃

6594
04:37:29,760 --> 04:37:34,359
它们 它们不匹配 嗯 所以如果我去

6595
04:37:32,039 --> 04:37:37,320
向前并且

6596
04:37:34,359 --> 04:37:40,799
实际上

6597
04:37:37,320 --> 04:37:44,039
呃，运行这个，我们得进行关联余弦计算。 

6598
04:37:40,799 --> 04:37:46,879
链接C LT，因为记得这里顶部的情况

6599
04:37:44,039 --> 04:37:50,760
我们做了夸斯轻型（这里“kuas lt”可能是特定术语，需结合具体语境准确翻译）。所以我们必须纳入。 

6600
04:37:46,879 --> 04:37:54,119
然后，如果我们只是，呃，运行这个，我们

6601
04:37:50,760 --> 04:37:58,039
可以看到，呃，我们得到了一个矩阵 A，所以行

6602
04:37:54,119 --> 04:38:00,279
主矩阵B，嗯，四阶方阵，然后是17

6603
04:37:58,039 --> 04:38:05,959
一直到20，就像我们所期望的那样，然后

6604
04:38:00,279 --> 04:38:07,719
我们得到一个 C 语言输出，即 106 664 106 664 106

6605
04:38:05,959 --> 04:38:09,439
这些不同的总共 664（个/份等，需结合具体语境确定单位）

6606
04:38:07,719 --> 04:38:12,480
精度，并且我们可以看到这些

6607
04:38:09,439 --> 04:38:14,039
与不容忍相匹配，太棒了，所以那就是

6608
04:38:12,480 --> 04:38:15,439
就像比较它们并确保

6609
04:38:14,039 --> 04:38:17,240
它们能按照我们期望的方式运行

6610
04:38:15,439 --> 04:38:19,400
所以我们可以带着它并将其移植到

6611
04:38:17,240 --> 04:38:22,199
别的东西；其他事情

6612
04:38:19,400 --> 04:38:23,561
但随后要实际将其用于比较……

6613
04:38:22,199 --> 04:38:26,439
衡量绩效，我们有一个

6614
04:38:23,561 --> 04:38:29,160
这里是不同的脚本，所以实际上我

6615
04:38:26,439 --> 04:38:30,359
做了同样的事情 嗯 别……别担心

6616
04:38:29,160 --> 04:38:33,279
关于一堆正在发生的……事情 

6617
04:38:30,359 --> 04:38:36,520
这里，这是，这只是一个呃，这是

6618
04:38:33,279 --> 04:38:40,279
只是一个，呃，一个基准测试脚本，那个我…… 

6619
04:38:36,520 --> 04:38:44,561
为比较非常大的（事物）而写

6620
04:38:40,279 --> 04:38:47,561
矩阵，所以我们要进行一个 496 行 1024 列的矩阵乘法运算（注：原句表述不太完整，“Times”一般表示“乘以”，这里推测是在说矩阵乘法相关，但原句未完整表达完整意思） 

6621
04:38:44,561 --> 04:38:49,840
a24 乘以 496，所以是内部尺寸

6622
04:38:47,561 --> 04:38:54,279
消去，那个K被消去了，并且

6623
04:38:49,840 --> 04:38:58,119
然后我们最终得到一个 496×496 的矩阵

6624
04:38:54,279 --> 04:38:59,920
嗯，所以我基本上是采用了一种比较天真的（方法/做法等，需结合上下文确定） 

6625
04:38:58,119 --> 04:39:02,039
矩阵相乘，因为这些非常……（此处英文句子似乎不完整）

6626
04:38:59,920 --> 04:39:04,320
如果数据量很大，CPU处理起来会花费很长时间

注：原英文句子似乎不太完整，推测前面可能省略了“If the data is”之类的内容，这里根据可能的语境进行了补充性翻译。若有更准确的原文或背景信息，请提供以便更精准翻译。 

6627
04:39:02,039 --> 04:39:06,119
所以我写了一个简单的矩阵

6628
04:39:04,320 --> 04:39:08,719
将其相乘，那仍然会让你知道一个

6629
04:39:06,119 --> 04:39:12,520
以行优先顺序排列的可验证为真的答案

6630
04:39:08,719 --> 04:39:15,240
下单，然后你知道的，我们有我们的…… 

6631
04:39:12,520 --> 04:39:18,439
我们的正态分布，呃，随机数

6632
04:39:15,240 --> 04:39:22,680
你所知道的这里的发电机能确保

6633
04:39:18,439 --> 04:39:24,840
一切都正如我们所预想的那样发展着 

6634
04:39:22,680 --> 04:39:28,080
想要一些，本质上就像你做的时候那样

6635
04:39:24,840 --> 04:39:30,279
torch.randn 它就会那样做

6636
04:39:28,080 --> 04:39:33,359
嗯，这会让它变得不像兰德（Rand）那样……嗯

注：由于原文 “Rand n” 表述不太清晰准确，这里只能按原文大致处理。“Rand” 可能是一个人名或特定名称。 

6637
04:39:30,279 --> 04:39:35,600
通常，呃，随机地，通常情况下

6638
04:39:33,359 --> 04:39:38,000
分布式的，嗯，那就是这个……

6639
04:39:35,600 --> 04:39:39,798
正在做的事情，然后同样地验证结果

6640
04:39:38,000 --> 04:39:41,760
想法，它是否会产生相对误差呢？ 

6641
04:39:39,798 --> 04:39:45,480
与不容忍相匹配

6642
04:39:41,760 --> 04:39:47,840
嗯，我们会做一个计时，所以和它一起，和我们的……

6643
04:39:45,480 --> 04:39:49,718
和我们之前的直播（或流媒体内容），所以我们

6644
04:39:47,840 --> 04:39:52,080
实际上我不太想把直播弄进来

6645
04:39:49,718 --> 04:39:54,520
但我们只是想，呃，记录一下时间

6646
04:39:52,080 --> 04:39:57,160
然后做这个计时的事情，呃，还有

6647
04:39:54,520 --> 04:39:59,958
然后把那个拿回来测量一下，嗯

6648
04:39:57,160 --> 04:40:02,520
在实际的设备本身 呃 然后

6649
04:39:59,958 --> 04:40:04,000
我们进行基准测试，而且我们只是有一堆……

6650
04:40:02,520 --> 04:40:05,520
这里中间还填充了其他东西

6651
04:40:04,000 --> 04:40:08,920
和你在……里面看到的一样

6652
04:40:05,520 --> 04:40:10,680
之前的脚本，嗯，然后我们，我们只是

6653
04:40:08,920 --> 04:40:12,320
最终打印出平均时间

6654
04:40:10,680 --> 04:40:15,000
之后；后来

6655
04:40:12,320 --> 04:40:16,718
所以，嗯，它还会返回最大误差，我们…… 

6656
04:40:15,000 --> 04:40:19,240
同样要考虑到可能存在一些错误。

6657
04:40:16,718 --> 04:40:23,200
使用半精度浮点数（FP16），所以我们应该了解这一点。

6658
04:40:19,240 --> 04:40:26,680
呃……但如果我只是把这个打印出来

6659
04:40:23,200 --> 04:40:26,680
这里两个

6660
04:40:29,280 --> 04:40:36,718
比较一下，我们把这个打印出来，注意

6661
04:40:33,360 --> 04:40:39,240
那么，好的，所以堪萨斯大学（KU）的失利结果与比赛情况相符

6662
04:40:36,718 --> 04:40:41,360
带有不容忍结果的朴素内核

6663
04:40:39,240 --> 04:40:43,480
比赛结果 比赛且结果相符

6664
04:40:41,360 --> 04:40:44,798
太棒了，所以一切都安排好了，嗯，我

6665
04:40:43,480 --> 04:40:46,400
确实给了它一些额外的容差

6666
04:40:44,798 --> 04:40:48,480
只是因为一些错误才到了这里

6667
04:40:46,400 --> 04:40:51,560
但是在这里，呃，我们注意到这个误差是

6668
04:40:48,480 --> 04:40:53,638
不是特别显著，嗯，它……它不是

6669
04:40:51,560 --> 04:40:55,320
这是最大误差，所以其中大部分情况（误差）

注：由于原文表述不太完整，此翻译是尽量按照字面意思呈现，若有更完整语境，翻译会更精准。 

6670
04:40:53,638 --> 04:40:57,040
将会变得非常微不足道

6671
04:40:55,320 --> 04:40:59,160
和这个相比，这就像一个

6672
04:40:57,040 --> 04:41:03,760
可能会偶尔出现的边缘特殊情况

6673
04:40:59,160 --> 04:41:05,480
次数，呃，非常少，几乎根本就不，所以

6674
04:41:03,760 --> 04:41:08,040
当我们实际查看那些时间时，我们

6675
04:41:05,480 --> 04:41:11,878
可以看到，正常的CU损失为我们提供了单精度浮点数（fp32）

6676
04:41:08,040 --> 04:41:14,440
平均时间为2.5毫秒 呃 夸斯

6677
04:41:11,878 --> 04:41:16,760
LT给我们平均2分

6678
04:41:14,440 --> 04:41:21,200
约2.8毫秒，这可不是……

6679
04:41:16,760 --> 04:41:25,958
太棒了，呃，然后华科大（Kuas可能有误，推测是华中科技大学HUST的错误表述）的LT FP 16带来了 

6680
04:41:21,200 --> 04:41:27,680
我们（用时）63毫秒，然后LT给我们

6681
04:41:25,958 --> 04:41:32,280
嗯，大概四个

6682
04:41:27,680 --> 04:41:33,760
呃，46毫秒，这真的很快。

6683
04:41:32,280 --> 04:41:35,718
与我们所拥有的这个简单内核相比

6684
04:41:33,760 --> 04:41:37,520
之前就写好了，所以这花了28（这里“28”后面信息缺失，推测可能是时间等单位）

6685
04:41:35,718 --> 04:41:39,878
毫秒来纠正，这是关于……的 

6686
04:41:37,520 --> 04:41:42,920
我ping谷歌所需的时间

6687
04:41:39,878 --> 04:41:46,320
服务器大约需要28毫秒来完成它（这里“完成它”指代不明，需结合上下文确定准确含义）

6688
04:41:42,920 --> 04:41:48,878
运行完整的朴素内核和 LT

6689
04:41:46,320 --> 04:41:52,400
大约花了5毫秒，也就是说

6690
04:41:48,878 --> 04:41:54,680
快得离谱 嗯，就像你看那个……如果你

6691
04:41:52,400 --> 04:41:57,120
只需回顾一下我们曾经的样子，我们

注：原文“at at at”可能存在输入错误。正常表述可能是“at”。 

6692
04:41:54,680 --> 04:42:00,840
我们正在进行一个矩阵乘法运算，其涉及到 

6693
04:41:57,120 --> 04:42:04,200
就像取这一列然后进行相乘操作

6694
04:42:00,840 --> 04:42:06,320
它和一行内容搭配，就像你有……它就像

6695
04:42:04,200 --> 04:42:09,520
尺寸 呃

6696
04:42:06,320 --> 04:42:11,760
1,24 并且它做到了这一点，而且它为……做到了

6697
04:42:09,520 --> 04:42:15,400
每一种组合 就是它 就是它

6698
04:42:11,760 --> 04:42:18,200
在，呃，半小时内完成所有那些事

6699
04:42:15,400 --> 04:42:21,680
毫秒，所以那大约是5

6700
04:42:18,200 --> 04:42:25,798
万分之一秒 呃 但不管怎样

6701
04:42:21,680 --> 04:42:27,480
此时那是一台库布罗斯LT（注：“kublos LT”可能是特定名称，若无标准译法可保留原英文） 

6702
04:42:25,798 --> 04:42:30,160
你可能会有点心烦意乱，或者

6703
04:42:27,480 --> 04:42:32,760
对我为什么只是呃在展示这件事感到沮丧

6704
04:42:30,160 --> 04:42:34,160
你先编写代码，然后对其进行审查，而不是……

6705
04:42:32,760 --> 04:42:35,718
就像从头开始写它一样，就像

6706
04:42:34,160 --> 04:42:37,040
从最上面开始，就像我们来……

6707
04:42:35,718 --> 04:42:39,600
定义这些内容，然后写下这个以及……

6708
04:42:37,040 --> 04:42:41,958
然后写下这个，关键在于就像所有的…… 

6709
04:42:39,600 --> 04:42:43,878
这，有很多
有很多线条

6710
04:42:41,958 --> 04:42:46,320
我不会手动把这些都打出来的

6711
04:42:43,878 --> 04:42:48,400
这门课程呢，已经够长了，就像

6712
04:42:46,320 --> 04:42:51,520
我没办法做到十次

不过原句表述不太符合常规语法，正常可能想说 “I'm not going to make it ten times”  。 

6713
04:42:48,400 --> 04:42:54,440
通过手写把所有内容写下来会更耗时

注：这里“longer”结合语境推测表达“更耗时”“更久”等意思，原英文表述不太完整准确。 

6714
04:42:51,520 --> 04:42:58,400
嗯，不过没错，你大概能明白这个

6715
04:42:54,440 --> 04:43:00,080
给你指出，我确定主要的，主要的

6716
04:42:58,400 --> 04:43:02,320
呃，你需要学习的材料

6717
04:43:00,080 --> 04:43:03,958
最重要的内容，我把它标出来了

6718
04:43:02,320 --> 04:43:05,760
嗯，但我不需要突出显示。

6719
04:43:03,958 --> 04:43:08,480
像开支票、堪萨斯大学（KU）失利之类的一切事情都是…… 

6720
04:43:05,760 --> 04:43:11,160
只是冗余的写作

6721
04:43:08,480 --> 04:43:12,520
嗯，我不知道，就像写……写作方面的事

6722
04:43:11,160 --> 04:43:15,320
这东西和你一样，纯属多余。

6723
04:43:12,520 --> 04:43:17,080
已经知道那是什么了，嗯，所以那是

6724
04:43:15,320 --> 04:43:18,320
这就是我要躲开的原因。

6725
04:43:17,080 --> 04:43:20,718
从那一边，只是试着友善点

6726
04:43:18,320 --> 04:43:22,638
试图取得快速进展

6727
04:43:20,718 --> 04:43:24,920
这里，嗯，我们可能会写下一些东西。

6728
04:43:22,638 --> 04:43:25,840
稍后，只是为了在某种程度上帮你

6729
04:43:24,920 --> 04:43:27,240
当它变得更多时就会理解它

6730
04:43:25,840 --> 04:43:29,638
直观的，而且你实际上就像

6731
04:43:27,240 --> 04:43:32,440
正在建造东西，但现在呢，呃，我们不（在建造了）

6732
04:43:29,638 --> 04:43:34,040
从概念上来说，这并不是很难，所以

6733
04:43:32,440 --> 04:43:37,718
我们只是有点匆匆忙忙地处理着，但

6734
04:43:34,040 --> 04:43:39,000
接下来这部分是关于库布罗斯XT的，所以它是

6735
04:43:37,718 --> 04:43:41,320
本质上和我们所拥有的是同一样东西

6736
04:43:39,000 --> 04:43:43,680
刚完成，只是有点不同，我们

6737
04:43:41,320 --> 04:43:46,000
仍然做那个把手 嗯 我们仍然在制作

6738
04:43:43,680 --> 04:43:47,600
如果我们开展这个名为“设备”的新事物

注：原英文 “it we do” 表述有误，推测可能想说 “if we do” ，以上翻译基于此修正进行。 

6739
04:43:46,000 --> 04:43:49,920
选择（回想）当我说话的时候

注：原英文句子可能存在表述不太准确的情况，这样的翻译是尽量贴合原文字面的译法。 

6740
04:43:47,600 --> 04:43:51,798
关于，嗯，你如何能拥有多个图形处理器（GPU）

6741
04:43:49,920 --> 04:43:55,120
并且在多个（对象）上进行一次计算

6742
04:43:51,798 --> 04:43:58,040
主机里的图形处理器，这就是它的情况，所以

6743
04:43:55,120 --> 04:44:01,080
我们实际上就只做这小小的…… 

6744
04:43:58,040 --> 04:44:03,718
黑掉它们，然后我们只需选择设备

6745
04:44:01,080 --> 04:44:05,480
不管主 GPU 设备是什么，嗯，还有

6746
04:44:03,718 --> 04:44:06,840
那 那就是我们在整个过程中做事的方式

6747
04:44:05,480 --> 04:44:09,360
这是 这只是一个小技巧，当……的时候

6748
04:44:06,840 --> 04:44:12,878
你有一块 GPU，所以你会（去做……这里句子不完整） 

6749
04:44:09,360 --> 04:44:14,280
这个，嗯，然后我们来处理这个XTS宝石（这里“gem”也可能有其他更合适的专业释义，需结合具体语境）。 

6750
04:44:12,878 --> 04:44:16,360
这和我们所拥有的完全是同一回事

6751
04:44:14,280 --> 04:44:17,878
除了你有这些之外，之前一直在做的事情

6752
04:44:16,360 --> 04:44:21,080
主机上的东西，然后

6753
04:44:17,878 --> 04:44:22,480
它们是由，呃，这个 Sjem 管理的。

6754
04:44:21,080 --> 04:44:24,440
起作用，这样你实际上就不必…… 

6755
04:44:22,480 --> 04:44:26,680
把任何东西移动到你刚刚所说的设备上

不过原英文句子 “move anything to device you just you” 表述不太准确，正常可能是 “move anything to the device you just mentioned” 之类的。 

6756
04:44:24,440 --> 04:44:28,520
我连一台摄像机都没有

注：原文 “camm” 可能是 “cam”（摄像机）的拼写错误。 

6757
04:44:26,680 --> 04:44:31,520
在这里复制

6758
04:44:28,520 --> 04:44:33,680
嗯，你只需在……上传入你的矩阵

6759
04:44:31,520 --> 04:44:35,760
主机，并且它将管理所有的内存

6760
04:44:33,680 --> 04:44:37,360
来来回回，但在某些演出中

6761
04:44:35,760 --> 04:44:41,798
成本 所以你马上就会看到，当……的时候

6762
04:44:37,360 --> 04:44:41,798
我编译这个，嗯

6763
04:44:44,080 --> 04:44:48,000
实际上我们并不需要关联 LT，但

6764
04:44:45,760 --> 04:44:48,000
那是；那就是

6765
04:44:48,280 --> 04:44:52,760
好的，嗯，所以你可以看到最大值

6766
04:44:50,600 --> 04:44:57,280
CPU和GPU结果之间的差异

6767
04:44:52,760 --> 04:44:57,280
对，嗯，然后如果我们去……

6768
04:44:58,480 --> 04:45:03,040
说，然后我们就把堪萨斯大学（KU）关联起来

6769
04:45:06,440 --> 04:45:10,958
布洛斯，我们在这里稍等一下，我……

6770
04:45:08,920 --> 04:45:14,080
我做的事情和我们的……做的完全一样吗？

注：原文“did I did”表述有误，正确的可能是“Did I do” ；“as as”可能是 “as...as...”结构，但表述不完整，这里只能按原文勉强翻译。 

6771
04:45:10,958 --> 04:45:17,718
科思（Koss）LT，但适用于XT，而且制作得非常……（这里“made very”后面似乎缺少内容） 

6772
04:45:14,080 --> 04:45:21,760
大矩阵，所以是 16384，你注意到了这个

6773
04:45:17,718 --> 04:45:23,840
郭润确实……但你知道，就像我喜欢…… 

6774
04:45:21,760 --> 04:45:26,680
我想我之前强调过这一点，但是 0。

6775
04:45:23,840 --> 04:45:28,638
平均59秒或6秒，并且

6776
04:45:26,680 --> 04:45:32,520
那么夸斯 LT 将会是一种方式（注：“夸斯 LT”可能是特定术语，若有更准确信息可替换更合适的译法） 

6777
04:45:28,638 --> 04:45:35,958
比那还要久，所以，呃，我们就……

6778
04:45:32,520 --> 04:45:37,920
等一会儿让这个完成，嗯，但是

6779
04:45:35,958 --> 04:45:40,280
是的，你，你，你明白我的意思，这需要一个……

6780
04:45:37,920 --> 04:45:43,040
也许你不想做这件事



6781
04:45:40,280 --> 04:45:45,760
你不想在这里运行这个

6782
04:45:43,040 --> 04:45:47,320
生产 嗯，所以我们得到了平均时间

6783
04:45:45,760 --> 04:45:49,560
所有数据都在公差范围内相符。

6784
04:45:47,320 --> 04:45:54,718
我们挺好的 嗯 不过 是的 就是这样

6785
04:45:49,560 --> 04:45:54,718
库布罗斯XT给你，嗯，去删掉

6786
04:45:55,080 --> 04:46:01,160
这些，我希望你喜欢关于……的那部分内容。

注：原英文句子似乎未表述完整，“on”后面可能缺失内容。 

6787
04:45:57,718 --> 04:46:03,160
Kuas 或 CUDA 基础线性代数

6788
04:46:01,160 --> 04:46:07,160
子程序，呃，那是，那是相当一个…… 

6789
04:46:03,160 --> 04:46:09,760
嘿，呃，美国有线电视新闻网（CNN）上还有第二部分内容。

6790
04:46:07,160 --> 04:46:13,920
那么当你做……当你做……嗯，为了……

6791
04:46:09,760 --> 04:46:17,360
例如像 P 那样安装 PyTorch（注：原句中“P”表意不明，推测可能想说“pip” ；“torch”一般指 PyTorch） 那样

注：原句表述不太准确和完整，以上是根据常见情形做的理解和翻译。 

6792
04:46:13,920 --> 04:46:20,200
这个，呃，你看，呃，它在哪里呢

6793
04:46:17,360 --> 04:46:21,520
库布罗斯·昆恩，没错，就是这里

6794
04:46:20,200 --> 04:46:22,920
这就是它的某种源头所在。

6795
04:46:21,520 --> 04:46:24,760
没错，而且你还有其他所有的东西。

6796
04:46:22,920 --> 04:46:26,718
像Q快速傅里叶变换和C随机数

6797
04:46:24,760 --> 04:46:29,000
生成器、约束规划求解器和约束规划稀疏模型 

6798
04:46:26,718 --> 04:46:31,760
以及跨……的集体通信

注：原文“across”后面缺少内容，若你能补充完整，我可以给出更准确的翻译。 

6799
04:46:29,000 --> 04:46:33,718
多个节点 性能分析器 英伟达Triton推理服务器 哪个

6800
04:46:31,760 --> 04:46:35,878
我们稍后再深入探讨，对吧，我的意思是这是

6801
04:46:33,718 --> 04:46:38,760
这就是我为什么要讲这些内容的原因，所以

6802
04:46:35,878 --> 04:46:40,360
这样你就可以，呃，所以你可以在某种程度上开展工作

6803
04:46:38,760 --> 04:46:42,040
有了它，你就会明白如何使用 PyTorch（此处“Pi torch”推测是“PyTorch”的拼写错误） 

6804
04:46:40,360 --> 04:46:45,240
幕后的工作，没错，那是其中之一

6805
04:46:42,040 --> 04:46:48,520
我这么做的主要原因是…… 

6806
04:46:45,240 --> 04:46:50,320
当你进入美国有线电视新闻网（CNN）的时候，嗯，那里有……有…… 

6807
04:46:48,520 --> 04:46:51,600
实际上这里还有很多需要深入探讨的内容，因为

6808
04:46:50,320 --> 04:46:54,000
与高雄应用科技大学相比，但它不是

6809
04:46:51,600 --> 04:46:56,920
从概念上来说很难，嗯，其中一些是…… 

6810
04:46:54,000 --> 04:47:01,600
有点直观，但其实也不是很直观，嗯

6811
04:46:56,920 --> 04:47:03,520
所以美国有线电视新闻网（CNN）并不完全支持《黑客帝国》

注：这里“matrix”如果结合电影语境通常指《黑客帝国》，如果有其他特定含义，请根据实际情况调整。 

6812
04:47:01,600 --> 04:47:05,240
它进行矩阵乘法运算

6813
04:47:03,520 --> 04:47:07,240
在某些运算中的乘法到

6814
04:47:05,240 --> 04:47:08,520
真的能加快事情的进度，呃，但它不是一个

6815
04:47:07,240 --> 04:47:10,120
性能瓶颈，你没有

6816
04:47:08,520 --> 04:47:12,600
实际上明确地进行矩阵运算

6817
04:47:10,120 --> 04:47:14,920
卷积神经网络中的乘法，那可不是一回事儿。

6818
04:47:12,600 --> 04:47:17,120
那就是 Kblast 处理的事情，对吧，嗯，所以

6819
04:47:14,920 --> 04:47:18,000
在卷积神经网络（CNN）中，你将处理各种事情。

6820
04:47:17,120 --> 04:47:22,520
像；喜欢

6821
04:47:18,000 --> 04:47:25,200
卷积 嗯 池化层 soft Max

6822
04:47:22,520 --> 04:47:27,718
嗯，立即进行随机失活，批量处理

6823
04:47:25,200 --> 04:47:30,558
归一化 呃 张量变换

6824
04:47:27,718 --> 04:47:33,280
像重塑层和拼接层

6825
04:47:30,558 --> 04:47:35,080
诺姆，这一切都没错，所以所有这些其他的

6826
04:47:33,280 --> 04:47:37,360
除……之外的深度学习操作

6827
04:47:35,080 --> 04:47:39,680
矩阵乘法就是量子神经网络（QNN）的本质所在。

注：这里“qnn”推测为“Quantum Neural Network（量子神经网络）”，若实际不是这个含义，你可提供更准确信息。 

6828
04:47:37,360 --> 04:47:41,440
要涵盖很多，嗯，很多……的内容

6829
04:47:39,680 --> 04:47:44,280
很多常用的……（原英文文本存在表述不完整和拼写错误的情况，“Comm L”可能有误，以上翻译是尽量处理现有内容） 

6830
04:47:41,440 --> 04:47:45,798
嗯，所以这在某种程度上就是原因所在。 

6831
04:47:44,280 --> 04:47:47,958
我要带你去看医生，这里是……

6832
04:47:45,798 --> 04:47:50,760
因为这个，这是一个超级……

注：原英文句子表述不太完整或准确，此翻译基于字面进行。 

6833
04:47:47,958 --> 04:47:52,558
与一切事物进行直接交互，嗯，所以

6834
04:47:50,760 --> 04:47:55,480
他们实际上有自己的一套，博士

6835
04:47:52,558 --> 04:47:57,480
英伟达深度学习卷积神经网络，然后你前往那里

6836
04:47:55,480 --> 04:47:59,200
然后它会把你带到这个页面，所以

6837
04:47:57,480 --> 04:48:00,680
这里有好几件事我们有

6838
04:47:59,200 --> 04:48:02,600
比如入门指南或安装说明

6839
04:48:00,680 --> 04:48:04,280
指南，我们并不在意这个指南，然后

6840
04:48:02,600 --> 04:48:06,958
其他的那些，重要的那些，哪些……（这里文本似乎不完整，译文供参考） 

6841
04:48:04,280 --> 04:48:08,400
后端 API 和开发者指南也是如此

6842
04:48:06,958 --> 04:48:11,240
我们接下来要看看这两个

6843
04:48:08,400 --> 04:48:14,638
今天，并且做一些关于 C 语言深度神经网络（DNN）的示例

6844
04:48:11,240 --> 04:48:18,200
操作并对它们进行比较，所以如果我们

6845
04:48:14,638 --> 04:48:20,320
去了解一下后端 API 概述，嗯，我们

6846
04:48:18,200 --> 04:48:23,240
能看出它就像

6847
04:48:20,320 --> 04:48:26,080
嗯，CUDA，所以它支持CUDA流

6848
04:48:23,240 --> 04:48:27,760
我们之前谈论的内容 嗯 它

6849
04:48:26,080 --> 04:48:30,320
有很多各种各样的东西，有点像是…… 

6850
04:48:27,760 --> 04:48:31,558
就像有联系一样，所以就好像……我，我也不清楚。 

6851
04:48:30,320 --> 04:48:33,958
我不会在意那个的。

6852
04:48:31,558 --> 04:48:35,600
完全地，但嗯，你有这些，你有

6853
04:48:33,958 --> 04:48:40,400
本质上有这三个部分，所以

6854
04:48:35,600 --> 04:48:46,000
你有QNN图、QNN算子、QNN卷积神经网络以及

6855
04:48:40,400 --> 04:48:49,160
广告系列，所以图表会朝着它（发展） 

6856
04:48:46,000 --> 04:48:51,000
呃，它不……它不支持。

6857
04:48:49,160 --> 04:48:53,600
就像图形操作，在这种操作中你会有这样的感觉

6858
04:48:51,000 --> 04:48:55,360
处理图表时，更重要的是如何……

6859
04:48:53,600 --> 04:48:57,280
你在……中将操作组合在一起

注：由于原文文本不完整，翻译可能存在表意不够准确的情况。若你能提供完整内容，我将为你提供更精准的翻译。 

6860
04:48:55,360 --> 04:48:59,480
以图表的形式呈现，所以当你在做……的时候

6861
04:48:57,280 --> 04:49:00,798
就像，就像一个卷积层，然后

6862
04:48:59,480 --> 04:49:03,558
你正在引入一种偏差，然后你又在

6863
04:49:00,798 --> 04:49:04,760
之后像那样进行一次最大池化操作

6864
04:49:03,558 --> 04:49:06,360
那看起来会像一幅图表，对吧

6865
04:49:04,760 --> 04:49:09,200
你将会拥有这些节点

6866
04:49:06,360 --> 04:49:11,480
本质上，就好像一个节点是一个

6867
04:49:09,200 --> 04:49:14,520
运算，而边是一个张量

6868
04:49:11,480 --> 04:49:17,280
对，或者是一个矩阵，所以它会像这样

6869
04:49:14,520 --> 04:49:19,240
二维卷积，然后将会

6870
04:49:17,280 --> 04:49:21,160
是一条边，这条边是……这条边是……

6871
04:49:19,240 --> 04:49:23,480
从……的输出端流出的数据

6872
04:49:21,160 --> 04:49:25,400
这里连接到下一个节点的输入以及

6873
04:49:23,480 --> 04:49:27,718
下一个节点可能类似于偏置项。

6874
04:49:25,400 --> 04:49:30,638
它正好加上，呃，然后，然后

6875
04:49:27,718 --> 04:49:33,480
它将从偏置中流出进入……

6876
04:49:30,638 --> 04:49:35,360
呃，比如最大池化层或者平均池化层

6877
04:49:33,480 --> 04:49:36,958
图层，然后它将从

6878
04:49:35,360 --> 04:49:38,240
就在那里，所以与其做这些事情

6879
04:49:36,958 --> 04:49:40,920
分别地，在你进行单独操作的地方

6880
04:49:38,240 --> 04:49:42,480
函数调用用于呃 卷积偏置 所以

6881
04:49:40,920 --> 04:49:44,840
你确实喜欢手动偏置内核，并且

6882
04:49:42,480 --> 04:49:47,000
然后一个手动的最大池化核，你只需

6883
04:49:44,840 --> 04:49:49,558
把这些全部融合成一体，然后你保留 

6884
04:49:47,000 --> 04:49:52,760
记录你所有的 你所有的 呃 数据

6885
04:49:49,558 --> 04:49:54,600
在这期间，它会为你做到这一点，所以……q 

6886
04:49:52,760 --> 04:49:56,440
那……那就是整个量子神经网络（QNN）图的情况

6887
04:49:54,600 --> 04:49:58,240
问题是，嗯，你知道的，它两边都支持。 

6888
04:49:56,440 --> 04:50:00,840
向前和向后的路径，所以当你……

6889
04:49:58,240 --> 04:50:03,600
正在进行预测计算

6890
04:50:00,840 --> 04:50:05,638
预测 呃 当你在 呃

6891
04:50:03,600 --> 04:50:07,600
修改所有梯度并返回

6892
04:50:05,638 --> 04:50:09,840
在其中传播的（某种事物）同时支持两者的……（因原句不完整，只能按已有内容翻译）

6893
04:50:07,600 --> 04:50:11,280
没错，所以它是为……而设计的，它是……

6894
04:50:09,840 --> 04:50:12,840
专为……类型而设计

6895
04:50:11,280 --> 04:50:14,160
呃，只是在安置些东西。

6896
04:50:12,840 --> 04:50:16,040
而不必写下所有的

6897
04:50:14,160 --> 04:50:20,798
从头开始构建内核只是有点……

6898
04:50:16,040 --> 04:50:23,520
这样能让你的生活更轻松 嗯 所以

6899
04:50:20,798 --> 04:50:26,958
在卷积神经网络（CNN）中有多个要素。

6900
04:50:23,520 --> 04:50:30,638
图表 所以我们有这些预编译的

6901
04:50:26,958 --> 04:50:32,480
引擎 运行时 已编译的引擎 嗯 我

6902
04:50:30,638 --> 04:50:36,920
在我的第二个显示器上打开这个

6903
04:50:32,480 --> 04:50:36,920
这边的这个，我可能就把它拿过来

6904
04:50:39,638 --> 04:50:43,120
嗯，它在哪里……（原句似乎不完整） 

6905
04:50:44,080 --> 04:50:48,600
行，是的，所以这个预编译的单一……

6906
04:50:47,080 --> 04:50:50,958
作战引擎 我要搞定这个

6907
04:50:48,600 --> 04:50:52,840
预编译的单个文件更具可读性

6908
04:50:50,958 --> 04:50:54,440
操作引擎预编译并

6909
04:50:52,840 --> 04:50:56,680
针对单一特定情况进行优化

6910
04:50:54,440 --> 04:50:58,120
像卷积一样的运算，因为

6911
04:50:56,680 --> 04:51:00,360
它们是预编译的，它们提供非常

6912
04:50:58,120 --> 04:51:02,558
执行效率高但缺乏灵活性

6913
04:51:00,360 --> 04:51:04,240
就它们所能执行的操作而言

6914
04:51:02,558 --> 04:51:06,558
对，它们被编译成了……

6915
04:51:04,240 --> 04:51:08,200
机器码，它们只执行一项特定的（任务） 

6916
04:51:06,558 --> 04:51:10,240
在某件事情上发挥作用，但进展得非常 

6917
04:51:08,200 --> 04:51:13,440
由于……中的所有优化而快速

6918
04:51:10,240 --> 04:51:15,480
b 区域，它确实有……嗯，所以就像对于

6919
04:51:13,440 --> 04:51:16,958
示例：一个大型乘法运算引擎

6920
04:51:15,480 --> 04:51:18,400
那是预编译并经过优化的

6921
04:51:16,958 --> 04:51:20,760
专门针对那次行动，对吧

6922
04:51:18,400 --> 04:51:23,360
就像和卷积类似，嗯，然后

6923
04:51:20,760 --> 04:51:26,600
有通用运行时融合。

6924
04:51:23,360 --> 04:51:29,520
旨在进行动态融合的引擎

6925
04:51:26,600 --> 04:51:31,040
在运行时进行多项操作，所以

6926
04:51:29,520 --> 04:51:32,600
与……相比提供更多的灵活性

6927
04:51:31,040 --> 04:51:34,878
预编译，因为它们是通用的，并且

6928
04:51:32,600 --> 04:51:36,840
他们能够适应，对吧，呃，这些都是些事情

6929
04:51:34,878 --> 04:51:40,600
那会 那会在……期间发生

6930
04:51:36,840 --> 04:51:42,958
编译，嗯，可能不会像……一样

6931
04:51:40,600 --> 04:51:44,760
高性能优化，但它们是

6932
04:51:42,958 --> 04:51:46,958
它们很普通，而且它们能够，并且它们

6933
04:51:44,760 --> 04:51:48,760
它们能充当……的通用融合器吗？

6934
04:51:46,958 --> 04:51:50,280
将各项运算合并起来，这样你就会得到

6935
04:51:48,760 --> 04:51:52,120
那些性能优势，但它们是

6936
04:51:50,280 --> 04:51:54,440
不会那么高，所以你仍然能得到

6937
04:51:52,120 --> 04:51:55,520
他们，但他们不会是，嗯

6938
04:51:54,440 --> 04:51:57,280
它们不会像……那么高

6939
04:51:55,520 --> 04:51:59,600
专门为此定制撰写的内容

6940
04:51:57,280 --> 04:52:02,240
算法，然后你有一个专门的

6941
04:51:59,600 --> 04:52:04,320
运行时融合引擎类似于通用引擎

6942
04:52:02,240 --> 04:52:06,320
运行时融合引擎 呃 但它们是

6943
04:52:04,320 --> 04:52:08,200
通常，呃，专门针对……进行了优化

6944
04:52:06,320 --> 04:52:12,000
某些模式或组合的

6945
04:52:08,200 --> 04:52:14,680
操作，没错，即提供运行时

6946
04:52:12,000 --> 04:52:18,638
灵活性和利用优化措施

6947
04:52:14,680 --> 04:52:20,798
针对特定用例或操作

6948
04:52:18,638 --> 04:52:23,200
序列，然后例如一台发动机

6949
04:52:20,798 --> 04:52:24,480
针对融合卷积层进行了优化

6950
04:52:23,200 --> 04:52:26,558
接着是激活函数在……中

6951
04:52:24,480 --> 04:52:28,360
神经网络，像……类似，怎样类似

6952
04:52:26,558 --> 04:52:29,920
关于我在你之前所谈论的内容

6953
04:52:28,360 --> 04:52:32,320
有像卷积这样的操作，然后还有一个偏置项

6954
04:52:29,920 --> 04:52:34,878
然后，呃，卷积偏置，接着是一个

6955
04:52:32,320 --> 04:52:37,958
最大拉层，呃，类似于……

6956
04:52:34,878 --> 04:52:39,958
没错，嗯，它会识别你的代码。

6957
04:52:37,958 --> 04:52:42,040
建筑，呃，它会找到保险丝

6958
04:52:39,958 --> 04:52:44,920
你能获得加速的模式

6959
04:52:42,040 --> 04:52:47,760
所以，嗯，它，它就要，它就要……

6960
04:52:44,920 --> 04:52:49,320
嗯，这会很明智的，对吧

6961
04:52:47,760 --> 04:52:50,718
当它……的时候，它会试图表现得聪明些

6962
04:52:49,320 --> 04:52:52,040
当把这个编译下来并查看时

6963
04:52:50,718 --> 04:52:54,400
在那里你实际上可以获得速度提升

6964
04:52:52,040 --> 04:52:57,040
从；来自

6965
04:52:54,400 --> 04:52:59,760
嗯，然后你有了专业的…… 

6966
04:52:57,040 --> 04:53:01,160
预编译的，所以是为……预编译的

6967
04:52:59,760 --> 04:53:03,958
特定的；具体的；明确的；独特的

6968
04:53:01,160 --> 04:53:05,718
它们所提供的序列同样具备高……（这里“high”后面似乎内容不完整） 

6969
04:53:03,958 --> 04:53:07,400
作为预编译单文件的性能

6970
04:53:05,718 --> 04:53:09,638
操作，所以这些曾经是…… 

6971
04:53:07,400 --> 04:53:11,400
非常快，呃，但能处理序列

6972
04:53:09,638 --> 04:53:13,480
是关于操作，而不仅仅是单一的（这里原句似乎不完整）

6973
04:53:11,400 --> 04:53:16,320
一些，所以这些是

6974
04:53:13,480 --> 04:53:18,280
实际上，如果……的话，这些实际上很棒。

6975
04:53:16,320 --> 04:53:19,558
你正试图做很多层处理。

6976
04:53:18,280 --> 04:53:22,080
就好像如果你有一整个，比如说一个

6977
04:53:19,558 --> 04:53:23,718
神经网络中的Transformer模块 呃

6978
04:53:22,080 --> 04:53:25,600
并且你想完成整个注意力相关的操作（注：由于原句表述不太符合常见语境，这样翻译尽量贴合字面意思但可能存在表意不够清晰情况，你可根据实际背景再调整）

6979
04:53:23,718 --> 04:53:27,440
阻止
这是一个关于那个的示例

6980
04:53:25,600 --> 04:53:29,000
那会是这样，你有很多不同的…… （由于原句不完整，这样翻译只是尽量处理现有内容） 

6981
04:53:27,440 --> 04:53:31,080
你在那里进行的操作

6982
04:53:29,000 --> 04:53:35,000
但如果你只有这个包装器，它

（注：原英文句子不完整，推测后面还有内容，翻译按照现有内容进行。）

6983
04:53:31,080 --> 04:53:36,558
多广告投放商表示，你管那叫……呃

6984
04:53:35,000 --> 04:53:38,000
你付出一切，就会得到一切

6985
04:53:36,558 --> 04:53:40,080
你所需要的，并且你把一切都拿出来了

6986
04:53:38,000 --> 04:53:42,400
那很有用，然后你可以继续。

6987
04:53:40,080 --> 04:53:44,558
而且它将经过高度优化。

6988
04:53:42,400 --> 04:53:46,400
专门预编译成二进制文件

6989
04:53:44,558 --> 04:53:48,638
那么，没错，事情大概就是这样

6990
04:53:46,400 --> 04:53:49,600
qnn 是有结构的，并且这些是…… 

6991
04:53:48,638 --> 04:53:50,798
你将要去做的那些你知道你想要做的事情

6992
04:53:49,600 --> 04:53:52,558
当你尝试时需要注意的是

6993
04:53:50,798 --> 04:53:54,440
当你留意寻找时进行优化

6994
04:53:52,558 --> 04:53:57,718
你如何能够利用潜在的（因素/事物等，需结合具体语境确定准确含义） 

6995
04:53:54,440 --> 04:54:01,000
量子神经网络（QNN）特性

注：“qnn” 一般是 “Quantum Neural Network” 的缩写，若这里 “qnn” 有其他含义，请根据实际情况调整。 

6996
04:53:57,718 --> 04:54:04,240
嗯，那个，你知道，有一个……的例子

6997
04:54:01,000 --> 04:54:07,240
就像这里的运行时融合，嗯，还有

6998
04:54:04,240 --> 04:54:09,160
那么如果我们回到图 API，如果

6999
04:54:07,240 --> 04:54:11,638
我们回去
我知道天很亮了
你会……

7000
04:54:09,160 --> 04:54:14,360
好吧，嗯

7001
04:54:11,638 --> 04:54:16,558
我们顺便看一下这个图 API，我

7002
04:54:14,360 --> 04:54:21,160
我觉得就是在那里，没错，图 API

7003
04:54:16,558 --> 04:54:23,480
随着“融合行动”如此

7004
04:54:21,160 --> 04:54:27,280
嗯，卷积

7005
04:54:23,480 --> 04:54:30,638
前向 逐点偏差 逐点值

7006
04:54:27,280 --> 04:54:33,240
嗯，对，这差不多就是全部情况了。

7007
04:54:30,638 --> 04:54:35,320
想法，如果你想把这些融合起来

7008
04:54:33,240 --> 04:54:37,480
你们一起会做，呃，你们会有

7009
04:54:35,320 --> 04:54:40,440
就本质而言，某个组织，你（这里原句表述不太完整和通顺）

7010
04:54:37,480 --> 04:54:41,840
有三个你输入的张量，嗯，还有

7011
04:54:40,440 --> 04:54:44,240
那将类似于他们的变量

7012
04:54:41,840 --> 04:54:46,920
名字 呃 然后像这两个会

7013
04:54:44,240 --> 04:54:49,240
像你，嗯，像你的X那样从这里穿过去

7014
04:54:46,920 --> 04:54:52,080
然后是你的……你的 W，你的权重核

7015
04:54:49,240 --> 04:54:53,520
卷积滤波器本身就是你的 W

7016
04:54:52,080 --> 04:54:56,600
并且那将会输出带有……的内容

7017
04:54:53,520 --> 04:54:58,400
这支箭，然后是这支，这种偏差

7018
04:54:56,600 --> 04:54:59,878
会进来，嗯，然后它会

7019
04:54:58,400 --> 04:55:01,600
本质上是在其输出结果的基础上进行补充

7020
04:54:59,878 --> 04:55:03,958
卷积，然后你会进行一次

7021
04:55:01,600 --> 04:55:06,798
逐点成立，也就是仅仅是…… 

7022
04:55:03,958 --> 04:55:10,718
a 它真的就是一个接一个地进行

7023
04:55:06,798 --> 04:55:12,360
贯穿 贯穿每个元素 嗯

7024
04:55:10,718 --> 04:55:14,080
然后你就得到了你的输出，这样

7025
04:55:12,360 --> 04:55:16,040
这就是图表的整体概念，就好像是…… 

7026
04:55:14,080 --> 04:55:18,040
你有这些，这就是你的数据流。

7027
04:55:16,040 --> 04:55:20,080
边缘部分是你的实际数据

7028
04:55:18,040 --> 04:55:21,638
以及它流向何处，然后是那……

7029
04:55:20,080 --> 04:55:24,798
指出节点本身是

7030
04:55:21,638 --> 04:55:27,160
行动，所以，嗯，继续进行

7031
04:55:24,798 --> 04:55:31,520
通过这个，嗯，你知道的，输入

7032
04:55:27,160 --> 04:55:34,400
卷积反向传播，所以，阿尔法、贝塔、dy 呃

7033
04:55:31,520 --> 04:55:35,920
W 和 DX 嗯，然后你最终会

7034
04:55:34,400 --> 04:55:38,798
得到；获得；变得

7035
04:55:35,920 --> 04:55:40,760
嗯，是的，你，你，你多少能明白那个

7036
04:55:38,798 --> 04:55:42,718
关键在于，你投入什么都是必要的。

7037
04:55:40,760 --> 04:55:45,680
为了一场手术，然后你得到了任何东西（这里表述可能不太通顺，原英文句子表意不是特别清晰完整，可能有上下文）

7038
04:55:42,718 --> 04:55:46,878
这是有用的，对吧，嗯，尤其是

7039
04:55:45,680 --> 04:55:48,440
重要的是你要留意那个在……（此处“in”后内容缺失，句子表意不完整） 

7040
04:55:46,878 --> 04:55:49,558
事物的逆向过程，因为

7041
04:55:48,440 --> 04:55:52,280
将会有更多的数据，你会…… 

7042
04:55:49,558 --> 04:55:54,760
不得不照顾；必须照料

7043
04:55:52,280 --> 04:55:57,600
嗯，不过没错，这些……这些还挺管用的，这个…… 

7044
04:55:54,760 --> 04:56:00,440
到处都是同样的方式，嗯，对你进行规范化处理

7045
04:55:57,600 --> 04:56:01,638
有像你所说的 ε（伊普西龙）和方差 

7046
04:56:00,440 --> 04:56:05,718
嗯，然后你的

7047
04:56:01,638 --> 04:56:08,520
规模持续向前发展，嗯，还是一样

7048
04:56:05,718 --> 04:56:09,958
通用运行时的创意、融合引擎，你

7049
04:56:08,520 --> 04:56:12,400
可以有点随意地浏览这个，然后

7050
04:56:09,958 --> 04:56:15,000
了解一切事物的情况

7051
04:56:12,400 --> 04:56:17,400
架构；设计；建造（architect的过去式和过去分词形式） 

7052
04:56:15,000 --> 04:56:19,000
嗯，这里有相当多的内容，我……

7053
04:56:17,400 --> 04:56:21,798
别指望你能读完所有的

7054
04:56:19,000 --> 04:56:24,480
这个，嗯

7055
04:56:21,798 --> 04:56:27,798
但没错，差不多就是这样

7056
04:56:24,480 --> 04:56:31,240
整个，呃，核聚变引擎这玩意儿是可行的，我（此处“I”单独出现表意不完整，可根据上下文推测完整语义） 

7057
04:56:27,798 --> 04:56:33,280
知道这是个有点傻的说法，但是

7058
04:56:31,240 --> 04:56:35,320
这……这是你实际上在融合

7059
04:56:33,280 --> 04:56:38,000
将操作组合在一起，你可以说

7060
04:56:35,320 --> 04:56:39,878
它就像一台发动机，对吧，所以如果

7061
04:56:38,000 --> 04:56:41,558
我们回到这里的这个VSS代码，那个…… 

7062
04:56:39,878 --> 04:56:44,120
我已经打开了你能（此处原英文句子不完整）的那个自述文件。 

7063
04:56:41,558 --> 04:56:46,320
实际上在这里能找到这些，所以只有你

7064
04:56:44,120 --> 04:56:49,480
知道一堆，嗯，一堆事情，但是

7065
04:56:46,320 --> 04:56:53,480
像图形 API 非常重要，嗯

7066
04:56:49,480 --> 04:56:55,638
马特·莫 卷积前向 卷积反向

7067
04:56:53,480 --> 04:56:57,440
反向数据

7068
04:56:55,638 --> 04:56:59,920
逐点地；点态地

7069
04:56:57,440 --> 04:57:02,200
嗯，是的，就像差不多一些……

7070
04:56:59,920 --> 04:57:04,440
这些图片被复制粘贴，然后就是这个了

7071
04:57:02,200 --> 04:57:07,798
一个是这个，实际上是

7072
04:57:04,440 --> 04:57:09,480
支持，呃，这个是对……的支持

7073
04:57:07,798 --> 04:57:12,320
不同的计算机能力，对吧

7074
04:57:09,480 --> 04:57:15,040
所以，举个例子，要是我……（此句英文表述不太完整且有重复结巴情况） 

7075
04:57:12,320 --> 04:57:16,840
呃，不记得那是什么了，就是…… 

7076
04:57:15,040 --> 04:57:18,360
像设备查询一样，请记住当我们……

7077
04:57:16,840 --> 04:57:19,958
打印出计算机性能以及

7078
04:57:18,360 --> 04:57:25,360
我的是 8 呃

7079
04:57:19,958 --> 04:57:28,120
8.6 所以，嗯，实际上我不会买那个（根据语境补充，原句表意不完整）

7080
04:57:25,360 --> 04:57:29,680
呃，卷积反向滤波器融合，我

7081
04:57:28,120 --> 04:57:32,920
不会买这个，因为它仅仅是…… 

7082
04:57:29,680 --> 04:57:33,958
支持 9.0 及以上版本，那么付费

7083
04:57:32,920 --> 04:57:35,120
当……的时候关注那样的事情

7084
04:57:33,958 --> 04:57:37,360
你在试图把东西融合在一起

7085
04:57:35,120 --> 04:57:39,240
用于类似研究、生产目的

7086
04:57:37,360 --> 04:57:41,200
你要留意是什么

7087
04:57:39,240 --> 04:57:43,878
在你的软件或其他什么东西上得到支持

7088
04:57:41,200 --> 04:57:45,320
你正在研究的硬件，嗯，所以说

7089
04:57:43,878 --> 04:57:47,600
你不喜欢尝试去做某件事，并且

7090
04:57:45,320 --> 04:57:49,040
让它无法正常运作还浪费时间，所以这是……

7091
04:57:47,600 --> 04:57:51,440
和这个再仔细核对一下挺好的。

7092
04:57:49,040 --> 04:57:53,320
各种事情，你看，这些都在有线电视新闻网（CNN）上有报道。 

7093
04:57:51,440 --> 04:57:56,080
文档

7094
04:57:53,320 --> 04:57:57,440
但我们还有几个部分

注：原英文句子不完整，这里按照字面逐行翻译了已有内容。 

7095
04:57:56,080 --> 04:58:00,760
有很多内容要涵盖，所以我要深入探讨一下

7096
04:57:57,440 --> 04:58:03,600
那些，嗯，我们有运维应用程序编程接口（Ops API），我会…… 

7097
04:58:00,760 --> 04:58:04,440
接下来深入探讨其实很简单，嗯，如果我们

7098
04:58:03,600 --> 04:58:09,480
走吧；就这么做吧；直接去

注：“just go”常见有以上几种意思，具体要结合语境判断。由于没有语境，这里把常见意思都列出。如果是在特定语境中翻译，可给我提供更多信息。如果仅按照字面逐字输出译文则为“就走” 。 

7099
04:58:04,440 --> 04:58:11,958
到这里，去行动部门，嗯，基本上你

7100
04:58:09,480 --> 04:58:14,200
有这些相同的不透明结构体类型

7101
04:58:11,958 --> 04:58:16,920
就像你对夸斯·乌姆所做的那样，除了他们会…… 

7102
04:58:14,200 --> 04:58:19,200
不同的操作，这样你就可以进行像……这样的操作

7103
04:58:16,920 --> 04:58:22,440
嗯，就像你可以创建张量一样。

7104
04:58:19,200 --> 04:58:24,638
池化 嗯 过滤器 随机失活 损失

7105
04:58:22,440 --> 04:58:26,400
激活所有这些，所以实际的

7106
04:58:24,638 --> 04:58:28,760
这里的函数可能很难读懂

7107
04:58:26,400 --> 04:58:32,080
它非常明亮。

7108
04:58:28,760 --> 04:58:33,600
嗯，但是激活，反向激活

7109
04:58:32,080 --> 04:58:34,798
往前，你就会看到有一个巨大的…… （注：原句不完整） 

7110
04:58:33,600 --> 04:58:37,200
我不会去做的事情清单

7111
04:58:34,798 --> 04:58:38,160
逐个地浏览这些，嗯……但是你

7112
04:58:37,200 --> 04:58:40,080
明白要点了，这些全都是……

7113
04:58:38,160 --> 04:58:42,558
与库南（Kunan，可能是特定名称）相关的受支持操作

7114
04:58:40,080 --> 04:58:44,080
致美国有线电视新闻网（CNN），我们要进行测试，我们…… 

7115
04:58:42,558 --> 04:58:47,718
打算测试其中一些

7116
04:58:44,080 --> 04:58:49,280
出去，这样你就知道你会得到一堆类似的东西

7117
04:58:47,718 --> 04:58:51,040
呃，关于每个“如果……会怎样”的描述 

7118
04:58:49,280 --> 04:58:52,200
在这些当中这样做，你知道的，以防万一

7119
04:58:51,040 --> 04:58:53,638
你在琢磨着什么事，或者说……

7120
04:58:52,200 --> 04:58:55,840
你不会像你期望的那样得到输出结果。 

7121
04:58:53,638 --> 04:58:57,798
期望 嗯 你通常会提到

7122
04:58:55,840 --> 04:58:59,680
这些文件，这样你就可以（根据它们）进行任何类型的（操作）了 

7123
04:58:57,798 --> 04:59:00,920
你正在使用的或者其他任何函数

7124
04:58:59,680 --> 04:59:03,920
你试图打电话，比如说

7125
04:59:00,920 --> 04:59:06,200
你知道的，你在和这个一起工作，或者……

7126
04:59:03,920 --> 04:59:07,958
也许你正在做，让我们看看，也许

7127
04:59:06,200 --> 04:59:12,520
像这样简单的事情

7128
04:59:07,958 --> 04:59:15,760
呃，就像你激活倒车档，对吧，所以你

7129
04:59:12,520 --> 04:59:17,400
有这个，你把它复制下来，然后你就可以了。

7130
04:59:15,760 --> 04:59:19,680
在各处找到这些，这样你就有了

7131
04:59:17,400 --> 04:59:20,920
量化神经网络（QNN）激活反向传播，并且它具备所有（相关要素） 

7132
04:59:19,680 --> 04:59:24,000
这里面你所说的不同类型

7133
04:59:20,920 --> 04:59:25,280
会用“呃”，然后你会有这个

7134
04:59:24,000 --> 04:59:26,480
这一个，我们的这一个原版的

7135
04:59:25,280 --> 04:59:27,760
之前已经高亮显示了，所以这就是你……（此处原英文句子不完整）

7136
04:59:26,480 --> 04:59:29,638
浏览这些内容，你只需搜索即可。 

7137
04:59:27,760 --> 04:59:32,120
不管哪里出了问题，然后就有点

7138
04:59:29,638 --> 04:59:33,798
比如，看看那个，然后看看其中任何一个

7139
04:59:32,120 --> 04:59:36,520
看看上面的笔记，看你是否遗漏了什么（此处原英文语义不太完整，此为大致合理推测翻译） 

7140
04:59:33,798 --> 04:59:40,440
嗯，有些事情就是那样的情况。 

7141
04:59:36,520 --> 04:59:43,360
呃，你应该这样处理这些……

7142
04:59:40,440 --> 04:59:45,480
然后进入呃美国有线电视新闻网（CNN）的应用程序编程接口（API），所以这个

7143
04:59:43,360 --> 04:59:48,000
就是事情可能会变得有点……

7144
04:59:45,480 --> 04:59:49,520
有意思，嗯，它和任何图表都不一样。

7145
04:59:48,000 --> 04:59:54,160
你正在做的融合方面的事情，就好像

7146
04:59:49,520 --> 04:59:56,440
原始算法 嗯，所以你会有 嗯，你

7147
04:59:54,160 --> 04:59:58,558
了解卷积反向传播中的偏置，就像了解所有方面一样

7148
04:59:56,440 --> 05:00:01,280
只是所有不同的卷积相关内容

7149
04:59:58,558 --> 05:00:04,080
嗯，我的意思是，有融合的情况

7150
05:00:01,280 --> 05:00:08,558
呃，所以这就是其中一些……的出处

7151
05:00:04,080 --> 05:00:09,718
会进来，不过嗯，是的，就是这样

7152
05:00:08,558 --> 05:00:11,718
是所有卷积相关内容所在之处

7153
05:00:09,718 --> 05:00:14,200
将用于类似图像处理方面

7154
05:00:11,718 --> 05:00:15,718
你说得没错，所以我们打算…… 

7155
05:00:14,200 --> 05:00:17,040
实际上，马上就要用到卷积了。

7156
05:00:15,718 --> 05:00:18,798
所以我打算，我打算保存

7157
05:00:17,040 --> 05:00:21,400
这个，但这是你，你去处理它这个（此处原文可能不完整，译文可能不太通顺） 

7158
05:00:18,798 --> 05:00:23,798
就像你处理运维（Ops）的方式一样

7159
05:00:21,400 --> 05:00:25,400
操作，然后你会有呃

7160
05:00:23,798 --> 05:00:30,320
对抗性的；敌对的；敌手的

7161
05:00:25,400 --> 05:00:33,680
API，呃，概念是一样的，但你懂的

7162
05:00:30,320 --> 05:00:37,040
其他功能，就像你知道的循环神经网络（RNN）那样

7163
05:00:33,680 --> 05:00:39,120
嗯，呃，CTC损失多头

7164
05:00:37,040 --> 05:00:42,320
注意 呃 我们会做 是的 明白

7165
05:00:39,120 --> 05:00:46,718
多头注意力权重 所以如果我继续

7166
05:00:42,320 --> 05:00:49,680
嗯，多头注意力机制，多……广告（这里“multi - ad”可能表述不太完整准确，“ad”一般是“advertisement”广告的缩写 ） 

7167
05:00:46,718 --> 05:00:55,160
注意 向前 真棒 我们该怎么用

7168
05:00:49,680 --> 05:00:55,160
这个，没错，这里有多头（机制）

7169
05:00:57,160 --> 05:01:03,638
注意前方，这里面有22个这样的（东西）。 

7170
05:01:01,520 --> 05:01:07,160
这里 21

7171
05:01:03,638 --> 05:01:08,920
现在，所以你大概明白我们能……的意思了

7172
05:01:07,160 --> 05:01:12,958
滚动浏览

7173
05:01:08,920 --> 05:01:12,958
这些，有很多

7174
05:01:13,440 --> 05:01:19,080
哎呀，嗯，所以这就是你做……的方式 

7175
05:01:17,120 --> 05:01:21,280
多头注意力模块前向传播以及

7176
05:01:19,080 --> 05:01:23,320
前向传播，有很多内容

7177
05:01:21,280 --> 05:01:25,520
在这儿，但就是那样，就是那样，就是那样，就是那样。

7178
05:01:23,320 --> 05:01:27,920
事情大概就是这样，嗯，就只是这个…… 

7179
05:01:25,520 --> 05:01:29,360
对抗性的，就像额外的另一部分

7180
05:01:27,920 --> 05:01:33,520
杂七杂八，随便你怎么称呼

7181
05:01:29,360 --> 05:01:36,080
呃，但是现在我们实际上可以进入……

7182
05:01:33,520 --> 05:01:39,558
呃，其中一些

7183
05:01:36,080 --> 05:01:42,080
进行比较以理解，呃，如何去……

7184
05:01:39,558 --> 05:01:43,480
实际上现在我们在一个CUDA脚本中使用卷积神经网络（CNN）

7185
05:01:42,080 --> 05:01:46,360
实际上可以深入研究其中一些代码

7186
05:01:43,480 --> 05:01:48,360
以及卷积神经网络（CNN）背后的例子和它的工作原理

7187
05:01:46,360 --> 05:01:50,520
在引擎盖下
嗯，不是，不是它的工作原理

7188
05:01:48,360 --> 05:01:52,320
在表象之下，但我们如何利用这些事物

7189
05:01:50,520 --> 05:01:55,480
就像在幕后使用 PyTorch 来制作

7190
05:01:52,320 --> 05:01:58,680
操作真的很快，所以在这方面

7191
05:01:55,480 --> 05:02:00,798
例如，嗯，你知道的，我们会进行CUDA相关操作。 

7192
05:01:58,680 --> 05:02:03,320
运行时间和卷积神经网络。嗨，我只是打算

7193
05:02:00,798 --> 05:02:04,840
例如，执行这 10 个功能，嗯，然后在……里

7194
05:02:03,320 --> 05:02:08,680
万一你还没见过这 10 个功能

7195
05:02:04,840 --> 05:02:08,680
然而，嗯

7196
05:02:10,080 --> 05:02:14,040
我们去谷歌（网站；公司）

注：“Google”常见释义为“谷歌”，既可以指谷歌搜索引擎网站，也可以指谷歌公司，具体含义需结合语境判断。 

7197
05:02:11,440 --> 05:02:16,600
图片，呃，它看起来简直就像

7198
05:02:14,040 --> 05:02:19,160
像这样 10 H

7199
05:02:16,600 --> 05:02:22,520
嗯，或者像这样，也许这样更好

7200
05:02:19,160 --> 05:02:24,120
其一，它介于 -1 和 1 之间，它是…… 

7201
05:02:22,520 --> 05:02:26,320
只是一个小小的激活函数，它

7202
05:02:24,120 --> 05:02:30,320
你操作的时候，就像一条优美顺滑的 S 形曲线

7203
05:02:26,320 --> 05:02:31,558
呃，对，所以我们要说的就这些。

7204
05:02:30,320 --> 05:02:33,600
我们实际上并不需要在这里真正做这件事。 

7205
05:02:31,558 --> 05:02:35,200
要像那样在公式里输入内容，它是

7206
05:02:33,600 --> 05:02:37,240
已经为我们做好了 嗯 实际上我已经…… 

7207
05:02:35,200 --> 05:02:40,280
这里写出了10小时内核，并且

7208
05:02:37,240 --> 05:02:46,680
手术实际上对P来说只需10个高频单位。 

7209
05:02:40,280 --> 05:02:49,840
在设备上运行的功能，嗯，非常简单，嗯

7210
05:02:46,680 --> 05:02:56,440
我们 我们想拥有一个带有……的张量

7211
05:02:49,840 --> 05:02:58,760
形状，嗯，它叫什么来着，n 乘 n 乘 C 再乘…… 

7212
05:02:56,440 --> 05:03:01,440
高乘宽，这就是我们的格式

7213
05:02:58,760 --> 05:03:04,718
想使用，所以它会像 n 一样

7214
05:03:01,440 --> 05:03:07,360
批量大小、通道数，呃，通道是 C 吗？

7215
05:03:04,718 --> 05:03:09,320
是先通道高度，然后是宽度，对吗？

7216
05:03:07,360 --> 05:03:11,160
所以，关于频道的整个概念是，如果

7217
05:03:09,320 --> 05:03:12,600
你有，呃，就像一张……的图片

7218
05:03:11,160 --> 05:03:14,840
例如你视频里的那张图片

7219
05:03:12,600 --> 05:03:16,120
你现在正在看着我，这是

7220
05:03:14,840 --> 05:03:19,360
将会有三个频道，它即将…… 

7221
05:03:16,120 --> 05:03:21,400
要正确设置RGB，所以这是如果，呃，比如说

7222
05:03:19,360 --> 05:03:23,440
你你做了一些卷积，并且

7223
05:03:21,400 --> 05:03:26,280
现在你的，现在你的频道维度是

7224
05:03:23,440 --> 05:03:29,120
非常大，所以你得到的不是三个，而是…… 

7225
05:03:26,280 --> 05:03:30,920
就像你拥有的每个像素有32个元素一样

7226
05:03:29,120 --> 05:03:32,718
跟踪并进行操作

7227
05:03:30,920 --> 05:03:35,440
对，所以我们正在创建一个大张量。

7228
05:03:32,718 --> 05:03:38,958
这里有个大张量 嗯 如果我真的深入研究…… 

7229
05:03:35,440 --> 05:03:41,160
Python新的256 我们会进展顺利的 四

7230
05:03:38,958 --> 05:03:47,958
乘以，因为 4 是字节的数量

7231
05:03:41,160 --> 05:03:51,558
它将占用 4 * 256 * 32 * 2 *

7232
05:03:47,958 --> 05:03:54,760
224 呃的平方，我们最终得到了这个。

7233
05:03:51,558 --> 05:03:57,718
数字，并且如果我们用这个数字除以

7234
05:03:54,760 --> 05:04:01,718
呃，一百万，它是……（这里“it's”后面内容缺失，表述不太完整） 

7235
05:03:57,718 --> 05:04:02,958
大约1.6千兆字节，这就是它的大小。 

7236
05:04:01,718 --> 05:04:04,280
张量是，然后我们要进行一次…… 

7237
05:04:02,958 --> 05:04:06,958
持续10小时

7238
05:04:04,280 --> 05:04:08,040
所以Cuda DN将处理这个问题

7239
05:04:06,958 --> 05:04:10,840
然后我们将把它与……进行比较

7240
05:04:08,040 --> 05:04:14,480
简单内核，嗯

7241
05:04:10,840 --> 05:04:17,360
是的，所以就一步步来处理这个（事情）。 

7242
05:04:14,480 --> 05:04:19,000
同样的库达·马利克（Cuda Malik）初始化数据 库达·马（Cuda M）

7243
05:04:17,360 --> 05:04:21,240
收到，我们要创建一些活动。

7244
05:04:19,000 --> 05:04:23,000
我们可以在 GPU 上对内容进行计时，我们正在

7245
05:04:21,240 --> 05:04:26,200
准备做我们的热身活动，然后呢，然后……

7246
05:04:23,000 --> 05:04:29,718
基准测试运行，嗯，我们要进行一些（基准测试）

7247
05:04:26,200 --> 05:04:33,040
对刀核进行热身运行

7248
05:04:29,718 --> 05:04:34,718
嗯，我们要为它进行基准测试。

7249
05:04:33,040 --> 05:04:35,638
我们要搭建 QNN，这是

7250
05:04:34,718 --> 05:04:37,480
我们实际上要去学习一门（这里句子不完整，推测可能是“一门课程”之类的，“a”后面应该还有内容）

7251
05:04:35,638 --> 05:04:39,878
嗯，有那么一点点，然后就像基准测试那样

7252
05:04:37,480 --> 05:04:42,878
当然，对于美国有线电视新闻网（CNN）来说，这就是它……（原文未完整） 

7253
05:04:39,878 --> 05:04:45,000
发生了，所以我们有了这个QNN句柄

7254
05:04:42,878 --> 05:04:47,760
我们创造的类型

7255
05:04:45,000 --> 05:04:50,480
我们有这种张量描述符类型

7256
05:04:47,760 --> 05:04:52,638
所以你实际上需要，嗯，这就像那个……

7257
05:04:50,480 --> 05:04:54,520
当你像描述《黑客帝国》那样进行描述时

7258
05:04:52,638 --> 05:04:56,760
或者矩阵 B 的描述符，它是一样的

7259
05:04:54,520 --> 05:04:58,200
想法，但我们对张量这么做是因为

7260
05:04:56,760 --> 05:04:59,480
你知道的，它更深入内在。 

7261
05:04:58,200 --> 05:05:01,798
学习情境更加深入了

7262
05:04:59,480 --> 05:05:04,240
自[此处原文未提及时间]以来一直在学习CUDA CP DNN中的操作

7263
05:05:01,798 --> 05:05:08,878
这是深度神经网络 C 深度神经

7264
05:05:04,240 --> 05:05:10,120
呃，这么说吧，我们已经创建了洋葱网络（Tor）。

7265
05:05:08,878 --> 05:05:11,320
那个描述符，它接下来仅仅会……

7266
05:05:10,120 --> 05:05:12,760
获取这个的内存地址，并且

7267
05:05:11,320 --> 05:05:15,638
实际上创建张量描述符

7268
05:05:12,760 --> 05:05:17,320
基于类型，嗯，我们打算设定

7269
05:05:15,638 --> 05:05:20,680
张量描述符，所以它将会……

7270
05:05:17,320 --> 05:05:23,958
呃，是我们做过的这种类型

7271
05:05:20,680 --> 05:05:28,680
已经是张量格式、数据类型

7272
05:05:23,958 --> 05:05:30,600
然后，那些……呃，每个都是NCH HW格式

7273
05:05:28,680 --> 05:05:32,920
对，所以我们就按这个，按这个形式来做

7274
05:05:30,600 --> 05:05:37,080
而且你可以去查证这个，并且

7275
05:05:32,920 --> 05:05:41,840
嗯，它就在这儿，张量格式

7276
05:05:37,080 --> 05:05:46,400
所以我们可以做NCH作业，我们可以做NWC或者n

7277
05:05:41,840 --> 05:05:49,160
NHWC 嗯，诸如此类，对吧，所以那就是我们刚刚…… 

7278
05:05:46,400 --> 05:05:52,240
我们就选这一个，然后选这个数据

7279
05:05:49,160 --> 05:05:53,360
浮动 我们看看这个 嗯 我们可以有

7280
05:05:52,240 --> 05:05:57,440
像一堆不同的东西一样快

7281
05:05:53,360 --> 05:05:59,958
用于FP8的浮点数，嗯，FP8，所以我们会有一个

7282
05:05:57,440 --> 05:06:02,120
符号位，然后是五位指数位以及

7283
05:05:59,958 --> 05:06:05,000
然后是两个尾数比特，对，所以它是

7284
05:06:02,120 --> 05:06:07,200
总共八个，对吧，嗯，然后是FP8，你

7285
05:06:05,000 --> 05:06:08,958
了解更多 更多尾数位数，然后

7286
05:06:07,200 --> 05:06:10,558
布尔型，我们有所有这些不同的

7287
05:06:08,958 --> 05:06:13,200
类型，但我们需要浮点数，那里没有

7288
05:06:10,558 --> 05:06:17,798
就像这里的 32 位浮点数，我们只想要一个普通的

7289
05:06:13,200 --> 05:06:20,240
浮点、不、不、半精度、不、BF16（脑浮点16位），都不是，嗯

7290
05:06:17,798 --> 05:06:23,040
只是一些基本的东西来……来……来……

7291
05:06:20,240 --> 05:06:24,240
使用，然后我们不仅创造了

7292
05:06:23,040 --> 05:06:26,558
张量描述符，因为我们有这个

7293
05:06:24,240 --> 05:06:28,280
张量本身，然后我们有了这个

7294
05:06:26,558 --> 05:06:30,080
激活描述符，其内容是关于

7295
05:06:28,280 --> 05:06:32,558
激活将要做什么以及

7296
05:06:30,080 --> 05:06:34,320
针对那个我们有一个自定义类型，嗯，还有

7297
05:06:32,558 --> 05:06:37,160
你可以去这里，而且那里有一个……

7298
05:06:34,320 --> 05:06:39,878
一堆不同的 嗯 我觉得

7299
05:06:37,160 --> 05:06:41,440
我不知道这里到底是哪儿

7300
05:06:39,878 --> 05:06:42,958
但我只是喜欢对东西进行右键操作

7301
05:06:41,440 --> 05:06:46,080
去学习

7302
05:06:42,958 --> 05:06:49,240
是啊，不错

7303
05:06:46,080 --> 05:06:51,760
运气，呃，我们创造了ACT激活（机制） 

7304
05:06:49,240 --> 05:06:53,480
带有其内存地址的描述符以及

7305
05:06:51,760 --> 05:06:56,958
这里我们有激活描述符

7306
05:06:53,480 --> 05:06:59,520
像之前那样输入，我们有卷积神经网络（CNN），或者呃，我们

7307
05:06:56,958 --> 05:07:02,000
有激活类型，呃，模式类型，所以

7308
05:06:59,520 --> 05:07:05,480
激活模式呃将是

7309
05:07:02,000 --> 05:07:08,920
10小时，然后，呃，传播类型是

7310
05:07:05,480 --> 05:07:10,480
只是楠……呃，我们……我们不是……我们不是

7311
05:07:08,920 --> 05:07:13,840
正在做那件事

7312
05:07:10,480 --> 05:07:15,920
嗯，然后系数将会

7313
05:07:13,840 --> 05:07:17,638
呃，是零，所以不会……我

7314
05:07:15,920 --> 05:07:20,200
不知道什么 什么是KF 我不知道

7315
05:07:17,638 --> 05:07:22,120
那是什么，嗯，但不管怎样，这只是

7316
05:07:20,200 --> 05:07:23,798
喜欢我们现有的模板布局

7317
05:07:22,120 --> 05:07:25,360
而且我也没指望你会去

7318
05:07:23,798 --> 05:07:27,040
通过这个并理解每一个

7319
05:07:25,360 --> 05:07:28,920
这里正在发生的角色情况，这是

7320
05:07:27,040 --> 05:07:30,400
只是一个更具模板性的示例，用于

7321
05:07:28,920 --> 05:07:32,520
给你展示我们是如何比较这些的

7322
05:07:30,400 --> 05:07:34,000
我们是如何运行和测试的，还有你

7323
05:07:32,520 --> 05:07:35,520
能不能把这些拿出去然后放好

7324
05:07:34,000 --> 05:07:36,958
放入其他代码片段中，所以不要像

注：你提供的英文文本不太完整或表意不太清晰，以上翻译是按照字面意思进行的。 

7325
05:07:35,520 --> 05:07:39,840
如果你不明白，完全不必难过。

7326
05:07:36,958 --> 05:07:41,440
这个，这里有很多，嗯，但是

7327
05:07:39,840 --> 05:07:45,240
例如，如果我们像这样继续下去，我们

7328
05:07:41,440 --> 05:07:48,000
有像S型函数R 10、裁剪函数R 嗯、Swish函数

7329
05:07:45,240 --> 05:07:51,080
所有这些都没错，所以我们只需要双曲正切函数（tanh）。 

7330
05:07:48,000 --> 05:07:54,440
函数，嗯

7331
05:07:51,080 --> 05:07:57,360
现在我们像往常一样进入激活环节

7332
05:07:54,440 --> 05:07:59,120
就在几分钟前我看到了 嗯 我们

7333
05:07:57,360 --> 05:08:01,160
拥有我们定义的扫描句柄

7334
05:07:59,120 --> 05:08:02,958
在激活描述符之前，我们…… 

7335
05:08:01,160 --> 05:08:05,600
我们刚刚讲了阿尔法（部分）

7336
05:08:02,958 --> 05:08:10,480
参数 我们所使用的张量描述符

7337
05:08:05,600 --> 05:08:12,680
盖住了 呃，在这儿我们有这个 嗯

7338
05:08:10,480 --> 05:08:15,080
我们有这个空白区域X，所以就是这样

7339
05:08:12,680 --> 05:08:18,638
那只是一个输入，一个贝塔项，它

7340
05:08:15,080 --> 05:08:21,680
我们不需要嗯，然后也不需要张量

7341
05:08:18,638 --> 05:08:24,798
y 的描述符类型以及输出

7342
05:08:21,680 --> 05:08:26,480
它本身只是一个，呃，它，它什么都不是。

7343
05:08:24,798 --> 05:08:28,480
这没什么特别的，这是

7344
05:08:26,480 --> 05:08:29,958
只是一片虚无，所以我们不需要任何类似的东西

7345
05:08:28,480 --> 05:08:32,520
针对它的特殊类型，这就像一个

7346
05:08:29,958 --> 05:08:34,798
本质上是像数组输出这样的原始数据

7347
05:08:32,520 --> 05:08:36,680
嗯，会有很多花车游行队伍之类的，对吧

7348
05:08:34,798 --> 05:08:38,558
嗯，所以就是这样，事情还在发展

7349
05:08:36,680 --> 05:08:40,120
在设备上，这就是我们有D的原因

7350
05:08:38,558 --> 05:08:42,240
那儿，嗯

7351
05:08:40,120 --> 05:08:43,558
嗯，我们要把一切都同步起来。

7352
05:08:42,240 --> 05:08:44,798
然后进行我们的基准测试运行

7353
05:08:43,558 --> 05:08:46,600
基准测试运行，我们要找到那个

7354
05:08:44,798 --> 05:08:49,000
我们要验证的平均时间

7355
05:08:46,600 --> 05:08:49,000
反对；对抗；靠着；映衬着

请注意，“against the”并非完整的表达，“against”后一般会接名词等构成完整语义，如果你还有后续内容，可以继续提供让我准确翻译。 

7356
05:08:49,480 --> 05:08:53,840
CPU，就像给CPU“晒黑”，举个例子，它并不是

7357
05:08:52,280 --> 05:08:55,520
不会花很长时间，因为它就像个

7358
05:08:53,840 --> 05:08:57,360
就像逐点运算一样，它仅仅是

7359
05:08:55,520 --> 05:09:00,958
要逐个仔细检查它，这是…… 

7360
05:08:57,360 --> 05:09:05,000
非常，它就像线性时间，嗯，所以当我们

7361
05:09:00,958 --> 05:09:10,920
实际上，呃，当我们真正进行编译时

7362
05:09:05,000 --> 05:09:12,760
这个10进制转16进制（这里猜测10 H 可能是10进制转16进制的错误表述，一般10进制用D，16进制用H ）到深度神经网络（DNN），看它知道了

7363
05:09:10,920 --> 05:09:15,558
我们掌控局面，实际上你将会成为…… 

7364
05:09:12,760 --> 05:09:17,400
因某事而感到惊讶，所以来试试这个

7365
05:09:15,558 --> 05:09:20,080
仅次于；居于…之后

7366
05:09:17,400 --> 05:09:22,400
运行着，我的机器可能有点卡顿

7367
05:09:20,080 --> 05:09:24,798
但我不确定

7368
05:09:22,400 --> 05:09:27,320
但我们打算让它运行一段时间

（这里“for a”后面似乎缺了内容，不过按照原文已有部分翻译如上） 

7369
05:09:24,798 --> 05:09:30,878
其次，在这里我们的矩阵大小是……

7370
05:09:27,320 --> 05:09:34,600
相当大，记得我们有这些

7371
05:09:30,878 --> 05:09:37,680
所以，嗯，如我们所愿，你知道张量的大小了

7372
05:09:34,600 --> 05:09:41,280
嗯，朴素的增删改查（CRUD）内核时间，注意看如何……

7373
05:09:37,680 --> 05:09:45,680
实际上，这比卷积神经网络（CNN）更快。

7374
05:09:41,280 --> 05:09:49,080
激活时间 嗯，它们都是正确的

7375
05:09:45,680 --> 05:09:53,760
我们只是比较一下结果，嗯，你懂的。

7376
05:09:49,080 --> 05:09:55,600
逐点的，而且这更快，为什么会那样

7377
05:09:53,760 --> 05:09:57,040
当我看到的时候，真的让我很生气。

7378
05:09:55,600 --> 05:09:59,920
这时我就在想，……的意义何在呢

7379
05:09:57,040 --> 05:10:01,718
有一个 有一个像……这样的美国有线电视新闻网（CNN）激活（此处“CNN activation”具体含义需结合更多语境确定，常见的CNN也可指卷积神经网络）

7380
05:09:59,920 --> 05:10:04,680
这有什么意义呢，呃，还有这个……

7381
05:10:01,718 --> 05:10:06,440
这么做的目的仅仅是为了给予给予

7382
05:10:04,680 --> 05:10:07,958
你自己想想像阿尔法和贝塔这样的东西

7383
05:10:06,440 --> 05:10:09,320
好的，所以当你有了α和β时

7384
05:10:07,958 --> 05:10:11,240
这些是你所拥有的额外数字。

7385
05:10:09,320 --> 05:10:13,280
在操作中必须考虑，并且

7386
05:10:11,240 --> 05:10:16,558
当事情如此简单
当事情就这么简单

7387
05:10:13,280 --> 05:10:18,760
就像乘方或者类似一个…… 

7388
05:10:16,558 --> 05:10:20,718
乘法，嗯，它就像一种……

7389
05:10:18,760 --> 05:10:22,958
非常简单，比如鲁（Ru）拿

注：这里“Ru”可能是人名、地名等特定名称，如果有更多背景信息，可提供以让翻译更准确。 

7390
05:10:20,718 --> 05:10:24,718
几乎没时间完成，10个小时就像一场（此处原句不完整）

7391
05:10:22,958 --> 05:10:26,920
操作非常简单，仅需在单个（设备/物品等，需结合语境确定“single”所指）上进行 

7392
05:10:24,718 --> 05:10:28,958
数字，嗯，你就把那个输出到……

7393
05:10:26,920 --> 05:10:31,280
相同的索引，这在计算上非常……

7394
05:10:28,958 --> 05:10:34,080
很简单，但当你加入一些小细节时

7395
05:10:31,280 --> 05:10:35,798
就像阿尔法和贝塔，我怀疑这些是

7396
05:10:34,080 --> 05:10:38,160
究竟是什么导致了这种表现

7397
05:10:35,798 --> 05:10:40,520
差异 可能主要是这些 或者

7398
05:10:38,160 --> 05:10:42,680
头顶上有一些CDNN（此处CDNN可能是特定术语，需结合具体语境确定准确含义），我是说，再说我们

7399
05:10:40,520 --> 05:10:44,480
甚至都不知道这是什么，这是什么

7400
05:10:42,680 --> 05:10:46,480
在幕后所做的，这是一个完整的

7401
05:10:44,480 --> 05:10:48,638
黑盒 不透明结构体 我们不知道

7402
05:10:46,480 --> 05:10:50,878
发生什么事了，所以很难去……

7403
05:10:48,638 --> 05:10:53,920
实际上知道为什么会发生这种情况 嗯

7404
05:10:50,878 --> 05:10:55,520
关于原因方面的资源不是很多。

7405
05:10:53,920 --> 05:10:57,958
自定义内核可能比 C 语言更快。

7406
05:10:55,520 --> 05:10:59,400
而且我还真没发现任何那样的东西。

7407
05:10:57,958 --> 05:11:01,718
所以我们就只是要拿着这个

7408
05:10:59,400 --> 05:11:03,440
假设呃有这么个大的…… 

7409
05:11:01,718 --> 05:11:05,520
不透明结构体“黑匣子”之类的东西，我们…… 

7410
05:11:03,440 --> 05:11:07,440
不知道，嗯，然后你还有

7411
05:11:05,520 --> 05:11:09,840
还有阿尔法和贝塔也是那样

7412
05:11:07,440 --> 05:11:11,638
你……你在做乘法运算

7413
05:11:09,840 --> 05:11:13,600
然后适当地添加一些内容，所以就是这样

7414
05:11:11,638 --> 05:11:15,520
打算添加一些额外的计算资源 计算资源

7415
05:11:13,600 --> 05:11:17,240
在头顶上方，但这些不是很大

7416
05:11:15,520 --> 05:11:20,798
根本没有差异，那么你有

7417
05:11:17,240 --> 05:11:22,160
比如 8.52、3，然后是 8.6，就像这样

7418
05:11:20,798 --> 05:11:25,440
就好像没什么，实际上这不会…… 

7419
05:11:22,160 --> 05:11:28,840
生产中的问题，就好像如果你……如果你……

7420
05:11:25,440 --> 05:11:31,718
你算出差值，嗯，如果你留意的话

7421
05:11:28,840 --> 05:11:35,040
有多快呢，呃，那个朴素的计数器（这里“cter”可能是“counter”拼写错误 ）

7422
05:11:31,718 --> 05:11:36,480
公式是，实际上就是 1.3%

7423
05:11:35,040 --> 05:11:38,360
更快，而你永远也做不到

7424
05:11:36,480 --> 05:11:39,840
注意，在那样的真实环境中

7425
05:11:38,360 --> 05:11:41,840
这只是不易察觉而已

7426
05:11:39,840 --> 05:11:44,280
所以实际上这并没有那么重要

7427
05:11:41,840 --> 05:11:46,440
如果你真的特别在意，那就行动起来吧

7428
05:11:44,280 --> 05:11:47,760
去吧，去编译你自己的内核，但那

7429
05:11:46,440 --> 05:11:51,000
那 那是个大致的想法，它并不

7430
05:11:47,760 --> 05:11:53,480
真的有那么重要吗，嗯，对于……对于……

7431
05:11:51,000 --> 05:11:55,320
卷积，不过这会有影响的，嗯

7432
05:11:53,480 --> 05:11:57,638
然后往下到这里，我写了一个 a p （这里“a p”可能有误，不太符合正常表达） 

7433
05:11:55,320 --> 05:12:00,080
torch脚本，只是为了某种程度上进行说明

7434
05:11:57,638 --> 05:12:02,600
手动处理事情，就像 PyTorch 那样

7435
05:12:00,080 --> 05:12:04,280
处理方式，嗯，PyTorch 如何处理……（这里文本不太完整，翻译可能不太能准确表意） 

7436
05:12:02,600 --> 05:12:06,878
定制古铜色肌肤，就像你从……开始写它的时候（注：原文句子似乎不太完整通顺） 

7437
05:12:04,280 --> 05:12:09,200
自己动手从零开始做，嗯，对比当你……

7438
05:12:06,878 --> 05:12:14,160
只需使用内置的手电筒，那个……（原英文句子不完整） 

7439
05:12:09,200 --> 05:12:16,600
手电筒10号。它去哪儿了？是的，手电筒10号。

7440
05:12:14,160 --> 05:12:20,878
嗯，所以就是稍微比较一下那些方面

7441
05:12:16,600 --> 05:12:20,878
并排比较并观察它们的表现

7442
05:12:23,480 --> 05:12:30,798
嗯，所以如果我们把这些写出来，嗯，哦，它是

7443
05:12:27,400 --> 05:12:34,040
花些时间来做这件事，是的，所以

7444
05:12:30,798 --> 05:12:37,080
定制拇指，那要花21（未明确单位） 

7445
05:12:34,040 --> 05:12:39,638
毫秒 还记得之前中国是怎样的吗

7446
05:12:37,080 --> 05:12:41,360
呃，我刚才说的那个要点，我不太…… 

7447
05:12:39,638 --> 05:12:44,440
知道那是什么样的

7448
05:12:41,360 --> 05:12:46,718
在那时候，那是一个非常小的数字。

7449
05:12:44,440 --> 05:12:49,280
嗯，那种内置在10里面的习俗仍然…… 

7450
05:12:46,718 --> 05:12:53,320
非常快 嗯，所以如果我们回去，然后我们

7451
05:12:49,280 --> 05:12:55,760
只要让加拿大广播公司（NBCC）编译这个，然后你就知道了

7452
05:12:53,320 --> 05:12:57,400
跑起来，然后让我们看看是哪一个

7453
05:12:55,760 --> 05:12:59,040
我们数字的形状是真实存在的。

7454
05:12:57,400 --> 05:13:04,480
快；迅速地；马上；立即
快的；迅速的；时间短暂的；敏捷的；立竿见影的

7455
05:12:59,040 --> 05:13:11,120
嗯，如果我设置批量大小，比如说，或者如果我……

7456
05:13:04,480 --> 05:13:11,120
256 乘 32 乘 224 乘 224

7457
05:13:15,400 --> 05:13:20,600
四兰特（南非货币单位）以及我们把这些东西裹在……里面（注：原文最后“wrap these in”后面缺少内容，译文意思根据不完整原文大致表达） 

7458
05:13:18,120 --> 05:13:20,600
括号

7459
05:13:20,718 --> 05:13:26,718
在这里，我们可以，我们可以真正地检查这一个。

7460
05:13:23,558 --> 05:13:26,718
快点，看看这个有多快

7461
05:13:27,400 --> 05:13:32,920
运行，然后我们将比较Python

7462
05:13:30,958 --> 05:13:35,040
直接针对那个编写脚本，而不是像……

7463
05:13:32,920 --> 05:13:37,280
删除输出内容，这样我们就看不到它了

7464
05:13:35,040 --> 05:13:39,320
嗯，只是为了让我们明白，到底有多少

7465
05:13:37,280 --> 05:13:41,760
性能可以从比如说……中获得

7466
05:13:39,320 --> 05:13:45,480
使用，呃，使用类似自定义编写的（内容）

7467
05:13:41,760 --> 05:13:49,040
CUDA内核或自定义编写的呃卷积神经网络

7468
05:13:45,480 --> 05:13:51,280
函数 所以如果我们使用Python和PyTorch进行比较

7469
05:13:49,040 --> 05:13:54,280
这得花点时间
哦，对，跑了

7470
05:13:51,280 --> 05:13:57,280
输出到内存 真棒

7471
05:13:54,280 --> 05:13:57,280
所以；那么；于是

7472
05:13:58,798 --> 05:14:07,000
嗯，兰德，不，那行不通，我碰到问题了。 

7473
05:14:02,440 --> 05:14:07,000
把这个降到比如 128，可能会有用。

7474
05:14:11,760 --> 05:14:17,718
它不是很快，是的，就像自定义的那样

7475
05:14:15,638 --> 05:14:21,320
自定义10超级慢，然后那个

7476
05:14:17,718 --> 05:14:25,798
内置一个4.3，比如说4.4

7477
05:14:21,320 --> 05:14:27,600
毫秒，没错，嗯，然后我们继续推进

7478
05:14:25,798 --> 05:14:29,400
我们可以看到，你知道这是

7479
05:14:27,600 --> 05:14:32,080
这实际上是

7480
05:14:29,400 --> 05:14:37,240
嗯，这大约是那个的两倍，对吧，所以如果

7481
05:14:32,080 --> 05:14:37,240
我们做到了约 4.4 的 4 分（这里“4 point”和“4.4 *”表述不太明确其确切含义，只能按字面初步翻译） 

7482
05:14:37,480 --> 05:14:44,200
2 8.8 没错，所以我们回到上面，然后它是

7483
05:14:41,280 --> 05:14:45,600
像这样，这个比那个小，所以如果我们

7484
05:14:44,200 --> 05:14:47,200
编写一个像这样的简单Kud内核是

7485
05:14:45,600 --> 05:14:48,718
如果你要优化这个，那就太天真了。

7486
05:14:47,200 --> 05:14:50,798
并实现类似循环的功能

7487
05:14:48,718 --> 05:14:53,120
展开（我们稍后会详细讲解）以及

7488
05:14:50,798 --> 05:14:55,240
你优化这个，哪怕只是像……这样的东西 

7489
05:14:53,120 --> 05:14:57,400
作为一个激活函数，你可以很简单地（使用它） 

7490
05:14:55,240 --> 05:14:59,520
得到这个的速度比圆周率相关情况（可能这里指相关计算速度等情境）快得惊人

7491
05:14:57,400 --> 05:15:00,878
火炬 嗯 然后就把所有东西都写下来

7492
05:14:59,520 --> 05:15:03,920
实际上你可以手动获取

7493
05:15:00,878 --> 05:15:07,320
相当快的速度，联合包裹服务公司（UPS），所以，呃，就是这样

7494
05:15:03,920 --> 05:15:08,760
为了提供一些相关背景信息，呃，但是

7495
05:15:07,320 --> 05:15:10,080
是的，激活函数，别担心

7496
05:15:08,760 --> 05:15:13,400
关于那件事做得太多了，这其实不太好

7497
05:15:10,080 --> 05:15:15,080
会影响到你，嗯，然后我们接着讨论……（这里“go to”后面内容缺失，根据语境大致翻译为“接着讨论” ）

7498
05:15:13,400 --> 05:15:17,320
就像卷积一样，对吧，这就是，这就是

7499
05:15:15,080 --> 05:15:22,040
我们实际正在使用的一个例子是在……（此处原文似乎不完整） 

7500
05:15:17,320 --> 05:15:23,760
卷积 嗯，所以你知道我们……我们……我们

7501
05:15:22,040 --> 05:15:26,120
有更多的事情需要注意

7502
05:15:23,760 --> 05:15:27,680
我现在就要深入研究这个了

7503
05:15:26,120 --> 05:15:29,600
现在我们可以深入探讨卷积了，a

7504
05:15:27,680 --> 05:15:31,718
嗯，有那么一点点，我一直在随意捣鼓着。 

7505
05:15:29,600 --> 05:15:33,760
有了其中一些，呃，让我们就……

7506
05:15:31,718 --> 05:15:35,878
要给你展示这些是如何……这些是如何……

7507
05:15:33,760 --> 05:15:38,440
工作 所以我们将从一个开始

7508
05:15:35,878 --> 05:15:40,920
可视化 首先我要带来

7509
05:15:38,440 --> 05:15:40,920
在一个……之上；超过一个……

注：“over a”单独看语义不完整，若它处于具体语境中会有更合适的译法。 

7510
05:15:41,200 --> 05:15:46,600
可视化的卷积，只需转到

7511
05:15:43,760 --> 05:15:48,600
这里，嗯，这就是它看上去的样子

7512
05:15:46,600 --> 05:15:50,878
就像这样，我们可以，就像你有这些输入

7513
05:15:48,600 --> 05:15:54,240
尺寸 内核大小 填充 膨胀 以及

7514
05:15:50,878 --> 05:15:56,360
步幅输入大小就是这个，我可以更改。

7515
05:15:54,240 --> 05:15:59,600
输入图像
核大小
这个（此处“the”单独出现表意不太明确，需结合上下文判断，这里暂时如此翻译）

7516
05:15:56,360 --> 05:16:01,920
实际重量本身，“重量”这个术语

7517
05:15:59,600 --> 05:16:04,798
嗯，那个填充，那么有多少黑色像素呢？

7518
05:16:01,920 --> 05:16:07,920
被放置在输入周围……的膨胀

注：由于原英文文本似乎不完整，此翻译只能依据现有内容进行逐词翻译，可能语义不太通顺。 

7519
05:16:04,798 --> 05:16:10,558
它是对的

7520
05:16:07,920 --> 05:16:12,820
嗯，然后还有步伐，这样我就能…… 

7521
05:16:10,558 --> 05:16:13,958
它每次前进一个单位，或者按……前进 

7522
05:16:12,820 --> 05:16:16,718
[音乐]

7523
05:16:13,958 --> 05:16:19,798
呃，差不多就是这样了。 

7524
05:16:16,718 --> 05:16:22,320
只是，呃，你可以随意摆弄一下

7525
05:16:19,798 --> 05:16:24,600
在你自己方便的时候去做这件事，嗯，但我已经

7526
05:16:22,320 --> 05:16:28,520
写了两个剧本

7527
05:16:24,600 --> 05:16:30,280
所以一个是P torch，那么这个P torch和

7528
05:16:28,520 --> 05:16:32,920
这一个在……中使用了完全相同的值

7529
05:16:30,280 --> 05:16:35,558
完全相同的顺序 嗯 完全相同的

7530
05:16:32,920 --> 05:16:37,440
参数，这里它们全都一样，并且

7531
05:16:35,558 --> 05:16:39,280
我只是在做一个并排比较

7532
05:16:37,440 --> 05:16:42,638
其中的一些，这样我们就能得到想要的

7533
05:16:39,280 --> 05:16:44,798
输出，所以它是

7534
05:16:42,638 --> 05:16:48,440
本质上，它本质上就像一个……就像……

7535
05:16:44,798 --> 05:16:52,638
一个 4×4 的（东西），输入就像一张 4×4 的图像，所以 1

7536
05:16:48,440 --> 05:16:56,120
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 以及

7537
05:16:52,638 --> 05:16:59,600
那么内核本身就是 1 2 3 4 5 6 7

7538
05:16:56,120 --> 05:16:59,600
8 n 而且它还在继续

7539
05:16:59,760 --> 05:17:05,840
对，它会那样做，而且我们

7540
05:17:02,718 --> 05:17:09,000
在它上面加一层衬垫，呃，这样一来这就是……

7541
05:17:05,840 --> 05:17:11,680
最终会达到 1，所以，呃…… 

7542
05:17:09,000 --> 05:17:15,600
尺寸是三，然后对其进行除法运算，呃

7543
05:17:11,680 --> 05:17:18,680
除以二取整，所以如果我们用 Python 来处理，就是三

7544
05:17:15,600 --> 05:17:20,920
买二得一

7545
05:17:18,680 --> 05:17:22,200
而那将只是我们的填充部分

7546
05:17:20,920 --> 05:17:25,320
然后火炬将用……来做那件事

7547
05:17:22,200 --> 05:17:28,000
这里这个实用的图书馆，嗯，还有…… 

7548
05:17:25,320 --> 05:17:29,760
我们正确地得到了输出，所以这应该……

7549
05:17:28,000 --> 05:17:31,718
非常不言自明，非常简单，我们是

7550
05:17:29,760 --> 05:17:35,798
只是对它进行重塑，然后你懂的

7551
05:17:31,718 --> 05:17:38,240
也在这里重塑它 嗯 但当我们

7552
05:17:35,798 --> 05:17:41,280
看看这部分，实际上这里就是……

7553
05:17:38,240 --> 05:17:44,680
乐趣开始了，所以我们做我们的锡安（这里“cian”可能拼写有误，推测是“Zion”之类的；“N.H”不太明确其含义 ） 

7554
05:17:41,280 --> 05:17:46,160
在顶部我写了一段简单的 CUDA（代码）

7555
05:17:44,680 --> 05:17:48,480
用于进行二维操作的内核

7556
05:17:46,160 --> 05:17:50,360
卷积操作接收一个输入和一个核

7557
05:17:48,480 --> 05:17:52,680
输出、宽度、高度、通道数

7558
05:17:50,360 --> 05:17:55,680
输出通道数、核大小，呃，还有批次

7559
05:17:52,680 --> 05:17:57,840
尺寸，所以呃，别……别担心如何……

7560
05:17:55,680 --> 05:17:59,558
这在内部是可行的，只是它仅仅让

7561
05:17:57,840 --> 05:18:01,440
它就像某种模板代码一样存在那里

7562
05:17:59,558 --> 05:18:04,878
这会达到我们想要的效果，嗯，它会的。

7563
05:18:01,440 --> 05:18:07,360
模块化的，所以，嗯，然后我们拥有所有的…… 

7564
05:18:04,878 --> 05:18:09,520
和我们在 Python 脚本中设置的一样

7565
05:18:07,360 --> 05:18:12,558
在这儿的顶部，所以

7566
05:18:09,520 --> 05:18:14,000
嗯，我们要确定输入的规模有多大。

7567
05:18:12,558 --> 05:18:16,760
输出和内核元素将

7568
05:18:14,000 --> 05:18:18,840
我们把这个打印出来，嗯，我们来做我们的…… 

7569
05:18:16,760 --> 05:18:19,878
经典的，只是恶意的，我们有我们的……（此英文表述不太符合常见语法和表达逻辑，翻译可能不够精准表意） 

7570
05:18:18,840 --> 05:18:21,558
价值观；价值；数值

7571
05:18:19,878 --> 05:18:24,240
有组织的；有条理的；有安排的；有秩序的；有组织能力的

7572
05:18:21,558 --> 05:18:26,120
嗯，再复制一些东西，然后我们

7573
05:18:24,240 --> 05:18:27,878
创建卷积神经网络（CNN）句柄，所以就这些了

7574
05:18:26,120 --> 05:18:31,638
和我们当时所做的非常相似

7575
05:18:27,878 --> 05:18:33,400
通过美国有线电视新闻网（CNN）以及我们的……功能，嗯，我们

7576
05:18:31,638 --> 05:18:36,320
创建 我们创建一个输入和一个输出

7577
05:18:33,400 --> 05:18:39,520
用于……的张量统一滤波器描述符（注：原句不完整，“for the”后面应有内容）

7578
05:18:36,320 --> 05:18:40,878
内核本身 嗯

7579
05:18:39,520 --> 05:18:43,080
用于……的卷积描述符

注：由于原文“for the”后面内容缺失，这里翻译可能不完全贴合完整语境。 

7580
05:18:40,878 --> 05:18:44,558
卷积运算 我们创建了所有的

7581
05:18:43,080 --> 05:18:47,320
通过这些我们创建卷积

7582
05:18:44,558 --> 05:18:48,760
具有该内存地址的描述符，嗯

7583
05:18:47,320 --> 05:18:49,840
我们打算使用4D技术（这里原文“doing going to”表述有误，正确应为“going to” ） 

7584
05:18:48,760 --> 05:18:51,878
描述符，因为它将是

7585
05:18:49,840 --> 05:18:55,040
按通道、高度调整批量大小

7586
05:18:51,878 --> 05:18:57,600
按宽度，嗯，然后如果我们看看这些

7587
05:18:55,040 --> 05:19:00,120
所以我们有，我们有张量

7588
05:18:57,600 --> 05:19:01,878
描述符，格式，那么，怎样，哪个，什么

7589
05:19:00,120 --> 05:19:04,160
它就像它的形状，然后是那…… 

7590
05:19:01,878 --> 05:19:08,080
数据类型，就像我们所说的，它只是一个 32 位浮点数

7591
05:19:04,160 --> 05:19:10,718
这里有，嗯，然后我们有 N 乘以 C

7592
05:19:08,080 --> 05:19:12,638
由 h 由 W 那么按批次大小由

7593
05:19:10,718 --> 05:19:14,638
按高度、按宽度划分的通道，并且我们会

7594
05:19:12,638 --> 05:19:16,480
所有这些都是同样的情况，嗯，这个

7595
05:19:14,638 --> 05:19:17,798
输出将是输出通道

7596
05:19:16,480 --> 05:19:19,280
因为它不是英寸，它将会是

7597
05:19:17,798 --> 05:19:22,878
在……中我们能得到多少个输出通道呢？

由于原文不完整，“in the”后面似乎缺失了内容，若有完整内容可进一步完善翻译。 

7598
05:19:19,280 --> 05:19:24,680
呃，最后，过滤器描述符是

7599
05:19:22,878 --> 05:19:26,320
将会有一个不同的 它将会

7600
05:19:24,680 --> 05:19:29,558
以一种不同的方式进行组织，事情正在朝着这个方向发展

7601
05:19:26,320 --> 05:19:31,400
呃，要通过输入通道来输出通道 （此英文表述不太符合常规语法逻辑，翻译可能不太准确传达其确切意思） 

7602
05:19:29,558 --> 05:19:34,520
高度乘以宽度，所以输出通道在……

7603
05:19:31,400 --> 05:19:37,520
通道的高度，呃，高度乘以宽度，对吧

7604
05:19:34,520 --> 05:19:39,440
对于 对于内核本身 对于

7605
05:19:37,520 --> 05:19:41,360
卷积滤波器，我打算用你

7606
05:19:39,440 --> 05:19:44,160
那些可互换的卷积核

7607
05:19:41,360 --> 05:19:46,680
而卷积滤波器是同一回事，嗯，还有

7608
05:19:44,160 --> 05:19:48,200
那么实际的描述符本身，嗯

7609
05:19:46,680 --> 05:19:49,480
这是一个二维描述符，所以它将会

7610
05:19:48,200 --> 05:19:52,798
成为一个二维的（这里“2d”可根据具体语境理解为二维角色、二维事物等，单独看“be a 2d”表达不太完整准确）

7611
05:19:49,480 --> 05:19:57,240
卷积，嗯，然后我们把所有的都扔掉

7612
05:19:52,798 --> 05:19:59,840
这些，所以填充 H、填充 W，嗯，呃

7613
05:19:57,240 --> 05:20:02,680
还有 v 以及缩放，我们，我们只是……

7614
05:19:59,840 --> 05:20:04,280
甚至都不用缩放，呃，卷积

7615
05:20:02,680 --> 05:20:06,558
模式，所以它会是交叉的

7616
05:20:04,280 --> 05:20:09,200
相关性，并且数据类型仅仅是

7617
05:20:06,558 --> 05:20:10,920
呃，所以我不指望你知道

7618
05:20:09,200 --> 05:20:12,440
啥，啥，都像卷积法则一样

7619
05:20:10,920 --> 05:20:13,840
是，并且我们只是在比较一切

7620
05:20:12,440 --> 05:20:18,440
到 P 火炬并确保那

7621
05:20:13,840 --> 05:20:22,160
一切都对上了，嗯，然后就……

7622
05:20:18,440 --> 05:20:24,040
关于，嗯，就算法而言

7623
05:20:22,160 --> 05:20:26,120
就其本身而言，嗯，我们有个小事情，那就是…… 

7624
05:20:24,040 --> 05:20:27,798
在这里翻找东西 呃 我可能会

7625
05:20:26,120 --> 05:20:29,840
以后再改这个
这不行
这不是……（此处原文不完整） 

7626
05:20:27,798 --> 05:20:32,160
看起来非常漂亮，嗯，但又怎样呢？

7627
05:20:29,840 --> 05:20:35,280
你，你实际上能做的仅仅是

7628
05:20:32,160 --> 05:20:38,080
说真的，呃，它在哪儿呢，这个

7629
05:20:35,280 --> 05:20:40,360
当你做……当你给予的时候，这里有某种算法。

（注：原文“algo”推测为“algorithm（算法）”的口语化或不规范表达，且句子表述不完整，语义不太清晰。） 

7630
05:20:38,080 --> 05:20:42,760
呃，当你给美国有线电视新闻网（CNN）提供一个工作空间时

7631
05:20:40,360 --> 05:20:45,840
要在那里进行操作的尺寸，有这个

7632
05:20:42,760 --> 05:20:49,400
CNN卷积前向算法类型，哪种

7633
05:20:45,840 --> 05:20:52,480
就在这里，嗯，前向算法类型以及

7634
05:20:49,400 --> 05:20:53,760
这里面有一堆呢，所以，呃，到……的时候

注：原文 “so uh by” 后面似乎句子未完整，翻译只能根据现有内容进行。 

7635
05:20:52,480 --> 05:20:55,240
默认情况下，它应该做的是

7636
05:20:53,760 --> 05:20:57,878
逐个查看它们，找出哪一个是

7637
05:20:55,240 --> 05:20:59,320
最好的，但我发现这可能是一个

7638
05:20:57,878 --> 05:21:02,280
循环一下会稍微好一点

7639
05:20:59,320 --> 05:21:04,200
这些（任务）一个个地靠你自己去完成，所以试试看。

7640
05:21:02,280 --> 05:21:06,600
外部隐式宝石 特里
外部预编译宝石

7641
05:21:04,200 --> 05:21:09,600
尝试宝石
尝试直接快速傅里叶变换（FFT） 快速傅里叶变换（FFT）

注：“triy”可能是“try”的拼写错误。 

7642
05:21:06,600 --> 05:21:12,040
平铺WI 非融合计数正确 所以

7643
05:21:09,600 --> 05:21:13,760
把这些都试一遍，看看它们的效果如何。

7644
05:21:12,040 --> 05:21:15,080
嗯，我……我在这个……里有（东西）

7645
05:21:13,760 --> 05:21:18,520
我们要做对比脚本。

7646
05:21:15,080 --> 05:21:20,480
稍后再说，但呃，是的，别……别……别……

7647
05:21:18,520 --> 05:21:23,160
只对那些事过度担忧就好（此句英文表述可能存在不太符合常规语法的情况，翻译可能有一定局限性）

7648
05:21:20,480 --> 05:21:24,320
有点像就按原样运行脚本，嗯，但是

7649
05:21:23,160 --> 05:21:26,440
我们只是想找到最好的

7650
05:21:24,320 --> 05:21:28,558
针对我们在……的问题的卷积算法

7651
05:21:26,440 --> 05:21:31,680
右手，那么当你有一个更小的…… 

7652
05:21:28,558 --> 05:21:34,040
内核和一个有点类似的小图像

7653
05:21:31,680 --> 05:21:36,320
也许一个隐式的宝石（这里结合语境推测可能是某种隐式的代码模块等，需根据具体情况确定更准确表述）会更快。 

7654
05:21:34,040 --> 05:21:37,878
而不是说进行快速傅里叶变换（FFT）分块，呃，因为这个…… 

7655
05:21:36,320 --> 05:21:39,680
在头顶上方，没错，所以你只需要

7656
05:21:37,878 --> 05:21:42,718
把那样的事情当作你的问题

7657
05:21:39,680 --> 05:21:45,558
调整所有那些东西的大小，嗯，还有工作区的大小

7658
05:21:42,718 --> 05:21:48,160
尺寸只是指你有多大，你到底有多大

7659
05:21:45,558 --> 05:21:49,360
实际上，嗯，返回……的最小尺寸

7660
05:21:48,160 --> 05:21:52,040
要传递给……的工作区

7661
05:21:49,360 --> 05:21:53,958
卷积，给定一个算法，对吧，所以

7662
05:21:52,040 --> 05:21:56,160
你实际上只是在说有多少

7663
05:21:53,958 --> 05:21:58,320
你是在这里工作吗，嗯，还有这个…… 

7664
05:21:56,160 --> 05:22:00,280
由一堆它所具备的事物来定义

7665
05:21:58,320 --> 05:22:02,040
它就这么决定了，对吧，所以我们

7666
05:22:00,280 --> 05:22:04,718
给它一堆描述，然后它是

7667
05:22:02,040 --> 05:22:10,040
打算利用那个背景情况来做决定，嗯

7668
05:22:04,718 --> 05:22:10,040
工作区的大小应该是多少，嗯

7669
05:22:11,280 --> 05:22:16,840
好了好了，现在我们可以进行我们的基准测试了，呃

7670
05:22:14,520 --> 05:22:18,798
热身和基准测试运行，所以我们有

7671
05:22:16,840 --> 05:22:21,080
这个，嗯，你知道的，就是跳过了阿尔法阶段，然后

7672
05:22:18,798 --> 05:22:22,280
贝塔，我们有这个卷积前向传播

7673
05:22:21,080 --> 05:22:25,360
我将在……中向你展示的函数

7674
05:22:22,280 --> 05:22:28,280
马上来看看英伟达的文档，嗯，这个

7675
05:22:25,360 --> 05:22:30,718
由手柄阿尔法张量组成

7676
05:22:28,280 --> 05:22:33,520
输入的描述符，输入

7677
05:22:30,718 --> 05:22:36,120
它本身，那只是一个，你只是，任何，只是

7678
05:22:33,520 --> 05:22:40,200
一个空指针，对吧

7679
05:22:36,120 --> 05:22:43,320
嗯，然后是过滤器描述符

7680
05:22:40,200 --> 05:22:47,760
内核，呃，卷积内核，所以一个

7681
05:22:43,320 --> 05:22:51,718
再一次指向一个数组的指针 呃

7682
05:22:47,760 --> 05:22:54,958
卷积描述符，所以实际上，呃

7683
05:22:51,718 --> 05:22:57,240
操作算法本身，即该算法

7684
05:22:54,958 --> 05:22:59,360
嗯，我们刚刚进入的那个工作区

7685
05:22:57,240 --> 05:23:03,040
工作区大小和字节 工作区

7686
05:22:59,360 --> 05:23:05,600
大小和字节数 嗯，我们把这个传进去，我们，我们

7687
05:23:03,040 --> 05:23:08,878
做这种尺码的 T 恤，它类似一种尺码类型。 

7688
05:23:05,600 --> 05:23:10,638
用于存储大数值之类的，然后我们放置

7689
05:23:08,878 --> 05:23:13,000
把这个放进这里，然后是这个值

7690
05:23:10,638 --> 05:23:14,958
根据这些设置进行更改，对吧，那么

7691
05:23:13,000 --> 05:23:17,080
当我们把这个放回到这里时，它会…… 

7692
05:23:14,958 --> 05:23:18,558
来决定嗯它实际运行的时候

7693
05:23:17,080 --> 05:23:20,280
这……我们需要多少，还有……什么

7694
05:23:18,558 --> 05:23:22,440
这些是它所预测的资源需求吗？

注：原文 “it's pred” 可能存在拼写错误，推测可能是 “it's predicted” 。 

7695
05:23:20,280 --> 05:23:25,320
决定好了，对吧

7696
05:23:22,440 --> 05:23:27,558
嗯，然后我们做……嗯，我们只是……我们只是……

7697
05:23:25,320 --> 05:23:30,558
输入输出描述，然后

7698
05:23:27,558 --> 05:23:32,638
输出，呃，输出设备阵列

7699
05:23:30,558 --> 05:23:35,320
对，然后我们做同样的事情，不过

7700
05:23:32,638 --> 05:23:37,440
用我们的呃二维会议（这里“con”推测是“conference”的缩写），只是有点像

7701
05:23:35,320 --> 05:23:39,360
筛选起来没那么复杂，并且

7702
05:23:37,440 --> 05:23:41,760
然后我们同步所有的线程

7703
05:23:39,360 --> 05:23:44,000
以及使用CUDA设备的GPU中的线程块

7704
05:23:41,760 --> 05:23:45,558
同步非常简单，而且我们会做…… （原句不太完整，这里按常规理解给出大概译文）

7705
05:23:44,000 --> 05:23:47,798
基准测试运行也是同样的情况，除了我们

7706
05:23:45,558 --> 05:23:51,400
只需添加一个时间和一个事件记录

7707
05:23:47,798 --> 05:23:53,680
嗯，同样地，所以相当简单

7708
05:23:51,400 --> 05:23:55,798
这里所发生的概念，仅仅关乎时机，以及……（原句似乎未完整） 

7709
05:23:53,680 --> 05:23:57,600
基准测试，主要就是筛选

7710
05:23:55,798 --> 05:23:59,400
搞清楚一个函数到底接收什么参数

7711
05:23:57,600 --> 05:24:01,040
以及所有这些类型都在做什么

7712
05:23:59,400 --> 05:24:03,200
没错，那真的是你的一团糟啊 

7713
05:24:01,040 --> 05:24:06,400
不得不翻找；不得不深入探究 

7714
05:24:03,200 --> 05:24:08,798
嗯，现在如果我们往下走，嗯，实际上我们可以

7715
05:24:06,400 --> 05:24:11,840
我们实际上把卷积神经网络（CNN）的输出打印了出来，并且

7716
05:24:08,798 --> 05:24:13,280
朴素内核输出如此，然后是

7717
05:24:11,840 --> 05:24:15,000
也把它压平，这样我们就可以

7718
05:24:13,280 --> 05:24:17,000
逐元素与 PyTorch 中的圆周率（Pi）进行比较

7719
05:24:15,000 --> 05:24:18,878
元素 呃 我们只要把所有的……销毁就行

7720
05:24:17,000 --> 05:24:21,638
之后的语境，同样的情况也适用于……（这里句子似乎不完整）

7721
05:24:18,878 --> 05:24:27,360
棕褐色，呃，棕褐色的酷达（汽车名）也是一样的情况

7722
05:24:21,638 --> 05:24:30,958
脚本 嗯 去运行这个 然后结束

7723
05:24:27,360 --> 05:24:34,958
01 就像那个链接

7724
05:24:30,958 --> 05:24:38,440
我们能结束，我们能搞定这个。

注：原句“CN”可能是“Can”拼写错误。 

7725
05:24:34,958 --> 05:24:40,360
嗯，所有这些都……正如预期的那样，并且

7726
05:24:38,440 --> 05:24:42,120
所以，它……它接下来会……是的，它……

7727
05:24:40,360 --> 05:24:43,600
打算选择一种算法 这些 这些

7728
05:24:42,120 --> 05:24:45,638
都乱套了，我可能会改改这些

7729
05:24:43,600 --> 05:24:50,280
稍后，但是

7730
05:24:45,638 --> 05:24:51,920
嗯，我们注意到qnn比……慢

7731
05:24:50,280 --> 05:24:54,240
简单内核，这是因为它是

7732
05:24:51,920 --> 05:24:56,798
真的很小，对吧？它非常小。

7733
05:24:54,240 --> 05:24:58,440
嗯，某人可能有更多事情要去安排它是……

（注：原句 “um qn” 可能表述有误，推测 “qn” 是 “someone” 之类的词的不规范缩写 ） 

7734
05:24:56,798 --> 05:25:01,360
到处都是这些阿尔法贝塔术语

7735
05:24:58,440 --> 05:25:02,680
它得被照顾好，嗯，是的

7736
05:25:01,360 --> 05:25:06,080
那儿，那儿可能会有一些额外的东西

7737
05:25:02,680 --> 05:25:08,680
在头顶上方，所以确实是，嗯

7738
05:25:06,080 --> 05:25:10,760
你知道，大概三四次的样子

7739
05:25:08,680 --> 05:25:13,120
比这还慢，仅仅是因为它……

7740
05:25:10,760 --> 05:25:16,718
更小了，而且尺寸不是什么大问题

7741
05:25:13,120 --> 05:25:21,040
所以如果我们看这里的输出，我们会看到1

7742
05:25:16,718 --> 05:25:26,840
178 217，然后结尾类似 274 275

7743
05:25:21,040 --> 05:25:26,840
现在是175，如果我去运行，呃，Torch（这里“torch”可能指深度学习框架PyTorch ，需结合具体语境）

7744
05:25:27,120 --> 05:25:32,638
比较一下，它接下来会做完全相同的事

7745
05:25:29,320 --> 05:25:39,040
注意看，我们是如何得到 111、178、217 以及

7746
05:25:32,638 --> 05:25:43,360
然后 295 1 呃，或者抱歉，274 299 295 175

7747
05:25:39,040 --> 05:25:44,958
所以回到这里
274 295 175
完美，所以

7748
05:25:43,360 --> 05:25:49,200
我们可以查看所有这些内容

7749
05:25:44,958 --> 05:25:52,840
这些全都排成一排
1 2 3 4 5 6 7 8 9 10

7750
05:25:49,200 --> 05:25:55,160
11、12、13、14、15、16 号元素，呃，还有这个

7751
05:25:52,840 --> 05:25:58,600
如我们打印出来的那样，你要知道有16个元素。

7752
05:25:55,160 --> 05:26:00,120
呃，在这儿的底部，仅仅是这个

7753
05:25:58,600 --> 05:26:02,920
……的长度；……的持续时间

注：“length of”后面一般要接具体的事物，这里单独“length of”直接翻译是这样常见释义，在具体句子里要根据后面所接内容灵活翻译。 

7754
05:26:00,120 --> 05:26:05,480
所以我试着像……那样迅速地做…… （注：原英文句子似乎不完整）

7755
05:26:02,920 --> 05:26:07,638
你知道的，那真的有点像一个……

7756
05:26:05,480 --> 05:26:11,400
一堆我们……的样板代码 

7757
05:26:07,638 --> 05:26:13,200
快速浏览嗯，但现在呃，既然我们

7758
05:26:11,400 --> 05:26:15,280
知道这方法可行，而且它正在输出

7759
05:26:13,200 --> 05:26:17,718
我们希望它变成什么样，实际上我们就可以做到什么样（这里原文表意不是特别清晰，结合语境也可能有更合适的译文，此译文仅基于字面） 

7760
05:26:15,280 --> 05:26:20,840
那么，来看一下对比脚本。

7761
05:26:17,718 --> 05:26:22,080
对比脚本，嗯，实际上是真实的

7762
05:26:20,840 --> 05:26:24,280
快，在我进行这次比较之前

7763
05:26:22,080 --> 05:26:27,958
脚本 我打算调出那个，呃，那个

7764
05:26:24,280 --> 05:26:31,718
cian 和医生们在这里只是为了某种程度上展示

7765
05:26:27,958 --> 05:26:33,798
你；那个

注：“you the”并非一个常见或正确的表达，“you”是“你；你们”的意思，“the”是定冠词，这里这样呈现只是机械按要求翻译。 

7766
05:26:31,718 --> 05:26:37,400
呃，去……

7767
05:26:33,798 --> 05:26:40,200
美国有线电视新闻网（CNN），所以我们正在进行这样的卷积操作以…… 

7768
05:26:37,400 --> 05:26:42,400
CN 卷积前向传播，没错，所以我们来看

7769
05:26:40,200 --> 05:26:46,920
在这个……嗯，有很多事情

7770
05:26:42,400 --> 05:26:46,920
在它里面，所以就像这种描述符类型

7771
05:26:49,280 --> 05:26:53,280
嗯，处理阿尔法、贝塔，所以它只是

7772
05:26:51,878 --> 05:26:55,440
描述了我们所需要的一切

7773
05:26:53,280 --> 05:26:57,600
明白，所以如果我说的某些话没……

7774
05:26:55,440 --> 05:26:59,878
有道理，也许就像看看这里

7775
05:26:57,600 --> 05:27:02,400
而且这对你来说可能更有意义。

7776
05:26:59,878 --> 05:27:04,440
那样的话，嗯，但如果我们想说，听着

7777
05:27:02,400 --> 05:27:06,120
在类似前向算法类型的方面

7778
05:27:04,440 --> 05:27:07,680
我们到这里，点击它，然后有一个

7779
05:27:06,120 --> 05:27:10,040
有一堆……有一堆数值，所以

7780
05:27:07,680 --> 05:27:11,440
隐式的……表示为一个矩阵

7781
05:27:10,040 --> 05:27:12,878
实际上没有明确说明的产品

7782
05:27:11,440 --> 05:27:14,280
形成保存输入数据的矩阵

7783
05:27:12,878 --> 05:27:15,558
张量在里面，所以有一堆……（这里“a bunch of”后面缺内容，表述不太完整） 

7784
05:27:14,280 --> 05:27:18,520
这里有关于不同方面的描述

7785
05:27:15,558 --> 05:27:20,718
你可以使用的算法，嗯，就像

7786
05:27:18,520 --> 05:27:22,360
当你可能想使用它的时候，有……

7787
05:27:20,718 --> 05:27:24,040
还有关于其他哪些方面的文章呢

7788
05:27:22,360 --> 05:27:26,280
适用于不同的情况 嗯

7789
05:27:24,040 --> 05:27:27,920
卷积的内容已经讲解得非常透彻了。

7790
05:27:26,280 --> 05:27:31,040
呃，在整个深度学习领域，所以

7791
05:27:27,920 --> 05:27:33,040
导航应该不会太难，但是

7792
05:27:31,040 --> 05:27:35,718
这些是 这些将是你的

7793
05:27:33,040 --> 05:27:38,878
前向
前向传播

7794
05:27:35,718 --> 05:27:42,200
算法 现在如果我们

7795
05:27:38,878 --> 05:27:44,360
回到，嗯，我们回到这个话题

7796
05:27:42,200 --> 05:27:48,638
我实际上正在编写的对比脚本

7797
05:27:44,360 --> 05:27:51,638
完全一样的事情，只是我设置了那个……（“um”是语气词，这里不好准确翻译出意思，可根据上下文灵活处理） 

7798
05:27:48,638 --> 05:27:55,160
我设置了用于隐式宝石的算法

7799
05:27:51,638 --> 05:27:59,520
所以，嗯，就是这个，对吧

7800
05:27:55,160 --> 05:28:04,320
所以我就在这里手动设置了，呃

7801
05:27:59,520 --> 05:28:08,638
是啊，差不多就是这样了。

7802
05:28:04,320 --> 05:28:10,200
嗯，现在我们把这个设置为算法，然后

7803
05:28:08,638 --> 05:28:12,080
然后我们只需在那里接入一个算法，所以

7804
05:28:10,200 --> 05:28:13,680
那……那就是主要的区别。

7805
05:28:12,080 --> 05:28:15,480
然后另一个问题就是我们如何…… 

7806
05:28:13,680 --> 05:28:18,360
初始化我们的数据，其他的一切都是

7807
05:28:15,480 --> 05:28:20,718
和这个最初的一样，就像，呃，只是

7808
05:28:18,360 --> 05:28:26,360
这个……卷积，呃，有点像……比较 

7809
05:28:20,718 --> 05:28:30,798
在P火炬之间 嗯 所以我们 在哪里呢

7810
05:28:26,360 --> 05:28:33,200
是的，所以我们在 CPU 上进行初始化。

7811
05:28:30,798 --> 05:28:34,840
只有一堆随机的值，嗯

7812
05:28:33,200 --> 05:28:38,360
然后我们只需进行一个运算，运算对象是

7813
05:28:34,840 --> 05:28:40,200
那些，所以我制作了，我制作了元素 a

7814
05:28:38,360 --> 05:28:46,440
让整件事变得严重得多

7815
05:28:40,200 --> 05:28:51,000
所以它是 224 乘以 224 乘以 11 乘以 32 乘以

7816
05:28:46,440 --> 05:28:52,718
呃，11、11、32、64，这不是……这不是倍数关系

7817
05:28:51,000 --> 05:28:56,440
所有这些，但输入将会 

7818
05:28:52,718 --> 05:29:01,760
尺寸为宽乘以高 呃，它正在……

7819
05:28:56,440 --> 05:29:05,920
按宽度、高度以及输入通道数来确定（此处原文“by by”可能有误，推测可能是表述重复或者有遗漏，按照正常逻辑理解后翻译）

7820
05:29:01,760 --> 05:29:08,200
按批量大小，所以和我们之前做的一样，是 n 通道高度宽度 

7821
05:29:05,920 --> 05:29:09,680
这会占用很多空间，嗯

7822
05:29:08,200 --> 05:29:12,240
但我们只是要对这个进行基准测试

7823
05:29:09,680 --> 05:29:12,240
然后看看它怎么样

7824
05:29:15,760 --> 05:29:21,638
好了，所以我们去运行这个，弄一批出来

7825
05:29:18,280 --> 05:29:25,240
尺寸为四，并且我们注意到了 CN 平均值

7826
05:29:21,638 --> 05:29:26,958
时间是14.8毫秒，还有那个天真的（这里“naive”缺少更多语境信息，表意不太明确）

7827
05:29:25,240 --> 05:29:30,520
内核平均时间约为82

7828
05:29:26,958 --> 05:29:33,200
毫秒，所以如果我们那样做，如果我们…… 

7829
05:29:30,520 --> 05:29:33,200
那个部门；那个划分；那个分隔

注：“division”常见释义有“部门；分隔；划分；除法”等，需根据具体语境确定最合适的含义。 

7830
05:29:34,718 --> 05:29:42,240
在那里我们注意到我们获得了 5.5 倍的速度

7831
05:29:40,040 --> 05:29:44,760
通过使用二维（2D）提升效果，这有多棒啊

7832
05:29:42,240 --> 05:29:46,400
对，我是说，如果你对这个简单的（方法/方案等，需结合语境确定）进行优化 

7833
05:29:44,760 --> 05:29:48,718
内核在这上面，并且让它变得更…… 

7834
05:29:46,400 --> 05:29:50,520
针对你的特定用例

7835
05:29:48,718 --> 05:29:52,840
而不是计算一堆东西

7836
05:29:50,520 --> 05:29:55,200
这样会更快些，嗯，但这也算一种方式

7837
05:29:52,840 --> 05:29:57,558
只是出于演示目的

7838
05:29:55,200 --> 05:29:59,600
嗯，美国有线电视新闻网（CNN）的速度仍然非常快，而且它会……

7839
05:29:57,558 --> 05:30:02,520
需要花一段时间才能得到那样的东西

7840
05:29:59,600 --> 05:30:04,040
实际上，嗯，比这个更高效，嗯

7841
05:30:02,520 --> 05:30:07,638
它的性能显著提升了 

7842
05:30:04,040 --> 05:30:09,480
要做到那一点需要付出很多呢，嗯，但是

7843
05:30:07,638 --> 05:30:11,760
那……那就是这个想法，对吧，呃，这是

7844
05:30:09,480 --> 05:30:13,000
你为什么使用像卷积神经网络（CNN）和PyTorch这样的东西？

7845
05:30:11,760 --> 05:30:15,958
是因为他们 他们就像

7846
05:30:13,000 --> 05:30:18,120
超级快，它们（或他们等，需结合语境）刚刚……它刚刚做了一个（这里“一个”指代不明，需结合语境）

7847
05:30:15,958 --> 05:30:21,080
类似……的大规模卷积运算

7848
05:30:18,120 --> 05:30:25,878
批量大小为4且具有32个通道的图像

7849
05:30:21,080 --> 05:30:27,240
以及一个大小类似 11 微米乘 11 微米的内核尺寸

7850
05:30:25,878 --> 05:30:28,680
这……这简直太疯狂了，那数量……

7851
05:30:27,240 --> 05:30:30,840
它在这么小的（空间/范围等，需结合上下文确定）内所进行的操作

7852
05:30:28,680 --> 05:30:33,958
大量的时间，所以这就是我们正在……

7853
05:30:30,840 --> 05:30:36,040
和……一起工作，嗯，那就是，那就是，呃，那就是

7854
05:30:33,958 --> 05:30:38,878
那是 C，然后进入

7855
05:30:36,040 --> 05:30:41,120
你知道吗，当你和大型的（事物）打交道时 

7856
05:30:38,878 --> 05:30:42,840
大型数据中心和GPU集群

7857
05:30:41,120 --> 05:30:45,400
即使那是你自己的本地设备，那也是

7858
05:30:42,840 --> 05:30:47,798
就在旁边，然后你有8个409型，或者

7859
05:30:45,400 --> 05:30:50,240
309s 连接到它 嗯，这部分可能

7860
05:30:47,798 --> 05:30:54,200
稍微进来一点，挺方便的，对吧

7861
05:30:50,240 --> 05:30:56,920
更大的钻机或数据中心 嗯，让我

7862
05:30:54,200 --> 05:31:00,040
只是改变一下它的外观，嗯，所以

7863
05:30:56,920 --> 05:31:02,080
你有库布罗斯（Kublos）多处理（MP）与英伟达集体通信库（NCCL）相对比

注：“kublos”可能是特定的专业术语、名称等，如果它有特定准确的中文译法，需根据具体情况调整。 

7864
05:31:00,040 --> 05:31:03,240
呃，现在这些都是不同的，我……

7865
05:31:02,080 --> 05:31:05,240
从米格开始讲，因为它是

7866
05:31:03,240 --> 05:31:08,920
最容易解释的一个，本质上就是思考

7867
05:31:05,240 --> 05:31:11,080
把它当作你的，就像你的亚马逊、你的亚马逊网络服务（AWS）一样 

7868
05:31:08,920 --> 05:31:13,160
而且你有一个，你有一个巨大的，你知道的

7869
05:31:11,080 --> 05:31:15,480
你内部的（这里原文表述不太准确）GPU

7870
05:31:13,160 --> 05:31:17,558
为你的数据中心提供便利等等

7871
05:31:15,480 --> 05:31:19,520
通常对于这种类型的显卡，大多数

7872
05:31:17,558 --> 05:31:21,200
人们不会去用那个……

7873
05:31:19,520 --> 05:31:22,760
它的全部，就像一小部分一样

7874
05:31:21,200 --> 05:31:24,958
他们只是想要并行处理

7875
05:31:22,760 --> 05:31:27,080
方面，比如某些、某些，不管是什么

7876
05:31:24,958 --> 05:31:28,840
信号处理，我不知道，所以……

7877
05:31:27,080 --> 05:31:32,400
你能做的实际上是

7878
05:31:28,840 --> 05:31:34,958
分割那个节点 嗯 你分割那个节点

7879
05:31:32,400 --> 05:31:37,120
变成一堆 一堆更小的 GPU

7880
05:31:34,958 --> 05:31:39,680
这是多实例 GPU，你可以拥有

7881
05:31:37,120 --> 05:31:42,600
多个实例连接到同一个（这里“inst es”可能是“instances”拼写错误）

7882
05:31:39,680 --> 05:31:45,280
卡，而且你可以均匀地分配工作量

7883
05:31:42,600 --> 05:31:47,440
并且安全地跨越那些，所以那就是

7884
05:31:45,280 --> 05:31:49,520
那就是米格（Mig）所做的事情，它被用于…… 

7885
05:31:47,440 --> 05:31:54,000
呃，数据中心环境的用例

7886
05:31:49,520 --> 05:31:56,920
对，嗯，然后你有了NCCL，所以是NCCL

7887
05:31:54,000 --> 05:31:59,920
实际上对……真的真的很重要

7888
05:31:56,920 --> 05:32:01,920
嗯，分布式集群计算，所以这个

7889
05:31:59,920 --> 05:32:04,480
本质上正在进行

7890
05:32:01,920 --> 05:32:07,080
没错，它听起来就是那样，它就是……

7891
05:32:04,480 --> 05:32:09,760
不会去 这不会起作用

7892
05:32:07,080 --> 05:32:12,000
跨部门的业务操作，但这会有所帮助

7893
05:32:09,760 --> 05:32:14,280
管理并沟通，呃，不同的…… 

7894
05:32:12,000 --> 05:32:16,240
跨集群处理事务，因此用于

7895
05:32:14,280 --> 05:32:18,200
分发信息
收集信息

7896
05:32:16,240 --> 05:32:22,558
作为一个通用的集群级别来运作

7897
05:32:18,200 --> 05:32:24,680
通信器，而这里是库布罗斯的议员

7898
05:32:22,558 --> 05:32:26,638
将要去做……的繁重工作

7899
05:32:24,680 --> 05:32:28,878
就像说巨型矩阵那样做

7900
05:32:26,638 --> 05:32:30,400
像……的一种记录那样进行乘法运算

7901
05:32:28,878 --> 05:32:33,760
八 8

7902
05:32:30,400 --> 05:32:36,160
8100s 嗯，然后英伟达集体通信库（NCCL）将会……是

7903
05:32:33,760 --> 05:32:38,440
打算呃，以批次的方式运行这个，所以

7904
05:32:36,160 --> 05:32:41,360
记得集体通信 呃

7905
05:32:38,440 --> 05:32:43,600
这些，那个里面的操作，嗯，还有

7906
05:32:41,360 --> 05:32:45,520
而且关于这个还有更多的资源呢，呃

7907
05:32:43,600 --> 05:32:48,840
就像所有的规约广播一样

7908
05:32:45,520 --> 05:32:51,120
聚集 分散 穿过 右边 所以 不像

7909
05:32:48,840 --> 05:32:53,320
没有那种相乘或者类似融合的情况

7910
05:32:51,120 --> 05:32:55,400
这里的操作，它正在进行操作。 

7911
05:32:53,320 --> 05:32:59,480
跨越一个集群并进行通信，呃

7912
05:32:55,400 --> 05:33:02,280
传输数据，对，嗯，所以只是为了

7913
05:32:59,480 --> 05:33:05,480
在 PyTorch 中你会使用的参考内容

7914
05:33:02,280 --> 05:33:07,798
分布式数据并行，嗯，针对这个

7915
05:33:05,480 --> 05:33:09,440
分布式集群级计算，所以

7916
05:33:07,798 --> 05:33:11,360
分布式数据并行数据

7917
05:33:09,440 --> 05:33:13,000
模块级别的并行性，这（种并行性）

7918
05:33:11,360 --> 05:33:15,440
可以跨多台机器运行，因此

7919
05:33:13,000 --> 05:33:17,760
模块就好比是 P 中的一个函数

7920
05:33:15,440 --> 05:33:20,280
火炬，对，嗯，它可以跨越……（注：原句表述不太完整和清晰） 

7921
05:33:17,760 --> 05:33:22,120
多台机器，嗯，应该生成

7922
05:33:20,280 --> 05:33:23,920
多个进程并创建一个单一的

7923
05:33:22,120 --> 05:33:25,638
数据分布式并行实例 每个

7924
05:33:23,920 --> 05:33:27,638
过程呃，而且有一大堆

7925
05:33:25,638 --> 05:33:29,558
关于更多内容，你可以阅读相关信息。

7926
05:33:27,638 --> 05:33:32,558
实际上，这在 PyTorch 中被大量使用。

7927
05:33:29,558 --> 05:33:34,638
设置起来相当简单，嗯，但这个

7928
05:33:32,558 --> 05:33:38,440
这是不是有点像所有那些情况呢

7929
05:33:34,638 --> 05:33:41,240
简化成一个可用的东西 嗯

7930
05:33:38,440 --> 05:33:43,600
现在回到……嗯，我确实还有更多内容

7931
05:33:41,240 --> 05:33:45,160
关于这个也有相关资源 嗯 我不会去…… 

7932
05:33:43,600 --> 05:33:46,840
来涵盖所有这些内容，因为我没有（足够时间、能力等，需结合上下文理解） 

7933
05:33:45,160 --> 05:33:48,798
实际上我家里有一个集群用于

7934
05:33:46,840 --> 05:33:50,638
在，呃，上面做实验，但有一些……

7935
05:33:48,798 --> 05:33:52,120
你可以使用的链接和资源

7936
05:33:50,638 --> 05:33:53,840
要知道你可能会陷入困境

7937
05:33:52,120 --> 05:33:59,040
一个关于这些的无底洞，这到底是什么

7938
05:33:53,840 --> 05:34:01,200
可能会很有趣，嗯，但高雄应用科技大学的议员是

7939
05:33:59,040 --> 05:34:04,280
实际上要去，这简直就是…… 

7940
05:34:01,200 --> 05:34:06,520
设计用于进行分布式基础密集型（操作） 

7941
05:34:04,280 --> 05:34:08,160
线性代数 所以如果你正在学习类似……这样的（知识） 

7942
05:34:06,520 --> 05:34:12,200
多GPU

7943
05:34:08,160 --> 05:34:15,160
嗯，张量，张量运算，嗯，这个夸洛

7944
05:34:12,200 --> 05:34:17,718
议员会处理那件事，所以如果我们回到……

7945
05:34:15,160 --> 05:34:22,280
好了，我们前往……

7946
05:34:17,718 --> 05:34:24,360
夸斯 呃 夸斯MP高性能CUDA

7947
05:34:22,280 --> 05:34:29,040
分布式稠密线性库

7948
05:34:24,360 --> 05:34:32,920
代数 嗯，开始学了 嗯，为了……

7949
05:34:29,040 --> 05:34:35,480
例如代码示例之类的，嗯

7950
05:34:32,920 --> 05:34:38,360
没错，你，你有这些巨大的，就像…… 

7951
05:34:35,480 --> 05:34:39,798
你要处理的网格之类的东西 嗯

7952
05:34:38,360 --> 05:34:43,080
如何使用

7953
05:34:39,798 --> 05:34:44,558
呃，是的，也许是关于如何将它用于……

7954
05:34:43,080 --> 05:34:47,000
示例字幕

7955
05:34:44,558 --> 05:34:48,798
API 嗯，还有一堆……

7956
05:34:47,000 --> 05:34:51,040
这里有关于如何……的有趣资源

7957
05:34:48,798 --> 05:34:53,280
你会去做一些事情，也许就像

7958
05:34:51,040 --> 05:34:53,280
一个；某个；某一

7959
05:34:57,280 --> 05:35:02,080
行动 我不知道 嗯 那就是 这是

7960
05:35:00,000 --> 05:35:04,000
供你选择去操作，这是可选的，你 

7961
05:35:02,080 --> 05:35:05,600
实际上并不需要了解忽必烈的议员（此处“MP”含义需结合具体语境进一步明确，常见含义有“议员、国会议员”等）

7962
05:35:04,000 --> 05:35:06,920
因为 PyTorch 在很多方面都能做到这一点，用于 

7963
05:35:05,600 --> 05:35:08,958
你 如果你只是在处理那些东西

7964
05:35:06,920 --> 05:35:10,080
工作量 嗯，但如果你打算成为…… 

7965
05:35:08,958 --> 05:35:11,680
在像数据中心这样的领域工作

7966
05:35:10,080 --> 05:35:15,760
基础设施，这是你……（原句似乎不完整）

7967
05:35:11,680 --> 05:35:18,320
想学习像Koss MP和nccl这样的（相关知识或技能） 

7968
05:35:15,760 --> 05:35:23,000
所以，嗯，希望这有助于提供

7969
05:35:18,320 --> 05:35:23,000
关于，呃，类似更大规模的一些背景信息

7970
05:35:23,160 --> 05:35:27,638
设置
给自己一个鼓励

7971
05:35:25,520 --> 05:35:30,240
如果你坚持到了这里，这就是一场……（这里原句不完整） 

7972
05:35:27,638 --> 05:35:31,958
到目前为止有很多，而且我们已经涉及了我们已经……（原句似乎表述不太完整） 

7973
05:35:30,240 --> 05:35:33,360
实际上涵盖了惊人的数量，并且

7974
05:35:31,958 --> 05:35:36,120
现在我们要讲的是其中一个更……

7975
05:35:33,360 --> 05:35:37,798
这门课程中被称为呃的技术部分

7976
05:35:36,120 --> 05:35:41,240
矩阵乘法以及我们如何……（原文“we we”可能有误）

7977
05:35:37,798 --> 05:35:44,400
对其进行优化，这样它就会成为一个（整体/事物等，需结合语境明确） 

7978
05:35:41,240 --> 05:35:47,000
在最具技术性的部分呃 主要是

7979
05:35:44,400 --> 05:35:49,240
因为我们正在考虑，呃，就像

7980
05:35:47,000 --> 05:35:51,920
底层优化，我们该如何做

7981
05:35:49,240 --> 05:35:53,638
实际上在硬件上加快这个速度

7982
05:35:51,920 --> 05:35:55,000
所以现在它不再仅仅像那

注：由于原文不完整，此翻译可能在语义连贯性上有所欠缺。你可以提供完整的内容，以便我更准确地为你翻译。 

7983
05:35:53,638 --> 05:35:56,760
它的大致工作原理，我们……

7984
05:35:55,000 --> 05:35:58,160
实际上运用我们的知识以及

7985
05:35:56,760 --> 05:36:00,718
我即将获得的额外知识

7986
05:35:58,160 --> 05:36:02,558
和你们分享一下我们如何能在……方面做到……

注：原英文文本表述不太完整和清晰，以上翻译是尽力按原文逻辑处理。 

7987
05:36:00,718 --> 05:36:05,200
我们如何制作基础矩阵

7988
05:36:02,558 --> 05:36:08,360
乘法或马特·米尔算法

7989
05:36:05,200 --> 05:36:10,440
呃，真的非常快，所以这个算法

7990
05:36:08,360 --> 05:36:13,200
在深度学习中它是专有的，它是

7991
05:36:10,440 --> 05:36:15,120
到处，呃，所以我觉得最好的……

7992
05:36:13,200 --> 05:36:18,040
教你如何优化内核的方法

7993
05:36:15,120 --> 05:36:22,840
可以将此作为一个例子，并且

7994
05:36:18,040 --> 05:36:24,798
幸运的是，呃，我们有，呃，一个仓库。

7995
05:36:22,840 --> 05:36:26,760
西蒙·博希姆 我想 我觉得就是那样

7996
05:36:24,798 --> 05:36:28,558
你把它念成“这家伙是……这家伙是……”

7997
05:36:26,760 --> 05:36:31,480
一场演出，或是上校工程师在……

7998
05:36:28,558 --> 05:36:33,878
安普罗科普公司（注：Anthropic 是一家人工智能研究公司） 所以他可能知道自己在……

7999
05:36:31,480 --> 05:36:36,680
在做，呃，他做了这个超酷的（东西）

8000
05:36:33,878 --> 05:36:38,040
名为 sjem cuda 的仓库以及一篇博客

8001
05:36:36,680 --> 05:36:39,840
帖子来与之搭配

8002
05:36:38,040 --> 05:36:41,760
所以我就打算照这个来做

8003
05:36:39,840 --> 05:36:43,840
嗯，而且我有点懒，不想去。

8004
05:36:41,760 --> 05:36:45,798
要从头开始把这一切都写出来

8005
05:36:43,840 --> 05:36:48,798
靠我自己，所以我有点就这么顺其自然了

8006
05:36:45,798 --> 05:36:50,360
带着这个，我想向你解释

8007
05:36:48,798 --> 05:36:53,040
呃，经历这个的步骤以及

8008
05:36:50,360 --> 05:36:54,798
我们实际上……我们如何……我们怎样……

8009
05:36:53,040 --> 05:36:57,638
逐步推进这些不同的步骤

8010
05:36:54,798 --> 05:37:00,080
快接近库布罗斯了

8011
05:36:57,638 --> 05:37:01,558
性能和每秒十亿次浮点运算，呃，或者也许

8012
05:37:00,080 --> 05:37:03,958
甚至会根据具体情况超越它

8013
05:37:01,558 --> 05:37:05,480
你有硬件，但呃，这个，这是

8014
05:37:03,958 --> 05:37:07,600
这将是目标，所以你可能会有

8015
05:37:05,480 --> 05:37:09,760
已经看过这篇文章了，呃，但是

8016
05:37:07,600 --> 05:37:11,360
但万一你还没……或者万一你……

8017
05:37:09,760 --> 05:37:13,718
也许这太难了 我只是

8018
05:37:11,360 --> 05:37:15,958
接下来要详细讨论这个，呃，我们会……

8019
05:37:13,718 --> 05:37:17,360
我们要达到超级厉害的水平

8020
05:37:15,958 --> 05:37:19,558
之后事情会变得超级清晰。

8021
05:37:17,360 --> 05:37:21,400
你完成这部分，嗯，你接下来要……

8022
05:37:19,558 --> 05:37:23,920
了解如何优化呃 CUDA

8023
05:37:21,400 --> 05:37:25,840
内核 那么让我们开始吧 我们不

8024
05:37:23,920 --> 05:37:27,638
实际上要去修这门课程

8025
05:37:25,840 --> 05:37:29,320
使用这个仓库，我会把它链接进去。

8026
05:37:27,638 --> 05:37:30,920
README 文件，这样你就可以跟着操作了

8027
05:37:29,320 --> 05:37:32,000
万一你只是在经历这个“在……里”的过程（此处“in”单独使用表意不明确，需结合更多上下文准确理解）

8028
05:37:30,920 --> 05:37:34,280
万一你正在经历这件事，这件事

8029
05:37:32,000 --> 05:37:36,520
课程仓库，但实际上我打算

8030
05:37:34,280 --> 05:37:38,558
在这里往后退几步，然后我要去……

8031
05:37:36,520 --> 05:37:42,920
将其克隆到我这里的 CA 目录中，所以

8032
05:37:38,558 --> 05:37:42,920
我打算直接删除旧版本

8033
05:37:42,958 --> 05:37:47,840
嗯，我们要去克隆那个……（这里原文“clone the”后面内容缺失，表述不太完整） 

8034
05:37:45,360 --> 05:37:50,878
其他仓库在里面，所以就是这样

8035
05:37:47,840 --> 05:37:53,558
真的就是，呃，到这儿来复制、复制

8036
05:37:50,878 --> 05:37:56,480
把这个粘贴到，嗯，去阿哈德（Ahad 可能是特定名称）那里并获取克隆版

8037
05:37:53,558 --> 05:37:59,958
那个，呃，然后我们接下来要继续进行

8038
05:37:56,480 --> 05:38:02,558
然后打开这个，在 Visual Studio（VS）里打开这个

8039
05:37:59,958 --> 05:38:05,600
代码，所以我打算把它拖到我的……

8040
05:38:02,558 --> 05:38:10,000
这边的侧监视器即将关闭

8041
05:38:05,600 --> 05:38:13,240
这个，然后把这个打开

8042
05:38:10,000 --> 05:38:15,920
现在，再一次，在这里面我们打算

8043
05:38:13,240 --> 05:38:18,040
先查看说明文档进行设置，嗯

8044
05:38:15,920 --> 05:38:20,840
所以我们可以看到它，呃，在……里面 

8045
05:38:18,040 --> 05:38:22,240
我们得按照这些构建说明来做，嗯

8046
05:38:20,840 --> 05:38:28,280
我们必须

8047
05:38:22,240 --> 05:38:31,280
创建名为 build 的目录，然后进入该目录

8048
05:38:28,280 --> 05:38:31,280
它

8049
05:38:31,320 --> 05:38:37,558
哦，呃，然后我们打算……

8050
05:38:34,600 --> 05:38:41,280
蛋糕 这得花点时间
（这里 “cake it's going to take take a second” 原句可能表述有误，推测正确表达或许是 “The cake is going to take a second” ，更符合语境和表达习惯 ） 

8051
05:38:37,558 --> 05:38:45,040
就在那时，我们进入了 D 建造阶段，并且

8052
05:38:41,280 --> 05:38:48,200
它将为我们建造一切 嗯

8053
05:38:45,040 --> 05:38:49,798
现在这里的想法是，呃，建造

8054
05:38:48,200 --> 05:38:53,920
一切都展现出所有的不同

8055
05:38:49,798 --> 05:38:57,000
基准测试 呃，在我们实际上……之后 呃

8056
05:38:53,920 --> 05:39:01,280
逐个检查优化过程，所以我们要……

8057
05:38:57,000 --> 05:39:03,040
基本上要把夸斯（Kuas，可能是特定名称）打印出来

8058
05:39:01,280 --> 05:39:04,920
表演，然后我们要去……

8059
05:39:03,040 --> 05:39:06,478
打印出“naive”，然后我们要去

8060
05:39:04,920 --> 05:39:07,638
打印出下一次优化结果，然后

8061
05:39:06,478 --> 05:39:09,718
我们接下来要打印X一号（这里根据语境推测X One可能是特定编号，可按需调整）

8062
05:39:07,638 --> 05:39:11,040
XX 直到我们走到最后，然后我们就……

8063
05:39:09,718 --> 05:39:13,600
打算把它们都比较一下然后看看

8064
05:39:11,040 --> 05:39:17,160
哪一个是最快的

8065
05:39:13,600 --> 05:39:18,280
那么我们可以接着开始进行

8066
05:39:17,160 --> 05:39:21,680
正要走

8067
05:39:18,280 --> 05:39:24,040
只是来到这里，所以有一个 

8068
05:39:21,680 --> 05:39:26,600
我们有一堆不同的核函数，其中有朴素核函数

8069
05:39:24,040 --> 05:39:29,120
我们有一个全球性的、全球性的记忆冲突，所以 

8070
05:39:26,600 --> 05:39:30,920
如果我们真的回到那个博客

8071
05:39:29,120 --> 05:39:32,400
帖子，这就是你知道的，我有点……

8072
05:39:30,920 --> 05:39:34,798
期望你们能遵守，这里没有……（此句英文似乎不太完整和规范，译文只能根据现有内容大致翻译） 

8073
05:39:32,400 --> 05:39:38,478
这里太多了，主要就是代码

8074
05:39:34,798 --> 05:39:40,320
所以如果我们回到那篇博客文章，嗯

8075
05:39:38,478 --> 05:39:41,840
我们正在做 我们 我们 我们

8076
05:39:40,320 --> 05:39:43,440
基本上就是按这个顺序进行，并且

8077
05:39:41,840 --> 05:39:45,000
他也是按照这个顺序做的，所以这个

8078
05:39:43,440 --> 05:39:48,080
植入的那晚，我是说我们已经

8079
05:39:45,000 --> 05:39:50,840
已经做完这个了，对吧，嗯，我能

8080
05:39:48,080 --> 05:39:52,680
实际上回去，如果我想做这个的话

8081
05:39:50,840 --> 05:39:56,040
满的；完全的；完整的；充满的

8082
05:39:52,680 --> 05:39:59,920
屏幕，然后我走出这一切

8083
05:39:56,040 --> 05:40:05,958
嗯，然后我开始进行CUDA课程编写工作。

8084
05:39:59,920 --> 05:40:05,958
你的第一批内核，然后马特姆注意到

8085
05:40:08,160 --> 05:40:11,280
我打算复制这个用于……

8086
05:40:14,400 --> 05:40:20,040
第二和

8087
05:40:16,798 --> 05:40:23,200
然后我们就把它粘贴上去，呃

8088
05:40:20,040 --> 05:40:23,200
就在这里面，只为了

8089
05:40:24,958 --> 05:40:29,080
参考资料，所以我们有这两个内核

8090
05:40:28,040 --> 05:40:30,440
我只是想，我只是想

8091
05:40:29,080 --> 05:40:31,958
确保我们都跟上进度了

8092
05:40:30,440 --> 05:40:33,878
这里，我之前教过你的那个是……

8093
05:40:31,958 --> 05:40:39,400
和我们这里展示的完全一样的那个

8094
05:40:33,878 --> 05:40:41,680
所以这个接收，嗯，A、B 和 C，就是这个

8095
05:40:39,400 --> 05:40:43,280
取一个 A、一个 B 和一个 C，它……它取一个α

8096
05:40:41,680 --> 05:40:44,638
还有一个测试版，我的意思是它正在（运行之类，此处需结合上下文确定 doing 的准确意思） 

8097
05:40:43,280 --> 05:40:46,840
它正在做一件不同的事，它稍微…… 

8098
05:40:44,638 --> 05:40:48,878
不同的操作，所以它并不完全是

8099
05:40:46,840 --> 05:40:51,600
矩阵乘法，但它是……它是

8100
05:40:48,878 --> 05:40:53,920
本质上是在做这个，呃，这个

8101
05:40:51,600 --> 05:40:55,080
本质上，我所看到的那个CU损失图……（这里原文句子不完整） 

8102
05:40:53,920 --> 05:40:57,958
之前给你展示过它在哪里进行（做）……（由于原句不完整，翻译可能不太准确完整）

8103
05:40:55,080 --> 05:41:01,080
阿尔法项，呃，就像乘以每一个（元素） 

8104
05:40:57,958 --> 05:41:03,638
矩阵中那个元素，我们……（此英文表述不太符合常见语法逻辑，翻译可能不太精准表意） 

8105
05:41:01,080 --> 05:41:09,240
计算实际材料输出中的…… 

8106
05:41:03,638 --> 05:41:12,160
然后它加上，呃，β正 再加上一个 c

8107
05:41:09,240 --> 05:41:14,120
矩阵，然后将 C 赋值给那个新矩阵

8108
05:41:12,160 --> 05:41:16,120
所以这有点不同，这是一个

8109
05:41:14,120 --> 05:41:17,798
我们所进行的略有不同的操作

8110
05:41:16,120 --> 05:41:19,680
但我们主要会担心的是

8111
05:41:17,798 --> 05:41:23,040
矩阵乘法的机制，即

8112
05:41:19,680 --> 05:41:25,920
将我们的值赋给这个临时变量，这样当

8113
05:41:23,040 --> 05:41:29,200
我们来看这个，我们有 M、K 和 N，所以

8114
05:41:25,920 --> 05:41:30,920
这是一个特定形状的矩阵，所以矩阵 a 的形状是 M

8115
05:41:29,200 --> 05:41:32,360
所以这就像是垂直的 M，那就像是…… 

8116
05:41:30,920 --> 05:41:35,000
你可以说批量大小，然后它就是

8117
05:41:32,360 --> 05:41:37,718
就像 K，就像……的长度数值

8118
05:41:35,000 --> 05:41:41,400
右侧的列，然后是矩阵 B 是

8119
05:41:37,718 --> 05:41:44,400
垂直方向上为 K，长度为 N

8120
05:41:41,400 --> 05:41:45,920
对，所以我们实际上是把它传进去

8121
05:41:44,400 --> 05:41:48,280
同样的方式，并且我们以相同的方式对它们进行索引

8122
05:41:45,920 --> 05:41:51,080
方式，但在这个例子里，在……呃，在

8123
05:41:48,280 --> 05:41:53,320
西蒙的例子，我们就直接跳过

8124
05:41:51,080 --> 05:41:55,360
这些以不同的方式呈现，所以就像 m 和

8125
05:41:53,320 --> 05:41:56,680
就像边缘部分，然后 K 是那个…… 

8126
05:41:55,360 --> 05:41:58,558
中间那个是我们要关注的

8127
05:41:56,680 --> 05:42:00,240
所以我们把那个留到第三个，我

8128
05:41:58,558 --> 05:42:02,638
猜也许那就是……那就是所想的那个

8129
05:42:00,240 --> 05:42:05,840
那里的思考过程，但不管怎样，我们

8130
05:42:02,638 --> 05:42:09,120
我们有 X 和 Y，所以有行以及 

8131
05:42:05,840 --> 05:42:12,440
列 嗯，列的 Y 和行是一样的

8132
05:42:09,120 --> 05:42:14,878
那么，呃，它处于哪个 y 索引呢？

8133
05:42:12,440 --> 05:42:16,200
因为像行这样的行是垂直的，它

8134
05:42:14,878 --> 05:42:18,440
可能是这一排 这一排 就是这一排

8135
05:42:16,200 --> 05:42:22,360
就像一个垂直的刻度，对吧，然后那个

8136
05:42:18,440 --> 05:42:24,760
x 呃 是列，那么是哪一列呢

8137
05:42:22,360 --> 05:42:27,240
这是……这是……这是……

（注：原文表述不太符合常规语法逻辑，这样的翻译只是按字面呈现大概意思） 

8138
05:42:24,760 --> 05:42:29,000
水平的，所以我们要确保它不是

8139
05:42:27,240 --> 05:42:30,440
出界了，然后我们接着进行……

8140
05:42:29,000 --> 05:42:32,718
那块小玩意儿里面有什么

8141
05:42:30,440 --> 05:42:35,558
记忆，然后我们，我们继续，没错，所以我们

8142
05:42:32,718 --> 05:42:37,718
有这个累加器的和，呃，然后我们

8143
05:42:35,558 --> 05:42:40,798
有这个L项

8144
05:42:37,718 --> 05:42:43,080
呃，我们可以说那就是长度，并且

8145
05:42:40,798 --> 05:42:45,360
呃，然后我们有这个 K，它是

8146
05:42:43,080 --> 05:42:49,280
哪一个是 a 的长度，然后是……

8147
05:42:45,360 --> 05:42:50,958
呃，B的高度，对吧

8148
05:42:49,280 --> 05:42:54,558
所以当你在进行产品制作时，你会……（原句“do producting”表述有误，正确形式可能是“producing” ） 

8149
05:42:50,958 --> 05:42:57,360
你正在拿呃……那一排呃……那个A

8150
05:42:54,558 --> 05:42:59,680
A的一行和B的一列，所以你是

8151
05:42:57,360 --> 05:43:02,160
你正在对 k 进行迭代

8152
05:42:59,680 --> 05:43:04,040
并且你正在对 K 进行迭代，并且在……中

8153
05:43:02,160 --> 05:43:06,440
好吧，所以那就是那个……那个的所在之处

8154
05:43:04,040 --> 05:43:07,638
来自那种K类物质，所以你是

8155
05:43:06,440 --> 05:43:09,920
只是在反复做；只是在迭代

8156
05:43:07,638 --> 05:43:11,558
呃，就像连续地，你正在经历一场…… 

8157
05:43:09,920 --> 05:43:14,400
像这样，你正在逐一查看每个

8158
05:43:11,558 --> 05:43:15,718
像每个数字一样的片段，然后在 B 中

8159
05:43:14,400 --> 05:43:18,160
你正在逐个检查每个数字

8160
05:43:15,718 --> 05:43:20,760
垂直向右，然后我们只需加上

8161
05:43:18,160 --> 05:43:23,958
加上每次（的数值），然后输出这个总和

8162
05:43:20,760 --> 05:43:27,600
这个累加器，呃，它将只是……

8163
05:43:23,958 --> 05:43:29,600
本质上，所以，我们正在寻找…… 

8164
05:43:27,600 --> 05:43:32,040
呃，将第一个，第一个元素相乘

8165
05:43:29,600 --> 05:43:33,558
这里由这里的第一个元素开始，然后

8166
05:43:32,040 --> 05:43:35,000
然后前进，然后前进，并且

8167
05:43:33,558 --> 05:43:37,478
然后前进，然后再前进，对吧

8168
05:43:35,000 --> 05:43:39,680
这就是我们正在努力做的事情。

8169
05:43:37,478 --> 05:43:41,080
你也可以把它想象成一个……一个

8170
05:43:39,680 --> 05:43:44,520
我喜欢这样形象地看待这件事的好方法是

8171
05:43:41,080 --> 05:43:47,478
就像一个 2X 的方块，所以你有你……

注：原英文表述似乎不太完整或存在不太规范之处，翻译可能不太符合常规逻辑。 

8172
05:43:44,520 --> 05:43:49,840
有一个类似 2X 的两块瓷砖，你（这里原英文句子不太符合常见语法规范，翻译可能不是特别精准表意） 

8173
05:43:47,478 --> 05:43:53,200
我一直在尝试从你的角度来想象这个场景。

注：原英文句子存在语法错误，正确的可能是 “I've been trying to visualize this from your...”  以上翻译是基于推测的语义进行的。 

8174
05:43:49,840 --> 05:43:56,400
从视角上看，你这里上方有…… （原句表述不太完整和清晰） 

8175
05:43:53,200 --> 05:44:01,000
然后你在这儿下方有个 B，而且情况就像这样

8176
05:43:56,400 --> 05:44:03,638
那，那正确吗？也许是，也许吧

8177
05:44:01,000 --> 05:44:06,240
嗯，这里是 A，然后这里是 B

8178
05:44:03,638 --> 05:44:10,080
所以当矩阵 A 有某一行时，那一行是

8179
05:44:06,240 --> 05:44:12,320
打算去指一下，呃，就像那个……那个

8180
05:44:10,080 --> 05:44:14,638
呃，点 C 和点 B 的 y 坐标正在（这里句子不完整，原句表意未结束）

8181
05:44:12,320 --> 05:44:17,080
因此，在 C 语言中指向 x 坐标

8182
05:44:14,638 --> 05:44:19,200
当它们，当它们相交的时候

8183
05:44:17,080 --> 05:44:20,600
它将在 C 中找到该索引。

8184
05:44:19,200 --> 05:44:22,360
你要去计算那个点积

8185
05:44:20,600 --> 05:44:26,600
产品源于 那是个很酷的方式 我

8186
05:44:22,360 --> 05:44:28,878
想把它形象化展示出来，呃，但不管怎样

8187
05:44:26,600 --> 05:44:32,360
回到正题，呃，所以我们有

8188
05:44:28,878 --> 05:44:34,520
这一行乘以，呃，乘以K，那么比如哪个

8189
05:44:32,360 --> 05:44:37,320
排 我们到这一排的尽头了吗

8190
05:44:34,520 --> 05:44:39,600
对了还是抱歉，你说的是哪个，你在第几排呢

注：原英文句子表述不太符合常规语法，翻译时根据语义尽量通顺表达。 

8191
05:44:37,320 --> 05:44:42,360
那么，相对于你所知道的，是哪一排呢

8192
05:44:39,600 --> 05:44:43,478
CUDA架构本身，然后是K

8193
05:44:42,360 --> 05:44:45,320
它的长度是多少，所以你是……

8194
05:44:43,478 --> 05:44:47,360
往下走，你基本上就像

8195
05:44:45,320 --> 05:44:48,878
包裹着 你四处大步走着 并且

8196
05:44:47,360 --> 05:44:51,240
只要你愿意，你可以多次做这件事。

注：原英文表述不太完整，准确来说可能是 “You're doing this as many times as you want” 之类的，这里是根据大致语义进行的翻译。 

8197
05:44:48,878 --> 05:44:54,440
想要，就像取决于哪一行那样

8198
05:44:51,240 --> 05:44:56,000
你在（某个位置），然后你加上那个 K

8199
05:44:54,440 --> 05:44:58,320
对它进行偏移，所以你可能不会完全……

8200
05:44:56,000 --> 05:45:00,440
一路贯穿它的全长，所以

8201
05:44:58,320 --> 05:45:01,520
你停下来，而那就是那个“加”的所在之处

8202
05:45:00,440 --> 05:45:04,240
来了；到来；出现（come的第三人称单数形式） 

8203
05:45:01,520 --> 05:45:08,000
从这里开始，然后对我们来说情况相同

8204
05:45:04,240 --> 05:45:09,638
有这个 L 项，它等于 K，那么，呃……

8205
05:45:08,000 --> 05:45:11,478
本质上，你在哪个栏目（列）呢？ 

8206
05:45:09,638 --> 05:45:15,520
没错，所以我们这里有几行，然后这里

8207
05:45:11,478 --> 05:45:17,840
我们有几列，所以呢，这是 L，它代表的是……（原句表述不完整，这里只能按已有内容翻译） 

8208
05:45:15,520 --> 05:45:20,240
本质上，那个的长度

8209
05:45:17,840 --> 05:45:23,718
垂直方向，一列的长度，然后

8210
05:45:20,240 --> 05:45:27,000
你对，呃，你对 N 进行迭代

8211
05:45:23,718 --> 05:45:28,600
时间对了，所以 n 是……n 是长度

8212
05:45:27,000 --> 05:45:31,520
在那里以及

8213
05:45:28,600 --> 05:45:34,478
所以，从本质上来说，从本质上来说

8214
05:45:31,520 --> 05:45:36,280
根据你需要推进的次数，推进到……

（注：原英文句子似乎不完整，不过已按要求完成翻译） 

8215
05:45:34,478 --> 05:45:38,558
我想你可以说，对于……（这里文本不完整，“to the”后面缺少相关内容） 

8216
05:45:36,280 --> 05:45:40,600
对，然后你在任意位置进行抵消。 

8217
05:45:38,558 --> 05:45:44,000
列索引，这想法差不多，我们是……

8218
05:45:40,600 --> 05:45:47,320
只是 我们只是在推进 呃 而不是

8219
05:45:44,000 --> 05:45:49,638
我们不按行来，而是要……（这里原文未完整表述出“going”之后的内容）

8220
05:45:47,320 --> 05:45:52,440
右边的列，然后我们就

8221
05:45:49,638 --> 05:45:56,000
本质上分配 呃

8222
05:45:52,440 --> 05:45:59,638
无论在 C 语言里，我们就像这样去对它进行索引，我们继续

8223
05:45:56,000 --> 05:46:02,400
呃，划桨时间 呃，计时 所以这是一个 这是一个

8224
05:45:59,638 --> 05:46:08,240
M 它是

8225
05:46:02,400 --> 05:46:10,718
并且它是一个 m 行 n 列的（矩阵），所以它将会是

8226
05:46:08,240 --> 05:46:12,680
就像 M 在这儿，N 在这儿，所以它是

8227
05:46:10,718 --> 05:46:15,760
将要去；打算去

8228
05:46:12,680 --> 05:46:18,478
呃，行数乘以 n，所以它将会是

8229
05:46:15,760 --> 05:46:20,200
步幅 每次它循环然后

8230
05:46:18,478 --> 05:46:23,440
它将加上列索引

8231
05:46:20,200 --> 05:46:24,798
也就是那个 X 分量，对吧

8232
05:46:23,440 --> 05:46:26,040
这就是你再次表现得如此天真的方式，仅仅是这样

8233
05:46:24,798 --> 05:46:28,718
只是给你稍微复习一下

8234
05:46:26,040 --> 05:46:31,080
那是挺久之前的事了，我们当时做了，嗯

8235
05:46:28,718 --> 05:46:33,878
然后这里也是同样的想法，所以你

8236
05:46:31,080 --> 05:46:36,440
有M和N

8237
05:46:33,878 --> 05:46:38,120
m&n 你们有累加器，我们有

8238
05:46:36,440 --> 05:46:39,360
我们正在遍历的这个项

8239
05:46:38,120 --> 05:46:42,200
而且我们有

8240
05:46:39,360 --> 05:46:46,360
呃，然后我们有这个临时（的东西/情况等，需结合语境确定“temp”具体所指） 

8241
05:46:42,200 --> 05:46:51,558
项我们用 X 表示，所以 X 和行是一样的，所以

8242
05:46:46,360 --> 05:46:53,958
注意看如何将行分配给 Y，而 X 是……

8243
05:46:51,558 --> 05:46:57,600
嗯，实际上我有点卡住了。

8244
05:46:53,958 --> 05:47:00,400
当时我正看着，呃，那块街区。

8245
05:46:57,600 --> 05:47:02,440
以及这里的线程呃索引方案，并且

8246
05:47:00,400 --> 05:47:04,760
这有点误导人，所以要留意。

8247
05:47:02,440 --> 05:47:06,920
在这里，我们看到有行，并且这些行是按照……（原句似乎不完整）

8248
05:47:04,760 --> 05:47:08,718
这个 Y 索引，所以无论哪个 Y 位置

8249
05:47:06,920 --> 05:47:10,718
我……那就好像是它所在的那一排……

8250
05:47:08,718 --> 05:47:12,638
打算拔出或者是……那根柱子 

8251
05:47:10,718 --> 05:47:15,718
这就像X，所以它会挑出一个

8252
05:47:12,638 --> 05:47:19,638
行，或者抱歉，在这个里是一列

8253
05:47:15,718 --> 05:47:24,520
例如，我们做，嗯，像X这样的事，那指的是

8254
05:47:19,638 --> 05:47:25,840
就在这儿呢，嗯，正在挑选

8255
05:47:24,520 --> 05:47:27,760
喜欢它，这有点说得通，对吧

8256
05:47:25,840 --> 05:47:31,638
就像X与X匹配，而Y与……（原文此处不完整） 

8257
05:47:27,760 --> 05:47:33,520
和 Y 一起上升，但当我们看向这里时，嗯

8258
05:47:31,638 --> 05:47:36,280
与这个相比，这就像是

8259
05:47:33,520 --> 05:47:39,478
行数乘以 K 的步长，所以我们要开始了

8260
05:47:36,280 --> 05:47:40,878
跨越 K 的长度，然后

8261
05:47:39,478 --> 05:47:42,080
然后回到下一个，接着

8262
05:47:40,878 --> 05:47:45,840
与……相抵消；用……来弥补

8263
05:47:42,080 --> 05:47:48,400
在这一个里面我们有 X，它就像一个

8264
05:47:45,840 --> 05:47:50,280
列索引 没错，所以就好像，这是怎么回事，为什么啊

8265
05:47:48,400 --> 05:47:53,120
你会那样做吗？我们想，我们想要一个…… 

8266
05:47:50,280 --> 05:47:55,000
行索引，但实际上这是可行的，而且我们

8267
05:47:53,120 --> 05:47:58,320
不必太过担心，因为

8268
05:47:55,000 --> 05:48:01,520
这是一个方阵，所以因为这些

8269
05:47:58,320 --> 05:48:04,440
数值实际上是相同的，因为呃

8270
05:48:01,520 --> 05:48:07,320
网格以及其中的线程索引

8271
05:48:04,440 --> 05:48:08,558
X 维度和 Y 维度都相等。

8272
05:48:07,320 --> 05:48:10,120
实际上我们不必担心

8273
05:48:08,558 --> 05:48:12,760
所以这是你想要的东西

8274
05:48:10,120 --> 05:48:14,000
注意在长方形矩阵中

8275
05:48:12,760 --> 05:48:16,600
但我们不必为此担心

8276
05:48:14,000 --> 05:48:19,120
现在呢，所以就姑且假设一下，呃

8277
05:48:16,600 --> 05:48:21,040
我们可以大致说这是，呃

8278
05:48:19,120 --> 05:48:22,600
比如为什么要那样对待它，但我是

8279
05:48:21,040 --> 05:48:24,920
不打算编辑这个，因为我们可能会

8280
05:48:22,600 --> 05:48:28,160
稍后得处理这个问题，呃，在……方面

8281
05:48:24,920 --> 05:48:30,240
未来的内核，这样你在某种程度上就能得到那个（此处“那个”指代不明，需结合前文确定具体含义）

8282
05:48:28,160 --> 05:48:33,558
不过这个想法和……非常相似

8283
05:48:30,240 --> 05:48:34,798
我们之前在做……嗯，不太好描述

8284
05:48:33,558 --> 05:48:37,600
很多时候，别担心索引的问题。

8285
05:48:34,798 --> 05:48:40,478
计划 会没事的

8286
05:48:37,600 --> 05:48:43,878
嗯，然后我们，没错，实际上就只有

8287
05:48:40,478 --> 05:48:47,240
这里的变化是我们把呃……写出来

8288
05:48:43,878 --> 05:48:49,958
使用阿尔法、贝塔和C，没错，就是这样

8289
05:48:47,240 --> 05:48:52,160
实际上，那里唯一的区别就是这样

8290
05:48:49,958 --> 05:48:57,000
让我们继续，实际运行一下这个。

8291
05:48:52,160 --> 05:48:58,400
现在，所以我们突然进入呃SJ Cuda，然后

8292
05:48:57,000 --> 05:49:02,360
我们进入……（此处“into”后面缺少内容，语义不完整）

8293
05:48:58,400 --> 05:49:04,878
现在就建造 我们可以走了 呃 谢姆（可能为地名或人名） 然后我们

8294
05:49:02,360 --> 05:49:08,200
冲第一，所以这很天真

8295
05:49:04,878 --> 05:49:10,920
我们运行的内核，并且我们可以看到

8296
05:49:08,200 --> 05:49:14,080
我们要做一个最大尺寸的，所以

8297
05:49:10,920 --> 05:49:16,200
尺寸 M = Nal K 那么这些

8298
05:49:14,080 --> 05:49:20,080
还好吧，我刚才可能有点卡顿了

8299
05:49:16,200 --> 05:49:22,520
其次，不过是啊，我的意思是，正如我们所见，嗯

8300
05:49:20,080 --> 05:49:24,360
维度 m 等于 n 等于 K，对吧，所以这些

8301
05:49:22,520 --> 05:49:26,840
都是一样的，就像 128 一样

8302
05:49:24,360 --> 05:49:27,760
本质上，然后 256、512、1024 全部

8303
05:49:26,840 --> 05:49:29,638
通往……的路；向上到……的方式

注：由于“the way up to”不是完整句子，“up to”之后可能还有内容，所以这里只是比较宽泛的常见释义。如果有更完整的语境，翻译会更精准。 

8304
05:49:27,760 --> 05:49:31,958
496，而且我们实际上可以看到

8305
05:49:29,638 --> 05:49:35,200
吞吐量以及每秒的吉次浮点运算（G 浮点运算），所以

8306
05:49:31,958 --> 05:49:39,080
这意味着多少十亿，吉咖（千兆）

8307
05:49:35,200 --> 05:49:42,040
对，吉（咖）是，呃，乘以 10 的 9 次方，也就是十亿，并且

8308
05:49:39,080 --> 05:49:43,240
那么 FLOPS 指的是浮点运算次数

8309
05:49:42,040 --> 05:49:45,878
每；每一

8310
05:49:43,240 --> 05:49:50,000
第二，这是在给定的尺寸下，对吧

8311
05:49:45,878 --> 05:49:52,400
所以在尺寸为 128 时，我们平均得到 46.2

8312
05:49:50,000 --> 05:49:56,520
吉咖，即十亿次浮点运算

8313
05:49:52,400 --> 05:49:58,160
每秒，在496这个数值上我们得到大约166

8314
05:49:56,520 --> 05:49:59,958
每秒十亿次浮点运算（这里原英文文本似乎不完整，正常表述可能是“billion floating Point operations per second” ） 

8315
05:49:58,160 --> 05:50:01,920
第二，这听起来很多，那个

8316
05:49:59,958 --> 05:50:04,798
听起来有很多操作，对吧

8317
05:50:01,920 --> 05:50:07,280
每秒1660亿 哇，那……那是

8318
05:50:04,798 --> 05:50:08,878
真的很高，但答案是那是

8319
05:50:07,280 --> 05:50:11,558
实际上不会升得那么高

它接下来的情况会是这样 

8320
05:50:08,878 --> 05:50:13,280
比这高得多，实际上非常高

8321
05:50:11,558 --> 05:50:14,958
这看起来似乎会是这样的情况 

8322
05:50:13,280 --> 05:50:18,120
负击杀 这看起来会非常……

（原英文文本表述似乎不太完整和通顺） 

8323
05:50:14,958 --> 05:50:22,280
非常小，而且实际上很慢，所以注意

8324
05:50:18,120 --> 05:50:26,878
这怎么花了，嗯，这花了，呃，八个（单位，需结合上下文确定） 

8325
05:50:22,280 --> 05:50:31,600
大约83秒完成50次，对吧

8326
05:50:26,878 --> 05:50:35,000
所以，非常，嗯，非常慢，或者每次运行都不行 

8327
05:50:31,600 --> 05:50:37,240
抱歉，不是针对 50 次运行，而是针对…… 

8328
05:50:35,000 --> 05:50:40,520
它进行的每一次运行，总共进行了50次 

8329
05:50:37,240 --> 05:50:43,958
完成那件事大约花了 83 秒。

8330
05:50:40,520 --> 05:50:45,280
在 496 上使用一个简单的内核，所以有几个

8331
05:50:43,958 --> 05:50:48,920
在我们真正开始之前的其他要点

8332
05:50:45,280 --> 05:50:51,240
说到这个，嗯，我想先看看…… 

8333
05:50:48,920 --> 05:50:54,400
呃，我想先看看那篇博客文章。

8334
05:50:51,240 --> 05:50:56,638
在这里，所以当我们在计算……（原文未完整，推测后续还有内容） 

8335
05:50:54,400 --> 05:50:58,718
我的意思是在KN实现中的输出

8336
05:50:56,638 --> 05:51:01,080
就像，哪怕只是看着这个，呃

8337
05:50:58,718 --> 05:51:02,958
这真的很直观，呃，我很喜欢。

8338
05:51:01,080 --> 05:51:06,000
但这个例子

8339
05:51:02,958 --> 05:51:10,280
不管怎样，呃，当我们实际去看……

8340
05:51:06,000 --> 05:51:11,400
简单朴素的内核，嗯，本质上

8341
05:51:10,280 --> 05:51:13,600
我们正在努力

8342
05:51:11,400 --> 05:51:16,040
到；向；朝；往；对着；给；对；于；直到……为止；在……之前

8343
05:51:13,600 --> 05:51:19,878
呃，我们正在努力去……

8344
05:51:16,040 --> 05:51:23,558
在里面找到，呃，某个特定的部分

8345
05:51:19,878 --> 05:51:24,878
我们正在试图找到某个特定的索引

8346
05:51:23,558 --> 05:51:27,798
在 C 语言内部，那将是 

8347
05:51:24,878 --> 05:51:30,320
输出 所以我们是说我们想做这件事

8348
05:51:27,798 --> 05:51:34,080
尽可能快速的计算以得出，比如说

8349
05:51:30,320 --> 05:51:37,400
这个数字，呃，这个指数是在……中计算得出的 

8350
05:51:34,080 --> 05:51:40,600
直接用 C 语言输出 C 语言的结果

8351
05:51:37,400 --> 05:51:43,520
呃，所以目前要做到这一点的方法是

8352
05:51:40,600 --> 05:51:45,280
是要按行和列加载，并且

8353
05:51:43,520 --> 05:51:47,040
然后，只需计算一下，那就是

8354
05:51:45,280 --> 05:51:48,958
这就是我们目前天真地发现的情况

8355
05:51:47,040 --> 05:51:51,080
而且只需要很少几行代码就能

8356
05:51:48,958 --> 05:51:52,798
这样做，然后我们就有点像在不断迭代。 

8357
05:51:51,080 --> 05:51:54,320
就像我之前说的那样，你如何…… 

8358
05:51:52,798 --> 05:51:56,360
在这里放一个在边上，然后你就随它去

8359
05:51:54,320 --> 05:51:57,680
你让它们在某种程度上起到坐标的作用

8360
05:51:56,360 --> 05:52:03,000
那……那就是我所指的内容

8361
05:51:57,680 --> 05:52:04,360
呃，不过不管怎样，呃，就是那样了。

8362
05:52:03,000 --> 05:52:05,600
有点像是我们的目标之一

8363
05:52:04,360 --> 05:52:07,160
需要记住的是我们该如何

8364
05:52:05,600 --> 05:52:09,200
计算索引中的输出，这会有帮助的。

8365
05:52:07,160 --> 05:52:10,878
你 这将有助于提供一些关于……的背景信息

8366
05:52:09,200 --> 05:52:13,000
我们究竟要如何到达那里，因为当我们……

8367
05:52:10,878 --> 05:52:14,920
处理更复杂的内核，你将

8368
05:52:13,000 --> 05:52:16,840
实际上可以看到，有很多步骤要…… （原句不完整，这里翻译后保持未完成状态）

8369
05:52:14,920 --> 05:52:18,718
实际上到达某个特定的地方，然后如此

8370
05:52:16,840 --> 05:52:20,520
当你能够保持在一种（状态）时会有帮助

注：原文句子似乎不完整，“keep in a”后面可能缺失内容。 

8371
05:52:18,718 --> 05:52:22,080
始终如一的，呃，思维框架，在……（这里where后面内容缺失，所以译文也只能处理到这个程度） 

8372
05:52:20,520 --> 05:52:23,360
就好像，好吧，我们实际上到底怎么样了

8373
05:52:22,080 --> 05:52:25,280
最终得到了这个结果，然后你

8374
05:52:23,360 --> 05:52:28,320
可以在一定程度上回溯并查看

8375
05:52:25,280 --> 05:52:29,920
发生什么事了 嗯 所以与其只是

8376
05:52:28,320 --> 05:52:31,558
比如去做某事，还比如像读小说一样阅读

8377
05:52:29,920 --> 05:52:33,320
从科纳尔（此处“konal”可能有误，可能是某个特定专有名词）的开始到…… 

8378
05:52:31,558 --> 05:52:34,760
结束，然后就只是心想，哦，我猜就像……

8379
05:52:33,320 --> 05:52:36,160
我们 我们看看会偶然遇到什么 这是

8380
05:52:34,760 --> 05:52:37,798
就好像你真的想看看什么

8381
05:52:36,160 --> 05:52:39,840
你最终是想进行计算

8382
05:52:37,798 --> 05:52:42,240
这有帮助，还有这篇博客文章

8383
05:52:39,840 --> 05:52:43,798
雷法特，关于那方面有很多背景信息呢，所以…… 

注：“refat”可能是人名“雷法特”，由于原文表述不太完整清晰，翻译可能存在一定局限性。 

8384
05:52:42,240 --> 05:52:45,400
我想补充的另一个小说明是

8385
05:52:43,798 --> 05:52:47,680
别太担心三维结构了

8386
05:52:45,400 --> 05:52:50,718
很多时候，当我们遇到类似3维暗淡的情况时

8387
05:52:47,680 --> 05:52:52,360
输入，并且我们有那个 YX 和 Zed 呃

8388
05:52:50,718 --> 05:52:54,680
所有尺寸均已填入数字

8389
05:52:52,360 --> 05:52:56,798
大于一，就像四、二和

8390
05:52:54,680 --> 05:52:58,400
第三，就好像别担心那个事儿

8391
05:52:56,798 --> 05:52:59,638
我们不会处理三维相关的内容

8392
05:52:58,400 --> 05:53:01,840
事情不会是那样的

8393
05:52:59,638 --> 05:53:03,878
复杂，而且会变得更加复杂

8394
05:53:01,840 --> 05:53:07,400
就像你要怎么转变呢，呃

8395
05:53:03,878 --> 05:53:12,360
一维和二维，嗯

8396
05:53:07,400 --> 05:53:13,600
嗯，能高效地处理维度和索引，所以

8397
05:53:12,360 --> 05:53:17,760
别担心 3D 相关的东西，我们不会（担心）

8398
05:53:13,600 --> 05:53:22,040
打算做其中任何一件事，嗯，然后呢，那个…… 

8399
05:53:17,760 --> 05:53:25,760
实际上，呃，这里的索引方案正在给出

8400
05:53:22,040 --> 05:53:26,878
美国海岸内存访问，所以我要深入探讨一下

注：原文“coest”可能拼写有误，推测是“coast” ，但此句表述可能不太符合常见语境，存在一些费解之处。 

8401
05:53:25,760 --> 05:53:28,558
这在接下来的当下稍微……（原英文表述不太符合常规语法逻辑，翻译可能不太通顺） 

8402
05:53:26,878 --> 05:53:31,798
更深入一些，但本质上是什么

8403
05:53:28,558 --> 05:53:34,680
正在发生的事情是，呃，当我们……当我们在做的时候

8404
05:53:31,798 --> 05:53:36,558
这个，呃，比如说像行计算

8405
05:53:34,680 --> 05:53:39,520
嗯，当它通过的时候是什么感觉呢

8406
05:53:36,558 --> 05:53:41,520
嗯，实际上每一行是什么呢

8407
05:53:39,520 --> 05:53:43,840
正在发生的事情是，呃，我们有这个，我们有

8408
05:53:41,520 --> 05:53:47,240
这里的这个类似 X 的项，然后我们把它放到……（原文句子未完整） 

8409
05:53:43,840 --> 05:53:49,000
在所有类似CUDA的情况中的这个x项

8410
05:53:47,240 --> 05:53:50,760
当你有相邻的含义，就像在……里时

8411
05:53:49,000 --> 05:53:53,000
就像在……里的X维度

8412
05:53:50,760 --> 05:53:55,878
长度部分 水平方向 当它们是……时

8413
05:53:53,000 --> 05:54:00,080
彼此相邻时，实际上你会得到中欧夏令时。 

8414
05:53:55,878 --> 05:54:04,280
内存访问，所以当你在进行访问时

8415
05:54:00,080 --> 05:54:05,840
嗯，实际上，你真的可以，呃，在……

8416
05:54:04,280 --> 05:54:08,280
在汇编中，它实际上会进行分组

8417
05:54:05,840 --> 05:54:11,080
多个（事物）合并成一个，所以

8418
05:54:08,280 --> 05:54:13,520
当你有……就像当你有一个……一个……

8419
05:54:11,080 --> 05:54:17,440
在那个方块里面，你有一个扭曲场 

8420
05:54:13,520 --> 05:54:22,280
在这些扭曲的内部，你有，嗯，你

8421
05:54:17,440 --> 05:54:25,200
每个线程束有呃32个线程，对吧，所以

8422
05:54:22,280 --> 05:54:28,120
我们可以待在实际的曲速场内部。 

8423
05:54:25,200 --> 05:54:30,400
它本身呢，呃，它将会……

8424
05:54:28,120 --> 05:54:32,200
如果可能的话，请联系我们“内存访问”，并且

8425
05:54:30,400 --> 05:54:34,280
当事物相邻时，实际上

8426
05:54:32,200 --> 05:54:35,478
使那成为可能，所以有点……

8427
05:54:34,280 --> 05:54:37,520
为什么我们会看到这种奇怪的索引现象

8428
05:54:35,478 --> 05:54:39,558
这里的方案再次不适用于…… 

8429
05:54:37,520 --> 05:54:41,878
矩形矩阵，但在这种情况下

8430
05:54:39,558 --> 05:54:45,680
这算是一种效率提升。

8431
05:54:41,878 --> 05:54:47,760
用于 用于索引 嗯 那个 一个矩阵 所以

8432
05:54:45,680 --> 05:54:49,400
在我们转到全局内存之前

8433
05:54:47,760 --> 05:54:52,240
可乐的内核 我想我或许应该

8434
05:54:49,400 --> 05:54:53,558
突出显示某些内容，所以这很重要

8435
05:54:52,240 --> 05:54:55,440
要了解所有的内核，甚至是那些（这里原文似乎不完整）

8436
05:54:53,558 --> 05:54:58,080
之前的那些也是，但这个只是有点…… 

8437
05:54:55,440 --> 05:55:01,718
就像记忆是如何排列的，对吧，所以

8438
05:54:58,080 --> 05:55:04,080
当我们有一个 2×2 的矩阵
1  2
3  4
嗯，在……里 

8439
05:55:01,718 --> 05:55:07,160
记忆，这将被安排成

8440
05:55:04,080 --> 05:55:10,360
实际上只是一个向量 1 2 3 4

8441
05:55:07,160 --> 05:55:11,760
所以当我们想要，比如说在一个…… 

8442
05:55:10,360 --> 05:55:14,000
当我们想要迈向下一步时

8443
05:55:11,760 --> 05:55:16,840
本质上是下一行，然后进行一次…… 

8444
05:55:14,000 --> 05:55:21,840
抵消 我们正在做的是我们要进行一个

8445
05:55:16,840 --> 05:55:23,878
当前行乘以 K，也就是这个

8446
05:55:21,840 --> 05:55:26,798
这里的维度是水平维度

注：原文“the the the”表述有误，正常英文不会这样重复使用定冠词，可能是输入失误。 

8447
05:55:23,878 --> 05:55:28,798
其一，这么说吧，我们正在做……

8448
05:55:26,798 --> 05:55:30,520
想在这里达到数字四这个位置

8449
05:55:28,798 --> 05:55:33,160
对，所以如果我们想得到数字

8450
05:55:30,520 --> 05:55:35,040
四 它将会是当前行 嗯

8451
05:55:33,160 --> 05:55:37,520
当前行将变为零，并且

8452
05:55:35,040 --> 05:55:40,280
对，那么电流将是 1。

8453
05:55:37,520 --> 05:55:44,400
然后 K 太长了，所以它会……

8454
05:55:40,280 --> 05:55:46,878
呃，是 1 乘以 2，这将得出

8455
05:55:44,400 --> 05:55:49,958
这个索引，所以，呃，就像索引处的数组

8456
05:55:46,878 --> 05:55:53,040
二，就是这样，所以就像是 0、1，然后是二，并且

8457
05:55:49,958 --> 05:55:54,958
那么从那开始的偏移量将会是

8458
05:55:53,040 --> 05:55:57,920
那个那个那个将要用到的列索引

8459
05:55:54,958 --> 05:56:00,000
是一个，所以会是，呃，2 加 1 并且

8460
05:55:57,920 --> 05:56:01,400
它将为我们提供索引为 3 的数组

8461
05:56:00,000 --> 05:56:04,000
所以这就是我所说的那种意思

8462
05:56:01,400 --> 05:56:05,680
步幅，这就好像你要怎样怎样去走

8463
05:56:04,000 --> 05:56:08,280
就像跳过一整排，那是

8464
05:56:05,680 --> 05:56:11,200
有点是我在那儿想表达的意思，但要深入探讨……

（这里“going into”后面内容缺失，译文结合语境补充了“深入探讨”，以让表达更自然，若有完整原文可按需调整） 

8465
05:56:08,280 --> 05:56:13,080
这个，呃，全局内存卡内核滚动

8466
05:56:11,200 --> 05:56:15,520
向下；下方；倒下；下降；往下

注：“down”有多种词性和释义，需结合具体语境确定准确含义。这里提供常见释义供参考。若有上下文，可补充后我为你精准翻译。 

8467
05:56:13,080 --> 05:56:17,200
呃，我只是打算……我有点

8468
05:56:15,520 --> 05:56:20,718
打算跳过这部分，然后呢，然后…… 

8469
05:56:17,200 --> 05:56:22,760
只是给你详细说明一下，但整个…… 

8470
05:56:20,718 --> 05:56:26,120
这里的想法，而这是关键所在

8471
05:56:22,760 --> 05:56:28,160
概念，所以矩阵的内存布局就像我（这里句子似乎不完整）

8472
05:56:26,120 --> 05:56:29,878
只是突出显示了，它将会是它的

8473
05:56:28,160 --> 05:56:30,840
会像这样形成连续的记忆

8474
05:56:29,878 --> 05:56:33,760
打算做什么；将要去……（原句表述有误，正确形式可能是“What's going to... ” ） 

8475
05:56:30,840 --> 05:56:34,920
不管怎样，它会那样布置。 

8476
05:56:33,760 --> 05:56:36,798
嗯，而且这不会是

8477
05:56:34,920 --> 05:56:39,400
连续记忆，对吧

8478
05:56:36,798 --> 05:56:42,638
所以当我们真的对这个进行相乘运算时，并且

8479
05:56:39,400 --> 05:56:43,958
这将进入到第三个，呃

8480
05:56:42,638 --> 05:56:45,558
第三排，然后这将通向……

8481
05:56:43,958 --> 05:56:48,400
第三列，然后我们得到这个数值，对吧

8482
05:56:45,558 --> 05:56:51,040
这是一个连贯的……这不在……里面（原英文文本似乎不完整或表述不太清晰） 

8483
05:56:48,400 --> 05:56:53,920
天真的内核，我们会经历这些，并且

8484
05:56:51,040 --> 05:56:56,040
我们进行迭代，呃，我们进行迭代

8485
05:56:53,920 --> 05:56:57,160
那么我们从这个类似B列的地方开始，并且

8486
05:56:56,040 --> 05:57:01,440
然后我们

8487
05:56:57,160 --> 05:57:01,440
走，然后我们接着去下一个地方

8488
05:57:02,280 --> 05:57:07,718
好的，我们以那种方式进行索引。

8489
05:57:06,200 --> 05:57:10,000
我们通过数组在那方面推进

8490
05:57:07,718 --> 05:57:12,840
时尚以及我们最终所拥有的…… 

8491
05:57:10,000 --> 05:57:14,878
输出是我们得到这个，就像我们得到这个一样

8492
05:57:12,840 --> 05:57:16,040
一堆积木，对吧，还有这个，以及这个

8493
05:57:14,878 --> 05:57:17,920
这就是我们写信时的样子吗（由于原句表意不太完整通顺，翻译可能存在一定局限性） 

8494
05:57:16,040 --> 05:57:21,400
输出将会是一摞……

8495
05:57:17,920 --> 05:57:24,080
块，因为我们像这样竖着写，嗯，写成 

8496
05:57:21,400 --> 05:57:28,000
随着行列向前推进，这就是我们所…… （原句似乎不完整） 

8497
05:57:24,080 --> 05:57:30,718
然而要确定优先级，如果我们呃

8498
05:57:28,000 --> 05:57:34,080
相反，访问内存（这里“cess”可能是“access”的拼写错误 ）

8499
05:57:30,718 --> 05:57:37,878
通道 呃 我们能获取 我们能获取这些

8500
05:57:34,080 --> 05:57:40,160
以这种方式布置，所以从本质上来说

8501
05:57:37,878 --> 05:57:43,600
我们正在做的是，我们正在改变

8502
05:57:40,160 --> 05:57:46,240
这里的索引方案 嗯 所有这些

8503
05:57:43,600 --> 05:57:48,558
本质上保持不变，除了我们

8504
05:57:46,240 --> 05:57:51,120
改变对其进行索引的方式以及

8505
05:57:48,558 --> 05:57:53,958
我们确保我们正在使用线程索引

8506
05:57:51,120 --> 05:57:56,760
对，那么还记得我们……当我……的时候吗

8507
05:57:53,958 --> 05:57:59,718
我之前在说关于怎么，呃

8508
05:57:56,760 --> 05:58:03,080
所有的，基本上所有的，所有的

8509
05:57:59,718 --> 05:58:05,320
这个“X”就像线程索引组件一样

8510
05:58:03,080 --> 05:58:07,680
那些在一个弯曲中被组合在一起，所以

8511
05:58:05,320 --> 05:58:10,400
如果你有，例如块大小

8512
05:58:07,680 --> 05:58:13,840
32 嗯，将会有 32 个线程进入

8513
05:58:10,400 --> 05:58:16,320
一个翘曲，那是最大值，所以在……

8514
05:58:13,840 --> 05:58:19,478
如果你有这种类似的，就像一块块的那种 

8515
05:58:16,320 --> 05:58:22,320
这个，这个方形街区，它大概是32乘以（此处原文未完整给出相乘的另一个数值） 

8516
05:58:19,478 --> 05:58:23,718
32 然后你就得到了 X 维度，你是

8517
05:58:22,320 --> 05:58:25,440
要获取最大数量的

8518
05:58:23,718 --> 05:58:27,040
如果每个元素，单个线程束中的线程

8519
05:58:25,440 --> 05:58:29,920
有专用于不同线程的（资源等，这里原句表意不太完整，需结合上下文明确具体所指）

8520
05:58:27,040 --> 05:58:33,040
对，所以这样一来你就在实现最大化了。

8521
05:58:29,920 --> 05:58:35,080
内存访问，因为你可以放置

8522
05:58:33,040 --> 05:58:37,120
把所有这些放在一起，你就可以制作出

8523
05:58:35,080 --> 05:58:39,520
那个负载，呃，你可以生成那个数据

8524
05:58:37,120 --> 05:58:41,520
使传输操作更加高效

8525
05:58:39,520 --> 05:58:44,080
当你让一整群（或一整片、一批，需结合具体语境确定“warp”含义）来处理时 

8526
05:58:41,520 --> 05:58:45,958
它 它可以一次性处理所有的值，或者

8527
05:58:44,080 --> 05:58:48,798
或者，将它们归为一组并让它们……（这里原句似乎不完整） 

8528
05:58:45,958 --> 05:58:51,680
相比走着去要快得多

8529
05:58:48,798 --> 05:58:54,558
通过每一个个体，呃，每一个

8530
05:58:51,680 --> 05:58:58,080
单个的，呃，就像 y 分量，对吧，所以

8531
05:58:54,558 --> 05:59:00,360
当它像线程索引（thread idx）那样运行时，它是…… 

8532
05:58:58,080 --> 05:59:03,440
实际上，它其实并没有那么高效。

8533
05:59:00,360 --> 05:59:06,240
对，嗯，所以我们有点像刚……张（这里“Chang”可能是人名，但信息不足难以准确处理） 

8534
05:59:03,440 --> 05:59:08,160
这里的索引方案与这些一起到……（此句原文似乎不完整）

8535
05:59:06,240 --> 05:59:10,878
在某种程度上说明我之前提到的观点

8536
05:59:08,160 --> 05:59:12,920
写了一个小表格，呃，类似于……是什么来着

8537
05:59:10,878 --> 05:59:14,558
在这里的括号里，所以这个……的除法

8538
05:59:12,920 --> 05:59:17,520
线程索引和块大小，然后是

8539
05:59:14,558 --> 05:59:19,520
……的模，或者说……的绝对值，嗯，所以我

8540
05:59:17,520 --> 05:59:20,760
只是在这里大致列了一个关于什么的表格

8541
05:59:19,520 --> 05:59:23,240
这些实际上看起来会像在……里的样子

8542
05:59:20,760 --> 05:59:24,718
实用性，所以如果我们只是假设一个区块

8543
05:59:23,240 --> 05:59:26,718
大小是四，这意味着它不在这个里面。

8544
05:59:24,718 --> 05:59:28,320
这种情况，但我们可以直接简化然后

8545
05:59:26,718 --> 05:59:29,558
明白正在发生什么，这样我

8546
05:59:28,320 --> 05:59:32,440
不必像写一大堆那样去写

8547
05:59:29,558 --> 05:59:34,360
数字，呃，我们假设块大小为四。

8548
05:59:32,440 --> 05:59:36,240
所以，因为“因为”模块 

8549
05:59:34,360 --> 05:59:39,920
尺寸，即个体的尺寸

8550
05:59:36,240 --> 05:59:42,280
块编号是四，这意味着线程索引

8551
05:59:39,920 --> 05:59:44,280
里面将会有四个指标呃

8552
05:59:42,280 --> 05:59:46,400
所以它将是线程索引 Z 并且

8553
05:59:44,280 --> 05:59:49,360
然后 一 二 三 它将

8554
05:59:46,400 --> 05:59:51,638
里面有四个，对吧，所以当我们

8555
05:59:49,360 --> 05:59:53,520
分割 我们要向下取整到……（这里原文“floor the”后面内容缺失，翻译可能不够完整准确） 

8556
05:59:51,638 --> 05:59:54,798
手术 呃 那那正是……的情况

8557
05:59:53,520 --> 05:59:56,798
自然而然会发生的就是这个是

8558
05:59:54,798 --> 05:59:58,440
要被击倒了 它要……它要

8559
05:59:56,798 --> 06:00:00,680
打算把它的结尾部分截掉，因为

8560
05:59:58,440 --> 06:00:06,080
我们正在学习整数。

8561
06:00:00,680 --> 06:00:09,200
进行除法运算，然后我们会得到 0 0 0 0

8562
06:00:06,080 --> 06:00:11,320
对，四分之三是 75%，它会进行截断处理 

8563
06:00:09,200 --> 06:00:14,160
75 了，可你依然一无所有

8564
06:00:11,320 --> 06:00:16,878
嗯，然后我们跳到像这样的时候

8565
06:00:14,160 --> 06:00:18,798
进展，那么接下来会是，呃，好吧

8566
06:00:16,878 --> 06:00:21,200
块大小为 4，当索引（idx）……（原句不完整）

8567
06:00:18,798 --> 06:00:23,600
跳到1，然后它将会……它会

8568
06:00:21,200 --> 06:00:26,160
将会是 1 乘以 4 得 4，然后

8569
06:00:23,600 --> 06:00:28,600
再加上 Z，然后把它包起来，就有点像这样

8570
06:00:26,160 --> 06:00:30,400
重置正确，只不过它要加一，所以我们

8571
06:00:28,600 --> 06:00:33,840
有那件事在进行着，然后我们有…… 

8572
06:00:30,400 --> 06:00:36,478
模也是，所以模是，呃，你

8573
06:00:33,840 --> 06:00:38,040
进行除法运算，那么 0 除以 4

8574
06:00:36,478 --> 06:00:41,520
嗯，比如整数，然后……接下来是什么呢 

8575
06:00:38,040 --> 06:00:42,760
那剩下的部分，所以如果我们计算 1 除以 4，嗯

8576
06:00:41,520 --> 06:00:44,160
实际上，那并不等于一个整数。

8577
06:00:42,760 --> 06:00:45,718
数字，这样你最终会得到一个余数为

8578
06:00:44,160 --> 06:00:49,200
一次，然后你对剩下的部分都这么做

8579
06:00:45,718 --> 06:00:51,558
它们，所以就像3对4取模或者三个模…… （注：原文表述不太符合常规英文表达逻辑，翻译可能存在一定理解困难） 

8580
06:00:49,200 --> 06:00:53,320
四等于三，然后是四除以四的余数

8581
06:00:51,558 --> 06:00:54,798
因为它刚好等于一，所以没有…… 

8582
06:00:53,320 --> 06:00:56,320
剩下的余数，结果刚好是零

8583
06:00:54,798 --> 06:01:02,200
没错，然后你就会遇到这样的情况，即它是……

8584
06:00:56,320 --> 06:01:06,680
像 0 0 呃 0 0000 0 1111 一，然后

8585
06:01:02,200 --> 06:01:11,200
在这里就像 0 1 2 3 0 1 2 3，对吧，所以

8586
06:01:06,680 --> 06:01:14,760
当我们实际来看这个例子的时候

8587
06:01:11,200 --> 06:01:17,440
在这里面

8588
06:01:14,760 --> 06:01:21,958
它在哪里？不，不是这个，在里面。

8589
06:01:17,440 --> 06:01:23,958
关于科尔斯核，嗯，注意看在……里我是如何……

8590
06:01:21,958 --> 06:01:27,080
马上给你们展示一下我们代码里的一处内容

8591
06:01:23,958 --> 06:01:29,240
这一行实际上是如何没有变化的

8592
06:01:27,080 --> 06:01:31,878
而我们正在做的就是，我们只是

8593
06:01:29,240 --> 06:01:33,600
非常仔细地对这些值进行索引，所以

8594
06:01:31,878 --> 06:01:35,320
当我们……当我们有所不同时

8595
06:01:33,600 --> 06:01:37,760
那些因为各自……而相似的线程（这里原英文文本表意不太完整） 

8596
06:01:35,320 --> 06:01:41,400
线程将计算它自己的呃

8597
06:01:37,760 --> 06:01:43,360
点积，对，嗯，就像这条线索

8598
06:01:41,400 --> 06:01:46,080
并且这根线彼此相邻

8599
06:01:43,360 --> 06:01:48,478
在他们即将接入的同一曲速中

8600
06:01:46,080 --> 06:01:50,120
嗯，相邻值，所以当它们是……

8601
06:01:48,478 --> 06:01:52,040
访问同一（内容）中的相邻值

8602
06:01:50,120 --> 06:01:54,878
实际上，你可以把所有这些归为一组


8603
06:01:52,040 --> 06:01:56,760
一起 然而 相反 如果你只是 呃

8604
06:01:54,878 --> 06:01:58,400
如果你做了这个帖子，那这个（事情）也做了吗 

8605
06:01:56,760 --> 06:02:00,440
然后这根线
然后这根线

8606
06:01:58,400 --> 06:02:03,558
这意味着所有的第一个索引

8607
06:02:00,440 --> 06:02:05,520
那些，呃，所有那些线索，嗯，你，你

8608
06:02:03,558 --> 06:02:07,798
你实际上不能
你实际上不能

8609
06:02:05,520 --> 06:02:08,920
酷，那是因为你得像做一个……

8610
06:02:07,798 --> 06:02:12,440
大步走，而且他们不是，他们不是

8611
06:02:08,920 --> 06:02:14,040
相邻的，对，所以本质上就是这样

8612
06:02:12,440 --> 06:02:15,760
我们在这里所做的事情，嗯，然后我们就结束了。

8613
06:02:14,040 --> 06:02:17,638
忍受这个，就像不采用堆叠的方式那样 

8614
06:02:15,760 --> 06:02:21,040
就像积木一样，我们最终得到了这个，带着（此处“with”单独存在表意不太明确，需结合上下文理解）

8615
06:02:17,638 --> 06:02:23,600
这种水平布局，嗯，所以当我们继续的时候

8616
06:02:21,040 --> 06:02:25,958
在这里我们可以看到 C 行，所以这是

8617
06:02:23,600 --> 06:02:28,478
实际上只会改变每一个

8618
06:02:25,958 --> 06:02:30,320
呃，每次我们向前推进的时候，对吧，所以

8619
06:02:28,478 --> 06:02:32,440
这将保持为零，而（这里“which”后应该还有内容，原句不完整） 

8620
06:02:30,320 --> 06:02:34,760
意味着第 c 行将保持在……

8621
06:02:32,440 --> 06:02:36,478
零，然后是虚数部分的正 i，那就是……

8622
06:02:34,760 --> 06:02:40,600
带着这个点向前推进

8623
06:02:36,478 --> 06:02:42,040
产品本身，嗯，然后这里的“我”是

8624
06:02:40,600 --> 06:02:44,558
会自动推进，以便

8625
06:02:42,040 --> 06:02:47,280
意味着它要，呃，它要……它要…… 

8626
06:02:44,558 --> 06:02:49,000
每次推进一列，而（此处“while the”后面内容缺失，翻译仅供参考目前已有内容）

8627
06:02:47,280 --> 06:02:52,680
行将保持在同一位置

8628
06:02:49,000 --> 06:02:53,760
因为 c 行始终为零，对吧

8629
06:02:52,680 --> 06:02:56,400
这样你大概就能明白这是怎么回事了。

需要说明的是，你提供的英文句子不完整，但不影响大致意思的翻译。如果还有后续内容，可以继续提供给我进行翻译。 

8630
06:02:53,760 --> 06:02:58,520
结果是我们有……我们有C列或者……或者

8631
06:02:56,400 --> 06:03:00,280
或者当前列，而这实际上是

8632
06:02:58,520 --> 06:03:02,600
打算换一下线，这样它就会

（这里“it's”后面内容缺失，翻译结合已有内容尽量通顺表达，若有完整内容可进一步优化） 

8633
06:03:00,280 --> 06:03:04,638
要归零了
它会从 0 开始，然后到 1、2

8634
06:03:02,600 --> 06:03:07,040
3 4 然后它将跳到……

8635
06:03:04,638 --> 06:03:09,558
下一个街区
街区的想法
没错
那又怎样

8636
06:03:07,040 --> 06:03:14,558
你最终得到的实际上就是我刚才所说的

8637
06:03:09,558 --> 06:03:16,920
证明了 嗯 你最终会以……结尾

8638
06:03:14,558 --> 06:03:18,920
本质上，其中的每一个线程

8639
06:03:16,920 --> 06:03:21,120
warp 正在访问一个相邻的值

8640
06:03:18,920 --> 06:03:24,320
所以你可以把那些归为一类，还有……（原文“and cess”可能有误，猜测可能是输入不完整或拼写错误）

8641
06:03:21,120 --> 06:03:26,080
或者将这些记忆碎片组合在一起，并且

8642
06:03:24,320 --> 06:03:28,240
我们通过……获得更高的性能效率

（注：原文句子不完整，“with”后面应该还有内容，若你能补充完整，我可以给出更准确的翻译。） 

8643
06:03:26,080 --> 06:03:30,920
所以这有点像这个东西的样子。 

8644
06:03:28,240 --> 06:03:32,360
这部分所讨论的文章

8645
06:03:30,920 --> 06:03:35,920
嗯，并且如果

8646
06:03:32,360 --> 06:03:39,680
如果我们折回，折回到这里，并且

8647
06:03:35,920 --> 06:03:42,760
实际上运行这个，所以内核编号

8648
06:03:39,680 --> 06:03:46,280
二，我们可以看到，嗯，实际上我们正在得到

8649
06:03:42,760 --> 06:03:50,240
这个的吉咖浮点运算次数要高得多

8650
06:03:46,280 --> 06:03:53,200
一个，呃，然后我们可以看到我们得到了

8651
06:03:50,240 --> 06:03:55,240
这里大约有 1183 吉次浮点运算每秒，所以那就是

8652
06:03:53,200 --> 06:03:57,878
实际上有相当大的增长……（此处“of”后面内容缺失，译文在语义上不够完整） 

8653
06:03:55,240 --> 06:04:01,160
性能 我认为之前它是在……

8654
06:03:57,878 --> 06:04:03,280
当时大概是10点了，呃，那是什么情况来着？

8655
06:04:01,160 --> 06:04:05,920
比如180或者其他类似的数字之类的 

8656
06:04:03,280 --> 06:04:07,520
大概160（这个数字）我记不清了，但当时是……

8657
06:04:05,920 --> 06:04:09,558
非常低，所以实际上这就像

8658
06:04:07,520 --> 06:04:12,080
值得注意的是，它差不多是原来的10倍。 

8659
06:04:09,558 --> 06:04:14,718
更高，这可能是高 5 倍、8 倍、10 倍

8660
06:04:12,080 --> 06:04:16,920
比我们之前在496上所拥有的（情况）要好 

8661
06:04:14,718 --> 06:04:18,638
方阵，没错，所以那实际上是一个

8662
06:04:16,920 --> 06:04:23,920
疯狂的性能提升，我们当时（此处原句似乎不完整）

8663
06:04:18,638 --> 06:04:26,120
之前大约是每秒83……呃，每…… 

8664
06:04:23,920 --> 06:04:30,000
每；每一

8665
06:04:26,120 --> 06:04:32,600
嗯，每次运行，现在到这一点了

8666
06:04:30,000 --> 06:04:38,280
关于第二点，所以如果你，如果你实际上

8667
06:04:32,600 --> 06:04:40,120
算一下啊，呃，83除以，呃，12

8668
06:04:38,280 --> 06:04:42,760
这大约是在……方面增长了 7 倍

8669
06:04:40,120 --> 06:04:47,680
吞吐量方面的性能，所以，呃，那就是……

8670
06:04:42,760 --> 06:04:50,320
那相当不错，嗯，现在我们可以，呃，现在

8671
06:04:47,680 --> 06:04:52,440
我们可以接着讨论共享内存缓存。

8672
06:04:50,320 --> 06:04:55,160
阻塞，这引入了一种不同的

8673
06:04:52,440 --> 06:04:57,240
这个概念仍然使用我们目前所拥有的东西

8674
06:04:55,160 --> 06:04:59,280
完成了，但又引入了全然不同的（情况/事物等，需结合上下文确定准确语义） 

8675
06:04:57,240 --> 06:05:01,400
这种范式真的会有很大帮助。 

8676
06:04:59,280 --> 06:05:03,080
加速并加快事情的进展，所以接下来

8677
06:05:01,400 --> 06:05:05,878
我们投身于一种叫做共享的事物中

8678
06:05:03,080 --> 06:05:07,400
内存或者静态随机存取存储器（SRAM），这绝对是……

8679
06:05:05,878 --> 06:05:10,478
当我们……的时候，照顾好……至关重要

8680
06:05:07,400 --> 06:05:12,680
优化算法以提高性能，所以

8681
06:05:10,478 --> 06:05:18,240
让我大致解释一下那个……

8682
06:05:12,680 --> 06:05:22,160
处理这个问题，所以现在我们正在使用

8683
06:05:18,240 --> 06:05:25,200
呃，全局内存，对吧，呃，主机

8684
06:05:22,160 --> 06:05:26,798
只是我们的小内存插槽，呃，将要……

8685
06:05:25,200 --> 06:05:28,680
CPU，而且它真的很慢

8686
06:05:26,798 --> 06:05:33,200
那大约是每秒5吉字节。

8687
06:05:28,680 --> 06:05:35,798
仍然很快，但与嗯……相比非常慢。

8688
06:05:33,200 --> 06:05:39,320
我们所获得的每秒 200GB 的（数据传输速度等，需结合上下文确定具体所指） 

8689
06:05:35,798 --> 06:05:41,360
我们的显存，这就是我们现在正在使用的，或者

8690
06:05:39,320 --> 06:05:43,920
你可以变得更快，并且使用共享的（资源等，需结合上下文确定“shared”具体所指） 

8691
06:05:41,360 --> 06:05:46,558
每（此处“per”后内容缺失）约 1.5 TB 的内存

8692
06:05:43,920 --> 06:05:48,200
每秒的内存带宽或寄存器（此处原英文可能表述有误，推测“second”可能是“second per”这种意思的省略，但严格来说原句不完整且表意不太准确） 

8693
06:05:46,558 --> 06:05:49,840
即每秒约 8 太字节的

8694
06:05:48,200 --> 06:05:52,400
内存带宽，我们接下来就要探讨……（这里原文不完整，“we're just going to”后面应该还有内容，但从已有的部分只能推测大概是要做和内存带宽相关的事） 

8695
06:05:49,840 --> 06:05:53,718
现在专注于寄存器，或者，抱歉

8696
06:05:52,400 --> 06:05:59,478
共享内存权限

8697
06:05:53,718 --> 06:06:01,840
现在，嗯，在这篇博客文章里，他有，呃

8698
06:05:59,478 --> 06:06:03,718
约700吉字节的手套内存带宽

注：这里“glove”可能是“global”之类的拼写错误，因为“glove”常见意思是“手套”，“global”在一些科技语境中会用于相关专业概念，比如“global memory”（全局内存），若有上下文可进一步准确判断。 

8699
06:06:01,840 --> 06:06:06,160
与这个相比，那真的很快。

8700
06:06:03,718 --> 06:06:08,798
然后呢，呃

8701
06:06:06,160 --> 06:06:11,040
12太字节的 或 12.1太字节的

8702
06:06:08,798 --> 06:06:14,320
共享内存带宽

8703
06:06:11,040 --> 06:06:18,280
所以，呃，或者抱歉，不是 12 太字节，是 1 点（这里“1 Point”表述不太明确，可能需结合具体语境确定准确含义 ） 

8704
06:06:14,320 --> 06:06:19,958
1 点 1.2 太字节内存带宽

8705
06:06:18,280 --> 06:06:21,680
嗯，每……太字节

8706
06:06:19,958 --> 06:06:24,160
第二；秒

8707
06:06:21,680 --> 06:06:26,878
现在我们如何利用这一点呢？如何……

8708
06:06:24,160 --> 06:06:29,478
实际上我们很好地利用了共享内存，它是

8709
06:06:26,878 --> 06:06:33,958
实际上很容易

8710
06:06:29,478 --> 06:06:36,478
嗯，你用了这个叫“呃”的小关键词。

8711
06:06:33,958 --> 06:06:39,840
它不在这里，但是

8712
06:06:36,478 --> 06:06:42,840
我有，它叫，呃，共享的，所以

8713
06:06:39,840 --> 06:06:45,160
共享内存实际上就是你……的方式

（原句似乎不完整，翻译可能不太准确表达完整意思） 

8714
06:06:42,840 --> 06:06:47,760
使用那个小的一级（L1）缓存

8715
06:06:45,160 --> 06:06:50,680
所以当我们仰望实际的…… 

8716
06:06:47,760 --> 06:06:54,638
这个的架构，嗯，我可以打开

8717
06:06:50,680 --> 06:06:56,718
图片和新标签页，这样你就有你的…… 

8718
06:06:54,638 --> 06:06:58,400
全局内存，就像那一大块（内存）

8719
06:06:56,718 --> 06:07:01,240
你所拥有的记忆，大概有两段 

8720
06:06:58,400 --> 06:07:03,400
每秒200吉比特，然后是二级缓存（L2） 

8721
06:07:01,240 --> 06:07:06,320
缓存作为一种类似传输介质，并且

8722
06:07:03,400 --> 06:07:09,400
然后每个小型社交媒体账号或流媒体平台 

8723
06:07:06,320 --> 06:07:12,558
多处理器 嗯，这些有它们自己的

8724
06:07:09,400 --> 06:07:14,478
小的一级缓存或共享内存以及

8725
06:07:12,558 --> 06:07:16,600
与这两个相比，这个非常小。

8726
06:07:14,478 --> 06:07:18,840
对，嗯，但是它们速度极快，而且

8727
06:07:16,600 --> 06:07:20,520
它们直接与收银机相连，并且

8728
06:07:18,840 --> 06:07:23,520
以及你身上的核心（由于原文表意不太清晰，此翻译仅供参考）

8729
06:07:20,520 --> 06:07:25,080
GPU 所以当我们能够利用这些时，会有…… 

8730
06:07:23,520 --> 06:07:26,840
实际上你（的）出行距离要少得多

8731
06:07:25,080 --> 06:07:28,638
不得不走了，所以别像每次那样

8732
06:07:26,840 --> 06:07:32,718
你需要访问一个浮点数，你全力以赴

8733
06:07:28,638 --> 06:07:34,958
通过……嗯，比如 S&M（施虐与受虐）或者共享的方式

8734
06:07:32,718 --> 06:07:37,240
然后到 L2，接着到全球，你

8735
06:07:34,958 --> 06:07:39,520
实际上就是呃存放一堆……

8736
06:07:37,240 --> 06:07:41,920
将他们暂时放在 s 里以及共享中

8737
06:07:39,520 --> 06:07:45,000
记忆 让所有的思绪都利用它们

8738
06:07:41,920 --> 06:07:47,558
实际上做了大量的……（这里“for like like”表述不太准确，整体语义可能不太完整清晰）

8739
06:07:45,000 --> 06:07:49,638
利用它所拥有的记忆，并且

8740
06:07:47,558 --> 06:07:52,920
那么，一旦你完成了那件事，你

8741
06:07:49,638 --> 06:07:56,400
可以替换它 呃 你可以 你可以写

8742
06:07:52,920 --> 06:07:58,000
来自全局的新值，所以，而不是呃

8743
06:07:56,400 --> 06:08:01,920
每次你需要的时候，都从环球公司写信来 

8744
06:07:58,000 --> 06:08:03,718
要访问某个东西，你反而要加载一个

8745
06:08:01,920 --> 06:08:05,878
你预先加载了一堆到……

8746
06:08:03,718 --> 06:08:08,280
共享内存，然后你可以将它们用于

8747
06:08:05,878 --> 06:08:09,798
一堆工作，然后你，然后你

8748
06:08:08,280 --> 06:08:11,040
一旦你……就用一个新的替换它们

8749
06:08:09,798 --> 06:08:14,760
前进；进展；提前；预付；使提前发生；促进
进步；前进；预付款；增长
预先的；先行的

8750
06:08:11,040 --> 06:08:17,718
没错，这里的目标大致就是

8751
06:08:14,760 --> 06:08:20,718
确保我们能正确地完成这件事，所以

8752
06:08:17,718 --> 06:08:20,718
如果我就这么出去

8753
06:08:21,558 --> 06:08:26,120
再次说明，共享内存位于芯片上。

8754
06:08:24,200 --> 06:08:30,200
更低的延迟
更高的内存 

8755
06:08:26,120 --> 06:08:32,400
带宽，嗯，在支持电压的图形处理器（GPU）上留意这个

8756
06:08:30,200 --> 06:08:33,840
那么来详细说说我们究竟会如何使用

8757
06:08:32,400 --> 06:08:35,558
共享内存，实际上有点像…… 

8758
06:08:33,840 --> 06:08:37,240
不同的理念
现在我并非……并非（此处英文表述似乎不完整） 

8759
06:08:35,558 --> 06:08:39,798
打算，比如说，把这个写出来，然后

8760
06:08:37,240 --> 06:08:42,600
一切，因为情况可能会变得相当……

8761
06:08:39,798 --> 06:08:44,920
呃，当我们……的时候，情况可能会变得相当紧张。 

8762
06:08:42,600 --> 06:08:46,920
把东西写出来

8763
06:08:44,920 --> 06:08:48,600
但这本质上就是我们正在做的事情

8764
06:08:46,920 --> 06:08:50,958
我们正在做一件叫做铺瓷砖的小事。

8765
06:08:48,600 --> 06:08:54,240
这是我之前演示过的，当时你……（由于文本不完整，这样的翻译只是尽量贴合其可能的语义） 

8766
06:08:50,958 --> 06:08:56,478
有呃那种用来做矩阵的小方块

8767
06:08:54,240 --> 06:08:58,120
在一个更大的矩阵中进行乘法运算

8768
06:08:56,478 --> 06:09:00,840
相乘；使相乘；大量增加；繁殖；增殖

8769
06:08:58,120 --> 06:09:04,558
所以，与其做……与其做……

8770
06:09:00,840 --> 06:09:06,040
行和列，我们实际上会去做的

8771
06:09:04,558 --> 06:09:08,400
一些有点不同的东西，相反地

8772
06:09:06,040 --> 06:09:10,878
那是什么呢，就是说我们有这个这个

8773
06:09:08,400 --> 06:09:13,360
这里是C语言中的数据块，那么你……

8774
06:09:10,878 --> 06:09:14,958
你实际上会想要做的是

8775
06:09:13,360 --> 06:09:17,878
如果你有

8776
06:09:14,958 --> 06:09:21,478
嗯，说

8777
06:09:17,878 --> 06:09:25,440
a 让我试着用一下当前的 VS Code

8778
06:09:21,478 --> 06:09:29,080
以某个事物为例，所以我们有这个，呃

8779
06:09:25,440 --> 06:09:31,360
我们现在有一台……我们现在有一台空调正在运行

8780
06:09:29,080 --> 06:09:31,360
回来；回去；向后；在后面；以前；回到（原处）；恢复到（先前状态）；追溯到；回忆起；后面的；背后的；过去的；过期的；拖欠的；支持；资助；援助；备份
注：“back”含义丰富，具体含义需结合上下文确定。这里仅将其常见释义列出。如果有具体语境，请提供以便给出更准确翻译。 

8781
06:09:31,520 --> 06:09:36,000
回到这一个，我打算

8782
06:09:33,958 --> 06:09:39,120
尝试解释一下，这必须要解释吗？

8783
06:09:36,000 --> 06:09:41,520
所以请耐心听我说，嗯，我们实际上

8784
06:09:39,120 --> 06:09:43,520
即将加载图块，而且我们有这个

8785
06:09:41,520 --> 06:09:44,600
小C喜欢这里的坐标，并且

8786
06:09:43,520 --> 06:09:48,520
我们要做的只是

（不过原文“we're just”之后似乎还有内容未完整呈现） 

8787
06:09:44,600 --> 06:09:50,718
打算把这两个相乘，相乘，嗯

8788
06:09:48,520 --> 06:09:52,840
放在一起，然后将这两个相乘

8789
06:09:50,718 --> 06:09:54,400
把这两个数相乘在一起

8790
06:09:52,840 --> 06:09:58,040
然后基本上我们就只是

8791
06:09:54,400 --> 06:10:01,240
将每个矩阵相乘，嗯，然后那个

8792
06:09:58,040 --> 06:10:04,440
那，那类似的情况与呃，这个相匹配。 

8793
06:10:01,240 --> 06:10:06,360
这是最后一件事了，那么我们开始，我们开始

8794
06:10:04,440 --> 06:10:08,440
就像通过这种方式，而且我们有点……

8795
06:10:06,360 --> 06:10:12,400
我们从非常……就像……非常……开始

8796
06:10:08,440 --> 06:10:14,478
B的顶部以及A的最左侧和

8797
06:10:12,400 --> 06:10:16,958
我们把那些相乘，然后我们

8798
06:10:14,478 --> 06:10:18,760
把它加到我们接下来要做的那些里面去

8799
06:10:16,958 --> 06:10:20,878
然后接着接着接着，直到我们可能……

8800
06:10:18,760 --> 06:10:24,080
画个十字之类的，然后就那样

8801
06:10:20,878 --> 06:10:27,680
交点

8802
06:10:24,080 --> 06:10:30,200
嗯，就是这里的那个交点

8803
06:10:27,680 --> 06:10:32,478
那就是 C 正确的地方，所以当……当……

8804
06:10:30,200 --> 06:10:34,080
你有一堆这些更小的，嗯

8805
06:10:32,478 --> 06:10:36,000
不太密集的地图痣，那些可以是……

8806
06:10:34,080 --> 06:10:38,000
实际上是在街区完成的

8807
06:10:36,000 --> 06:10:39,920
呃，在线程块方面，实际上它……

8808
06:10:38,000 --> 06:10:42,000
让这份工作轻松了许多，因为什么

8809
06:10:39,920 --> 06:10:43,440
你能做的就是你可以在这件事上表现得明智些。

8810
06:10:42,000 --> 06:10:45,718
并且实际上将这些块存储在

8811
06:10:43,440 --> 06:10:47,440
共享内存，对吧，呃，如果你正在做……

8812
06:10:45,718 --> 06:10:49,440
单个的行或列，我是说，当然可以

8813
06:10:47,440 --> 06:10:51,718
你可以那样做，但实际上它允许

8814
06:10:49,440 --> 06:10:54,760
让我们呃分配一些工作

8815
06:10:51,718 --> 06:10:57,798
当我们使用积木时会更多（情况）

8816
06:10:54,760 --> 06:11:01,558
当我们使用……的实体瓦片时

8817
06:10:57,798 --> 06:11:03,920
矩阵，对，呃，那么让我们接着来

8818
06:11:01,558 --> 06:11:05,440
深入探究这在……之下实际是如何运作的

8819
06:11:03,920 --> 06:11:07,360
你会理解的，伙计（这里“hood”可能有“伙计、朋友”等意思，“ort”单独来看是“残屑、剩菜”等意思，但结合语境不太明确，可能是拼写错误等情况 ，暂只能这样翻译） 

8820
06:11:05,440 --> 06:11:09,320
等我解释过后，你会对瓷砖铺贴的原理有更深入的了解。

注：原英文句子表述不太完整和准确，推测想表达的大概意思如上翻译，你可以根据实际情况进行调整。 

8821
06:11:07,360 --> 06:11:13,520
它以及我如何解释一切

8822
06:11:09,320 --> 06:11:16,440
随着我们更深入地探究细节而取得进展

8823
06:11:13,520 --> 06:11:18,400
但是，呃，这就是这里的想法，我们

8824
06:11:16,440 --> 06:11:19,878
只是我们把这些进行拼接，然后储存起来。

8825
06:11:18,400 --> 06:11:22,200
在共享内存中临时阻塞，并且

8826
06:11:19,878 --> 06:11:25,040
尽可能多地和他们一起工作

8827
06:11:22,200 --> 06:11:28,958
好的，所以这是一个共享的……的代码

8828
06:11:25,040 --> 06:11:32,520
一个共享内存缓存 或者 平铺地图缓存（注：原文“mapal”可能有误，推测可能是“map cache” ）

8829
06:11:28,958 --> 06:11:34,280
你可以这么说，呃，而且差不多有很多

8830
06:11:32,520 --> 06:11:36,478
其中……呃，嗯，其中不多的一部分，但那……

8831
06:11:34,280 --> 06:11:40,120
起始点相当接近或者实际上就是那个

8832
06:11:36,478 --> 06:11:43,680
和我们上次写的 C 完全一样，所以

8833
06:11:40,120 --> 06:11:47,200
我们有这个，呃，c行映射到块索引

8834
06:11:43,680 --> 06:11:52,200
dox c 行映射到块索引 dox 和 C

8835
06:11:47,200 --> 06:11:54,798
C列 伊西（这里“isy”可能有误，推测可能是名字）
现在我们有这个了

8836
06:11:52,200 --> 06:11:58,320
螺纹柱 呃

8837
06:11:54,798 --> 06:12:01,878
呃，“is”映射到取模运算符，然后

8838
06:11:58,320 --> 06:12:05,558
行映射到除法运算符，所以

8839
06:12:01,878 --> 06:12:09,000
行对应于分区，列对应于

8840
06:12:05,558 --> 06:12:12,280
呃，对，所以这些是，这些是

8841
06:12:09,000 --> 06:12:14,240
本质上，我们使用的是同样的……（原文“the the”表述有误，这里按大致意思翻译） 

8842
06:12:12,280 --> 06:12:16,478
和之前一样的想法，然后我们加上这个

8843
06:12:14,240 --> 06:12:18,718
另外一部分，其中将会…… 

8844
06:12:16,478 --> 06:12:20,558
在……里分配呃一些空间

8845
06:12:18,718 --> 06:12:24,160
共享内存，它将是…… 

8846
06:12:20,558 --> 06:12:26,040
尺寸，呃，逐个方块的尺寸，对吧

8847
06:12:24,160 --> 06:12:27,680
所以可以说它就是个巨大的东西

8848
06:12:26,040 --> 06:12:29,520
就像这些小行中的每一行 

8849
06:12:27,680 --> 06:12:32,200
就像缠绕起来，然后你就有了这样的……

8850
06:12:29,520 --> 06:12:33,638
在内存中展开的超长内容，但是

8851
06:12:32,200 --> 06:12:36,798
我们将把它当作一个真正的（事物/情况等，需结合上下文确定）

8852
06:12:33,638 --> 06:12:39,600
像正方形一样的方块，嗯，那么我们为什么要使用

8853
06:12:36,798 --> 06:12:41,080
逐个块的大小来处理是因为，嗯

8854
06:12:39,600 --> 06:12:42,718
如果我们只是说，我的意思是我们打算……

8855
06:12:41,080 --> 06:12:45,080
降低，我们要降低，降低什么，我们……

8856
06:12:42,718 --> 06:12:47,280
将块大小解释为处于……之中（此句英文表意不太完整和清晰） 

8857
06:12:45,080 --> 06:12:49,958
只是为了便于直观理解而举的例子，不过

8858
06:12:47,280 --> 06:12:52,320
实际上这应该是 32，对吧

8859
06:12:49,958 --> 06:12:55,638
块大小将为 32，你有 32

8860
06:12:52,320 --> 06:12:58,440
适合经纱的线以及最大量的线

8861
06:12:55,638 --> 06:13:00,718
1，每个线程块有24个线程，所以如果你

8862
06:12:58,440 --> 06:13:00,718
实际上

8863
06:13:00,958 --> 06:13:08,280
分割 嗯，如果你分割

8864
06:13:04,120 --> 06:13:11,080
1，用24乘以32得到32，那么我们最终得到的是…… 

8865
06:13:08,280 --> 06:13:12,478
正在做的是我们有一个曲速引擎，一个曲速引擎需要…… （注：这里原英文句子不完整） 

8866
06:13:11,080 --> 06:13:14,040
照顾好这些扭曲，照顾好这些

8867
06:13:12,478 --> 06:13:15,320
Warp 会处理这些问题，并且我们有

8868
06:13:14,040 --> 06:13:17,440
就好像我们真的在占据着……

8869
06:13:15,320 --> 06:13:21,920
各地的最大数量 呃 仅仅通过

8870
06:13:17,440 --> 06:13:23,840
使用块大小，呃，或者一个共享的、共享的

8871
06:13:21,920 --> 06:13:26,878
逐个块进行块大小的分配

8872
06:13:23,840 --> 06:13:29,558
尺寸合适，没错，这就是关键所在，嗯

8873
06:13:26,878 --> 06:13:33,920
于是我们下去，而我正要去……

8874
06:13:29,558 --> 06:13:35,878
把这个在这边打开，就为了……

8875
06:13:33,920 --> 06:13:37,840
参考，嗯

8876
06:13:35,878 --> 06:13:41,360
所以在

8877
06:13:37,840 --> 06:13:42,878
a 我们所做的是，呃，我们打算

8878
06:13:41,360 --> 06:13:45,280
将指针推进到起始位置

8879
06:13:42,878 --> 06:13:49,120
位置 没错

8880
06:13:45,280 --> 06:13:53,400
所以从本质上来说，我们打算

8881
06:13:49,120 --> 06:13:57,840
乘以，呃，c行，我们要对c进行操作

8882
06:13:53,400 --> 06:14:02,240
当前行乘以 呃 乘以

8883
06:13:57,840 --> 06:14:04,080
哦，可以将当前行缩小 K 倍。

8884
06:14:02,240 --> 06:14:06,680
好的，那么 K 将是这个维度。

8885
06:14:04,080 --> 06:14:09,478
这儿，这个，这个，这个长的，那个，那个

8886
06:14:06,680 --> 06:14:11,320
把水平的那个分类，所以如果我们

8887
06:14:09,478 --> 06:14:14,840
将当前行乘以 K，我们就这么做

8888
06:14:11,320 --> 06:14:19,160
比如说我们有像当前行这样的东西

8889
06:14:14,840 --> 06:14:21,520
呃，如果我们有当前的一行，如果我们

8890
06:14:19,160 --> 06:14:23,920
想对当前行进行一次向右操作，所以

8891
06:14:21,520 --> 06:14:25,558
我们想计算当前行乘以 K，这（这里原句 which 引导的内容不完整，语义未表达完） 

8892
06:14:23,920 --> 06:14:27,760
是这个长度，所以它要跳了

8893
06:14:25,558 --> 06:14:29,520
到这一个了，然后我们想做……

8894
06:14:27,760 --> 06:14:32,040
时间乘以块大小，在这种情况下

8895
06:14:29,520 --> 06:14:33,680
既然我们把它分割成了一堆小块

8896
06:14:32,040 --> 06:14:35,840
将会是两个，对吧？将会……

8897
06:14:33,680 --> 06:14:37,798
两个两个地；成双成对地 

8898
06:14:35,840 --> 06:14:40,440
呃，所以我们最后反而跳了两步。

8899
06:14:37,798 --> 06:14:41,920
关于那个，所以我们说，嗯，当前行是

8900
06:14:40,440 --> 06:14:45,280
会成为一个（某种事物），所以我们要去做

8901
06:14:41,920 --> 06:14:46,680
这个，就是这边这个，所以它会跳起来

8902
06:14:45,280 --> 06:14:49,040
呃……的长度

8903
06:14:46,680 --> 06:14:51,000
那乘以我们想要处理的数字

8904
06:14:49,040 --> 06:14:52,680
本质上是一个，所以我们不

8905
06:14:51,000 --> 06:14:54,200
往下跳一格，然后就会翻倍

8906
06:14:52,680 --> 06:14:55,958
因为我们的块大小等于 2

8907
06:14:54,200 --> 06:14:57,798
好的，所以它向下移动
呃，两行然后

8908
06:14:55,958 --> 06:15:01,360
然后我们最终正好到达了我们想去的地方

不过原句 “then we end up exactly where we want we” 表述有误，可能正确的表述是 “then we end up exactly where we want to be” 。 

8909
06:14:57,798 --> 06:15:03,440
想从第一个数字开始，嗯，在……上

8910
06:15:01,360 --> 06:15:05,760
第一个，在第一个，呃，比如

8911
06:15:03,440 --> 06:15:09,638
本质上是这一行的瓷砖（这里“tile”常见意思是“瓷砖”，但需结合具体语境看是否有其他更合适的含义）

8912
06:15:05,760 --> 06:15:12,760
对，呃，然后到B，我们推进那个

8913
06:15:09,638 --> 06:15:14,920
指向，呃，当前列的指针乘以

8914
06:15:12,760 --> 06:15:18,120
块大小，所以在这种情况下，假设是 b

8915
06:15:14,920 --> 06:15:23,520
我们希望 B 大概是 2，所以这个

8916
06:15:18,120 --> 06:15:28,320
当前列是，呃，是 2，所以我们处理 2

8917
06:15:23,520 --> 06:15:32,000
* 2 乘以 2 等于 4，所以我们数 0、1、2、3、4，然后

8918
06:15:28,320 --> 06:15:34,280
我们最终到了那里，对吧，非常直观

8919
06:15:32,000 --> 06:15:37,120
呃，然后我们有 C，它本质上

8920
06:15:34,280 --> 06:15:38,680
将……与……结合起来，所以，呃，在这种情况下我们

8921
06:15:37,120 --> 06:15:43,440
想做C，所以它要……它要……

8922
06:15:38,680 --> 06:15:45,000
嗯，会是这一排

8923
06:15:43,440 --> 06:15:48,840
还有这边的这一列，所以我们打算

8924
06:15:45,000 --> 06:15:51,000
最后结果会是，嗯，第一个

8925
06:15:48,840 --> 06:15:53,520
一行，然后，然后是这一列，所以

8926
06:15:51,000 --> 06:15:55,400
会是这块瓷砖，呃，就是我们（提到的）这块

8927
06:15:53,520 --> 06:15:58,680
想要照顾好，所以它将会

8928
06:15:55,400 --> 06:16:00,638
跳 它要跳到呃 这个上面去了

8929
06:15:58,680 --> 06:16:05,080
一个来自

8930
06:16:00,638 --> 06:16:06,840
呃，从那个……叫什么来着，从……

8931
06:16:05,080 --> 06:16:10,160
从矩阵中我们即将跳跃

8932
06:16:06,840 --> 06:16:12,200
一直到……还是什么来着
不不不

8933
06:16:10,160 --> 06:16:14,798
在 B 部分，我们要一直跳下去

8934
06:16:12,200 --> 06:16:17,400
在这里，然后在一个，呃，我们，我们

8935
06:16:14,798 --> 06:16:19,798
基本上只是要加上“我们是”

8936
06:16:17,400 --> 06:16:24,240
接下来要添加偏移量，没错，所以我们想要

8937
06:16:19,798 --> 06:16:26,280
因为这个，我们想直接跳到……（原英文表述不太符合常见语法规则，此翻译尽力贴合原文意思） 

8938
06:16:24,240 --> 06:16:31,240
是末地维度，所以，而不是

8939
06:16:26,280 --> 06:16:31,240
乘以 K，我们会进行（以下操作）

8940
06:16:32,200 --> 06:16:38,160
呃，我们会做……呃，我们会乘以 n，所以

8941
06:16:35,400 --> 06:16:40,638
结果基本上就是这样

8942
06:16:38,160 --> 06:16:43,360
我们本质上是把这个和这个相加，对吧

8943
06:16:40,638 --> 06:16:44,878
除了不用呃不用 K（这里不太明确“K”具体所指，需结合上下文理解） 

8944
06:16:43,360 --> 06:16:46,440
我们用 n 是因为那就是那个（这里原句不完整，表意不太清晰）

8945
06:16:44,878 --> 06:16:49,840
C的长度，没错，所以那就是……

8946
06:16:46,440 --> 06:16:54,000
呃，有个想法，然后我们最后到了呃，我……

8947
06:16:49,840 --> 06:16:57,200
相信就是这个，这个总数是 24、25、34

8948
06:16:54,000 --> 06:16:58,718
35 嗯，所以我们继续往下，然后这个

8949
06:16:57,200 --> 06:17:01,840
这里就是我们定义累加器的地方，对吧

8950
06:16:58,718 --> 06:17:03,840
所以我们有的那个临时累加器，呃

8951
06:17:01,840 --> 06:17:05,680
然后事情就真的变得有趣起来了

8952
06:17:03,840 --> 06:17:07,840
一旦我们，一旦我们进入这个里面为了……

注：原英文句子似乎表述不太完整和准确，以上是按照字面逐词翻译。 

8953
06:17:05,680 --> 06:17:11,120
循环，这就是奇迹发生的地方，嗯

8954
06:17:07,840 --> 06:17:13,160
所以我们有这个术语，呃，块索引（block idx），并且

8955
06:17:11,120 --> 06:17:17,040
我们要对 K 进行迭代，对吧，那么就是 K

8956
06:17:13,160 --> 06:17:18,798
那是 K 吗 那是呃 那一行 那……

8957
06:17:17,040 --> 06:17:21,320
抱歉，“The Columns”的列数

8958
06:17:18,798 --> 06:17:23,000
矩阵 A 的列数和矩阵 B 的行数

8959
06:17:21,320 --> 06:17:25,718
好的，那么我们要推进方块了。

8960
06:17:23,000 --> 06:17:28,360
每次的尺寸 呃 或者 抱歉 要去……

8961
06:17:25,718 --> 06:17:32,360
按块大小推进块索引

8962
06:17:28,360 --> 06:17:35,680
每次，嗯，所以在这里面

8963
06:17:32,360 --> 06:17:37,958
最初我们想存放，呃，那些东西

8964
06:17:35,680 --> 06:17:40,638
在静态随机存取存储器（SRAM）中，或者在共享内存中，所以我们

8965
06:17:37,958 --> 06:17:44,638
想把它真真正正地存放在这里

8966
06:17:40,638 --> 06:17:47,520
我们所做的就是查看那个指数

8967
06:17:44,638 --> 06:17:50,478
在这儿里面，那么线的排，哪一排？

8968
06:17:47,520 --> 06:17:51,840
它是块大小的倍数，那么块大小

8969
06:17:50,478 --> 06:17:53,680
将会是那种步伐或者那种

8970
06:17:51,840 --> 06:17:55,280
包装器，然后加上线程列

8971
06:17:53,680 --> 06:17:56,520
那么我们想要处于哪个偏移量呢

8972
06:17:55,280 --> 06:18:01,760
对，它要挑出某一个

8973
06:17:56,520 --> 06:18:03,760
那儿有个位置，嗯，而且很幸运的是，呃，我

8974
06:18:01,760 --> 06:18:06,680
选择了一个大小为二的块，所以它将会……

8975
06:18:03,760 --> 06:18:08,360
要变成两两一组，而这实际上使得

8976
06:18:06,680 --> 06:18:09,798
我们的工作要容易理解得多

8977
06:18:08,360 --> 06:18:12,520
我的意思是你可以将它抽象成类似这样的东西

8978
06:18:09,798 --> 06:18:14,878
4 个，或者 8 个，甚至 32 个，但我们打算

8979
06:18:12,520 --> 06:18:16,958
目前先采用大小为二的块，并且

8980
06:18:14,878 --> 06:18:19,680
这意味着我们接下来要……嗯

8981
06:18:16,958 --> 06:18:21,680
我们只会有两条线索。（这里原句可能表述有误，更准确的或许是“we're just going to have two threads” ） 

8982
06:18:19,680 --> 06:18:26,200
线程索引 线程

8983
06:18:21,680 --> 06:18:28,920
零和一的索引，对吧，所以非常非常……

8984
06:18:26,200 --> 06:18:31,000
这里有一些基本的线程可以使用，所以……

8985
06:18:28,920 --> 06:18:32,920
实际上，我们只是要加载，呃

8986
06:18:31,000 --> 06:18:35,320
进入这个我们的共享内存中

8987
06:18:32,920 --> 06:18:38,080
在这里定义，呃，而且我们正要去做（继续进行等，需结合上下文准确判断going的含义） 

8988
06:18:35,320 --> 06:18:40,798
基本上就是那个小点儿

8989
06:18:38,080 --> 06:18:43,718
在它里面，我们打算……我们要……

8990
06:18:40,798 --> 06:18:46,680
从A和B中挑选出那个，所以在一个…… 

8991
06:18:43,718 --> 06:18:48,760
这将是线程行数乘以K

8992
06:18:46,680 --> 06:18:51,558
所以 K 将会是那个那个那个

8993
06:18:48,760 --> 06:18:54,878
长度 对

8994
06:18:51,558 --> 06:18:57,600
呃，然后将会是

8995
06:18:54,878 --> 06:19:00,440
呃，还有那个螺纹柱

8996
06:18:57,600 --> 06:19:02,240
向右偏移，所以就只是那个……那个例子

8997
06:19:00,440 --> 06:19:05,760
本质上和什么的想法是一样的



8998
06:19:02,240 --> 06:19:09,200
我们在这里正在做……嗯

8999
06:19:05,760 --> 06:19:13,760
然后我们将拥有，呃，同样的（东西/情况等，需结合语境） 

9000
06:19:09,200 --> 06:19:16,080
关于 B 的想法，B 将会是 n，所以是 n

9001
06:19:13,760 --> 06:19:20,120
那又是 n 是……（这句话不太完整和通顺，可能原文有信息缺失）

9002
06:19:16,080 --> 06:19:22,760
这里的 n 是上面那个，嗯，然后是 K

9003
06:19:20,120 --> 06:19:26,958
这里最上面的这个，所以 K 对应于

9004
06:19:22,760 --> 06:19:28,240
A和N对应于B，对吧，嗯，我希望如此

9005
06:19:26,958 --> 06:19:30,760
那倒有点道理，然后呢

9006
06:19:28,240 --> 06:19:32,520
之后我们只需把所有内容同步一下，所以

9007
06:19:30,760 --> 06:19:34,360
这部分有点奇怪，因为我们

9008
06:19:32,520 --> 06:19:36,478
有点像同步线程，但这个内核

9009
06:19:34,360 --> 06:19:39,200
它本身，就像这里到目前为止的一切事物一样

9010
06:19:36,478 --> 06:19:41,478
现在就像一根线
那么这意味着什么

9011
06:19:39,200 --> 06:19:42,958
是说在整个街区里它正在…… 

9012
06:19:41,478 --> 06:19:44,040
确保所有线程都能捕获

9013
06:19:42,958 --> 06:19:45,440
到目前为止，它会确保

9014
06:19:44,040 --> 06:19:47,360
每一次（这里“every”表意不太明确，可能语境中有指代）它都会设置一道障碍

9015
06:19:45,440 --> 06:19:48,638
并确保所有的线程

9016
06:19:47,360 --> 06:19:51,000
把他们所需要的东西放进去了

9017
06:19:48,638 --> 06:19:53,240
记忆，不然要是我们开始做其他的

9018
06:19:51,000 --> 06:19:55,000
事情，然后你可能会有类似零这样的情况

9019
06:19:53,240 --> 06:19:56,360
那里存在着某种价值，就好像那里有……

9020
06:19:55,000 --> 06:19:58,878
那个地方不存在任何东西

9021
06:19:56,360 --> 06:20:00,240
记忆，而你正用它来做

9022
06:19:58,878 --> 06:20:01,638
操作，这接下来将会使得

9023
06:20:00,240 --> 06:20:03,638
你的答案错了，所以你得重新做。（注：原英文表述不太完整通顺，这里是根据常见语义补充翻译） 

9024
06:20:01,638 --> 06:20:05,600
确保该（此处原文未完整表述“within the”后面的内容）内的所有线程

9025
06:20:03,638 --> 06:20:07,760
街区实际上已经发展到这里了，所以

9026
06:20:05,600 --> 06:20:09,878
就像这些处于线程的层面

9027
06:20:07,760 --> 06:20:11,638
但实际上我们是在告诉CUDA，

9028
06:20:09,878 --> 06:20:12,878
我们想要所有不同的线索。

9029
06:20:11,638 --> 06:20:14,718
那些正在同时进行所有这些（事情）的

9030
06:20:12,878 --> 06:20:16,040
在……范围内进行追赶行动（由于“for”后面内容缺失，翻译可能不太精准） 

9031
06:20:14,718 --> 06:20:18,000
循环，那就是我们所……（这里原句不完整）

9032
06:20:16,040 --> 06:20:23,120
正在做；从事；进行

9033
06:20:18,000 --> 06:20:24,920
嗯，然后我们……推进……然后我们

9034
06:20:23,120 --> 06:20:27,080
将 a 按块大小推进，所以这仅仅是

9035
06:20:24,920 --> 06:20:29,200
就像先发制人地推进它，我们

9036
06:20:27,080 --> 06:20:31,320
已经有了所有这些东西 呃……

9037
06:20:29,200 --> 06:20:33,600
存储在共享内存中，这样我们就可以

9038
06:20:31,320 --> 06:20:35,240
实际上，只要推进“A”（这里推测“Advance a”里的“a”可能是某个特定的内容，结合后面“ADV”来看可能有关联），我们就可以进行“ADV” 。 

9039
06:20:33,600 --> 06:20:37,878
可以推进这个观点，因为要记住

9040
06:20:35,240 --> 06:20:39,400
a 是一个指针，对吧，嗯，我们只能

9041
06:20:37,878 --> 06:20:42,000
实际上要像使用索引那样来获取这个（东西）

9042
06:20:39,400 --> 06:20:44,080
值，但a本身是一个指针，所以我们

9043
06:20:42,000 --> 06:20:47,798
我们提出，在记忆中我们提出，

9044
06:20:44,080 --> 06:20:51,120
在内存空间中按块大小划分，所以一个

9045
06:20:47,798 --> 06:20:54,200
呃，所以 a 就像这样，这是一边，1

9046
06:20:51,120 --> 06:20:56,520
那就像是向内指向点 c

9047
06:20:54,200 --> 06:20:59,920
然后 B 将指向下方

9048
06:20:56,520 --> 06:21:02,680
所以，呃，A 要前进一格

9049
06:20:59,920 --> 06:21:05,120
块，所以例如如果 A 在像这里的位置

9050
06:21:02,680 --> 06:21:09,280
嗯，A 打算向方块一侧推进，所以

9051
06:21:05,120 --> 06:21:10,520
二，它要跳到这儿，对吧，嗯

9052
06:21:09,280 --> 06:21:14,878
然后

9053
06:21:10,520 --> 06:21:16,558
呃，B 打算……B 打算做这件事

9054
06:21:14,878 --> 06:21:19,000
一样，但它马上要跳了，所以说它是

9055
06:21:16,558 --> 06:21:19,000
将要；打算去

9056
06:21:20,120 --> 06:21:24,280
去吧，它只是要……它要……

9057
06:21:22,200 --> 06:21:26,478
直接跳过去，所以这里的 n 是像这样的

9058
06:21:24,280 --> 06:21:28,240
长度，它将进行块大小乘以……（这里原句似乎不完整）

9059
06:21:26,478 --> 06:21:30,440
它要跳了，它要跳了

9060
06:21:28,240 --> 06:21:31,638
向下两个，向右，然后它会去做

9061
06:21:30,440 --> 06:21:34,040
这正是我们想要的，所以它将会

9062
06:21:31,638 --> 06:21:37,200
按照以下方向推进方块

9063
06:21:34,040 --> 06:21:39,040
我们期望把它们给你，你可能已经有了 

9064
06:21:37,200 --> 06:21:41,240
对于我们仅仅是……这件事有些困惑

9065
06:21:39,040 --> 06:21:45,280
使用类似螺纹柱之类的东西，还有仅仅一个

9066
06:21:41,240 --> 06:21:47,360
提醒一下，呃，这个……这个术语已经……

9067
06:21:45,280 --> 06:21:49,878
前进到正确的位置，对吧

9068
06:21:47,360 --> 06:21:52,958
所以一旦我们进展到像这样的程度

9069
06:21:49,878 --> 06:21:55,600
标题 例如，然后我们就可以接着

9070
06:21:52,958 --> 06:21:57,520
我们几乎可以只使用线程，我们

9071
06:21:55,600 --> 06:21:59,718
可以使用线程索引

9072
06:21:57,520 --> 06:22:01,878
方案，而这将准确地为我们提供所需的东西

9073
06:21:59,718 --> 06:22:01,878
我们

9074
06:22:02,320 --> 06:22:06,920
现在想要注意这个“for”里面的内容

9075
06:22:04,920 --> 06:22:09,478
循环中，我们有与……相同的索引方案

9076
06:22:06,920 --> 06:22:12,760
我们在全球记忆库（不太明确“colest”，可能拼写有误）里做了……呃

9077
06:22:09,478 --> 06:22:15,718
内核 所以当我们 呃 当我们……的时候

9078
06:22:12,760 --> 06:22:18,120
只是在处理……方面很高效（因原文不完整，“through the”后面内容缺失，翻译可能不太精准） 

9079
06:22:15,718 --> 06:22:20,040
列，并且让 C 像一个……一样（原文表述不太完整和清晰） 

9080
06:22:18,120 --> 06:22:22,360
想要一个水平布局，而不是像……那样

9081
06:22:20,040 --> 06:22:23,878
我们有的一摞垂直堆放的积木

9082
06:22:22,360 --> 06:22:27,280
我在这里也在做完全一样的事情。

9083
06:22:23,878 --> 06:22:31,400
对，嗯，所以你可能在想

9084
06:22:27,280 --> 06:22:33,280
关于这个临时变量，嗯，所以这个临时变量

9085
06:22:31,400 --> 06:22:34,958
这种暂时的情况只是……只是会…… 

9086
06:22:33,280 --> 06:22:37,840
从一无所有开始

9087
06:22:34,958 --> 06:22:39,440
而我们所做的就是让每个线程

9088
06:22:37,840 --> 06:22:41,478
本质上，每个线程都有其自己的临时变量 

9089
06:22:39,440 --> 06:22:43,760
变量，没错，它将被存储

9090
06:22:41,478 --> 06:22:45,760
呃，在登记簿里，每三个（此处信息不明确，thre 可能拼写错误，推测可能是 three）都有其各自的…… 

9091
06:22:43,760 --> 06:22:49,280
临时变量，并且它将

9092
06:22:45,760 --> 06:22:51,440
累积这个临时变量，呃

9093
06:22:49,280 --> 06:22:52,840
它将累积一个点积

9094
06:22:51,440 --> 06:22:54,760
那么这将会是……

9095
06:22:52,840 --> 06:22:57,160
所做的是实际上它不会去……（原英文句子似乎不完整） 

9096
06:22:54,760 --> 06:22:59,280
把矩阵相乘，除此之外还有什么（做法）？ 

9097
06:22:57,160 --> 06:23:01,680
它要做的就是它仅仅要

注：你提供的句子不完整，以上翻译是根据现有内容进行的。 

9098
06:22:59,280 --> 06:23:03,958
在它穿过方块时进行累积

9099
06:23:01,680 --> 06:23:07,440
没错，所以当它进行的时候，它在持续推进 

9100
06:23:03,958 --> 06:23:11,000
去累加……中的每个值

9101
06:23:07,440 --> 06:23:14,360
C语言的输出会随着程序的执行而逐步产生，对吧

9102
06:23:11,000 --> 06:23:16,718
所以根据这个帖子，它将会说

9103
06:23:14,360 --> 06:23:19,520
说某人打算做像……那一排那样的事

9104
06:23:16,718 --> 06:23:21,440
这个，然后是这个的这一列

9105
06:23:19,520 --> 06:23:23,200
对，所以当他们……当他们

9106
06:23:21,440 --> 06:23:24,520
相互交流，或者当他们……当他们……

9107
06:23:23,200 --> 06:23:26,958
互动 他们最终会处于类似的状态

9108
06:23:24,520 --> 06:23:28,320
也许是左上角这个部分，还有这根线

9109
06:23:26,958 --> 06:23:30,958
为那个保存临时值

9110
06:23:28,320 --> 06:23:32,638
特定的部分，嗯，以及它将会……

9111
06:23:30,958 --> 06:23:35,080
就像它穿过……那样去做

（原英文句子似乎表述不太完整准确，但按照要求进行了翻译） 

9112
06:23:32,638 --> 06:23:36,958
瓷砖，它会积累这个点

9113
06:23:35,080 --> 06:23:39,958
产品权益，所以你先得到你……（此英文表述不太符合常见语法，翻译可能存在表意不精准情况） 

9114
06:23:36,958 --> 06:23:41,680
求出第一个点积，然后你

9115
06:23:39,958 --> 06:23:42,798
把它加到下一个的下一个上面去

9116
06:23:41,680 --> 06:23:44,520
标题正确，因为你就是你

注：这里“tile”可能是“title”的拼写错误。若有其他语境信息，可进一步修正翻译。 

9117
06:23:42,798 --> 06:23:46,600
本质上只是在做普通的、天真的（事） 

9118
06:23:44,520 --> 06:23:48,280
矩阵乘法，但你只是

9119
06:23:46,600 --> 06:23:52,520
通过……积累

9120
06:23:48,280 --> 06:23:55,878
瓷砖等等，所以最后呃，你会……

9121
06:23:52,520 --> 06:23:59,320
仅凭这积累的温度

9122
06:23:55,878 --> 06:24:01,160
然而，这仅适用于单个点。

9123
06:23:59,320 --> 06:24:03,718
产品运营，这仅适用于一个（情况/对象等，需结合具体语境确定） 

9124
06:24:01,160 --> 06:24:05,958
标题以及我们为此设置这个的原因

9125
06:24:03,718 --> 06:24:08,440
在这个循环内部，我们非常…… 

9126
06:24:05,958 --> 06:24:10,120
在这件事上聪明些，这样我们就可以

9127
06:24:08,440 --> 06:24:12,120
实际上是通过……来进行这种积累

9128
06:24:10,120 --> 06:24:14,160
把瓷砖摆放好，这样我们就可以……（原文句子似乎不完整） 

9129
06:24:12,120 --> 06:24:16,920
我们可以在如何……方面变得聪明些

（不过原句 “of be” 可能存在拼写错误，推测可能是想表达 “or we” 之类，以上是基于现有文本的翻译） 

9130
06:24:14,160 --> 06:24:18,798
我们，呃，着手去做那件事，呃，然后

9131
06:24:16,920 --> 06:24:21,040
等我们结束后，我们就可以走了

9132
06:24:18,798 --> 06:24:22,360
往前，呃，你知道的，把所有的……同步起来

9133
06:24:21,040 --> 06:24:24,718
线程要确保它们都是

9134
06:24:22,360 --> 06:24:27,920
跟上进度，在我们真正开始书写之前

9135
06:24:24,718 --> 06:24:30,160
把这个送到 C 那里，所以我想就去……（这里“going a”表述不太完整准确，可能有信息缺失） 

9136
06:24:27,920 --> 06:24:33,040
有点像再次对这个进行迭代

9137
06:24:30,160 --> 06:24:35,558
线程行，所以那就像是哪个

9138
06:24:33,040 --> 06:24:36,920
我们想要乘以瓷砖内的哪一行

9139
06:24:35,558 --> 06:24:39,558
块大小，所以那将是我们的

9140
06:24:36,920 --> 06:24:41,920
包装器，然后索引（idx）将会

9141
06:24:39,558 --> 06:24:44,160
看看我们是如何对其进行迭代的，所以一个

9142
06:24:41,920 --> 06:24:45,558
是行，所以我们要处理……那是索引

9143
06:24:44,160 --> 06:24:48,478
我们打算从这条路走

9144
06:24:45,558 --> 06:24:52,320
那将是……上的偏移量

9145
06:24:48,478 --> 06:24:56,600
水平部分，然后B将 

9146
06:24:52,320 --> 06:24:58,878
呃，索引（idx）乘以块大小，呃，然后

9147
06:24:56,600 --> 06:25:00,160
另外还有我们当时正在处理的那个偏移量，呃

9148
06:24:58,878 --> 06:25:03,638
在那之前，没错，所以我们坚持认为

9149
06:25:00,160 --> 06:25:06,760
全局内存访问 呃 那种访问

9150
06:25:03,638 --> 06:25:08,760
我们之前有的模式，嗯，而且我们现在……（原句似乎未完整，这里按已有内容翻译） 

9151
06:25:06,760 --> 06:25:11,478
而我们只是简单地把它写出来

9152
06:25:08,760 --> 06:25:13,120
随着它不断累积，成为临时变量

9153
06:25:11,478 --> 06:25:15,240
穿过那些瓷砖，没错，就是那样

9154
06:25:13,120 --> 06:25:18,000
这里的想法是我们正在积累

9155
06:25:15,240 --> 06:25:19,320
穿过这些瓷砖，所以现在我们可以，呃

9156
06:25:18,000 --> 06:25:21,080
希望这能讲得通，随时可以……

9157
06:25:19,320 --> 06:25:23,320
可以随时重看其中的一些部分。

9158
06:25:21,080 --> 06:25:25,478
把它接入像ChatGPT这样的（工具），或者…… 

9159
06:25:23,320 --> 06:25:28,638
CLA 之类的，然后……（注：这里“CLA son”表述不太清晰，推测可能是信息有误或有特定语境下的不常见表达） 

9160
06:25:25,478 --> 06:25:31,638
试着，试着去想象正在发生的事情

9161
06:25:28,638 --> 06:25:33,798
我有 我有一个单独的，呃，额外的

9162
06:25:31,638 --> 06:25:36,240
就像这里的图表，只是关于这个的图表 

9163
06:25:33,798 --> 06:25:38,878
看起来像是布置好了 呃 我决定添加

9164
06:25:36,240 --> 06:25:41,080
这与课程资产相关（注：原英文文本表述不太符合常规语法，此翻译是尽力贴合语义） 

9165
06:25:38,878 --> 06:25:43,040
更快磨坊区域内的文件夹

9166
06:25:41,080 --> 06:25:46,478
所以如果你想了解一下这个，我可能会

9167
06:25:43,040 --> 06:25:48,958
往里面添加其他的，但呃，就是这样啦

9168
06:25:46,478 --> 06:25:50,920
这……这就是共享内存

9169
06:25:48,958 --> 06:25:54,360
阻塞 呃 块状物（“cud”常见释义为反刍的食物团、块状物等，这里结合语境“uh”来看，“cud”可能不是标准用法或表意不太清晰，需根据更多上下文准确理解） 

9170
06:25:50,920 --> 06:25:57,840
内核 所以现在我们实际上可以深入研究并

9171
06:25:54,360 --> 06:26:01,400
呃，然后对这个东西进行剖析，所以我就深入到……

9172
06:25:57,840 --> 06:26:03,680
这里，然后直接选 sjem 编号

注：“sjem”可能不是一个常见的正确英文单词，也许是特定领域的术语、拼写错误或缩写，需结合具体语境进一步确认。 

9173
06:26:01,400 --> 06:26:05,920
三
我们再运行这个一秒，它是

9174
06:26:03,680 --> 06:26:08,240
会非常快，所以如果我们

9175
06:26:05,920 --> 06:26:11,080
实际上，比较一下，等一下再看

9176
06:26:08,240 --> 06:26:14,240
它正在处理那里的最后一个，所以如果

9177
06:26:11,080 --> 06:26:18,440
实际上，我把这个和数字作比较

9178
06:26:14,240 --> 06:26:18,440
两个，那不是

9179
06:26:19,638 --> 06:26:25,798
呃，试一试吧

9180
06:26:21,718 --> 06:26:27,680
第二，是的，所以我们的第二名仅有…… 

9181
06:26:25,798 --> 06:26:30,878
卡式存储器访问正在实现

9182
06:26:27,680 --> 06:26:33,280
关于你知道的大概1200个，而这个是

9183
06:26:30,878 --> 06:26:35,878
达到了约1600，所以我们有一个

9184
06:26:33,280 --> 06:26:37,600
相比之前有了不错的提升，对吧，嗯

9185
06:26:35,878 --> 06:26:39,760
但我可能早该这么做了

9186
06:26:37,600 --> 06:26:42,200
早些时候，但只是为了……只是为了

9187
06:26:39,760 --> 06:26:46,680
破坏惊喜吧，库布罗斯实际上是一个…… 

9188
06:26:42,200 --> 06:26:51,000
你提供的英文文本“lot fast we run the 0 kublos is uh about” 并不是一个符合语法规则的正常英文句子，可能存在拼写错误和语序混乱的问题，以下是尽力调整语序和猜测可能意思后的翻译：

我们快速跑了大概 0 公里（这里“kublos”可能是拼写错误，推测你想说“kilometers” ） 

9189
06:26:46,680 --> 06:26:52,958
1.14万吉次浮点运算每秒，即11.5太次浮点运算每秒

9190
06:26:51,000 --> 06:26:58,520
这真的很快，尤其是与……相比

9191
06:26:52,958 --> 06:27:01,120
关于我们之前的，呃，我们之前的

9192
06:26:58,520 --> 06:27:03,558
天真的内核，没错，这极其…… 

9193
06:27:01,120 --> 06:27:06,320
现在快点，在我们继续之前再强调一下

9194
06:27:03,558 --> 06:27:08,240
在，呃，这个，这个，呃，共享内存内核上

9195
06:27:06,320 --> 06:27:10,478
这并没有完全按照那样去实现

9196
06:27:08,240 --> 06:27:12,840
这种平铺的版本仅仅是

9197
06:27:10,478 --> 06:27:15,920
实现类似部分点积的操作

9198
06:27:12,840 --> 06:27:18,240
一种被称为分块的平铺方式，所以

9199
06:27:15,920 --> 06:27:20,160
当我们，当我们像点一样积累

9200
06:27:18,240 --> 06:27:22,000
那些实际上并不像……的产品

9201
06:27:20,160 --> 06:27:23,798
全像你会认为的因纽特人那样（此英文原句可能表述有误，这是尽力按照顺序翻译的结果） 

9202
06:27:22,000 --> 06:27:25,160
平铺，正如我所描述的那样进行平铺

9203
06:27:23,798 --> 06:27:27,680
以前是当你比如拿走那个……

注：原文 “before is when you like take the” 并非完整通顺的句子，可能存在遗漏内容，以上翻译是基于现有文本尽量表意。 

9204
06:27:25,160 --> 06:27:29,360
矩阵，你将它们相乘，然后你

9205
06:27:27,680 --> 06:27:31,760
你先进位，然后再相乘

9206
06:27:29,360 --> 06:27:35,400
并且你每次在他们……的时候都喜欢添加它们

（原英文句子似乎不完整） 

9207
06:27:31,760 --> 06:27:38,478
逐元素相乘，呃，而且这不是

9208
06:27:35,400 --> 06:27:40,958
我们在这里所做的
我们所做的是一件……（原文“a”后内容缺失） 

9209
06:27:38,478 --> 06:27:42,920
部分点积，所以请记住这一点。

9210
06:27:40,958 --> 06:27:44,520
下一个会稍微有点……

9211
06:27:42,920 --> 06:27:49,718
不过有所不同

9212
06:27:44,520 --> 06:27:52,120
所以一维，呃，一维分块平铺要稍微更……

9213
06:27:49,718 --> 06:27:54,120
高级的，嗯，但我们会挺过去的，所以

9214
06:27:52,120 --> 06:27:56,798
只是为了帮助让平铺效果在……中变得无比清晰

9215
06:27:54,120 --> 06:27:58,520
在你脑海里我打算用两个矩阵

9216
06:27:56,798 --> 06:28:00,520
举个例子，只是为了展示这是如何……

9217
06:27:58,520 --> 06:28:02,680
直觉是有用的，实际上我……

9218
06:28:00,520 --> 06:28:04,360
写出来了 我写了一点 我当时在测试

9219
06:28:02,680 --> 06:28:05,798
有那么一点，而且我算错数了。

9220
06:28:04,360 --> 06:28:09,240
手工操作，所以我们就打算使用使用

9221
06:28:05,798 --> 06:28:13,240
那台电脑……不过我写出来了

9222
06:28:09,240 --> 06:28:17,680
这里有一个矩阵 A，即 1 2 3 4 5 6 7 8 9 10

9223
06:28:13,240 --> 06:28:19,520
11 12 13 14 15 16 然后这个 B 它

9224
06:28:17,680 --> 06:28:23,120
以二为单位计数，但它是倒着数的，所以

9225
06:28:19,520 --> 06:28:25,920
2 4 6 8 10 12 14 16 然后 然后

9226
06:28:23,120 --> 06:28:28,558
连续到32，所以我已经写了

9227
06:28:25,920 --> 06:28:29,958
这些在航站楼外面，嗯，如果

9228
06:28:28,558 --> 06:28:32,520
我们就这么做

9229
06:28:29,958 --> 06:28:35,000
一个乘法；一次相乘

注：“multiply”常见作动词，意为“乘；使相乘” ，“a multiply”这样的表达比较少见，也有可能这里“multiply”作为名词使用，具体还需结合上下文理解。 

9230
06:28:32,520 --> 06:28:36,440
B 我们注意到我们得到了这个输出

9231
06:28:35,000 --> 06:28:37,878
结果，而且这些很漂亮，我是说这些

9232
06:28:36,440 --> 06:28:40,440
这些数字很容易处理

9233
06:28:37,878 --> 06:28:42,920
对，所以我想做的就是工作

9234
06:28:40,440 --> 06:28:46,878
具体来说，就是这个右上角的方块

9235
06:28:42,920 --> 06:28:48,840
200、180、456、404，那究竟是什么

9236
06:28:46,878 --> 06:28:51,240
我想和……一起工作，那么我们要怎么做呢

注：原文 “work with so” 表述有误，推测可能是 “work with sb.” 之类的正确表达，但按照要求，我仅进行了翻译。 

9237
06:28:48,840 --> 06:28:53,400
为此，我们将使用……（原句似乎未完整）

9238
06:28:51,240 --> 06:28:55,080
我们打算采用一个来自……的想法

9239
06:28:53,400 --> 06:28:58,638
这里

9240
06:28:55,080 --> 06:29:02,000
嗯，要拿到右上角的这块，我们

9241
06:28:58,638 --> 06:29:03,600
本质上是想向内交叉

9242
06:29:02,000 --> 06:29:08,638
好的，那么我们将从……开始

9243
06:29:03,600 --> 06:29:09,958
将这个……这个部分乘以……呃

9244
06:29:08,638 --> 06:29:12,798
对于这部分B，我们打算…… 

9245
06:29:09,958 --> 06:29:16,000
将这些相乘：a * 非B * a * a

9246
06:29:12,798 --> 06:29:18,320
* B 然后我们要把它加上去

9247
06:29:16,000 --> 06:29:22,240
与该产品 矩阵模型

（不过原英文“the the”表述有误，推测可能是笔误） 

9248
06:29:18,320 --> 06:29:25,558
这部分与这部分的乘积

9249
06:29:22,240 --> 06:29:28,440
好的，那么如果我们首先开始做

9250
06:29:25,558 --> 06:29:31,840
1 二 5 六 和

9251
06:29:28,440 --> 06:29:34,798
去说“嗯”

9252
06:29:31,840 --> 06:29:37,760
呃，一个临时工；呃，一个临时的（情况等，“temp”含义需结合语境确定，常见有“临时工”“临时的事物”等意思 ）

9253
06:29:34,798 --> 06:29:37,760
火炬；火把；手电筒；喷灯；焊枪 （注：“torch”常见释义有这些，这里“torch.”若在编程语境中，通常是指Python的深度学习库“PyTorch” ） 

9254
06:29:38,360 --> 06:29:43,558
张量，然后在这里面我们是

9255
06:29:40,478 --> 06:29:47,798
打算要小一点的，所以它是

9256
06:29:43,558 --> 06:29:47,798
首先会是，呃，1

9257
06:29:50,440 --> 06:29:56,320
1256 呃，然后我们将其与……相乘

9258
06:29:53,360 --> 06:29:56,320
火炬；手电筒；火把。（这里 “torch” 是比较常见的释义，不过如果 “torch.” 处于特定语境中，也可能有其他含义，比如在编程里，“torch” 常指 PyTorch 深度学习框架）

由于不清楚 “torch.” 更具体的使用场景，以上是常见含义供你参考。若你能提供更多上下文，我会给出更精准的翻译。

如果你只需要单纯按照格式输出 “torch.” 的字面翻译（“torch” 常见的名词义），则为：
火炬。 

9259
06:30:00,760 --> 06:30:05,958
张量 托尔。更紧绷的 4 到 1210

9260
06:30:09,760 --> 06:30:15,798
对，而且如果我们打印出一个临时变量，我们会得到

9261
06:30:13,878 --> 06:30:20,600
这；这个

9262
06:30:15,798 --> 06:30:20,600
结果，现在我们来做，呃，B

9263
06:30:22,160 --> 06:30:28,200
临时温度（这里“temp tch.”可能有误，推测是温度相关，但不太准确）。张量，而且我接下来要去…… 

9264
06:30:26,280 --> 06:30:30,160
打印呃 实际上我就……我会……

9265
06:30:28,200 --> 06:30:31,798
就在这里打印布局，我们会进行一次（操作）

9266
06:30:30,160 --> 06:30:33,040
但我们会为临时工采用同样的办法。

9267
06:30:31,798 --> 06:30:34,558
我只是打算移除这些数值。

9268
06:30:33,040 --> 06:30:37,760
然后我们会把这个放好

9269
06:30:34,558 --> 06:30:40,958
呃，有了 B 温度，所以这将……

9270
06:30:37,760 --> 06:30:40,958
呃

（由于“be uh”这样的表述比较口语化且不完整，这样翻译符合一般口语场景下的呈现。） 

9271
06:30:46,240 --> 06:30:52,958
3478 用，呃，201828 乘以它

9272
06:31:02,920 --> 06:31:10,398
26 20 18 28 26 好嘞，行，太棒啦

9273
06:31:08,080 --> 06:31:12,840
现在我们打印出 B

9274
06:31:10,398 --> 06:31:18,600
临时的；暂时的；临时工（此处需结合具体语境确定准确含义，“temp”常见释义如上） 

9275
06:31:12,840 --> 06:31:20,840
哦，然后我们计算 temp 加上 b

9276
06:31:18,600 --> 06:31:24,600
温度，然后我们得到了我们想要的结果

注：原英文句子似乎不完整，这里根据字面大致翻译。 

9277
06:31:20,840 --> 06:31:30,080
预计 200 180 456

9278
06:31:24,600 --> 06:31:31,360
404 呃 2 180 45644 那是一个 TOD M

9279
06:31:30,080 --> 06:31:32,638
那 那真的就是全部了 就是这样

9280
06:31:31,360 --> 06:31:34,680
当你能把这个画出来时会有帮助

9281
06:31:32,638 --> 06:31:36,798
用手算出来并理解……是什么（此处原文不完整）

9282
06:31:34,680 --> 06:31:38,878
当我们有所进展时，目标（目的）就出现了。

注：原英文句子表述不太符合常见语法规范，此翻译是根据大致语义进行的理解。 

9283
06:31:36,798 --> 06:31:41,040
例如，当我们将指针推进比如

9284
06:31:38,878 --> 06:31:42,160
比一两个更大的偏移量

9285
06:31:41,040 --> 06:31:44,040
或者三四个，就好像当你……的时候

9286
06:31:42,160 --> 06:31:46,360
跳过整行，而且你打算……

9287
06:31:44,040 --> 06:31:48,760
就像当我们，当我们，当我们那样做的时候的一个“c”（这里“a c”表意不太明确，需结合更多语境理解） 

9288
06:31:46,360 --> 06:31:50,958
这些东西会帮助你明白为什么

9289
06:31:48,760 --> 06:31:54,360
我们正在做这件事

9290
06:31:50,958 --> 06:31:55,840
嗯，不过，是的，我们可以继续开始了。

9291
06:31:54,360 --> 06:31:57,798
太棒了，那么现在让我们继续看看

9292
06:31:55,840 --> 06:32:02,360
关于这个的呃样板代码如下

9293
06:31:57,798 --> 06:32:04,120
嗯，至于这个的运行脚本，呃，所以

9294
06:32:02,360 --> 06:32:06,360
在运行脚本中，我们实际上会弹出

9295
06:32:04,120 --> 06:32:08,080
向下，然后你可以看到每一个，呃，每一个小的……

9296
06:32:06,360 --> 06:32:10,600
比如函数以及我们如何调用所有内容

9297
06:32:08,080 --> 06:32:11,958
在这里，所以就像高雄科学工业园区（Kuas可能指Kaohsiung Science and Technology Park，即高雄科学工业园区 ，需结合具体语境确定）的功能是为了…… 

9298
06:32:10,600 --> 06:32:15,840
例如，有不同类型的用于……

9299
06:32:11,958 --> 06:32:17,840
像FP32、脑浮点16、张量浮点32

9300
06:32:15,840 --> 06:32:20,000
对，呃，然后我们有类似那种天真的（情况）

9301
06:32:17,840 --> 06:32:21,798
你提供的内容似乎存在拼写错误，可能想说 “the coolest shared memory caching which” 

最酷的共享内存缓存，它…… 

9302
06:32:20,000 --> 06:32:24,080
我们最近刚做了，然后我们有

9303
06:32:21,798 --> 06:32:26,000
一维块平铺，对吧，所以注意看……

9304
06:32:24,080 --> 06:32:29,040
在我们刚刚拥有的共享内存块中

9305
06:32:26,000 --> 06:32:31,478
32秒，到处都是32 32 32 32 ，以及

9306
06:32:29,040 --> 06:32:33,680
32 没错，一切都是 32，因为

9307
06:32:31,478 --> 06:32:36,440
一切都是方形的，但在这个里面却不是

9308
06:32:33,680 --> 06:32:38,638
实际上，我们会稍微做些调整，所以

9309
06:32:36,440 --> 06:32:42,280
我们 我们本质上有这些 这些

9310
06:32:38,638 --> 06:32:46,040
块 呃，所以 M 将会是这个 这个

9311
06:32:42,280 --> 06:32:49,638
在，呃，在一个……所以它将会

9312
06:32:46,040 --> 06:32:52,040
因为它是专门针对呃 A 和 C 的

9313
06:32:49,638 --> 06:32:54,080
因为当我们做我们的……呃，像我们的…… 

9314
06:32:52,040 --> 06:32:56,558
矩阵乘法的形状，我们要开始讲了

9315
06:32:54,080 --> 06:32:59,200
为了抵消里面的那些，呃，K 和

9316
06:32:56,558 --> 06:33:01,360
那么你就会剩下，呃

9317
06:32:59,200 --> 06:33:04,000
我们最后会剩下 M 和 N

9318
06:33:01,360 --> 06:33:05,760
那么，没错

9319
06:33:04,000 --> 06:33:08,840
只需留意这里的这些形状。

9320
06:33:05,760 --> 06:33:10,760
呃，我们下面也有数字 8 呢，所以……

9321
06:33:08,840 --> 06:33:13,160
呃，只要……只要留意这个，我们

9322
06:33:10,760 --> 06:33:15,200
我们在这里使用不同的，呃，形状来

9323
06:33:13,160 --> 06:33:18,000
帮助加快操作速度，因为我们

9324
06:33:15,200 --> 06:33:21,680
介绍一个新概念，嗯，还有那个

9325
06:33:18,000 --> 06:33:24,760
概念是用于……的一维块平铺

注：原句“concept is 1D block tiling for”表述不完整，“for”后面似乎缺少内容。 

9326
06:33:21,680 --> 06:33:28,080
每个线程计算多个结果

9327
06:33:24,760 --> 06:33:31,878
所以如果我们真的回到，呃，那个……

9328
06:33:28,080 --> 06:33:34,120
和我分享呃，当我们写作时呃屏蔽（的情况）

9329
06:33:31,878 --> 06:33:36,680
我们的输出有特定的……特定的

注：原文“spe ific”可能存在拼写错误，推测正确的是“specific” 。 

9330
06:33:34,120 --> 06:33:38,920
我们输出的每个线程的索引，它是

9331
06:33:36,680 --> 06:33:41,638
只是一个，我们写出它的一个输出

9332
06:33:38,920 --> 06:33:43,360
那块瓷砖的……或者，抱歉，那块瓷砖的……以及 

9333
06:33:41,638 --> 06:33:45,000
就这样吧，呃，我们就到此为止。

9334
06:33:43,360 --> 06:33:48,000
没有迭代，我们不是……我们是

9335
06:33:45,000 --> 06:33:50,160
每个线程不是运行多个，只是运行一个

9336
06:33:48,000 --> 06:33:52,200
现在，如果我们到这里，我们会注意到

9337
06:33:50,160 --> 06:33:56,280
实际上我们正在写多个，所以我们开始吧

9338
06:33:52,200 --> 06:33:59,398
关于这个结果或者这个结果索引，嗯

9339
06:33:56,280 --> 06:34:01,200
本质上是这样的，呃，它会进行迭代。

9340
06:33:59,398 --> 06:34:03,760
通过，呃

9341
06:34:01,200 --> 06:34:07,840
TM，也就是我们在……中发现的这个术语

9342
06:34:03,760 --> 06:34:10,600
在这儿，呃，本质上就是话题串。 

9343
06:34:07,840 --> 06:34:13,920
每M维度，你可以这样去想它

9344
06:34:10,600 --> 06:34:16,040
那样的话，简而言之，我们接下来要

9345
06:34:13,920 --> 06:34:17,760
每个线程输出多个结果

9346
06:34:16,040 --> 06:34:19,798
而且那将会加快速度，嗯

9347
06:34:17,760 --> 06:34:21,920
所有的一切 很多 所以 比如想象一下 要是你

9348
06:34:19,798 --> 06:34:23,200
不得不做 呃 你不得不发布一个新的

9349
06:34:21,920 --> 06:34:25,280
每次你打算写作的时候都要连贯思路（注：这里“thread”直译为“连贯”等，结合语境推测可能是“保持思路连贯”之类意思，原表述较模糊） 

9350
06:34:23,200 --> 06:34:26,558
整个矩阵的一个输出，所以如果

9351
06:34:25,280 --> 06:34:28,440
你有一个

9352
06:34:26,558 --> 06:34:31,360
496 呃 通过

9353
06:34:28,440 --> 06:34:34,080
496，那大概会是16

9354
06:34:31,360 --> 06:34:36,160
正在输出的不同线程

9355
06:34:34,080 --> 06:34:37,520
没错，你有很多头绪呢（这里“threads”结合语境可以灵活理解，也可译为线索、思路等 ） 

9356
06:34:36,160 --> 06:34:41,520
有；拥有；持有；吃；喝；进行；经受

9357
06:34:37,520 --> 06:34:42,840
那里有很多事情在发生，所以，呃

9358
06:34:41,520 --> 06:34:45,878
当……时候；何时

9359
06:34:42,840 --> 06:34:48,478
我们，嗯，当我们使用，当我们迭代的时候

9360
06:34:45,878 --> 06:34:50,040
我们可以让一个线程进行计算

9361
06:34:48,478 --> 06:34:51,878
呃，增加数量并让事情变得更……

9362
06:34:50,040 --> 06:34:54,080
高效 它确实 它确实使这……（由于文本不完整，可能语义表达不够准确） 

9363
06:34:51,878 --> 06:34:55,558
索引更加复杂，并且这是

9364
06:34:54,080 --> 06:34:57,398
可能是最直观的方式之一

9365
06:34:55,558 --> 06:35:00,760
难以理解的核心内容，但一旦（理解了）

9366
06:34:57,398 --> 06:35:03,440
我们到那儿呃，应该轻而易举，所以

9367
06:35:00,760 --> 06:35:07,040
为我们的锅炉运行代码而上调（这里“going up”结合语境猜测可能有“上调”等意思，原英文表述似乎不太完整和准确） 我们

9368
06:35:03,440 --> 06:35:10,280
有这个 c r 是块 ID x.y 所以我们正在

9369
06:35:07,040 --> 06:35:14,080
打算使用方块，呃，每个单独的…… （此句不太完整，翻译仅供参考） 

9370
06:35:10,280 --> 06:35:17,080
呃，一组线程即将……

9371
06:35:14,080 --> 06:35:19,718
计算，呃，在……上的一个特定瓦片（这里“tile”结合语境可能有不同准确释义，如瓷砖、瓦片、地图瓦片等）

9372
06:35:17,080 --> 06:35:23,080
输出
没错，我们有这样一个模块

9373
06:35:19,718 --> 06:35:25,320
本质上，当前，当前行

9374
06:35:23,080 --> 06:35:28,080
以及当前的列，所以是当前的

9375
06:35:25,320 --> 06:35:30,398
行就好像是一种垂直的东西

9376
06:35:28,080 --> 06:35:32,040
我们正在选择哪一行，这就是原因

9377
06:35:30,398 --> 06:35:34,040
好的，那这是垂直方向，然后是……

9378
06:35:32,040 --> 06:35:38,120
像我们之前那样排成纵队，轮到你了

9379
06:35:34,040 --> 06:35:42,120
知道水平维度，嗯，现在我们开始

9380
06:35:38,120 --> 06:35:45,478
到这里，这里本质上是……那个（此处原文“the the”表述有误，可能影响完整准确表意） 

9381
06:35:42,120 --> 06:35:48,760
线程 呃 较低层级的线程

9382
06:35:45,478 --> 06:35:51,160
在那里面的列，所以我们有这个，我们

9383
06:35:48,760 --> 06:35:54,840
有一个使用的“BN”术语，而且这个

9384
06:35:51,160 --> 06:35:57,760
我们回忆到这里时的 BN 项是 64

9385
06:35:54,840 --> 06:36:01,718
好的，那么让我回到

9386
06:35:57,760 --> 06:36:04,520
这个这个BN项，我们在这两者中都能看到它。

9387
06:36:01,718 --> 06:36:07,360
B 矩阵以及 C 矩阵，就是这个 

9388
06:36:04,520 --> 06:36:10,120
BN是对的，就是那边那个长度，对吧

9389
06:36:07,360 --> 06:36:13,440
所以当我们实际上

9390
06:36:10,120 --> 06:36:16,320
嗯，当我们进行模 BN 运算时，接下来会…… 

9391
06:36:13,440 --> 06:36:19,080
要做的是，这就好像如果 BN 是 64，那它就是…… 

9392
06:36:16,320 --> 06:36:21,000
会像，嗯，线程索引是零这样

9393
06:36:19,080 --> 06:36:22,878
除以那个，结果就会是

9394
06:36:21,000 --> 06:36:24,680
零，向右，然后它会移动 1、2

9395
06:36:22,878 --> 06:36:27,638
3 4 5 因为我们刚好有这个

9396
06:36:24,680 --> 06:36:29,478
余数，那就不是 64 了，对吧，所以

9397
06:36:27,638 --> 06:36:31,360
一旦我们超过 64，那么它……然后它就会开始

9398
06:36:29,478 --> 06:36:32,840
进行循环，所以它将会，它将会

9399
06:36:31,360 --> 06:36:36,200
遍历所有的列，并且它是…… 

9400
06:36:32,840 --> 06:36:40,718
从 0 上升到 63，然后一旦我们

9401
06:36:36,200 --> 06:36:42,160
实际上达到了64，它接下来要，嗯，它会

9402
06:36:40,718 --> 06:36:44,000
要……它要分开了，对吧

9403
06:36:42,160 --> 06:36:46,478
它要把它弄平 它要

9404
06:36:44,000 --> 06:36:48,638
将这些索引中的每一个都归零

9405
06:36:46,478 --> 06:36:50,958
一直到64，然后一旦我们

9406
06:36:48,638 --> 06:36:52,600
实际上撞击它，它会分裂并且

9407
06:36:50,958 --> 06:36:54,398
它 它会变成一，对吧

9408
06:36:52,600 --> 06:36:55,558
因为它会向下取整为 1

9409
06:36:54,398 --> 06:36:57,398
而且我们会成为，它将会成为

9410
06:36:55,558 --> 06:36:59,080
就像一串零，然后是一个一

9411
06:36:57,398 --> 06:37:03,000
对，我们用这个来挑选我们的

9412
06:36:59,080 --> 06:37:04,958
行，所以列就像 0 1 2 3 4

9413
06:37:03,000 --> 06:37:07,240
一直从5到64，然后是那个

9414
06:37:04,958 --> 06:37:09,600
划船 感觉每次我们这样划动时

9415
06:37:07,240 --> 06:37:11,680
很多 它会 它会猛增

9416
06:37:09,600 --> 06:37:12,958
其一，这样的划分将会持续到……

9417
06:37:11,680 --> 06:37:15,878
就像一个，接着两个，然后三个

9418
06:37:12,958 --> 06:37:17,320
每次我们迈出那64步的距离，并且

9419
06:37:15,878 --> 06:37:19,320
然后它将增加行数

9420
06:37:17,320 --> 06:37:21,680
索引，所以它基本上会…… 

9421
06:37:19,320 --> 06:37:24,840
会像我所说的那样，是一个行索引

9422
06:37:21,680 --> 06:37:27,360
它马上就要把我们向下移动了

9423
06:37:24,840 --> 06:37:30,680
呃，这有点像是……

（注：原英文表述不太完整和清晰，这里根据已有内容翻译并按要求保持格式。） 

9424
06:37:27,360 --> 06:37:33,638
为什么我们把这个放在这里，如此感人啊 

9425
06:37:30,680 --> 06:37:35,120
再往下我们有一个共享的和

9426
06:37:33,638 --> 06:37:37,360
B 共享，所以只是普通的

9427
06:37:35,120 --> 06:37:41,120
我们分配的共享内存，嗯，所以

9428
06:37:37,360 --> 06:37:42,638
这将是一个 M 行 K 列的矩阵乘以一个 K 行 n 列的矩阵 

9429
06:37:41,120 --> 06:37:47,718
对，那就是我们所在的空间

9430
06:37:42,638 --> 06:37:49,320
存储，然后，呃，在这个特定的，呃

9431
06:37:47,718 --> 06:37:55,120
在这个特定的（情况/方面等，需结合上下文确定完整意思）

9432
06:37:49,320 --> 06:37:58,558
线索 我们推进 我们 我们推进 

9433
06:37:55,120 --> 06:38:01,080
将方块瓷砖移到 A 行的开头

9434
06:37:58,558 --> 06:38:03,478
还有B列，没错，所以我们也做了同样的事

9435
06:38:01,080 --> 06:38:06,638
我们过去的事情，其中有一件是我们曾经……（此处句子不完整，可根据完整内容调整） 

9436
06:38:03,478 --> 06:38:07,840
一切都很高级，呃，往前，对，就是这样

9437
06:38:06,638 --> 06:38:10,558
这是

9438
06:38:07,840 --> 06:38:13,840
说真的，呃，这真的一模一样。

9439
06:38:10,558 --> 06:38:15,398
主意，对，所以我们正在做这个

9440
06:38:13,840 --> 06:38:16,718
那里的情况完全一样，我们只是在使用

9441
06:38:15,398 --> 06:38:19,320
稍微不同的术语，因为

9442
06:38:16,718 --> 06:38:21,000
现在是矩形瓷砖了，嗯，这些

9443
06:38:19,320 --> 06:38:23,000
这里的断言基本都到位了

9444
06:38:21,000 --> 06:38:26,000
呃，要说我们不想走出……（这里文本似乎不完整）

9445
06:38:23,000 --> 06:38:27,478
块维度x范围 没错 这就像一个

9446
06:38:26,000 --> 06:38:29,798
本质上，你可以这样想它



9447
06:38:27,478 --> 06:38:32,160
作为一个边界检查器，所以当我们……当

9448
06:38:29,798 --> 06:38:34,200
我们遍历 BM 或 BK，我们不……

9449
06:38:32,160 --> 06:38:35,920
想要超出范围，我们想要打造

9450
06:38:34,200 --> 06:38:38,520
当然，这些（情况）是会累积的，我们希望

9451
06:38:35,920 --> 06:38:40,360
以确保嗯当我们有这个的时候

9452
06:38:38,520 --> 06:38:42,440
就像二维结构，当我们将其展平的时候

9453
06:38:40,360 --> 06:38:44,638
它伸展开来，有一个街区那么长。

9454
06:38:42,440 --> 06:38:48,120
昏暗的文档（此处“dox”可能是“docs”的拼写错误），差不多就是这样了

9455
06:38:44,638 --> 06:38:51,000
那边发生什么事了 嗯 我们 我们断言

9456
06:38:48,120 --> 06:38:55,200
这两个，所以，呃，从本质上来说，当我们……

9457
06:38:51,000 --> 06:38:57,240
回去吧，就好像，嗯，你知道的，N 和 K

9458
06:38:55,200 --> 06:39:00,638
是相同的，然后 M 和 K 也是

9459
06:38:57,240 --> 06:39:02,760
同样的，所以那种情况在那里是相符的。 

9460
06:39:00,638 --> 06:39:05,478
然后同样，接着对于这些



9461
06:39:02,760 --> 06:39:08,878
和我们在这里使用的相同的集成开发环境

9462
06:39:05,478 --> 06:39:11,878
那么螺纹柱，所以我们做这个……这个 x

9463
06:39:08,878 --> 06:39:14,160
除以呃 那里的X维度

9464
06:39:11,878 --> 06:39:16,160
哪个是 BN，那就是……那就是……那就是……

9465
06:39:14,160 --> 06:39:20,200
在 C 语言中，尾随维度将会是

9466
06:39:16,160 --> 06:39:23,000
M 行 n 列，所以在这里我们只进行线程操作

9467
06:39:20,200 --> 06:39:25,520
idx 被除，或者针对该列而言 

9468
06:39:23,000 --> 06:39:28,080
a的索引 内部列索引k

9469
06:39:25,520 --> 06:39:32,000
或者抱歉，呃，我们要开始讲线程了。

9470
06:39:28,080 --> 06:39:35,760
索引对 BK 取模，所以 BK 就是那个水平方向的（参数之类，这里原文表意不太完整，可结合上下文理解） 

9471
06:39:32,000 --> 06:39:37,440
在右边的维度，因为它是M乘以…… （这里“by”后面似乎缺少内容） 

9472
06:39:35,760 --> 06:39:39,958
K 和

9473
06:39:37,440 --> 06:39:43,558
然后内排进入

9474
06:39:39,958 --> 06:39:45,398
a 将只是那个除法运算

9475
06:39:43,558 --> 06:39:47,200
关于那个，所以无论何时我们跨越那段距离 

9476
06:39:45,398 --> 06:39:48,558
关于K，它将增加一个，而且它是

9477
06:39:47,200 --> 06:39:50,520
打算告诉我们我们所在的是哪一行索引

9478
06:39:48,558 --> 06:39:52,200
没错，那差不多就是我们的……（句子不完整，此处翻译可能无法准确表达完整语义） 

9479
06:39:50,520 --> 06:39:53,958
那就是我们如何利用线索来做决定的方式

9480
06:39:52,200 --> 06:39:56,520
我们处于哪个索引，然后是同样的思路

9481
06:39:53,958 --> 06:39:58,718
呃，这里对于 B 也是同样的思路，只是我们

9482
06:39:56,520 --> 06:40:03,080
使用 B 中的最后一个维度，该维度是

9483
06:39:58,718 --> 06:40:04,878
嗯，在矩阵 a 里不用 K 对吧

9484
06:40:03,080 --> 06:40:07,280
并且 并且 然后 在 在

9485
06:40:04,878 --> 06:40:09,878
呃，从本质上来说，我们在这里进行分配。

9486
06:40:07,280 --> 06:40:11,440
记忆，这将会非常……

9487
06:40:09,878 --> 06:40:14,040
当我们把东西写出来的时候很重要

9488
06:40:11,440 --> 06:40:17,200
稍后，注意我们是如何对……进行迭代的

9489
06:40:14,040 --> 06:40:20,200
本学期（TM）我们要制作线。

9490
06:40:17,200 --> 06:40:23,040
结果就像，呃，一条真正的线

9491
06:40:20,200 --> 06:40:25,680
具有大小为 TM 的本地缓存，TM 是

9492
06:40:23,040 --> 06:40:27,120
非常小，对吧？所以在这里，TM 是，TM 是

9493
06:40:25,680 --> 06:40:30,360
实际上是八个，所以那个可以，那个可以

9494
06:40:27,120 --> 06:40:32,160
很容易放入寄存器中，嗯，然后我们

9495
06:40:30,360 --> 06:40:33,440
只需用一个数字来初始化这个，只需

9496
06:40:32,160 --> 06:40:35,320
说零，然后我们要去……

9497
06:40:33,440 --> 06:40:36,920
稍后再填充那个，对吧，所以我们就

9498
06:40:35,320 --> 06:40:40,478
事先对其进行初始化，然后

9499
06:40:36,920 --> 06:40:42,320
我们稍后会改变它。嗯，现在我们

9500
06:40:40,478 --> 06:40:46,558
实际上再深入探讨一点

9501
06:40:42,320 --> 06:40:48,440
高深的内容 所以这整个 抱歉 这个

9502
06:40:46,558 --> 06:40:51,760
整个循环在这里，这里有很多的……（由于原文未完整，此处翻译可能在语义上不太明确） 

9503
06:40:48,440 --> 06:40:53,920
魔法实际上真的会发生，所以当我们……

9504
06:40:51,760 --> 06:40:57,478
当我们处于单身状态时，呃，当我们处于…… 

9505
06:40:53,920 --> 06:40:58,798
一声“嗯”，当我们身处其中时，当我们…… 

9506
06:40:57,478 --> 06:41:02,080
在其中一个里面

9507
06:40:58,798 --> 06:41:06,478
我们正在尝试计算的迭代次数

9508
06:41:02,080 --> 06:41:09,360
呃，一个呃……完整的标题

9509
06:41:06,478 --> 06:41:11,840
在呃 C 语言里在一个代码块内输出

9510
06:41:09,360 --> 06:41:14,280
这就是我们试图在一个街区里做的事情。

9511
06:41:11,840 --> 06:41:17,360
在某个特定的块索引中的一个块

9512
06:41:14,280 --> 06:41:20,680
在网格内将会计算呃

9513
06:41:17,360 --> 06:41:23,558
在C语言中生成一个输出图块，这就是这里的目标。

9514
06:41:20,680 --> 06:41:26,958
所以我们在外部对这些块进行循环操作。

9515
06:41:23,558 --> 06:41:31,398
通过对 K 进行迭代来处理瓦片，没错，K 是

9516
06:41:26,958 --> 06:41:34,520
那个，嗯，K 是，呃，水平维度

9517
06:41:31,398 --> 06:41:37,718
在A中的……以及在B中的垂直维度

9518
06:41:34,520 --> 06:41:39,920
好的，所以我们对那些进行迭代，然后我们

9519
06:41:37,718 --> 06:41:42,200
每次我们都前进这么多，我们没有

9520
06:41:39,920 --> 06:41:44,360
实际上打算用 呃 我们不会（用）

9521
06:41:42,200 --> 06:41:46,360
实际上打算像这样使用块索引 

9522
06:41:44,360 --> 06:41:48,040
你可以看到，实际上我们只在……（原句似乎不完整） 

9523
06:41:46,360 --> 06:41:50,558
这里的这一行没有显示出来

9524
06:41:48,040 --> 06:41:52,638
其他任何地方，所以这只是为了制作

9525
06:41:50,558 --> 06:41:54,638
当然，呃，如果我们只是喜欢的话，我们不会……（注：原英文表述不太完整和通顺，翻译尽量贴合原意） 

9526
06:41:52,638 --> 06:41:55,958
每次递增一，然后它就会继续进行 

9527
06:41:54,638 --> 06:41:58,080
超出范围了，而且我们打算去做

9528
06:41:55,958 --> 06:42:01,000
这个循环的次数远超我们所需，所以我们

9529
06:41:58,080 --> 06:42:03,878
只是想在尽可能多的街区做这件事，或者

9530
06:42:01,000 --> 06:42:07,440
只要我们需要多少街区（就多少街区）啊 

9531
06:42:03,878 --> 06:42:11,558
好的，然后我们填充那个……共享的（部分）

9532
06:42:07,440 --> 06:42:14,840
内存缓存，所以这是在，呃，这个里面

9533
06:42:11,558 --> 06:42:17,760
是在单个呃瓷砖范围内，对吧，所以

9534
06:42:14,840 --> 06:42:19,878
注意我们是如何使用内部行 a 次的

9535
06:42:17,760 --> 06:42:24,398
行，所以就是那个，就是那个，就是……

9536
06:42:19,878 --> 06:42:27,440
我们在它里面的哪一排呢，嗯

9537
06:42:24,398 --> 06:42:30,040
而且这……这些就像是，嗯，这些是

9538
06:42:27,440 --> 06:42:31,520
就像非常小的索引范围，对吧

9539
06:42:30,040 --> 06:42:33,558
并且那会在……它会……

（原英文表述不太完整和清晰，此翻译仅基于字面内容） 

9540
06:42:31,520 --> 06:42:35,160
围绕 K 循环，然后处理那一列外部数据（EXT 一般为 External 的缩写，这里结合语境意译为外部数据 ） 

9541
06:42:33,558 --> 06:42:37,840
索引将告诉我们是哪个位置

9542
06:42:35,160 --> 06:42:39,558
相对于那个线来说，我们现在的位置是对的。

9543
06:42:37,840 --> 06:42:41,320
当然，这样我们就可以像并行处理……（原文未完整）

9544
06:42:39,558 --> 06:42:44,120
ACT 实际负载

9545
06:42:41,320 --> 06:42:45,680
部分，然后我们对 B 做同样的事情

9546
06:42:44,120 --> 06:42:48,718
好吧，所以我们有这个，他们也有这个

9547
06:42:45,680 --> 06:42:52,160
呃，然后我们……我们有……我们有

9548
06:42:48,718 --> 06:42:54,798
比如我们到哪一排了，然后呢，呃，我们

9549
06:42:52,160 --> 06:42:56,360
本质上想要跨越那个数字

9550
06:42:54,798 --> 06:42:59,160
基于 n ，然后得到那个结果

9551
06:42:56,360 --> 06:43:02,320
偏移列索引，嗯，所以就是这样

9552
06:42:59,160 --> 06:43:04,680
这就是
在这里我们把一切都同步好，所以

9553
06:43:02,320 --> 06:43:07,000
这又是在街区层面上

注：“at the at the”可能存在表述错误，不过我按照原文内容进行了翻译。 

9554
06:43:04,680 --> 06:43:09,478
所以通常情况下，一个内核运行在……（原英文文本可能存在表述错误，“so it so”可能有误） 

9555
06:43:07,000 --> 06:43:11,080
线程级别，但因为我们正在做

9556
06:43:09,478 --> 06:43:13,798
同步线程，它将应用于所有情况

9557
06:43:11,080 --> 06:43:15,120
它们之中，所以所有的线程，呃，在……之内

9558
06:43:13,798 --> 06:43:16,478
在这个块里面实际上是

9559
06:43:15,120 --> 06:43:17,760
要去排队了 他们都要去 我们……

9560
06:43:16,478 --> 06:43:19,080
打算设置一道屏障，而且他们所有人都……

9561
06:43:17,760 --> 06:43:22,280
他们打算碰面，而且他们将会……

9562
06:43:19,080 --> 06:43:24,240
在同一个相同的地点同步，对吧

9563
06:43:22,280 --> 06:43:27,200
嗯，然后我们就推进这个街区。

9564
06:43:24,240 --> 06:43:29,040
下一步的规划 所以当我们，呃

9565
06:43:27,200 --> 06:43:31,080
当我们需要再次进行这项负载操作时，这个……

9566
06:43:29,040 --> 06:43:32,440
已经准备好了，而且我们不想……我们

9567
06:43:31,080 --> 06:43:33,600
不想为这事操心了

9568
06:43:32,440 --> 06:43:35,878
再也不了，对吧

9569
06:43:33,600 --> 06:43:38,000
好的，那么记住 A 和 B 仅仅是

9570
06:43:35,878 --> 06:43:41,840
指针 当我们向上滚动时 我们会看到

9571
06:43:38,000 --> 06:43:44,120
A 和 B 是指向呃浮点型数组的指针

9572
06:43:41,840 --> 06:43:46,120
好的，那么当这些被布置在……的时候

9573
06:43:44,120 --> 06:43:49,040
记忆 呃 它们……它们并非像……就是那样的

9574
06:43:46,120 --> 06:43:50,760
不像数组的数组，嗯，或者像

9575
06:43:49,040 --> 06:43:52,478
一个指针数组，其中每个

9576
06:43:50,760 --> 06:43:54,160
那个数组里的指针指向一个新数组

9577
06:43:52,478 --> 06:43:56,798
就像我们在 C 和 C++ 里所做的那样

9578
06:43:54,160 --> 06:43:58,680
复习章节 事情不是那样的 这是

9579
06:43:56,798 --> 06:44:01,280
这简直就是一个 这简直就是

9580
06:43:58,680 --> 06:44:04,080
只是一个指针，并且这个指针是

9581
06:44:01,280 --> 06:44:05,760
在那件事开始的时候，那就是开端

9582
06:44:04,080 --> 06:44:07,040
在内存中布局的数组的

9583
06:44:05,760 --> 06:44:08,878
所以这不是实际价值，它只是

9584
06:44:07,040 --> 06:44:10,878
内存地址，所以如果我们考虑那个

9585
06:44:08,878 --> 06:44:12,638
内存地址，然后我们对它加 1，它会

9586
06:44:10,878 --> 06:44:15,360
转到下一个索引
下一个
下一个

9587
06:44:12,638 --> 06:44:17,320
下一个，好的，嗯，那就是我们要……的（这里原句不完整） 

9588
06:44:15,360 --> 06:44:20,120
在这里做的事，所以我们已经在……里做过这个了

9589
06:44:17,320 --> 06:44:23,240
上次我们已经在这里做过这个了，嗯，在哪里呢

9590
06:44:20,120 --> 06:44:27,638
我们，还是说就是这部分，我们只是，我们只是

9591
06:44:23,240 --> 06:44:30,520
再往前推进 嗯 所以说 A 推进 嗯

9592
06:44:27,638 --> 06:44:33,840
本质上再加上一整个块的大小

9593
06:44:30,520 --> 06:44:37,280
所以我们前进，我们只是前进

9594
06:44:33,840 --> 06:44:38,320
另外，呃，把这个值加到 a 上，所以

9595
06:44:37,280 --> 06:44:40,478
它正在进行

9596
06:44:38,320 --> 06:44:42,798
它只会增加那么多

9597
06:44:40,478 --> 06:44:44,120
无论我们把它设置成什么，然后这是

9598
06:44:42,798 --> 06:44:46,638
将会增加，但它会有

9599
06:44:44,120 --> 06:44:50,360
那一大步迈得很对，所以那落后的……

9600
06:44:46,638 --> 06:44:52,478
B 的维数是 n，所以就像 K 乘以 n 一样

9601
06:44:50,360 --> 06:44:54,320
所以它将会……它将会结束

9602
06:44:52,478 --> 06:44:57,240
对，它就要结束了，而且只是

9603
06:44:54,320 --> 06:45:00,558
打算去寻找下一个类似的东西

9604
06:44:57,240 --> 06:45:01,638
下一个在，呃，在B里，对吧，然后

9605
06:45:00,558 --> 06:45:03,878
就是这样，这真的就是我们所有的情况了。 

9606
06:45:01,638 --> 06:45:06,200
在那里做（事情）

9607
06:45:03,878 --> 06:45:08,360
那么接下来我们进入下一部分，呃，这

9608
06:45:06,200 --> 06:45:10,000
这里实际上是许多奇迹发生的地方

9609
06:45:08,360 --> 06:45:11,920
我会尽我所能解释这一点，但

9610
06:45:10,000 --> 06:45:15,440
这部分有点凭直觉的感觉

9611
06:45:11,920 --> 06:45:18,478
很难，所以这里有好几个福布斯（相关人物或事物）在这儿 

9612
06:45:15,440 --> 06:45:21,718
我们有这个索引，我们会遍历它，遍历次数为 BK 次 

9613
06:45:18,478 --> 06:45:25,280
呃，我们有这个浮标，我们有这个

9614
06:45:21,718 --> 06:45:28,000
这个特定的浮点数 嗯 这个 这个 这个

9615
06:45:25,280 --> 06:45:30,000
抱歉，这是个临时变量。

9616
06:45:28,000 --> 06:45:31,160
然后我们在这里有一个内循环，所以

9617
06:45:30,000 --> 06:45:33,558
我会尽力把这解释清楚。 

9618
06:45:31,160 --> 06:45:36,920
可能，嗯

9619
06:45:33,558 --> 06:45:38,558
我们跳回到这里，我们注意到，呃……

9620
06:45:36,920 --> 06:45:40,000
起初，我们有这两个

9621
06:45:38,558 --> 06:45:43,080
我们试图相乘的矩阵

9622
06:45:40,000 --> 06:45:44,558
在一起 所以这是 呃 这是一个 和

9623
06:45:43,080 --> 06:45:46,280
这是B，对吧，而且我们有这个，这个

9624
06:45:44,558 --> 06:45:50,520
像我们在……上所做的那样处理瓷砖交叉处

注：原英文句子似乎不完整，“on the”后面应该还有内容。这里根据现有内容进行了基本翻译。 

9625
06:45:46,280 --> 06:45:52,280
那边有块白板，嗯，所以说真的……

9626
06:45:50,520 --> 06:45:55,040
魔法发生的时刻就像是在……

注：原英文表述存在重复用词的语病，翻译时按大致语义进行了处理。 

9627
06:45:52,280 --> 06:45:56,638
这些循环，没错，我们已经处理过了，嗯

9628
06:45:55,040 --> 06:45:58,398
在这个外面的（部分）里，实际上我们已经……

9629
06:45:56,638 --> 06:45:59,878
拿上我们已经有的方块瓷砖

9630
06:45:58,398 --> 06:46:03,160
这些存于共享内存中，现在我们有

9631
06:45:59,878 --> 06:46:04,718
用它们进行快速运算，所以我们开始

9632
06:46:03,160 --> 06:46:06,240
一直到这里，在这儿我们实际上有

9633
06:46:04,718 --> 06:46:09,558
这些都在共享内存里，对吧，这是一个

9634
06:46:06,240 --> 06:46:11,558
又高又不太宽，这是，呃

9635
06:46:09,558 --> 06:46:13,040
宽且有点高，对吧，所以它是

9636
06:46:11,558 --> 06:46:18,600
它有点匹配

9637
06:46:13,040 --> 06:46:23,520
向上，然后在这儿里面，我们要做的是

9638
06:46:18,600 --> 06:46:26,000
我们留意我们是如何对索引（idx）进行迭代的

9639
06:46:23,520 --> 06:46:28,000
然后在这里我们进行迭代，呃，遍历

9640
06:46:26,000 --> 06:46:31,160
通过这个这个这个商标（TM），没错，所以我们

9641
06:46:28,000 --> 06:46:35,440
有这个索引（idx），然后是结果索引（res idx），呃，结束

9642
06:46:31,160 --> 06:46:38,040
所以如果我们真的回到这里，嗯

9643
06:46:35,440 --> 06:46:40,600
本质上正在发生的事情是这样的，在……

9644
06:46:38,040 --> 06:46:44,958
最内层循环中的最低层级

9645
06:46:40,600 --> 06:46:46,920
资源索引正在经历，呃，就像我们……我们…… 

9646
06:46:44,958 --> 06:46:48,398
这里有个跳跃动作，我会解释一下。

9647
06:46:46,920 --> 06:46:52,000
像我们这样在一秒内完成索引操作

9648
06:46:48,398 --> 06:46:54,040
实际上阿韦在那里，但资源索引正在变化

注：由于原文 “res idx” 一般理解为 “resource index”（资源索引），但原句 “res idx is going” 表意不太清晰，以上翻译是根据字面做出的大致处理。 

9649
06:46:52,000 --> 06:46:57,240
通过这些，它正在推进，呃

9650
06:46:54,040 --> 06:46:59,520
垂直向下，而且它在不断增加

9651
06:46:57,240 --> 06:47:01,840
无论这个值是什么，以便

9652
06:46:59,520 --> 06:47:03,558
B 中左上角的那个顶部

9653
06:47:01,840 --> 06:47:06,000
B 中的左上角值将保持不变

9654
06:47:03,558 --> 06:47:08,478
同样的，资源索引（res idx）只是要

9655
06:47:06,000 --> 06:47:11,160
与那个值相乘，它将会

9656
06:47:08,478 --> 06:47:12,958
去做，然后它会计算一个偏导数（注：“partial”常见含义有“偏导数”等，需结合具体语境确定，这里为常见可能义）

9657
06:47:11,160 --> 06:47:16,680
沿此方向的点积

9658
06:47:12,958 --> 06:47:19,718
现在这一列，现在当我们……呃，当

9659
06:47:16,680 --> 06:47:22,680
我们对呃 idx 进行迭代，接下来会怎样

9660
06:47:19,718 --> 06:47:24,478
发生的事情是，呃，IDX要……它要……

9661
06:47:22,680 --> 06:47:26,760
以这种方式继续前行，并且它将会

9662
06:47:24,478 --> 06:47:29,040
沿着这条路走，对吧，所以注意看如何…… 

9663
06:47:26,760 --> 06:47:30,558
这些 这些箭头被 被涂成了非常（这里原文似乎不完整）

9664
06:47:29,040 --> 06:47:33,638
同样地，他们实际上是……

9665
06:47:30,558 --> 06:47:36,320
同样的颜色，这意味着我们要…… 

9666
06:47:33,638 --> 06:47:38,958
idx 将在 B 中向下演变

9667
06:47:36,320 --> 06:47:43,920
并且索引（idx）将会演变成，呃，到那个…… 

9668
06:47:38,958 --> 06:47:45,718
没错，所以无论何时我们像这样进化 

9669
06:47:43,920 --> 06:47:47,120
其一，它本质上将会……（原句“res”可能不完整，导致语义不太明确）

9670
06:47:45,718 --> 06:47:50,000
idx 将会取这个值，它是

9671
06:47:47,120 --> 06:47:52,200
打算去，然后我们要，呃

9672
06:47:50,000 --> 06:47:54,200
向前进化一步，然后看看九号在哪里

9673
06:47:52,200 --> 06:47:56,040
即将重置，然后它将会进行（下一步动作）。 

9674
06:47:54,200 --> 06:47:57,920
一个点积 下一个的部分点积

9675
06:47:56,040 --> 06:47:59,958
右列 它将进行部分操作

9676
06:47:57,920 --> 06:48:02,280
点积，呃，用于下一列以及

9677
06:47:59,958 --> 06:48:05,280
它会一直这样做，直到

9678
06:48:02,280 --> 06:48:07,000
它在里面，里面，呃，完成了。

9679
06:48:05,280 --> 06:48:09,360
这个，整个这一部分，然后当……的时候

9680
06:48:07,000 --> 06:48:12,320
这些向内进化，对吧，所以当……

9681
06:48:09,360 --> 06:48:14,360
这是当它向前推进的时候，嗯

9682
06:48:12,320 --> 06:48:16,320
而且甚至都没考虑过资源（此处“res”可能是“resources”的缩写，需结合上下文确定准确含义）

9683
06:48:14,360 --> 06:48:17,718
我就只是想着，当然了

9684
06:48:16,320 --> 06:48:20,040
这些都在这个里面填满了。 

9685
06:48:17,718 --> 06:48:21,680
也是，但当这件事推进时，当这件事…… 

9686
06:48:20,040 --> 06:48:23,478
向前推进并与这个相乘

9687
06:48:21,680 --> 06:48:26,558
而且他们都在一点一点地往一个方向挪动 

9688
06:48:23,478 --> 06:48:30,120
时间如点，这就是正在发生的情况，正如…… 

9689
06:48:26,558 --> 06:48:32,798
idx正在上升，嗯，这些是

9690
06:48:30,120 --> 06:48:34,878
实际上表现得有点像……

9691
06:48:32,798 --> 06:48:39,000
本质上就是小方块，对吧，所以

9692
06:48:34,878 --> 06:48:41,440
你最终会计算这个特定的呃

9693
06:48:39,000 --> 06:48:44,638
你最终会计算出完整的点积

9694
06:48:41,440 --> 06:48:47,958
这个的产物，所以当……当这个…… 

9695
06:48:44,638 --> 06:48:50,718
移动起来，就像这里大概四分之一是…… 

9696
06:48:47,958 --> 06:48:54,200
做得对
四分之一已经完成了，然后它

9697
06:48:50,718 --> 06:48:56,080
向上移动
完成一半了
完成一半了
75
75

9698
06:48:54,200 --> 06:48:59,280
然后一旦那个完成了，它就全部完成了。 

9699
06:48:56,080 --> 06:49:02,080
将整个索引的所有四个步骤进行演进

9700
06:48:59,280 --> 06:49:03,958
就在这里进行计算，于是我们注意到

9701
06:49:02,080 --> 06:49:06,120
当我们进行资源索引（res idx）操作，然后继续推进的时候

9702
06:49:03,958 --> 06:49:09,760
历经这一切，我们最终

9703
06:49:06,120 --> 06:49:11,718
完成整一行，所以当我们继续时

9704
06:49:09,760 --> 06:49:14,680
通过这种方式以及这些……这个……这个

9705
06:49:11,718 --> 06:49:18,360
向前推进，我们一次完成一列。

9706
06:49:14,680 --> 06:49:24,280
一次只处理一列的时间，呃

9707
06:49:18,360 --> 06:49:27,160
每个线程完成，所以当我们，嗯

9708
06:49:24,280 --> 06:49:30,360
当我们有其他线程表现得像

9709
06:49:27,160 --> 06:49:32,200
线程列和线程行，其中

9710
06:49:30,360 --> 06:49:33,920
就像这些小方块一样在起作用，它们

9711
06:49:32,200 --> 06:49:36,920
正在向下滑落而不是像（后面内容缺失）

9712
06:49:33,920 --> 06:49:38,200
小的独立一维柱状体 嗯 你

9713
06:49:36,920 --> 06:49:41,320
实际上最终会计算出整个

9714
06:49:38,200 --> 06:49:42,600
所以线程列是这样排列的

注：你提供的英文文本似乎存在一些表述问题，可能不太符合常规语法，但我按照你要求进行了逐字翻译。 

9715
06:49:41,320 --> 06:49:45,878
一路前行，就好像从本质上来说是这样的

9716
06:49:42,600 --> 06:49:48,718
矩阵 B 中的所有列索引

9717
06:49:45,878 --> 06:49:52,000
平铺，然后你就有了线行

9718
06:49:48,718 --> 06:49:54,120
哪些在这里，所以这将会

9719
06:49:52,000 --> 06:49:56,200
计算……中的所有列

9720
06:49:54,120 --> 06:49:58,920
C 它会……它会覆盖一切

9721
06:49:56,200 --> 06:50:01,040
在拼接方面的它们，然后

9722
06:49:58,920 --> 06:50:02,398
这也将涵盖他们所有人

9723
06:50:01,040 --> 06:50:05,240
所以实际上你最终得到的就是你（自己）

9724
06:50:02,398 --> 06:50:08,280
可以通过给出一个来完成整个板块（此句英文表述似乎不完整，翻译可能不够准确）

9725
06:50:05,240 --> 06:50:10,878
线程还有更多操作要做，所以当我们…… 

9726
06:50:08,280 --> 06:50:13,878
实际上跳进这个里面



9727
06:50:10,878 --> 06:50:15,958
嗯，我们可以看到，首先我们有

9728
06:50:13,878 --> 06:50:18,520
这个临时的 B，对吧，所以这是来自……

9729
06:50:15,958 --> 06:50:19,878
B共享内存，这就是为什么我们只是

9730
06:50:18,520 --> 06:50:22,160
说

9731
06:50:19,878 --> 06:50:23,958
idxx 为零，这是第一次迭代。

9732
06:50:22,160 --> 06:50:26,718
它还没有，或者说迭代为零的时候它…… 

9733
06:50:23,958 --> 06:50:27,718
还没有变化，所以这是零，并且

9734
06:50:26,718 --> 06:50:30,760
它正在进行；它要开始了（具体含义需结合语境确定）

9735
06:50:27,718 --> 06:50:35,280
它将会不断演变，你知道的，贯穿……（这里across后面内容缺失，句子表意不完整） 

9736
06:50:30,760 --> 06:50:36,878
BN 零次，对吧，所以 0 乘以…… 

9737
06:50:35,280 --> 06:50:40,000
那是 z，然后再加上螺纹

9738
06:50:36,878 --> 06:50:41,680
列，如果那也是，如果那也是

9739
06:50:40,000 --> 06:50:43,520
零，那么它就只会在这里

9740
06:50:41,680 --> 06:50:47,680
对，实际上就会是

9741
06:50:43,520 --> 06:50:49,440
呃，当 idx 上升时，那么它是

9742
06:50:47,680 --> 06:50:51,680
将要；打算；即将去

9743
06:50:49,440 --> 06:50:53,320
嗯，就像这样，它不会……它不会（这样）

9744
06:50:51,680 --> 06:50:55,440
打算往这个方向移动，那个……这个

9745
06:50:53,320 --> 06:50:57,440
这里的偏移量是相对于线程本身而言的。

9746
06:50:55,440 --> 06:50:58,958
线程索引本身，但我们是

9747
06:50:57,440 --> 06:51:00,600
实际上要向下移动

9748
06:50:58,958 --> 06:51:04,120
对，那就是……就像我之前说的那样，这就是那个索引（由于 “do idx” 可能不是常见规范表达，这里按发音可能推测是 “index” 索引，需结合具体语境确认） 

9749
06:51:00,600 --> 06:51:07,958
之前在解释，然后呢，你有……

9750
06:51:04,120 --> 06:51:10,160
呃，这个 res idx（结果索引），以及……（这里原文不完整，翻译仅供参考当前部分） 

9751
06:51:07,958 --> 06:51:13,958
这要经过翻译记忆库（TM），对吧，所以这是

9752
06:51:10,160 --> 06:51:15,600
我们这里的这个小方块

9753
06:51:13,958 --> 06:51:18,120
嗯

9754
06:51:15,600 --> 06:51:20,920
当我们真正去审视这究竟是怎样的情况时

9755
06:51:18,120 --> 06:51:23,638
积累，记住这就是规模

9756
06:51:20,920 --> 06:51:26,000
呃，这就是我们要使用的TM（可能指某种工具、模型等，需结合上下文确定）的规模。 

9757
06:51:23,638 --> 06:51:27,840
用这个红色索引遍历翻译记忆库（TM）

9758
06:51:26,000 --> 06:51:29,680
或者资源索引，那将是那个……（这里原文表述不太完整和清晰） 

9759
06:51:27,840 --> 06:51:31,718
通过交易管理系统（TM）刷取该金额

注：原句“POS the the amount”中“the”重复使用，可能是表述有误，推测正确表述为“POS the amount” ，POS在这里作动词，常见意思是通过销售点终端机刷取金额 ；TM推测为Transaction Management的缩写，即交易管理系统 。 

9760
06:51:29,680 --> 06:51:34,360
我们已经反复研究过了，我们正在进行设定。

9761
06:51:31,718 --> 06:51:36,878
那个索引指向共享空间里的一个位置。 

9762
06:51:34,360 --> 06:51:41,718
记忆，而这个确切的地方将会

9763
06:51:36,878 --> 06:51:45,718
所以是线程行次数，呃，TM 加上

9764
06:51:41,718 --> 06:51:47,878
资源索引 对 所以在这个里的线程行

9765
06:51:45,718 --> 06:51:50,240
此案例中的线程行是

9766
06:51:47,878 --> 06:51:52,360
无论它落在这些中的哪一个上，对吧

9767
06:51:50,240 --> 06:51:55,600
所以那是它的特定一行

9768
06:51:52,360 --> 06:51:57,680
考虑到我们在进化啊，这很令人沮丧 （这里“falls at”表述不太准确，推测可能是“it's frustrating at”之类有表达沮丧意思的内容，按可能的意思补充翻译）

9769
06:51:55,600 --> 06:52:00,200
就像在TM模块里一样，对吧，就是那样，就是那样

9770
06:51:57,680 --> 06:52:02,558
那就是我们进化的程度，我们……

（原英文句子似乎表述不太完整或存在一定语病，以上翻译是尽力基于现有内容进行的处理。） 

9771
06:52:00,200 --> 06:52:07,200
我们每次都在进步，然后这个结果…… 

9772
06:52:02,558 --> 06:52:09,478
索引部分 嗯 第一个索引是 我们有多少（这里原英文句子可能存在表述不完整或不太准确的情况） 

9773
06:52:07,200 --> 06:52:11,240
垂直偏移，所以我们像这样推进

9774
06:52:09,478 --> 06:52:12,878
四个，或者像八个，或者四个，或者八个

9775
06:52:11,240 --> 06:52:15,920
向下，然后我们有这个

9776
06:52:12,878 --> 06:52:17,920
额外偏移量资源索引 嗯 但我们有

9777
06:52:15,920 --> 06:52:19,600
以确保我们实际上能到达

9778
06:52:17,920 --> 06:52:21,718
那特定的一块，因为它……它正在（发展/进行等，需结合语境确定“going”含义） 

9779
06:52:19,600 --> 06:52:23,160
像这样在内存中进行布局，对吧

9780
06:52:21,718 --> 06:52:25,080
所以我们必须确保我们不断发展

9781
06:52:23,160 --> 06:52:28,240
笔直向下，然后我们到达……

9782
06:52:25,080 --> 06:52:28,240
那个特定的资源 ID 示例

9783
06:52:28,680 --> 06:52:34,440
位置 现在我们将其乘以 k

9784
06:52:32,840 --> 06:52:35,680
这让我们的事情变得容易多了

9785
06:52:34,440 --> 06:52:37,840
对，基本上问题就解决了。

9786
06:52:35,680 --> 06:52:40,520
那个问题，所以不管我们想要多少…… 

9787
06:52:37,840 --> 06:52:43,280
顺着这条线索往下查，不管是哪一条

9788
06:52:40,520 --> 06:52:46,080
线程行 我们正在谈论时代 商标

9789
06:52:43,280 --> 06:52:49,718
你知道的，就是那个街区

9790
06:52:46,080 --> 06:52:51,920
空间，嗯，加上资源索引，也就是那个

9791
06:52:49,718 --> 06:52:54,680
偏移量，然后将所有这些都乘以…… 

9792
06:52:51,920 --> 06:52:56,680
乘以 BK，就是这个，这个 K 维度

9793
06:52:54,680 --> 06:52:57,558
在这里，而且那只会乘以它的……（此英文句子表意不太完整和清晰） 

9794
06:52:56,680 --> 06:53:02,200
将要；打算

9795
06:52:57,558 --> 06:53:02,200
直接前往我们该去的地方

9796
06:53:02,638 --> 06:53:06,638
然后我们只需加上索引（idx）偏移量，该偏移量如

9797
06:53:05,280 --> 06:53:08,520
我突出显示了

9798
06:53:06,638 --> 06:53:10,520
之前简直就只是要去……

9799
06:53:08,520 --> 06:53:11,920
以那种方式取得进展，所以它将会

9800
06:53:10,520 --> 06:53:14,200
一直迭代到起始位置

9801
06:53:11,920 --> 06:53:16,558
位置，呃，然后索引（idx）将会

9802
06:53:14,200 --> 06:53:19,440
告诉我们它已经到了……（原文句子不完整）

9803
06:53:16,558 --> 06:53:22,718
对，呃，那么你要做这个吗

9804
06:53:19,440 --> 06:53:24,760
这里有一个向下遍历的索引，并且

9805
06:53:22,718 --> 06:53:27,398
在这里它通向……（因文本不完整，这里“通向”后面的内容未知）

注：“traverse”有“穿过；横贯；通向”等意思，结合语境“traverse to”这里意译为“通向” 。 

9806
06:53:24,760 --> 06:53:31,120
现在，如果我们回去，我们就会……（原句未完整，这里补充省略号表示句子不完整） 

9807
06:53:27,398 --> 06:53:33,840
将这个，嗯，乘以这个，我们就……

9808
06:53:31,120 --> 06:53:37,320
用，呃，临时的B乘以它

9809
06:53:33,840 --> 06:53:39,958
价值 请记住这是唯一的

9810
06:53:37,320 --> 06:53:41,280
控制这个的是索引（idx），它

9811
06:53:39,958 --> 06:53:43,200
我们已经强调过这将会……

9812
06:53:41,280 --> 06:53:45,638
让它往下走，然后是线

9813
06:53:43,200 --> 06:53:47,080
列，所以线程列，正如我所提到的

9814
06:53:45,638 --> 06:53:48,920
在再次开始之前，我们有点只是要去……

9815
06:53:47,080 --> 06:53:50,160
就从视觉示例开始

9816
06:53:48,920 --> 06:53:53,200
然后进入代码，接着

9817
06:53:50,160 --> 06:53:55,280
将其与我们的视觉示例联系起来，所以

9818
06:53:53,200 --> 06:53:57,878
螺纹柱是指那个水平的（部件）

注：这里原文“thread column”一般可理解为“螺纹柱” ，但由于缺乏更多上下文，此翻译可能存在不准确之处。 

9819
06:53:55,280 --> 06:53:59,360
偏移量，并且就好像每个线程是

9820
06:53:57,878 --> 06:54:01,040
只是打算换个水平角度

9821
06:53:59,360 --> 06:54:03,680
向右偏移，所以这取决于哪一个

9822
06:54:01,040 --> 06:54:07,200
线程 我们在，呃

9823
06:54:03,680 --> 06:54:09,240
然后我们回到这里，嗯，然后我们

9824
06:54:07,200 --> 06:54:10,360
有这么一场争论，没错，就是这样

9825
06:54:09,240 --> 06:54:12,798
这仅仅取决于哪一个

9826
06:54:10,360 --> 06:54:15,240
块 我们现在所处的这个
所以在这种情况下 我们不是

9827
06:54:12,798 --> 06:54:17,440
在街区呃……抱歉，我们没到（那个地方）。 

9828
06:54:15,240 --> 06:54:20,478
在线程行零，我们处于线程行

9829
06:54:17,440 --> 06:54:22,240
其一，所以它要前往特拉弗斯TM（注：这里“Traverse TM”不太明确具体所指，“TM”可能是商标标识）呃

9830
06:54:20,478 --> 06:54:24,000
一层层地铺下来，在这种情况下就像

9831
06:54:22,240 --> 06:54:26,280
也许是四个，或者八个，或者随便多少个都行

9832
06:54:24,000 --> 06:54:28,040
我们选的数字，对，嗯，然后它是

9833
06:54:26,280 --> 06:54:29,920
最终会到那里，然后是剩下的部分

9834
06:54:28,040 --> 06:54:31,600
这些数学知识将确保我们

9835
06:54:29,920 --> 06:54:34,840
相对于……到达正确的位置

9836
06:54:31,600 --> 06:54:34,840
居住并且

需要说明的是，“resid”并不是一个常见的正确英文单词，可能是“reside”的拼写错误，“reside”意为“居住；定居” 。 

9837
06:54:35,280 --> 06:54:40,680
索引 你想支付的其他一些东西

9838
06:54:37,200 --> 06:54:43,600
注意这里，这些实际上是如何……（原英文文本似乎表述不完整） 

9839
06:54:40,680 --> 06:54:46,798
呃，它们在记忆中是连贯的，对吧，所以在……

9840
06:54:43,600 --> 06:54:48,878
记忆，嗯，当我们……的时候要记住

9841
06:54:46,798 --> 06:54:50,320
当我们在……的时候加载这些列

9842
06:54:48,878 --> 06:54:51,878
我们正在加载这些小的柱状片段。

9843
06:54:50,320 --> 06:54:54,478
在……在……呃……在……

9844
06:54:51,878 --> 06:54:55,878
记忆 我们正在加载它们，就好像它们是

9845
06:54:54,478 --> 06:54:58,080
就像相邻的、彼此紧挨着，对吧

9846
06:54:55,878 --> 06:55:00,398
所以像这样的零号线程将会是

9847
06:54:58,080 --> 06:55:01,840
与第一螺纹列相邻

9848
06:55:00,398 --> 06:55:03,680
线程列Z与线程相邻

9849
06:55:01,840 --> 06:55:05,840
第一列 它们一个挨着一个

9850
06:55:03,680 --> 06:55:08,200
其他线程 第二列 第三列 第四列 第五列

9851
06:55:05,840 --> 06:55:10,840
好的，那么当我们实际加载这个时

9852
06:55:08,200 --> 06:55:12,240
内存访问的线程级别

9853
06:55:10,840 --> 06:55:14,320
将会是中欧夏令时，将会是

9854
06:55:12,240 --> 06:55:16,240
结合起来，我们不必对你这样做

不过原英文文本“combined we're not going to have to you”表述不太符合常见语法规则，可能存在一些错误，但我是按照字面意思进行翻译的。 

9855
06:55:14,320 --> 06:55:18,080
了解 想想这一步 然后就像

9856
06:55:16,240 --> 06:55:19,878
哦，我们需要进行两次内存访问以

9857
06:55:18,080 --> 06:55:22,958
把这两个都拿到
这就好像不行，你可以（拿到）

9858
06:55:19,878 --> 06:55:27,040
实际上很合适，嗯，就像一堆……像……

9859
06:55:22,958 --> 06:55:29,000
然而，你需要多少就合成一个，对吧

9860
06:55:27,040 --> 06:55:32,360
所以从技术层面来讲，你将会拥有的是

9861
06:55:29,000 --> 06:55:34,718
这里是，你将会，嗯

9862
06:55:32,360 --> 06:55:38,040
因为批量归一化（Batch Normalization，BN）是

9863
06:55:34,718 --> 06:55:40,280
640亿（这里BN可能是billion的缩写）是64，所以这……整个长度

9864
06:55:38,040 --> 06:55:41,798
这里将会有两个扭曲，所以

9865
06:55:40,280 --> 06:55:44,320
实际上它将会是，呃

9866
06:55:41,798 --> 06:55:48,600
就像我们需要进行的两次内存访问那样

9867
06:55:44,320 --> 06:55:50,320
做是因为，嗯，那就像一整个扭曲（状态/情况等，需结合语境确定warp的准确含义） 

9868
06:55:48,600 --> 06:55:52,360
那实际上可以进行内存访问

9869
06:55:50,320 --> 06:55:54,120
当我们有两个的时候真的很高效，那就是

9870
06:55:52,360 --> 06:55:56,798
实际上那只有两个内存

9871
06:55:54,120 --> 06:55:58,638
我们必须要担心的访问权限呃

9872
06:55:56,798 --> 06:56:00,878
所以我们拥有……真的很棒。

9873
06:55:58,638 --> 06:56:03,398
我们有这些胆甾醇，对吧，我……

注：你提供的文本可能存在拼写错误，“colest”可能不是一个正确的英文单词，推测可能是“cholesterol（胆固醇）”之类的词。  

9874
06:56:00,878 --> 06:56:05,760
意思是这个本身，而另一个不是

9875
06:56:03,398 --> 06:56:07,840
会很紧张，但没关系，嗯

9876
06:56:05,760 --> 06:56:09,798
因为我们，你知道的，我们仍然…… 

9877
06:56:07,840 --> 06:56:11,600
使用共享内存时我们真正关心的问题

9878
06:56:09,798 --> 06:56:14,160
不过问题在于，这些是最接近的（此处“colest”可能拼写有误，推测可能是“closest” ） 

9879
06:56:11,600 --> 06:56:15,240
对，列访问是最接近的，并且 

9880
06:56:14,160 --> 06:56:18,638
那会让事情变得真的……

9881
06:56:15,240 --> 06:56:21,040
真的很快，所以要重申一下，嗯，我们……

9882
06:56:18,638 --> 06:56:23,200
本质上进行迭代，然后我们完成

9883
06:56:21,040 --> 06:56:25,398
我们让线程完成 呃 那个

9884
06:56:23,200 --> 06:56:27,000
柱子，呃，有点像部分地，而且它们……

9885
06:56:25,398 --> 06:56:29,200
前进越过那个点

9886
06:56:27,000 --> 06:56:30,638
产品正在销售或者那个点 ID 示例（这句话原文可能存在表述错误，翻译只能基于现有文本尽量呈现大致意思） 

9887
06:56:29,200 --> 06:56:32,280
将会进化，而且它们……它们

9888
06:56:30,638 --> 06:56:34,398
向内合拢，然后它们会

9889
06:56:32,280 --> 06:56:35,958
慢慢地去完成那件事，对吧，然后

9890
06:56:34,398 --> 06:56:37,840
这些 这些单独的线索正在进行

9891
06:56:35,958 --> 06:56:38,878
完成这些列，对，这样它们就…… 

9892
06:56:37,840 --> 06:56:42,080
他们打算继续前进

9893
06:56:38,878 --> 06:56:44,360
资源索引，然后是操作索引分别是

9894
06:56:42,080 --> 06:56:45,878
以这种方式进化，所以你最终会

9895
06:56:44,360 --> 06:56:47,638
只是为了完成一整列，因为

9896
06:56:45,878 --> 06:56:50,520
这些对齐了，而这一个也对齐了。

9897
06:56:47,638 --> 06:56:53,680
所以你会得到 你会得到一堆……

9898
06:56:50,520 --> 06:56:56,360
这些，然后再来一个这样的东西

9899
06:56:53,680 --> 06:56:57,600
好的，那么接下来我们同步这些线程，我们

9900
06:56:56,360 --> 06:56:58,558
确保他们都跟上进度了，所以

9901
06:56:57,600 --> 06:57:00,120
我们实际上可以把……写出来

9902
06:56:58,558 --> 06:57:02,360
结果很安全，没错，这是为了一个…… 

9903
06:57:00,120 --> 06:57:03,718
特定的方块瓷砖，所以当我们有像……这样的情况时

9904
06:57:02,360 --> 06:57:04,600
在整个事情里有一堆它们，我们

9905
06:57:03,718 --> 06:57:06,958
我们有一堆块状瓷砖，我们是……（原句似乎未完整表达意思） 

9906
06:57:04,600 --> 06:57:08,240
担心……嗯，我们想确保

9907
06:57:06,958 --> 06:57:09,638
为此我们已经把它们同步好了。

9908
06:57:08,240 --> 06:57:10,920
当前方块图块，只是为了安全起见

9909
06:57:09,638 --> 06:57:12,558
目的，没错，我们不想把事情搞砸

9910
06:57:10,920 --> 06:57:14,920
有什么事吗？所以我们正要走，我们……

9911
06:57:12,558 --> 06:57:17,080
在那里会很安全，然后当我们……

9912
06:57:14,920 --> 06:57:19,160
实际上把结果写出来，它是

9913
06:57:17,080 --> 06:57:22,160
将会和我们所……的非常相似

9914
06:57:19,160 --> 06:57:25,798
实际上是在这儿上面做的，嗯，所以我们

9915
06:57:22,160 --> 06:57:27,558
再把这个图灵机（TM）术语过一遍，嗯

9916
06:57:25,798 --> 06:57:31,840
我们即将迎来闲聊时光

9917
06:57:27,558 --> 06:57:34,320
DM 加上红色资源索引，然后乘以 n

9918
06:57:31,840 --> 06:57:38,520
对，所以从更宏观的角度来看，n 处于……的范畴中 

9919
06:57:34,320 --> 06:57:40,840
整个，整个 C 矩阵，嗯，还有

9920
06:57:38,520 --> 06:57:43,360
然后再加上实际的呃螺纹柱

9921
06:57:40,840 --> 06:57:45,478
其本身将是那个偏移量

9922
06:57:43,360 --> 06:57:47,478
呃，那才是真正的呃索引。

9923
06:57:45,478 --> 06:57:51,160
我们把它写出来，然后我们要……

9924
06:57:47,478 --> 06:57:52,718
每次遍历张量模式（TM）或八个索引

9925
06:57:51,160 --> 06:57:54,240
单线程，所以每个线程都将

9926
06:57:52,718 --> 06:57:56,080
而是正确地写出八个元素

9927
06:57:54,240 --> 06:57:59,240
仅仅是一人写出了八个

9928
06:57:56,080 --> 06:58:01,360
元素，嗯，然后我们……我们只是

9929
06:57:59,240 --> 06:58:02,958
会记住这个的，你知道的，这个

9930
06:58:01,360 --> 06:58:05,040
这个线程的结果 结果 我们只是

9931
06:58:02,958 --> 06:58:07,760
本质上，每次我们写出 “it's” 时

9932
06:58:05,040 --> 06:58:09,240
只是要填充那个索引，所以

9933
06:58:07,760 --> 06:58:12,160
这就像是一种非常简单的方式，仅仅是

9934
06:58:09,240 --> 06:58:13,840
记录一下，呃，记录一下是哪些

9935
06:58:12,160 --> 06:58:16,440
我们在最低的层面上进行书写。

9936
06:58:13,840 --> 06:58:18,440
像流多处理器（SM）和寄存器这样的硬件，所以它是

9937
06:58:16,440 --> 06:58:20,320
只是为了让我们在……上的工作更轻松

9938
06:58:18,440 --> 06:58:22,360
那个级别，所以我们简直就可以

9939
06:58:20,320 --> 06:58:23,680
把它们一个一个地存放起来，这就像……八个一个（这里“eight an”表述不太符合常规，可能有误） 

9940
06:58:22,360 --> 06:58:25,160
一个包含八个元素的数组，然后我们

9941
06:58:23,680 --> 06:58:26,638
写出那个包含八个元素的数组

9942
06:58:25,160 --> 06:58:29,840
我们不必担心步幅或者

9943
06:58:26,638 --> 06:58:32,320
任何那样的东西，对，嗯，我们相乘

9944
06:58:29,840 --> 06:58:34,120
阿尔法，呃，针对每一个，针对每一个个体

9945
06:58:32,320 --> 06:58:36,760
对每个索引进行操作，然后我们进行…… 

9946
06:58:34,120 --> 06:58:41,360
贝塔也是如此，所以贝塔是另一个术语

9947
06:58:36,760 --> 06:58:43,760
而且我们有 C，呃，我的意思是 c 仅仅是

9948
06:58:41,360 --> 06:58:45,680
从本质上来说，我们不过是元素而已，或者说我们就是元素。 

9949
06:58:43,760 --> 06:58:47,360
我们正在逐点乘以 β，所以

9950
06:58:45,680 --> 06:58:49,680
就好像无论β是什么，也许就像

9951
06:58:47,360 --> 06:58:53,080
0.5 或者 3 或者不管是多少，我们…… 

9952
06:58:49,680 --> 06:58:55,558
只是将每一个都进行相乘，呃，所以

9953
06:58:53,080 --> 06:58:57,920
我们考虑这些进步以及那些……（原文“the the”可能有误）

9954
06:58:55,558 --> 06:59:00,798
也用于……进行抵消（由于原文表意不太完整，此翻译仅供参考） 

9955
06:58:57,920 --> 06:59:03,000
那太好了，所以现在我们实际上可以

9956
06:59:00,798 --> 06:59:06,080
生成，或者我们实际上可以看看这是怎样的

9957
06:59:03,000 --> 06:59:08,160
表现呃，所以还记得我们的……有多糟糕吗

9958
06:59:06,080 --> 06:59:11,680
最初的核心内容是我打算继续进行下去

9959
06:59:08,160 --> 06:59:13,040
然后运行SJ 00，只是为了向夸斯展示，嗯，它是…… 

9960
06:59:11,680 --> 06:59:16,520
我们要进行迭代，而且我们打算

9961
06:59:13,040 --> 06:59:18,320
获得约11.4、11.5太浮点运算每秒的 

9962
06:59:16,520 --> 06:59:20,760
性能，然后如果我们继续并

9963
06:59:18,320 --> 06:59:24,360
将块运行到 1，这样就能得到内核编号

9964
06:59:20,760 --> 06:59:24,360
四，接着跑吧

9965
06:59:24,520 --> 06:59:28,558
实际上，我们接下来要……（这里英文表述不太完整，译文结合语境做了一定推测补充）

9966
06:59:26,840 --> 06:59:29,878
比之前快了不少

9967
06:59:28,558 --> 06:59:32,958
那是

9968
06:59:29,878 --> 06:59:36,360
03 还有这个

9969
06:59:32,958 --> 06:59:36,360
呃，给它一个（机会之类，需结合语境）

9970
06:59:36,840 --> 06:59:42,600
其次，这一个给了我们大约11600 呃

9971
06:59:40,040 --> 06:59:44,240
1600吉次浮点运算，这台大约是3倍（的性能） 

9972
06:59:42,600 --> 06:59:46,920
我们之前所拥有事物的加速，这……

9973
06:59:44,240 --> 06:59:49,320
真的很不错，所以差不多就是这样

9974
06:59:46,920 --> 06:59:51,680
表明，呃，内存访问模式

9975
06:59:49,320 --> 06:59:54,440
你提供的英文文本存在表述错误，推测可能想表达 “We use so that the cooling of memory” ，翻译为：
我们使用（某种方式）以便实现内存的冷却。 

9976
06:59:51,680 --> 06:59:57,360
访问权限真的非常有用，而且

9977
06:59:54,440 --> 06:59:58,920
更有用的是使用单线程来

9978
06:59:57,360 --> 07:00:00,718
进行多次计算以计算

9979
06:59:58,920 --> 07:00:02,680
八个元素，而不只是一个，对吧

9980
07:00:00,718 --> 07:00:06,360
所以那真的极大地加快了我们的……（此处文本似乎不完整） 

9981
07:00:02,680 --> 07:00:07,478
那里的吞吐量和性能，所以现在

9982
07:00:06,360 --> 07:00:10,840
如果

9983
07:00:07,478 --> 07:00:13,600
嗯，实际上我在镜头外写了……我

9984
07:00:10,840 --> 07:00:17,040
写了一份单独的，呃，我写了一份单独的

9985
07:00:13,600 --> 07:00:19,840
函数是否在此处，还是在主函数文件中。

9986
07:00:17,040 --> 07:00:22,398
库（可能是cuu拼写有误）在凯尔的文件夹里面，所以我们……

9987
07:00:19,840 --> 07:00:25,200
可以很容易地把它编译起来 嗯 我……

9988
07:00:22,398 --> 07:00:27,958
我差不多就是做了，呃，导入的操作。

9989
07:00:25,200 --> 07:00:29,878
这……所以……这本质上是为了……（原英文表述不太符合正常语法逻辑，此翻译只能大致根据现有内容呈现） 

9990
07:00:27,958 --> 07:00:32,360
块平铺内核  用于……的头文件（这里原文“the the”可能有误，推测可能是笔误）

9991
07:00:29,878 --> 07:00:34,200
就在这里，呃，我加入了宏。

9992
07:00:32,360 --> 07:00:37,558
我们在上一个文件里有的那个，我…… 

9993
07:00:34,200 --> 07:00:40,878
初始化了主矩阵，大小为 1024×1024

9994
07:00:37,558 --> 07:00:44,398
1024 微米，然后是我们之前类似的 64、64

9995
07:00:40,878 --> 07:00:46,958
8加8，然后我就把这些都填上了

9996
07:00:44,398 --> 07:00:48,680
嗯，阿玛利克能不能就像……那样处理呢

9997
07:00:46,958 --> 07:00:49,798
这个，这个统一内存，它就像

9998
07:00:48,680 --> 07:00:52,160
打算只减少一堆……

9999
07:00:49,798 --> 07:00:53,798
官样文章，让事情呃稍微……

10000
07:00:52,160 --> 07:00:55,280
对我们来说有点快了，但你，你……

10001
07:00:53,798 --> 07:00:57,440
打算去看看那个……主要的东西


10002
07:00:55,280 --> 07:00:58,840
我们接下来要找的 嗯 我

10003
07:00:57,440 --> 07:01:00,718
正确地初始化所有内容，然后

10004
07:00:58,840 --> 07:01:02,040
我把这个内核叫做，呃，而且我们只是

10005
07:01:00,718 --> 07:01:05,958
试图弄清楚到底是什么

10006
07:01:02,040 --> 07:01:08,638
这里底层的代码看起来是这样的，所以如果

10007
07:01:05,958 --> 07:01:12,558
呃，如果我回到我运行过的这个命令

10008
07:01:08,638 --> 07:01:14,680
最近，nvcc（NVIDIA CUDA编译器驱动程序）D PTX，这意味着并行。

10009
07:01:12,558 --> 07:01:17,120
线程执行
并行线程

10010
07:01:14,680 --> 07:01:19,638
执行是CUDA编译后的结果

10011
07:01:17,120 --> 07:01:22,040
这是用于并行的汇编语言

10012
07:01:19,638 --> 07:01:23,840
处理器，呃，然后你就只有……（注：此处原文未完整，翻译只能根据现有内容处理） 

10013
07:01:22,040 --> 07:01:26,798
我们正在编译的文件，然后我们

10014
07:01:23,840 --> 07:01:30,920
输出内核。并行线程执行（PTX）

10015
07:01:26,798 --> 07:01:32,398
对，还是说我得离开这儿，嗯

10016
07:01:30,920 --> 07:01:36,920
然后进入

10017
07:01:32,398 --> 07:01:38,360
源内核，然后去运行它

10018
07:01:36,920 --> 07:01:40,878
这将为我们提供这个内核。

10019
07:01:38,360 --> 07:01:42,680
我就在这里打开的 PTX 文件 

10020
07:01:40,878 --> 07:01:49,558
把这个带来

10021
07:01:42,680 --> 07:01:49,558
我们往上进入内核。

10022
07:01:49,878 --> 07:01:56,958
PTX 我们注意到，呃，有很多……

10023
07:01:53,638 --> 07:01:58,600
这里有308行。

10024
07:01:56,958 --> 07:02:01,558
线条；行；台词；线路（需根据具体语境选择合适含义）

10025
07:01:58,600 --> 07:02:04,320
而且它并没有告诉我们任何特别的事情

10026
07:02:01,558 --> 07:02:07,760
具体的，具体的权利，就像我们能看到的那样

10027
07:02:04,320 --> 07:02:12,040
嗯，比如说，像一则广告，一则广告

10028
07:02:07,760 --> 07:02:15,760
操作，或者呃，像熔断器倍增广告

10029
07:02:12,040 --> 07:02:18,558
使用一个 一个32位浮点数

10030
07:02:15,760 --> 07:02:19,958
嗯，就好像我想着输出，然后

10031
07:02:18,558 --> 07:02:21,798
比如将这些相乘，然后再加上这个

10032
07:02:19,958 --> 07:02:23,280
其一，我记不清确切的顺序了，不过

10033
07:02:21,798 --> 07:02:25,330
就像融合乘加，没错，你可以

10034
07:02:23,280 --> 07:02:26,478
在这里找到所有这些说明

10035
07:02:25,330 --> 07:02:32,638
[音乐]

10036
07:02:26,478 --> 07:02:32,638
嗯，相乘，对，嗯

10037
07:02:33,000 --> 07:02:38,360
是的，我们有加载指令，所以

10038
07:02:35,718 --> 07:02:40,920
LD 所以它要加载呃一个浮动的（这里“浮动的”表述较模糊，需结合具体语境进一步明确，比如“浮动窗口”“浮动元素”等） 

10039
07:02:38,360 --> 07:02:44,840
把数字点进呃

10040
07:02:40,920 --> 07:02:44,840
分享到……进入……

注：你提供的内容“shared into the into the”可能存在表述错误，不是完整通顺的表达。 

10041
07:02:45,558 --> 07:02:52,160
静态随机存取存储器（SRAM），然后如果可以的话，我们就跳过这个。 

10042
07:02:48,478 --> 07:02:54,320
退出 Vim 呃，我有一个单独的……我（这里原文表述不太完整） 

10043
07:02:52,160 --> 07:02:57,520
同时输出了，这就是着色器

10044
07:02:54,320 --> 07:03:00,280
汇编 所以最初nvcc将

10045
07:02:57,520 --> 07:03:01,920
将所有内容编译成PTX，然后

10046
07:03:00,280 --> 07:03:03,638
PTX 将进一步编译为

10047
07:03:01,920 --> 07:03:05,520
着色器汇编代码，而这实际上是

10048
07:03:03,638 --> 07:03:09,440
在GPU上运行
着色器汇编是什么

10049
07:03:05,520 --> 07:03:12,040
它会执行，所以如果我们编译，呃，你知道的

10050
07:03:09,440 --> 07:03:14,000
此刻，真正的CUDA二进制文件

注：原英文文本表述不太符合常见的规范语法，这样的翻译只是尽量贴近语义进行的。 

10051
07:03:12,040 --> 07:03:16,120
我们运行的二进制文件，然后我们，接着…… 

10052
07:03:14,000 --> 07:03:18,958
我们，呃，把这个备份整合到……里去

10053
07:03:16,120 --> 07:03:21,520
着色器汇编语言，呃，是

10054
07:03:18,958 --> 07:03:25,878
实际执行，然后我们输出

10055
07:03:21,520 --> 07:03:25,878
在 CUDA 呃……CUDA 二进制文件中

10056
07:03:26,558 --> 07:03:32,280
格式化我们

10057
07:03:28,280 --> 07:03:32,280
呃，可以……

10058
07:03:33,080 --> 07:03:40,120
哦，选错了，让我，让我查一下真正的

10059
07:03:37,120 --> 07:03:43,478
快点，我们走
是的，所以我们已经把它整理好了

10060
07:03:40,120 --> 07:03:44,920
投入到这件事里，现在我们，呃，我们来看看它

10061
07:03:43,478 --> 07:03:47,920
再次通过特殊指令，所以

10062
07:03:44,920 --> 07:03:50,520
CUDA对象转储 呃 转储着色器汇编代码

10063
07:03:47,920 --> 07:03:53,680
然后基本上就是打开那个

10064
07:03:50,520 --> 07:03:56,120
它会给我们确切的呃

10065
07:03:53,680 --> 07:03:58,120
汇编代码，或者我们刚刚……我们……

10066
07:03:56,120 --> 07:04:00,240
呃，刚好把那整个都编译好了

10067
07:03:58,120 --> 07:04:03,360
脚本；剧本；手稿；笔迹；书写体；处方

10068
07:04:00,240 --> 07:04:05,680
所以如果我们非常仔细地去寻找

10069
07:04:03,360 --> 07:04:09,160
比如加载指令，没错，所以如果我们

10070
07:04:05,680 --> 07:04:12,840
寻找LD

10071
07:04:09,160 --> 07:04:15,840
嗯，我知道它是来自……它来自

10072
07:04:12,840 --> 07:04:19,240
在这里，所以PTX被编译成着色器汇编代码

10073
07:04:15,840 --> 07:04:21,520
S共享内存从B加载

10074
07:04:19,240 --> 07:04:24,878
共享的被矢量化了 对 B 共享的是

10075
07:04:21,520 --> 07:04:26,280
就是我们有，呃，这些单个的……那个场景（因缺乏语境，“the one”这里暂按常见影视场景相关情境理解为“那个场景” ） 

10076
07:04:24,878 --> 07:04:30,040
呃，列，对吧，所以当那个在……的时候

10077
07:04:26,280 --> 07:04:31,718
共享内存
SMM（系统管理模式）从共享（处）加载

10078
07:04:30,040 --> 07:04:33,878
是向量化的 记得我们有过……的时候吗

10079
07:04:31,718 --> 07:04:35,680
彼此相邻的线程

10080
07:04:33,878 --> 07:04:38,200
那些正是我们要找的，所以如果

10081
07:04:35,680 --> 07:04:38,200
我们寻找

10082
07:04:41,798 --> 07:04:50,920
后期圣徒教会（LDS），所以我们有

10083
07:04:44,280 --> 07:04:55,160
LDS 嗯 U 128 对  LDS u32 对  我们有

10084
07:04:50,920 --> 07:04:57,798
这里所有这些 LDS（后期圣徒教会成员，这里可能结合上下文有特定含义）嗯 而这是在……的时候

10085
07:04:55,160 --> 07:05:00,760
他们不是同时出现的，所以这个……这个后期制作系统（LDS 可能需要结合具体语境确定准确含义）在……的时候 

10086
07:04:57,798 --> 07:05:03,080
我们有32，这意味着它是它是它是

10087
07:05:00,760 --> 07:05:06,080
不，呃，它不是完全在一起的，对吧

10088
07:05:03,080 --> 07:05:08,160
这些 这些 嗯 当它……当它不是的时候

10089
07:05:06,080 --> 07:05:10,840
连续访问了大概四次，所以如果你

10090
07:05:08,160 --> 07:05:14,600
做一个 32 位浮点数 32

10091
07:05:10,840 --> 07:05:16,920
比特数乘以 4 等于 128，所以当我们访问时

10092
07:05:14,600 --> 07:05:19,600
连续四个，它将是128位的

10093
07:05:16,920 --> 07:05:21,200
加载呃 着色器汇编代码，所以这是

10094
07:05:19,600 --> 07:05:24,000
当我们到达时，它实际上是什么样子

10095
07:05:21,200 --> 07:05:25,120
那些列内存访问正在进行，并且

10096
07:05:24,000 --> 07:05:27,600
这就是当我们……时的样子

10097
07:05:25,120 --> 07:05:29,320
不太对，所以最后我们不得不，呃，你

10098
07:05:27,600 --> 07:05:32,200
知道吗，也许再加载一些，这样我们就有大概两个了

10099
07:05:29,320 --> 07:05:34,160
这里有很多东西呃，但不管怎样，这个这个

10100
07:05:32,200 --> 07:05:37,120
这里的全部要点仅仅是为了展示

10101
07:05:34,160 --> 07:05:39,280
你看看实际的负载是什么样的在……（此处原文似乎不完整） 

10102
07:05:37,120 --> 07:05:41,080
二进制格式，这……这是什么

10103
07:05:39,280 --> 07:05:44,200
它们看起来像，呃，而且我们打算……

10104
07:05:41,080 --> 07:05:47,200
进一步优化，呃，这些内核以

10105
07:05:44,200 --> 07:05:50,558
表现得更好，对吧，呃，我觉得这个

10106
07:05:47,200 --> 07:05:52,478
f ffma 是不是类似于融合乘加运算

10107
07:05:50,558 --> 07:05:55,080
浮点融合乘加 我做不到

10108
07:05:52,478 --> 07:06:02,920
记得我们实际上可以去搜索一下这个内容。

10109
07:05:55,080 --> 07:06:02,920
呃，在着色器汇编里涉及呃 F FMA

注：“F FMA”可能是特定领域的专业术语，如果有更准确的背景信息，能给出更精准的翻译。 

10110
07:06:09,240 --> 07:06:15,840
所以，是的，融合，融合，相乘，还有……

10111
07:06:14,320 --> 07:06:17,280
可能在某个地方有一本手册，而我……

10112
07:06:15,840 --> 07:06:19,680
现在不会去翻阅的，你（这里原句语序有些奇怪，正常语序可能是You're not going to look through right now） 

10113
07:06:17,280 --> 07:06:21,280
可以那样做，但呃，这些是着色器。

10114
07:06:19,680 --> 07:06:23,440
我们正在处理的组装说明

10115
07:06:21,280 --> 07:06:27,280
和……在一起；具有；用；随着；因为；关于；在……方面

10116
07:06:23,440 --> 07:06:29,680
嗯，现在我们来讨论二维块平铺。

10117
07:06:27,280 --> 07:06:31,840
这是在我们已经完成的工作基础上进行的拓展。 

10118
07:06:29,680 --> 07:06:34,120
但让它变得更加高效，并且

10119
07:06:31,840 --> 07:06:36,200
让它变得更加…… 

10120
07:06:34,120 --> 07:06:37,478
高效的 好的 绝对可以 给自己（的机会等，需结合语境理解） 

10121
07:06:36,200 --> 07:06:39,520
如果你坚持到了这一步，那就给自己点个赞吧。

10122
07:06:37,478 --> 07:06:40,958
这挺有挑战性的，所以，呃，你

10123
07:06:39,520 --> 07:06:43,398
知道的话，随时去喝杯咖啡

10124
07:06:40,958 --> 07:06:45,878
休息一下或者怎样，嗯，找点（东西）

10125
07:06:43,398 --> 07:06:49,520
茶
我这儿正好带着些茶呢

10126
07:06:45,878 --> 07:06:51,920
所以你知道，这是个苦差事，嗯，但是

10127
07:06:49,520 --> 07:06:54,798
如果我们仅回顾这篇博客文章

10128
07:06:51,920 --> 07:06:56,600
现在我们来看第五个内核，所以

10129
07:06:54,798 --> 07:06:58,320
通过二维方式提高算术强度

10130
07:06:56,600 --> 07:06:59,718
块平铺，在这之前我们只是

10131
07:06:58,320 --> 07:07:01,878
计算列，没错，我们刚才还在（做这件事）

10132
07:06:59,718 --> 07:07:03,398
正在计算列，现在这一列是

10133
07:07:01,878 --> 07:07:04,680
打算计算整个区块，它是

10134
07:07:03,398 --> 07:07:06,120
打算像计算一个小模块那样进行计算

10135
07:07:04,680 --> 07:07:08,638
在大块瓷砖里面，对吧

10136
07:07:06,120 --> 07:07:11,958
这就是想法所在，所以在那之前我们仅仅是有……

10137
07:07:08,638 --> 07:07:13,320
这个索引在 B 瓷砖里（这里原文表述“in the in the in the”可能有误，推测想表达“在……里”的意思） 

10138
07:07:11,958 --> 07:07:14,478
这原本会走向下坡路，而我们

10139
07:07:13,320 --> 07:07:16,240
仅仅有一件事，那就是

10140
07:07:14,478 --> 07:07:18,760
向下迭代并进行计算，你懂的

10141
07:07:16,240 --> 07:07:20,080
一列，所以你有这个，你只需要

10142
07:07:18,760 --> 07:07:22,160
有点相交，然后你就得到这个了

10143
07:07:20,080 --> 07:07:26,040
列已填充

10144
07:07:22,160 --> 07:07:27,840
出去了，但现在我们有这个资源索引 呃 n

10145
07:07:26,040 --> 07:07:29,360
组件右边，所以就是这样，就是…… 

10146
07:07:27,840 --> 07:07:33,160
我这就去做这个。

10147
07:07:29,360 --> 07:07:35,280
基本上覆盖，嗯，就像一个正方形

10148
07:07:33,160 --> 07:07:36,600
或者就像一行和一列，对吧，所以它们

10149
07:07:35,280 --> 07:07:39,680
相交，然后它会像这样填满

10150
07:07:36,600 --> 07:07:40,958
一个正方形区域，嗯，所以我们有这个，我们有

10151
07:07:39,680 --> 07:07:43,200
这个我们将要迭代的项

10152
07:07:40,958 --> 07:07:45,878
然后我们有了这个新的 TN 项

10153
07:07:43,200 --> 07:07:49,120
所以 TM 实际上就只是这个组件

10154
07:07:45,878 --> 07:07:52,360
然后TM是下面这个组件

10155
07:07:49,120 --> 07:07:54,398
对，嗯，所以现在就像步入了

10156
07:07:52,360 --> 07:07:56,558
这 这看起来就是这样的东西

10157
07:07:54,398 --> 07:07:58,760
就像在表象之下，当我们有点……

10158
07:07:56,558 --> 07:08:02,160
想象一下这是怎样的存在方式


10159
07:07:58,760 --> 07:08:04,360
经过计算，所以我们看看我们的，嗯

10160
07:08:02,160 --> 07:08:06,600
我们看着我们的一块瓷砖，然后我们看向…… 

10161
07:08:04,360 --> 07:08:10,000
我们的B板块，实际上就是我们在…… 

10162
07:08:06,600 --> 07:08:12,280
将一列数值存储在寄存器 M 中，所以就是这样

10163
07:08:10,000 --> 07:08:14,040
在这方面就像一个真正的寄存器内存

10164
07:08:12,280 --> 07:08:16,040
内核 我们实际上正在使用寄存器

10165
07:08:14,040 --> 07:08:18,718
记忆，所以我们正在……我们正在占据它一个（此处原文可能存在表述不完整或不准确的情况） 

10166
07:08:16,040 --> 07:08:21,200
再多一点，正如你所见，我们呃……

10167
07:08:18,718 --> 07:08:23,478
我们实际上是在填充它，所以寄存器 M 是

10168
07:08:21,200 --> 07:08:27,600
会是那种大小，然后是调节性T细胞

10169
07:08:23,478 --> 07:08:29,000
n 是 TN 尺寸，对吧，嗯，还有总数

10170
07:08:27,600 --> 07:08:31,600
结果将是表面积

10171
07:08:29,000 --> 07:08:33,120
在那总面积中，那里

10172
07:08:31,600 --> 07:08:35,520
嗯，实际上我们只是存储

10173
07:08:33,120 --> 07:08:37,440
一列和一行，那些会，那些……

10174
07:08:35,520 --> 07:08:38,958
将对整个过程进行点积运算

10175
07:08:37,440 --> 07:08:41,600
事物，它们会相交，并且你会

10176
07:08:38,958 --> 07:08:43,240
把这边这个小方块，嗯，还有

10177
07:08:41,600 --> 07:08:44,680
你可以，我们可以看看那在……会如何发展。

10178
07:08:43,240 --> 07:08:49,160
每一步

10179
07:08:44,680 --> 07:08:50,600
好了，现在这是我的记号笔，咱们来

10180
07:08:49,160 --> 07:08:55,000
实际上走进这个里面

10181
07:08:50,600 --> 07:08:57,320
内核，所以我们回到这里，然后我们看到

10182
07:08:55,000 --> 07:09:01,120
嗯，你知道运行 Sjem 2D 块平铺

10183
07:08:57,320 --> 07:09:04,440
好的，那么我们有这个，我们有一个……我们 

10184
07:09:01,120 --> 07:09:07,320
有同样的“BK”术语，没错，所以“BK”是

10185
07:09:04,440 --> 07:09:09,478
在这种情况下就会是八，嗯

10186
07:09:07,320 --> 07:09:11,120
而且我们有 TM，它也是一样的。

10187
07:09:09,478 --> 07:09:12,160
而且我们现在有了这个新的TN术语，对吧，所以

10188
07:09:11,120 --> 07:09:14,840
本质上，我们只是打算

10189
07:09:12,160 --> 07:09:16,638
计算，嗯，就像我们填充的这个区域

10190
07:09:14,840 --> 07:09:19,478
输出将包含64个元素，它是

10191
07:09:16,638 --> 07:09:20,878
将会是 8 乘 8 的规格，那样就能填满了

10192
07:09:19,478 --> 07:09:22,718
把整件事处理好，然后我们将

10193
07:09:20,878 --> 07:09:24,798
有64个在……里

注：由于“in”后无内容，这里只能给出较宽泛的翻译。若有具体语境可进一步完善。 

10194
07:09:22,718 --> 07:09:27,558
好了，现在我们有了这个小技巧

10195
07:09:24,798 --> 07:09:29,878
处理情况，就像非常……（此英文文本表述不太清晰完整） 

10196
07:09:27,558 --> 07:09:31,360
非常低，就像那些较小的矩阵，它们……（这里原句似乎不完整） 

10197
07:09:29,878 --> 07:09:32,718
当我们进行一项……时，将会接受测试。

注：原英文句子不完整，翻译尽量根据已有内容通顺表达。 

10198
07:09:31,360 --> 07:09:34,958
基准，所以这就是我们有这个的原因

10199
07:09:32,718 --> 07:09:39,558
这里有个小声明

10200
07:09:34,958 --> 07:09:42,120
嗯，所以万一我们，你懂的，决定使用

10201
07:09:39,558 --> 07:09:43,920
嗯，万一我们决定使用类似一种非常…… 

10202
07:09:42,120 --> 07:09:45,958
小矩阵，这是能够处理的

10203
07:09:43,920 --> 07:09:46,878
实际上，但通常我们只是

10204
07:09:45,958 --> 07:09:48,718
我们只是打算去付款。

10205
07:09:46,878 --> 07:09:51,080
首先关注这个 `if` 语句，用于

10206
07:09:48,718 --> 07:09:53,920
现在，嗯，所以如果这些比…… 

10207
07:09:51,080 --> 07:09:56,000
大于或等于 128

10208
07:09:53,920 --> 07:09:59,280
对；没错；好的

10209
07:09:56,000 --> 07:10:03,320
嗯，是的，所以在

10210
07:09:59,280 --> 07:10:07,040
这里注意一下，我们有一个

10211
07:10:03,320 --> 07:10:11,440
网格维度，它将有一个……X

10212
07:10:07,040 --> 07:10:12,760
右侧分量，然后是一个 y 分量

10213
07:10:11,440 --> 07:10:15,000
对，所以那……那将会是……那

10214
07:10:12,760 --> 07:10:16,878
保持不变，然后这个

10215
07:10:15,000 --> 07:10:18,440
块维度 那个……数量的 （注：原英文文本表述不太符合常见语法规范，此为尽量贴近字面的翻译） 

10216
07:10:16,878 --> 07:10:20,200
一个线程块内的线程，对吧，它是…… 

10217
07:10:18,440 --> 07:10:22,240
就像街区本身一样，还有维度方面 

10218
07:10:20,200 --> 07:10:24,080
其中，那个 X 分量仅仅是

10219
07:10:22,240 --> 07:10:26,958
这里会有一个值，并且那是

10220
07:10:24,080 --> 07:10:29,760
基本上将会是……呃……总数

10221
07:10:26,958 --> 07:10:32,320
因此，输出图块中的元素数量

10222
07:10:29,760 --> 07:10:34,718
你知道我们有这个 B 和这个 BN，并且

10223
07:10:32,320 --> 07:10:36,760
然后他们，然后他们，他们，你有点……

10224
07:10:34,718 --> 07:10:39,718
把这个填好，C区域



10225
07:10:36,760 --> 07:10:42,000
这个C瓷砖将会是这样的

10226
07:10:39,718 --> 07:10:44,120
这么大尺寸的，对吧，然后我们来分割

10227
07:10:42,000 --> 07:10:47,680
按所覆盖的总表面积来计算

10228
07:10:44,120 --> 07:10:49,840
嗯，仅仅通过一条线索来计算，所以……

10229
07:10:47,680 --> 07:10:51,600
一个线程将遍历那64个。

10230
07:10:49,840 --> 07:10:52,760
元素，它将是 8×8 的，它是

10231
07:10:51,600 --> 07:10:54,280
打算把那些过一遍，而且它们是……

10232
07:10:52,760 --> 07:10:57,878
打算计算一个小小的数值

10233
07:10:54,280 --> 07:11:00,520
给我们的网格，嗯，就像每个线程那样，对吧，嗯

10234
07:10:57,878 --> 07:11:04,638
所以如果我们对总数进行除法运算

10235
07:11:00,520 --> 07:11:06,558
输出结果……由，呃，由……得出的结果 

10236
07:11:04,638 --> 07:11:08,000
我们一根线所覆盖的空间

10237
07:11:06,558 --> 07:11:10,160
实际上要正确设置线程数量

10238
07:11:08,000 --> 07:11:12,320
因为这里的每一小片都是一个

10239
07:11:10,160 --> 07:11:13,520
线程，所以如果我们用这个除以这个

10240
07:11:12,320 --> 07:11:16,680
我们实际上得到了……的总数

10241
07:11:13,520 --> 07:11:18,478
整个SE瓦片内的线程，嗯，所以

10242
07:11:16,680 --> 07:11:22,360
如果我们来做这道数学题

10243
07:11:18,478 --> 07:11:22,360
在这里我们将会如此

不过你提供的英文句子似乎不太完整，可能影响理解其确切含义。 

10244
07:11:23,680 --> 07:11:26,680
128

10245
07:11:27,718 --> 07:11:32,840
乘以8，然后将其除以

10246
07:11:31,760 --> 07:11:37,840
8

10247
07:11:32,840 --> 07:11:40,360
乘以8，这可以简化为，嗯，128是2（这里句子似乎不完整，表述不太符合常规数学语境）

10248
07:11:37,840 --> 07:11:42,878
到 7 右边，因为记住，就像如果你

10249
07:11:40,360 --> 07:11:44,798
如果你了解像 8 位整数精度，它是

10250
07:11:42,878 --> 07:11:47,958
这就好像，本质上它就像一幅图像

10251
07:11:44,798 --> 07:11:51,680
比如……比如呃，RGB的数量

10252
07:11:47,958 --> 07:11:54,638
单个 U 中的数值，就像在单个……中一样

10253
07:11:51,680 --> 07:11:56,718
像素，所以你有像 RGB 这样的，并且每一个

注：此英文句子似乎不完整，翻译可能不太能体现完整准确的语义。 

10254
07:11:54,638 --> 07:11:58,558
那些是从 0 到 255，所以就是这样。

10255
07:11:56,718 --> 07:12:00,878
就像你怎么能……之类的……呃

10256
07:11:58,558 --> 07:12:02,798
128 是 2 的 7 次方，因为它就像是 7（次方的情况） 

10257
07:12:00,878 --> 07:12:07,600
相反，这就是我制作那个东西的方式。

10258
07:12:02,798 --> 07:12:07,600
协会，但我们有这两个

10259
07:12:08,320 --> 07:12:16,520
7

10260
07:12:10,878 --> 07:12:20,280
7/ 2 3 * 2 3 以及你最终得到的结果

10261
07:12:16,520 --> 07:12:20,280
这句话可能存在拼写错误，推测可能想说 “this is 2”，如果是这样，翻译为：
这是 2

10262
07:12:22,718 --> 07:12:29,160
14

10263
07:12:24,878 --> 07:12:33,680
/ 2 6 然后我们运用指数运算法则，接着我们

10264
07:12:29,160 --> 07:12:36,680
答对了八个，所以 14 减 6 等于 8，那么两个

10265
07:12:33,680 --> 07:12:40,120
那意味着我们有

10266
07:12:36,680 --> 07:12:45,040
256 我的马克笔能用。

10267
07:12:40,120 --> 07:12:45,040
恰当地使用256个线程

10268
07:12:47,200 --> 07:12:53,958
对，256 个线程，我的书写很潦草。

10269
07:12:50,718 --> 07:12:55,240
忽略那个，嗯，太棒了，所以我们知道了

10270
07:12:53,958 --> 07:12:56,280
我们正在计算的线程数量

10271
07:12:55,240 --> 07:12:58,200
现在，当我们……的时候，这将对我们有帮助。 

10272
07:12:56,280 --> 07:13:00,718
实际上，在这里跳进这个内核，所以

10273
07:12:58,200 --> 07:13:03,520
你知道我们有我们的BM或者BN、BK、TM 

10274
07:13:00,718 --> 07:13:03,520
然后又是商标符号（TM）

10275
07:13:04,120 --> 07:13:10,398
没错，这里发生了很多事，咱们

10276
07:13:06,638 --> 07:13:12,840
把这个分解一下，首先我们有我们的

10277
07:13:10,398 --> 07:13:14,398
我们这一排，它将会是那个……

10278
07:13:12,840 --> 07:13:17,160
典型的 y 分量，我们已经处理过了

10279
07:13:14,398 --> 07:13:19,920
在此之上，块中的总结果

10280
07:13:17,160 --> 07:13:22,680
正如我们之前在……里所说的那样，瓷砖……（原文似乎不完整）

10281
07:13:19,920 --> 07:13:24,600
运行文件 呃 这只是

10282
07:13:22,680 --> 07:13:26,760
从本质上来说，整个，整个……（这里原文表述不完整且重复较多，可能不太准确表意） 

10283
07:13:24,600 --> 07:13:28,160
种子矩阵，这样你就有了 M 维

10284
07:13:26,760 --> 07:13:29,638
那么你拥有了N维度，你

10285
07:13:28,160 --> 07:13:30,798
将它们相乘，你就会得到总面积。

10286
07:13:29,638 --> 07:13:32,680
对，这就是我们得到的结果数量

10287
07:13:30,798 --> 07:13:36,320
去进行计算，然后我们会得到

10288
07:13:32,680 --> 07:13:38,718
每个完整的……的线程数量（此处“that entire”后面缺少内容，译文表意可能不完整）

10289
07:13:36,320 --> 07:13:41,680
事情，那么有多少个单独的正方形呢

10290
07:13:38,718 --> 07:13:43,360
那里有一个线程正在占用，对吧

10291
07:13:41,680 --> 07:13:45,080
这样一来，正方形的表面积就是

10292
07:13:43,360 --> 07:13:46,520
这是我们已经计算过的，所以

10293
07:13:45,080 --> 07:13:49,840
每个块瓦片的线程数量

10294
07:13:46,520 --> 07:13:51,558
应该等于 256，对吧，然后我们就

10295
07:13:49,840 --> 07:13:53,958
断言就在这里下面，所以我们想做

10296
07:13:51,558 --> 07:13:55,280
当然，那个 256 的值等于我们（想要的）……

注：原英文句子似乎不完整，以上翻译尽量贴合原文表述。 

10297
07:13:53,958 --> 07:13:57,240
刚刚计算了哪个会被保留

10298
07:13:55,280 --> 07:13:59,878
当然是真的，然后它不会……它会

10299
07:13:57,240 --> 07:14:03,440
实际上继续执行，对吧

10300
07:13:59,878 --> 07:14:05,638
嗯，咱们再往下一点。

10301
07:14:03,440 --> 07:14:06,920
嗯，现在别担心这些。

10302
07:14:05,638 --> 07:14:10,360
我们将在某一（时间、方面等，需结合上下文明确）探讨这些内容。

10303
07:14:06,920 --> 07:14:12,680
其次，所以我们就按照传统的方式来做

10304
07:14:10,360 --> 07:14:15,558
分配共享内存，我们推进了……（这里文本似乎不完整） 

10305
07:14:12,680 --> 07:14:17,840
基于，嗯，你知道是哪里的块状瓷砖

10306
07:14:15,558 --> 07:14:20,920
他们应该在……里面。

注：你提供的句子“they're supposed to be at in”可能存在表述错误，“at”和“in”都是介词，此处一般只用一个。 

10307
07:14:17,840 --> 07:14:25,798
呃，在当前的街区里

10308
07:14:20,920 --> 07:14:25,798
对，或者，我猜在当前…… 

10309
07:14:26,120 --> 07:14:30,600
线索 这就是很多奇妙之事发生的地方

10310
07:14:28,120 --> 07:14:32,478
就在这里发生，所以，这部分是

10311
07:14:30,600 --> 07:14:34,958
至关重要
注意听
让我们先出发

10312
07:14:32,478 --> 07:14:36,478
跳过简单的部分，所以线程结果是

10313
07:14:34,958 --> 07:14:38,280
就像那个小东西到底有多大啊

10314
07:14:36,478 --> 07:14:40,080
对那根线进行平方运算然后进行计算

10315
07:14:38,280 --> 07:14:42,718
那只会是，嗯，这就要……

10316
07:14:40,080 --> 07:14:45,520
达到 8 乘 8 的规格（这里“8 by 8”常见表达为长 8 宽 8 之类的规格，需结合具体语境确定准确含义）

10317
07:14:42,718 --> 07:14:49,200
好的，我们有这个正则 M 项，我们

10318
07:14:45,520 --> 07:14:51,360
在博客文章里看到的，所以雷格·M就是这个情况

10319
07:14:49,200 --> 07:14:55,478
并且寄存器 n 是

10320
07:14:51,360 --> 07:14:59,478
那个 TM 和 TN 没错，那正要…… 

10321
07:14:55,478 --> 07:15:01,240
成为那个小小的，我猜那个……那个……

（你提供的英文内容似乎不太完整或存在表述问题，这样的译文可能不太符合完整准确的语义逻辑。） 

10322
07:14:59,478 --> 07:15:04,320
点积的迭代，所以每个

10323
07:15:01,240 --> 07:15:06,718
在 idx 的每次迭代处的点，它是

10324
07:15:04,320 --> 07:15:07,840
打算把那些存储在寄存器里，并且

10325
07:15:06,718 --> 07:15:09,600
它真的会去计算它们

10326
07:15:07,840 --> 07:15:10,878
真的很快，对吧，它会变得像……

10327
07:15:09,600 --> 07:15:12,920
快八点了，马上就到……

10328
07:15:10,878 --> 07:15:16,040
要变成一个 8 行 1 列的矩阵，然后再变成一个 1 行 8 列的矩阵

10329
07:15:12,920 --> 07:15:16,040
而且事情就会那样发展下去

10330
07:15:16,360 --> 07:15:20,840
现在我们抬头看向

10331
07:15:19,040 --> 07:15:23,798
这些

10332
07:15:20,840 --> 07:15:26,200
所以连续地，啊，所以本质上我们只是

10333
07:15:23,798 --> 07:15:27,718
有线程索引，然后我们对其进行划分

10334
07:15:26,200 --> 07:15:30,478
作者：BK

10335
07:15:27,718 --> 07:15:32,160
排成一排，想法相同，但我们使用…… 

10336
07:15:30,478 --> 07:15:33,398
模运算

10337
07:15:32,160 --> 07:15:35,080
然后我们有了这个叫做“a”的新术语

10338
07:15:33,398 --> 07:15:36,478
向右跨步，现在我们实际上

10339
07:15:35,080 --> 07:15:38,160
要去做数学题了，我们要去做了

10340
07:15:36,478 --> 07:15:42,240
一步的数学计算（注：这里“the math for a stride”语义不太明确，可能结合上下文有更合适的译法，“一步的数学计算”只是按字面直译）

10341
07:15:38,160 --> 07:15:42,240
这里，马马虎虎地迈着步子

10342
07:15:50,798 --> 07:15:58,718
一步的跨度将是……的数量

注：原英文句子似乎不太完整和准确，这是按照字面意思尽量连贯的翻译。 

10343
07:15:53,958 --> 07:15:58,718
每个块线程瓦片，其数量为 256

10344
07:16:01,638 --> 07:16:07,200
除以 BK，在这种情况下

10345
07:16:08,360 --> 07:16:14,120
那么在这里，如果你把这个进行除法运算，你……

10346
07:16:11,478 --> 07:16:14,120
最终得到；到头来获得

10347
07:16:14,958 --> 07:16:20,958
32 所以我们的步长 a 将是 32

10348
07:16:21,120 --> 07:16:27,000
好吧，我的记号笔有点怪，咱们来……

10349
07:16:24,080 --> 07:16:29,120
注意那个术语

10350
07:16:27,000 --> 07:16:32,080
嗯，然后我们还有另一种步伐。

10351
07:16:29,120 --> 07:16:34,160
在下面这里，步幅 B 是同样的情况，但是

10352
07:16:32,080 --> 07:16:36,920
我们不除以 BK，而是除以

10353
07:16:34,160 --> 07:16:41,680
BN 所以 BN 实际上是

10354
07:16:36,920 --> 07:16:43,398
128 所以如果我们用 256 来除

10355
07:16:41,680 --> 07:16:46,958
对；正确；好吧

10356
07:16:43,398 --> 07:16:46,958
128 答案是

10357
07:16:47,040 --> 07:16:50,840
两个
现在，这些将是很重要的

10358
07:16:49,520 --> 07:16:53,000
这些将非常重要，因为

10359
07:16:50,840 --> 07:16:55,120
我们有点像逐步推进这个，所以让我们

10360
07:16:53,000 --> 07:16:58,440
跳到这里实际的这个呃循环部分

10361
07:16:55,120 --> 07:17:00,520
现在，在一个共享的视角下看看我们如何…… 

10362
07:16:58,440 --> 07:17:02,398
索引从此处开始并结束

10363
07:17:00,520 --> 07:17:05,680
在那里，我们有这第一件事在……（原文此处似乎未完整表达） 

10364
07:17:02,398 --> 07:17:06,878
括号，也就是呃，内排 A，所以它是

10365
07:17:05,680 --> 07:17:10,200
会有某一行，我们是……

10366
07:17:06,878 --> 07:17:13,600
看着再加上一个负载偏移，对吧，所以

10367
07:17:10,200 --> 07:17:16,080
负载偏移将向上迭代

10368
07:17:13,600 --> 07:17:19,440
到 BM，在这种情况下它是

10369
07:17:16,080 --> 07:17:21,360
128 所以你可以把它想象成我们拥有

10370
07:17:19,440 --> 07:17:25,240
这；这个

10371
07:17:21,360 --> 07:17:25,240
嗯，这是那个……（这里“the a”表述有误，“the”和“a”都是冠词，不能这样连用） 

10372
07:17:26,600 --> 07:17:32,680
瓷砖；瓦片；地砖；墙砖；片状物；小块；（计算机屏幕的）图块，拼贴画面

10373
07:17:28,398 --> 07:17:36,240
对，所以这将会

10374
07:17:32,680 --> 07:17:36,240
这会是……吗
（注：原文“be this going to be”表述不太符合常规英语语法习惯，常见的表达可能是“Is this going to be...” ） 

10375
07:17:36,718 --> 07:17:42,600
BM，那接下来会是BK，对吧，所以

10376
07:17:40,520 --> 07:17:45,600
在这里面，我们要进行迭代操作

10377
07:17:42,600 --> 07:17:50,558
以一步的跨度向 BM 迈进，现在迈出一步

10378
07:17:45,600 --> 07:17:52,600
a是32码的右束带，a是32码，所以如果我们

10379
07:17:50,558 --> 07:17:53,798
实际上，看看它出现了多少次

10380
07:17:52,600 --> 07:17:55,680
要大步走过这一切，直到……

10381
07:17:53,798 --> 07:17:59,398
到达终点时，它将从……开始

10382
07:17:55,680 --> 07:18:02,760
零，然后它将下降到

10383
07:17:59,398 --> 07:18:02,760
32 我可以

10384
07:18:04,360 --> 07:18:07,398
然后它会下降到

10385
07:18:08,920 --> 07:18:14,718
64，然后它会降到，呃

10386
07:18:12,280 --> 07:18:14,718
我相信

10387
07:18:17,200 --> 07:18:20,558
96，然后它就会停下来，对吧

10388
07:18:19,280 --> 07:18:22,080
它将会……它……它不会……

10389
07:18:20,558 --> 07:18:24,040
实际上按下这个，它就会停止。

10390
07:18:22,080 --> 07:18:26,120
那么，我们接下来会有这个这个

10391
07:18:24,040 --> 07:18:27,680
初始偏移量为零，然后它是

10392
07:18:26,120 --> 07:18:29,360
接下来要提升到32了

10393
07:18:27,680 --> 07:18:33,840
迭代，然后它将跳到64

10394
07:18:29,360 --> 07:18:35,320
然后是96，所以注意实际面积

10395
07:18:33,840 --> 07:18:37,040
我们得在这里填写，对吧

10396
07:18:35,320 --> 07:18:38,478
注意我们实际需要填充的区域

10397
07:18:37,040 --> 07:18:41,478
在这样的情况下；因此  （不过 “in so this” 并非常见规范表达，可能存在表述不完整或有误情况） 

10398
07:18:38,478 --> 07:18:41,478
区域；地区；面积；领域；范围

10399
07:18:44,160 --> 07:18:49,798
是

10400
07:18:46,878 --> 07:18:52,200
32，然后我们已经知道这个BK是

10401
07:18:49,798 --> 07:18:52,200
八

10402
07:18:54,240 --> 07:18:58,680
没错，而且对于……情况也会是一样的

10403
07:18:56,280 --> 07:19:00,920
这个如此，那个也如此，而且……同样如此 

10404
07:18:58,680 --> 07:19:04,040
那么，实际上这就是……这就是……的地方

10405
07:19:00,920 --> 07:19:07,680
现在一些非常酷的东西来了，这个

10406
07:19:04,040 --> 07:19:11,040
这里的内部A排，这个内部A排

10407
07:19:07,680 --> 07:19:13,040
计算方式为线程索引除以

10408
07:19:11,040 --> 07:19:16,200
BK
（注：“BK”可能是特定名称、缩写等，仅这两个字母较难给出确切的对应中文表述，需结合具体语境。） 

10409
07:19:13,040 --> 07:19:21,240
对，所以如果我们进行计算，这个数值……

10410
07:19:16,200 --> 07:19:21,240
这里，比如说 idx 表示 Max 出局于…… 

10411
07:19:22,878 --> 07:19:32,638
256 我的记号笔，我得去拿

10412
07:19:26,080 --> 07:19:32,638
一个256的ID BK，这是正确的

10413
07:19:32,878 --> 07:19:37,798
现在这个数字将会达到最大值在……

10414
07:19:35,360 --> 07:19:40,240
32，那将是我们的行，对吧

10415
07:19:37,798 --> 07:19:43,520
所以记住这一点，如果它是

10416
07:19:40,240 --> 07:19:45,840
32 这个数字 这个 这内排 哪一个

10417
07:19:43,520 --> 07:19:48,878
是基于线程本身的是

10418
07:19:45,840 --> 07:19:51,320
现在要将其最大值设定为32，这个内部的（这里“inner”表意不太明确，需结合更多语境确定准确含义） 

10419
07:19:48,878 --> 07:19:54,958
另一方面，列将要做…… 

10420
07:19:51,320 --> 07:19:56,600
模组BK 没错，所以当我们这么做的时候，它是

10421
07:19:54,958 --> 07:19:59,000
本质上要……它要去…… 

10422
07:19:56,600 --> 07:20:00,760
比如 0、1、2、3，一直到 8，并且

10423
07:19:59,000 --> 07:20:01,958
然后一旦它再次到了八点，那就是……就是……

10424
07:20:00,760 --> 07:20:04,360
准备跳转到零号架，并且它正在进行

10425
07:20:01,958 --> 07:20:06,200
要重置，这样它就会变成像 0 一样

10426
07:20:04,360 --> 07:20:08,040
从 0 到 8，然后重置，再从 0 到 8，并且

10427
07:20:06,200 --> 07:20:11,080
重置右边，然后我们将会有

10428
07:20:08,040 --> 07:20:13,320
这些 这些行 呃 行索引那个

10429
07:20:11,080 --> 07:20:15,320
从 0 到 32，对吧，所以每次我们

10430
07:20:13,320 --> 07:20:17,280
接下来击中八个 这将……这是

10431
07:20:15,320 --> 07:20:19,320
准备提高一个（数量/程度等，需结合具体语境）

10432
07:20:17,280 --> 07:20:22,160
没错，所以这实际上很有……（此处原句未完整） 

10433
07:20:19,320 --> 07:20:24,280
从常理来讲，在这里面我们有这个

10434
07:20:22,160 --> 07:20:27,600
加载即将进行跨步操作的偏移量

10435
07:20:24,280 --> 07:20:30,320
多了这么多，这里的这个32，然后我们

10436
07:20:27,600 --> 07:20:32,280
加上这一行的偏移量，这样我们

10437
07:20:30,320 --> 07:20:34,718
让行偏移量加上任何那个（这里“whatever that”语义不太明确，需结合上下文确定更准确意思） 

10438
07:20:32,280 --> 07:20:37,040
数量是我们可以有效地填充

10439
07:20:34,718 --> 07:20:39,160
这边的整个区域，所以它就像是那个…… 

10440
07:20:37,040 --> 07:20:42,000
零，或者那个，或者说就好像我不想（这么做之类的，需结合语境） 

10441
07:20:39,160 --> 07:20:44,558
知道 64，然后加上它所在的任意一行（的数值）

10442
07:20:42,000 --> 07:20:48,320
从线程索引本身，我们……（此处文本不完整） 

10443
07:20:44,558 --> 07:20:52,320
我们在这里进行计算的（内容）

注：由于没有上下文，“which”具体指代不明，此翻译仅从字面进行处理。 

10444
07:20:48,320 --> 07:20:53,600
嗯，它将是那个乘以 K。

10445
07:20:52,320 --> 07:20:55,878
维度，所以这就是为什么它在发展（进行）

10446
07:20:53,600 --> 07:20:57,638
跨越所需的尽可能多的行

10447
07:20:55,878 --> 07:21:00,080
并且它最终会到达某个（地方） 

10448
07:20:57,638 --> 07:21:02,000
某个指数，然后一旦我们进行相乘

10449
07:21:00,080 --> 07:21:04,680
我们知道它在垂直方向上的位置

10450
07:21:02,000 --> 07:21:07,638
然后我们只需将内列相加

10451
07:21:04,680 --> 07:21:09,040
指向该索引，因此是内部列索引

10452
07:21:07,638 --> 07:21:11,958
就像我之前说的，会达到上限的

10453
07:21:09,040 --> 07:21:14,398
在8，对吧，所以它会在8达到上限。

10454
07:21:11,958 --> 07:21:17,280
而且它会落在这附近的某个地方，所以

10455
07:21:14,398 --> 07:21:21,760
通过这样做，我们实际上只是进行迭代

10456
07:21:17,280 --> 07:21:24,760
重复这个过程四次，并且每个线程

10457
07:21:21,760 --> 07:21:28,200
跨越，你知道的，如果是 32×8 个编码单元

注：这里“CU”可能是“Coding Unit（编码单元）”的缩写，需结合具体语境判断。 

10458
07:21:24,760 --> 07:21:32,520
实际上算一下 32 乘以 8，那就是

10459
07:21:28,200 --> 07:21:32,520
像2和5

10460
07:21:33,680 --> 07:21:42,200
2的5次方是32，然后呢，2的3次方是

10461
07:21:38,680 --> 07:21:46,638
8 所以根据我们的指数运算法则，5 + 3 就是……

10462
07:21:42,200 --> 07:21:48,760
2的8次方，也就是int 8，对应的值是256

10463
07:21:46,638 --> 07:21:49,878
对，所以那就是我大概的制作方式

10464
07:21:48,760 --> 07:21:52,878
那些关联你不必有

10465
07:21:49,878 --> 07:21:55,840
跟着算一下，不过 8 乘以 32 等于

10466
07:21:52,878 --> 07:21:57,798
256 看看每一根线有多棒啊

10467
07:21:55,840 --> 07:22:00,280
将在……占据一个单独的位置

10468
07:21:57,798 --> 07:22:02,200
那么在这里，我们要加载这个数据块了。 

10469
07:22:00,280 --> 07:22:05,080
每个线程都会占用一点（资源等，需结合上下文确定具体所指） 

10470
07:22:02,200 --> 07:22:06,600
在那里输入 32 * 8，然后我们加载进来

10471
07:22:05,080 --> 07:22:09,600
下一个，每个线程都有其自己的（东西）

10472
07:22:06,600 --> 07:22:11,000
位置，所以这就像是一次针对……的操作

10473
07:22:09,600 --> 07:22:12,478
每一次迭代，对吧，所以我们不

10474
07:22:11,000 --> 07:22:16,360
必须依次逐个地浏览它

10475
07:22:12,478 --> 07:22:18,320
线程就这么完成了，就是这样一个（线程）。 

10476
07:22:16,360 --> 07:22:20,120
说明相同，这个也是，这个也是

10477
07:22:18,320 --> 07:22:22,558
同样适用于

10478
07:22:20,120 --> 07:22:24,080
这样，然后我们只需相应地进行索引

10479
07:22:22,558 --> 07:22:26,558
我们只是稍微调整了一下，这样就不用…… 

10480
07:22:24,080 --> 07:22:28,638
BK 就是那个跨越你（前行）的存在 

10481
07:22:26,558 --> 07:22:30,160
知道我们确实这样做，我们乘以 K，所以它能够

10482
07:22:28,638 --> 07:22:32,878
当我们……的时候跨越整个事情 

10483
07:22:30,160 --> 07:22:34,320
实际上是从 GPU 显存加载，嗯

10484
07:22:32,878 --> 07:22:36,440
因为实际上它更大，对吧

10485
07:22:34,320 --> 07:22:39,080
所以这些矩阵要大得多

10486
07:22:36,440 --> 07:22:40,958
当我们……当他们还没……呃，还没铺瓷砖的时候

10487
07:22:39,080 --> 07:22:43,080
所以我们必须像整个K那样大步前行

10488
07:22:40,958 --> 07:22:45,680
距离，而不仅仅是那那那那

10489
07:22:43,080 --> 07:22:48,958
瓷砖 K
（备注：“tile”常见释义为“瓷砖；瓦片” ，这里如果有特定语境，含义可能会不同。） 

10490
07:22:45,680 --> 07:22:53,240
距离，然后同样的概念适用于

10491
07:22:48,958 --> 07:22:55,240
嗯，胡说，对吧，这……这可不是胡说

10492
07:22:53,240 --> 07:22:59,558
这个“bshar”可能并不是一个常见的英文单词，也许是拼写错误。由于缺乏更多信息，无法准确翻译，勉强音译为“巴舍尔” 。 

10493
07:22:55,240 --> 07:22:59,558
不是 不是那个

10494
07:23:01,878 --> 07:23:06,318
如果我为了……而起床

10495
07:23:03,440 --> 07:23:08,958
其次，看看什么才是胡说八道的样子

10496
07:23:06,318 --> 07:23:08,958
这简直是

10497
07:23:10,840 --> 07:23:15,878
这实际上让我得到了一个不同的

10498
07:23:12,878 --> 07:23:15,878
标记；记号笔；标识物；里程碑；马克（德国旧货币单位） 

10499
07:23:17,478 --> 07:23:23,760
糟糕，情况会变成这样的，走吧

10500
07:23:20,638 --> 07:23:27,280
往这边走，没错，就是这样。 

10501
07:23:23,760 --> 07:23:30,040
如果我们现在来看，BS 会是什么样子呢

10502
07:23:27,280 --> 07:23:32,398
看，如果我们看这些数值

10503
07:23:30,040 --> 07:23:36,680
在内部，我们有这个负载偏移，它是

10504
07:23:32,398 --> 07:23:37,920
打算迭代到，嗯，迭代到 BK

10505
07:23:36,680 --> 07:23:39,958
没错，并且

10506
07:23:37,920 --> 07:23:43,318
BK 是

10507
07:23:39,958 --> 07:23:46,318
记住，这不是，这不是这个

10508
07:23:43,318 --> 07:23:49,840
再也不是那一部分了，是侧面，然后

10509
07:23:46,318 --> 07:23:52,318
这部分是 BN，对吧，因为它是 K byn 

10510
07:23:49,840 --> 07:23:55,240
作为 B 矩阵

10511
07:23:52,318 --> 07:23:57,440
所以当我们，当我们在这些当中进行迭代时

10512
07:23:55,240 --> 07:24:02,000
步幅 实际上最终会

10513
07:23:57,440 --> 07:24:04,680
呃，在这种情况下，BN是128，所以

10514
07:24:02,000 --> 07:24:08,120
会是这样的，呃，这样的步伐

10515
07:24:04,680 --> 07:24:12,240
值将会是，嗯，或者是步长 B

10516
07:24:08,120 --> 07:24:16,240
抱歉，结果将是 256 除以 128，即

10517
07:24:12,240 --> 07:24:20,680
没错，正如我们所计算的，嗯，往下

10518
07:24:16,240 --> 07:24:23,360
在这里，所以实际上它会大踏步前进，嗯

10519
07:24:20,680 --> 07:24:23,360
实际上它将会

10520
07:24:23,440 --> 07:24:30,558
步幅，它要跨两步，对吗

10521
07:24:26,318 --> 07:24:32,558
而它长度的两倍是

10522
07:24:30,558 --> 07:24:34,440
实际上是四分之一，对，所以如果你有

10523
07:24:32,558 --> 07:24:37,718
八个数值，你有八个不同的（数值）

10524
07:24:34,440 --> 07:24:40,600
你把它分成八行不同的行

10525
07:24:37,718 --> 07:24:42,638
现在你分成了两半，就有四个了

10526
07:24:40,600 --> 07:24:45,558
这里几行，那里四行，现在如果你

10527
07:24:42,638 --> 07:24:45,558
把它分成两半

10528
07:24:46,398 --> 07:24:50,718
那么，你又有了两个、两个还有两个

10529
07:24:49,240 --> 07:24:53,040
而这一切加起来是……（注：原英文表述不太符合常规语法逻辑，此翻译尽量贴合字面意思） 

10530
07:24:50,718 --> 07:24:55,040
八，所以当我们实际跨步时，我们是

10531
07:24:53,040 --> 07:24:56,760
只走了四分之一的路程往下

10532
07:24:55,040 --> 07:24:59,558
这里也是同样的情况，我们开始，四分之一的…… 

10533
07:24:56,760 --> 07:25:01,958
四分之一、四分之一，没错，还是同样的思路

10534
07:24:59,558 --> 07:25:03,958
这里适用，所以不管这一步幅是怎样的

10535
07:25:01,958 --> 07:25:05,520
值是它将从零开始，并且

10536
07:25:03,958 --> 07:25:09,120
它会涨到六，因为它……

10537
07:25:05,520 --> 07:25:12,318
它将达到……的上限

10538
07:25:09,120 --> 07:25:15,360
嗯，它最终会达到B，不管是BK什么的

10539
07:25:12,318 --> 07:25:18,558
在这种情况下是八，而且仅仅是

10540
07:25:15,360 --> 07:25:22,000
即将停止，所以将会变为 0 0 2

10541
07:25:18,558 --> 07:25:26,318
4 6 然后就在那时它会停下来，我们

10542
07:25:22,000 --> 07:25:29,318
有这个内部行 b，它从这里开始

10543
07:25:26,318 --> 07:25:32,920
而这正是同样的思路，所以在里面

10544
07:25:29,318 --> 07:25:35,280
关于这个，我们有线程索引（thread idx），嗯，在……

10545
07:25:32,920 --> 07:25:37,440
在这种情况下，它只会达到最大值。 

10546
07:25:35,280 --> 07:25:41,318
在；于；向；朝

10547
07:25:37,440 --> 07:25:41,318
256，然后我们对其进行除法运算

10548
07:25:41,718 --> 07:25:47,240
数字 我们用那个数字除以 BN，而（此处“which”引导从句，但原句不完整，翻译较难达意） 

10549
07:25:44,638 --> 07:25:47,240
在这种情况下是

10550
07:25:49,318 --> 07:25:55,318
128，列的思路也是一样的，它是

10551
07:25:52,318 --> 07:25:56,638
从 0 一直到 128

10552
07:25:55,318 --> 07:25:57,958
然后它就要重置了，对吧

10553
07:25:56,638 --> 07:26:01,558
它不只是会每隔一段时间进行迭代

10554
07:25:57,958 --> 07:26:04,360
时间到了，我们剥（这里“stri 128”可能有误，推测可能是“strip” ）……呃，要去…… 

10555
07:26:01,558 --> 07:26:09,280
它要上升了，它要……

10556
07:26:04,360 --> 07:26:12,120
本质上，模128中的1是……这里“one 127 28”表述不太清晰，推测你想说的可能是内容有偏差，正常表述或许不是这样，按现有英文可勉强翻译为：
本质上，模128中的1是 127 28 是 

10557
07:26:09,280 --> 07:26:15,600
127 对，所以实际上就这些了

10558
07:26:12,120 --> 07:26:15,600
它将在这里做（某事）

10559
07:26:15,798 --> 07:26:20,080
嗯，万一你还没注意到的话

10560
07:26:18,478 --> 07:26:21,878
这和这里的想法一样，只是

10561
07:26:20,080 --> 07:26:23,958
我们只是在处理类似……一种……一个…… 

10562
07:26:21,878 --> 07:26:25,840
更像是被拉得很长的东西

10563
07:26:23,958 --> 07:26:29,478
而不是 而不是像这些 真好去…… （此句英文本身表述不太完整和规范，翻译只能大致表意） 

10564
07:26:25,840 --> 07:26:31,680
看 我 糖果 看着 积木 对 所以 

注：你提供的英文文本可能存在语法和表意上的问题，若你有更准确的英文内容，可随时让我翻译。 

10565
07:26:29,478 --> 07:26:33,760
这里的想法是，我们就出发

10566
07:26:31,680 --> 07:26:37,040
无论我们在这里需要做多少事，特写这个

10567
07:26:33,760 --> 07:26:39,398
这整个的总和大概是128加上128 

10568
07:26:37,040 --> 07:26:40,878
总数达到了 256，所以它是

10569
07:26:39,398 --> 07:26:43,160
本质上，每个线程都有其自己的

10570
07:26:40,878 --> 07:26:45,040
那里空间很小，一根线，两根

10571
07:26:43,160 --> 07:26:46,958
线程三
线程四

10572
07:26:45,040 --> 07:26:48,718
线程，没错，它们都有各自的……（这里句子不太完整，“get their own”后面可能省略了内容，根据已有信息大致翻译如此） 

10573
07:26:46,958 --> 07:26:51,160
里面有一小块，而且他们能够……（这里原句未完整，“able”后应有内容才完整表意） 

10574
07:26:48,718 --> 07:26:52,160
以四分之一的量向下加载，对，就是那样

10575
07:26:51,160 --> 07:26:54,878
那 那基本上就是我们的……（原句不完整） 

10576
07:26:52,160 --> 07:26:57,840
加载到共享内存，所以只需等待

10577
07:26:54,878 --> 07:26:59,878
我们刚刚加载的这个新上下文，嗯

10578
07:26:57,840 --> 07:27:01,318
你知道我们只是在耍小聪明而已。

10579
07:26:59,878 --> 07:27:04,240
我们如何装载

10580
07:27:01,318 --> 07:27:05,360
那么，鉴于我们已经明白如何……

10581
07:27:04,240 --> 07:27:06,920
所有东西都已加载到共享区。

10582
07:27:05,360 --> 07:27:08,200
记忆，我们可以继续并投身到下一段中

10583
07:27:06,920 --> 07:27:09,680
这里的这部分，而这部分就像是在……的地方

10584
07:27:08,200 --> 07:27:11,360
事情变得有点……有点好笑

10585
07:27:09,680 --> 07:27:13,958
实际上它并没有那么直观，而且

10586
07:27:11,360 --> 07:27:15,798
这部分虽然很糟糕，嗯，但它仍然是一个

10587
07:27:13,958 --> 07:27:20,040
索引部分有点奇怪

10588
07:27:15,798 --> 07:27:23,000
所以如果我们投身其中，那就是我们要不断迭代。

10589
07:27:20,040 --> 07:27:25,080
在这个索引上，对吧，而且这个索引在移动

10590
07:27:23,000 --> 07:27:28,000
回到这，实际上就只是……它就是……它就是……

10591
07:27:25,080 --> 07:27:29,160
即将进化，对吧，所以索引（idx）是 0、1、2

10592
07:27:28,000 --> 07:27:30,718
还有三个，没错，他们要去，他们……

10593
07:27:29,160 --> 07:27:32,120
像这样向内探索

10594
07:27:30,718 --> 07:27:34,680
呃，有一个线程负责这个

10595
07:27:32,120 --> 07:27:36,840
中间有个小方块，嗯，还有那个

10596
07:27:34,680 --> 07:27:40,040
每个线程都要负责（注：原英文句子存在拼写错误，正确可能是“Each thread is responsible” ）

10597
07:27:36,840 --> 07:27:44,080
用于，呃，按列和按行加载

10598
07:27:40,040 --> 07:27:47,718
没错，一个线程就能处理好那件事。

10599
07:27:44,080 --> 07:27:49,200
嗯，现在如果我们看看这里面，我们加载

10600
07:27:47,718 --> 07:27:51,120
进入寄存器，对吧，所以这个

10601
07:27:49,200 --> 07:27:52,478
寄存器是速度极快的部件

10602
07:27:51,120 --> 07:27:56,558
就在旁边的存储空间

10603
07:27:52,478 --> 07:27:58,280
深入到核心，在，在，在 GPU 里，所以

10604
07:27:56,558 --> 07:28:01,120
我们有这个M规则，对吧，它正在……

10605
07:27:58,280 --> 07:28:03,478
要加载那一列，那么我们该如何加载呢

10606
07:28:01,120 --> 07:28:06,318
这个，我们得看看这一排线

10607
07:28:03,478 --> 07:28:08,318
没错，并且要理解其他的一切

10608
07:28:06,318 --> 07:28:10,760
那我们来看看这边的线排吧，所以

10609
07:28:08,318 --> 07:28:14,080
这条线排在哪里呢，所以它是…… 

10610
07:28:10,760 --> 07:28:18,000
线程 ID x.x，所以这可能是最大值

10611
07:28:14,080 --> 07:28:23,280
你知道的

10612
07:28:18,000 --> 07:28:29,160
256，然后我们用它除以 BN / TN

10613
07:28:23,280 --> 07:28:35,240
对，所以 BN 是 128，TN 是 8，那么你

10614
07:28:29,160 --> 07:28:39,798
用 128 除以 8，结果是 16，所以我们得到

10615
07:28:35,240 --> 07:28:41,398
256 被划分，范围从 0 到 255，然后

10616
07:28:39,798 --> 07:28:47,200
不管是其中哪一个，都对其进行除法运算。

10617
07:28:41,398 --> 07:28:49,840
到16 没错 所以在这内部 我们最终

10618
07:28:47,200 --> 07:28:51,280
有 16 个不同的数字，它们可能

10619
07:28:49,840 --> 07:28:54,600
我们可能已经结束了，所以如果我们看看

10620
07:28:51,280 --> 07:28:56,520
在这个最初的位置 这里有16个

10621
07:28:54,600 --> 07:28:59,760
不同的

10622
07:28:56,520 --> 07:29:01,798
嗯，我们可能会有16种不同的排列组合 

10623
07:28:59,760 --> 07:29:03,718
没错，这些只是偏移量，保持

10624
07:29:01,798 --> 07:29:06,718
在脑海中，我们正在按列加载那些

10625
07:29:03,718 --> 07:29:10,200
长度为八个元素，所以我们有像

10626
07:29:06,718 --> 07:29:11,280
16 16 16 一直往下，呃，我们有

10627
07:29:10,200 --> 07:29:13,638
这八个；这八（个、位等，需结合具体语境确定“eight”所指代的事物） 

10628
07:29:11,280 --> 07:29:17,798
次数 嗯

10629
07:29:13,638 --> 07:29:21,760
并且这些中的每一个，哦不对，要重复16次。

10630
07:29:17,798 --> 07:29:23,760
嗯，这里的每一小列

10631
07:29:21,760 --> 07:29:26,360
你看这个有点像彩色区域的小块儿 

10632
07:29:23,760 --> 07:29:28,798
可以说那将会长达八（个单位，此处“八”后面未明确单位，需结合语境理解） 

10633
07:29:26,360 --> 07:29:32,120
对，所以我们实际上正在加载

10634
07:29:28,798 --> 07:29:36,718
就像我们到了八点那样，那感觉就像，那感觉就像

10635
07:29:32,120 --> 07:29:38,520
一个“嗯”，也就是单列，并且

10636
07:29:36,718 --> 07:29:39,920
然后接下来不管是哪一个，就好像是

10637
07:29:38,520 --> 07:29:42,638
这又是一个八分，而且我们一直都……（此处原英文句子似乎不完整）

10638
07:29:39,920 --> 07:29:46,478
向下移动16次，然后累积起来

10639
07:29:42,638 --> 07:29:49,680
到M的总长度，其为128，所以

10640
07:29:46,478 --> 07:29:51,080
数学就是在进行数学运算，嗯，还是同样的事儿

10641
07:29:49,680 --> 07:29:52,798
适用于线程列，对吧，我的意思是

10642
07:29:51,080 --> 07:29:54,280
这些是 这些是方阵，所以

10643
07:29:52,798 --> 07:29:58,080
实际上处理起来也不算太糟糕。

10644
07:29:54,280 --> 07:30:00,360
这个，嗯，所以这里也是同样的思路，嗯，然后我们结束。

10645
07:29:58,080 --> 07:30:02,840
取值范围在 0 到 50 之间

10646
07:30:00,360 --> 07:30:08,718
对，所以如果我们回到过去

10647
07:30:02,840 --> 07:30:13,760
向下线程行时间 商标 所以 商标是

10648
07:30:08,718 --> 07:30:16,160
呃，“TM”是，呃，就像“TM”本质上是

10649
07:30:13,760 --> 07:30:18,080
八，对，所以会是

10650
07:30:16,160 --> 07:30:21,160
无论我们处于哪一行线程，那么是哪一个（线程行）呢 

10651
07:30:18,080 --> 07:30:22,878
嗯，在这些当中的任意一个，从……当中

10652
07:30:21,160 --> 07:30:28,040
我们是十六分之一

10653
07:30:22,878 --> 07:30:31,080
然后乘以，嗯，乘以

10654
07:30:28,040 --> 07:30:33,718
TM加上我，而我将会是那样

10655
07:30:31,080 --> 07:30:35,360
这里有个小迭代器，它会递增到TM

10656
07:30:33,718 --> 07:30:37,958
没错，那个商标就是那样的，就是那个的长度。 

10657
07:30:35,360 --> 07:30:39,280
柱子之类的 是啊，你可以这么说

10658
07:30:37,958 --> 07:30:41,878
那个的高度或者长度

10659
07:30:39,280 --> 07:30:43,360
列，它将迭代到 I 并且

10660
07:30:41,878 --> 07:30:46,318
它会把那个录入收银机。

10661
07:30:43,360 --> 07:30:48,440
好，我们将整个式子乘以……

注：原文 “M right” 可能有误，推测想说 “All right” ，这里按理解的通顺意思翻译。 

10662
07:30:46,318 --> 07:30:50,360
BK 这样我们就能产生这个偏移量了

10663
07:30:48,440 --> 07:30:52,440
因为我们必须经历这一切，好的

10664
07:30:50,360 --> 07:30:53,760
每次我们……的时候都要重新设置某件事

注：原文句子似乎不完整，此翻译是基于现有内容给出的。 

10665
07:30:52,440 --> 07:30:56,200
想得到一个新的列，你不能仅仅

10666
07:30:53,760 --> 07:30:58,558
直接往下走，你得大步走一步

10667
07:30:56,200 --> 07:31:01,478
全程过去到达下一个（地点/目标等，需结合具体语境确定）

10668
07:30:58,558 --> 07:31:03,240
一个，然后我们把索引（idx）加到这个上面，所以 这

10669
07:31:01,478 --> 07:31:06,600
当我们……时，实际上会变得非常直观。 

10670
07:31:03,240 --> 07:31:08,200
一眼看过去，所以希望如此

10671
07:31:06,600 --> 07:31:12,000
这有点……希望这是那种……

10672
07:31:08,200 --> 07:31:13,680
在你脑子里弄明白 嗯 但这个

10673
07:31:12,000 --> 07:31:16,080
idx 只会让我们不断进化，它是 

10674
07:31:13,680 --> 07:31:17,440
将会是那个水平偏移量

10675
07:31:16,080 --> 07:31:18,878
然后这就是垂直偏移量

10676
07:31:17,440 --> 07:31:21,040
没错，这里的这一整部分就是那个

10677
07:31:18,878 --> 07:31:24,478
垂直偏移量

10678
07:31:21,040 --> 07:31:26,200
嗯，然后我们将同样的概念应用于

10679
07:31:24,478 --> 07:31:28,600
加载到寄存器 n 中，没错，那么让

10680
07:31:26,200 --> 07:31:30,360
寄存器 n 没那么糟糕，嗯，因为我们…… 

10681
07:31:28,600 --> 07:31:33,120
实际上在加载，呃，我们实际上

10682
07:31:30,360 --> 07:31:35,798
水平加载，所以它将会是

10683
07:31:33,120 --> 07:31:39,520
顺便说一下，那个索引正在（进行某种状态，但原文未明确说明“going”的具体指向） 

10684
07:31:35,798 --> 07:31:41,558
现在向下，所以索引（idx）乘以 BN，BN 是

10685
07:31:39,520 --> 07:31:46,280
它的长度，对吧，所以你要去…… 

10686
07:31:41,558 --> 07:31:48,958
往下，嗯，无论你处于哪个索引位置

10687
07:31:46,280 --> 07:31:51,840
嗯，你要减少那么多啊

10688
07:31:48,958 --> 07:31:54,280
分层，然后你要去做，呃

10689
07:31:51,840 --> 07:31:56,160
无论你在哪个线程列里

10690
07:31:54,280 --> 07:31:58,120
所以每个线程都将拥有它的

10691
07:31:56,160 --> 07:31:59,680
拥有 呃 它会有它自己小小的…… 

10692
07:31:58,120 --> 07:32:01,280
那个右边部分它将会有

10693
07:31:59,680 --> 07:32:03,680
它有自己的工作，因为线程就像

10694
07:32:01,280 --> 07:32:06,600
正在加载特定的……特定的方块于……

10695
07:32:03,680 --> 07:32:10,200
那个瓷砖，所以线索在这儿，线索在这儿

10696
07:32:06,600 --> 07:32:12,398
这里有条线索 这里有条线索 就好像

10697
07:32:10,200 --> 07:32:13,680
是的，每个线程都有其独特之处，所以

10698
07:32:12,398 --> 07:32:16,040
我们只是在担心某一个

10699
07:32:13,680 --> 07:32:19,200
线程；线；螺纹；思路；一连串；一缕；细细的一条；线索；脉络；情节

10700
07:32:16,040 --> 07:32:22,600
嗯，线程，线程就像，你知道的，线程

10701
07:32:19,200 --> 07:32:24,080
一个像在这儿，然后线程 255 是

10702
07:32:22,600 --> 07:32:25,840
或者线程 0 在这里，然后是线程

10703
07:32:24,080 --> 07:32:27,558
255 在这里是因为它与……类似

注：由于原文未完整表述，翻译可能存在表意不够清晰的情况。 

10704
07:32:25,840 --> 07:32:30,160
最边缘，然后又是最边缘，

10705
07:32:27,558 --> 07:32:31,200
然后它们在256处相交，对吗？

10706
07:32:30,160 --> 07:32:33,680
就是这样 就是这样 我有点……

10707
07:32:31,200 --> 07:32:34,840
现在来想象一下，我们有这个额外的…… 

10708
07:32:33,680 --> 07:32:36,680
我所说的这个术语，从字面上看仅仅是那个（此处缺少上下文，不太明确“那个”具体所指） 

10709
07:32:34,840 --> 07:32:38,398
水平偏移，所以当你……当你……

10710
07:32:36,680 --> 07:32:40,680
你已经绕了大概多少圈了

10711
07:32:38,398 --> 07:32:42,760
无论你需要多少个身份证件副本

10712
07:32:40,680 --> 07:32:44,080
然后你还有那个额外的“i”，它是

10713
07:32:42,760 --> 07:32:45,600
将会是那个偏移量，所以你要去……

10714
07:32:44,080 --> 07:32:46,920
加载第一个元素进入

10715
07:32:45,600 --> 07:32:48,280
第一排，然后第二排，接着第三排

10716
07:32:46,920 --> 07:32:49,680
然后是第四个，接着情况相同

10717
07:32:48,280 --> 07:32:51,520
适用于这里上面的这一列，我们……（这里原句不完整） 

10718
07:32:49,680 --> 07:32:53,520
已经做了，接下来就做 1、2、3 了

10719
07:32:51,520 --> 07:32:55,080
一直到八，对吧，然后

10720
07:32:53,520 --> 07:32:57,558
它会把这个存储在类似一个……的地方

10721
07:32:55,080 --> 07:32:59,398
像一行那样记录内存，并且这个

10722
07:32:57,558 --> 07:33:02,718
使我们能够轻松地生产出那种产品

（不过原英文句子可能表述有误，准确的句子可能是“allows us to easily make a product that...” 之类的） 

10723
07:32:59,398 --> 07:33:05,478
好的，所以当我们降到这里的时候，嗯

10724
07:33:02,718 --> 07:33:08,798
这就是整个黄色到黄色的循环

10725
07:33:05,478 --> 07:33:11,120
嗯，我们从 M 分量开始。

10726
07:33:08,798 --> 07:33:13,440
对，所以线程 m 是这一部分，然后

10727
07:33:11,120 --> 07:33:16,600
线程 n 处于这一部分，所以这个……这个 n

10728
07:33:13,440 --> 07:33:19,000
组件现在实际上在它里面了

10729
07:33:16,600 --> 07:33:22,160
线程结果计算为 res

10730
07:33:19,000 --> 07:33:26,200
索引 M，所以无论它是多少

10731
07:33:22,160 --> 07:33:28,200
通过，呃，TM，对，那乘以TN，这…… 

10732
07:33:26,200 --> 07:33:29,920
哪个是水平步幅？

10733
07:33:28,200 --> 07:33:32,760
你需要做些什么才能进入到下一个（阶段/环节等，需结合上下文确定）

10734
07:33:29,920 --> 07:33:35,680
接下来，嗯，接下来这一行

10735
07:33:32,760 --> 07:33:40,440
对，然后你也有这个TN（这里需结合具体语境确定TN的准确含义）

 

10736
07:33:35,680 --> 07:33:40,440
所以TN表示你进展到什么程度了，那么

10737
07:33:41,240 --> 07:33:45,440
抱歉，“res idx”进行到什么程度了

注：“res idx”可能是特定领域的术语或缩写，如果有具体背景信息可提供更准确翻译。 

10738
07:33:43,798 --> 07:33:48,000
你，呃，所以这将是你的

10739
07:33:45,440 --> 07:33:50,160
你的垂直步幅，然后这是

10740
07:33:48,000 --> 07:33:51,558
将是水平偏移量，对吧

10741
07:33:50,160 --> 07:33:53,520
所以这就是我们所说的……我们是……

10742
07:33:51,558 --> 07:33:55,360
将它存储在线性内存中，但这是

10743
07:33:53,520 --> 07:34:01,718
这就是我们要如何对其进行索引的方式

10744
07:33:55,360 --> 07:34:01,718
对，然后我们就去做那件事，嗯

10745
07:34:02,080 --> 07:34:06,200
并且请记住，这是一个

10746
07:34:03,520 --> 07:34:08,318
单个的，嗯，这是一个单个的网格。

10747
07:34:06,200 --> 07:34:11,440
好，假设你正在看着一个

10748
07:34:08,318 --> 07:34:13,760
你正在谈论网格内的某个点，嗯

10749
07:34:11,440 --> 07:34:15,840
本质上是对这些进行点积运算

10750
07:34:13,760 --> 07:34:18,638
所以你得进行迭代，你懂的

10751
07:34:15,840 --> 07:34:19,760
八，然后再乘以八，所以结果是六十四。

10752
07:34:18,638 --> 07:34:22,798
你必须经历的迭代次数

10753
07:34:19,760 --> 07:34:24,398
填满整个方块，嗯，然后

10754
07:34:22,798 --> 07:34:27,398
你就像你平常那样去用，你懂的。

10755
07:34:24,398 --> 07:34:29,440
期望那个值，无论它是什么，所以

10756
07:34:27,398 --> 07:34:31,478
你实际上只是在穿过

10757
07:34:29,440 --> 07:34:33,878
你正在寻找它们的相交之处。

10758
07:34:31,478 --> 07:34:36,280
然后你正在设置这个不管是什么的东西

10759
07:34:33,878 --> 07:34:39,398
那么，这样一来结局就变成这样了

10760
07:34:36,280 --> 07:34:42,200
整个呃，矩阵灯都熄灭了，就好像

10761
07:34:39,398 --> 07:34:43,798
而不是像这样被……装载着，你

10762
07:34:42,200 --> 07:34:46,040
就拿这一排，然后把它连接到

10763
07:34:43,798 --> 07:34:47,680
结束，然后把这个附在那里

10764
07:34:46,040 --> 07:34:50,398
然后这个，它甚至更远了

10765
07:34:47,680 --> 07:34:51,878
对，我们在那里就做这些事，所以

10766
07:34:50,398 --> 07:34:54,840
这简直就和你想象的一模一样。

10767
07:34:51,878 --> 07:34:56,240
在你脑海里，事情就是这样运作的，嗯

10768
07:34:54,840 --> 07:34:57,680
只是……只是这很重要，要…… 

10769
07:34:56,240 --> 07:34:59,080
实际上突出显示，就像……什么的

10770
07:34:57,680 --> 07:35:01,080
索引实际上在做的事情，而不是

10771
07:34:59,080 --> 07:35:02,520
只是相信它会起作用，这真的……

10772
07:35:01,080 --> 07:35:04,440
真正深入探究到底是什么很重要

10773
07:35:02,520 --> 07:35:05,920
这是在幕后进行的，所以我

10774
07:35:04,440 --> 07:35:07,840
如果这并非完全如此，鼓励你（此处原英文句子不太完整通顺，可能影响表意准确性）

10775
07:35:05,920 --> 07:35:09,120
有道理，这非常直观，我

10776
07:35:07,840 --> 07:35:11,040
鼓励你用你自己的（东西）来测试它。

10777
07:35:09,120 --> 07:35:12,680
例子 所以哪怕只是拿一片

10778
07:35:11,040 --> 07:35:14,680
在一张纸上写下 在白板上写下

10779
07:35:12,680 --> 07:35:15,958
无论你需要做什么，嗯，还有就是……

10780
07:35:14,680 --> 07:35:17,920
就把这个写出来，然后试着……

10781
07:35:15,958 --> 07:35:20,080
一步一步地去想象它，对吧

10782
07:35:17,920 --> 07:35:21,878
你甚至可以设置，例如，将TM设置为以及

10783
07:35:20,080 --> 07:35:23,440
精确到四位小数，没错，你可以让它更……（此处“much”后语义不完整） 

10784
07:35:21,878 --> 07:35:25,398
对自己好点，你不必去的

10785
07:35:23,440 --> 07:35:26,958
在我们所使用的最大程度上

10786
07:35:25,398 --> 07:35:28,760
你知道我们像“八”这样的参数，以及…… 

10787
07:35:26,958 --> 07:35:30,638
两份128（这里不清楚“128”具体指代什么，可能是价格、数量等），你甚至都不用去（这里“去”的具体指向也不明）

10788
07:35:28,760 --> 07:35:32,958
到目前为止，你可以对此非常简单地处理。

10789
07:35:30,638 --> 07:35:35,920
你如何锻炼那个（或 你如何运用那个）

10790
07:35:32,958 --> 07:35:38,920
嗯，不过没错，这实际上就是我们……的方式（原句不完整）

10791
07:35:35,920 --> 07:35:41,478
计算单个线程块

注：原文“the the”存在重复使用定冠词的错误，正常应是“calculate the individual thread tile” 。 

10792
07:35:38,920 --> 07:35:43,718
所以这个“此线程”磁贴，这个小小的二维（元素） 

10793
07:35:41,478 --> 07:35:45,318
大砖块里面的东西

10794
07:35:43,718 --> 07:35:48,760
并且我们为每个线程计算其中一个

10795
07:35:45,318 --> 07:35:53,520
好的，那么 256 个线程是这样排列的，嗯，所以

10796
07:35:48,760 --> 07:35:56,840
这 这就像是从 0 到 16，我觉得是从 0 到……

10797
07:35:53,520 --> 07:35:58,440
240，然后在这边是256，那

10798
07:35:56,840 --> 07:36:00,080
它可能会基于……而有所偏移

10799
07:35:58,440 --> 07:36:02,398
你是怎么看待我脑海中的这幅画面的

10800
07:36:00,080 --> 07:36:05,040
摆摆手，但大概意思就是这样，你呢

10801
07:36:02,398 --> 07:36:08,440
从 0 开始（原句“from from”可能有误，推测正确表述是“from 0” ） 

10802
07:36:05,040 --> 07:36:10,600
到256，对吧，让我确认一下

10803
07:36:08,440 --> 07:36:12,878
一切呢，呃，都同步好了，你知道的，我们

10804
07:36:10,600 --> 07:36:14,920
确保所有这些都完成了，嗯，你

10805
07:36:12,878 --> 07:36:16,840
要知道，当我们遍历所有……

10806
07:36:14,920 --> 07:36:18,798
所有这些块状瓷砖，对吧，我们

10807
07:36:16,840 --> 07:36:21,638
得往更大的方向发展之类的

10808
07:36:18,798 --> 07:36:24,280
对于矩阵 A 和 B，我们实际上必须

10809
07:36:21,638 --> 07:36:26,120
拿着这些瓷砖，然后我们得，呃，移动

10810
07:36:24,280 --> 07:36:27,920
把它们靠得更近一些，对，所以这是

10811
07:36:26,120 --> 07:36:29,680
整个这个循环正在做的事情，我们想……

10812
07:36:27,920 --> 07:36:34,080
确保一切都同步了，两边都是

10813
07:36:29,680 --> 07:36:36,280
在呃共享内存呃填充之后

10814
07:36:34,080 --> 07:36:38,360
所以在我们填充完那些之后，我们想要…… 

10815
07:36:36,280 --> 07:36:39,920
同步所有内容，然后一旦我们……

10816
07:36:38,360 --> 07:36:42,000
一旦我们把所有的都写好了之后再写

10817
07:36:39,920 --> 07:36:43,240
结果 在这里我们也想进行同步

10818
07:36:42,000 --> 07:36:45,398
把所有东西整理好，确保所有的线头（情况、头绪等，需结合具体语境确定“threads”准确含义）

10819
07:36:43,240 --> 07:36:48,958
在我们，你懂的，进化之前被卷入其中

10820
07:36:45,398 --> 07:36:51,200
到下一个，然后去捣鼓些东西，嗯

10821
07:36:48,958 --> 07:36:52,680
那么接下来我们要把这个写出来，嗯，还有

10822
07:36:51,200 --> 07:36:56,920
这实际上也不算太糟，这部分的

10823
07:36:52,680 --> 07:36:58,600
相当不错，所以在这儿里面我们进行迭代

10824
07:36:56,920 --> 07:37:00,600
和我们在这里做的同样的事情

10825
07:36:58,600 --> 07:37:02,600
当我们实际在计算的时候，呃

10826
07:37:00,600 --> 07:37:05,398
当我们在进行那些乘法运算的时候

10827
07:37:02,600 --> 07:37:07,440
那些线程行和列，那些

10828
07:37:05,398 --> 07:37:11,080
小线头；小丝线（需结合具体语境确定更合适的表述）

10829
07:37:07,440 --> 07:37:12,600
瓷砖，要是我们就这么一步步来处理这个（问题） 

10830
07:37:11,080 --> 07:37:14,878
实际上，这看起来会有点……

10831
07:37:12,600 --> 07:37:17,558
一开始有点奇怪，但如果我们往上滚动

10832
07:37:14,878 --> 07:37:20,680
记住，我们把一切都推进到…… 

10833
07:37:17,558 --> 07:37:23,318
鉴于这个话题的起始立场

10834
07:37:20,680 --> 07:37:24,878
对，或者更确切地说，鉴于这个模块，所以我们

10835
07:37:23,318 --> 07:37:27,798
有这些初始项，它们是

10836
07:37:24,878 --> 07:37:30,040
方块 这些是 我们用的是哪些瓷砖 哪些

10837
07:37:27,798 --> 07:37:31,318
在 C 语言中我们真正关心的部分

10838
07:37:30,040 --> 07:37:32,798
并且这个已经存储在这里了，所以我们

10839
07:37:31,318 --> 07:37:34,760
已经知道我们实际上想要哪一块瓷砖了

10840
07:37:32,798 --> 07:37:36,520
去担忧以及那回忆

10841
07:37:34,760 --> 07:37:38,360
地址已经过了，它跳过了一个

10842
07:37:36,520 --> 07:37:41,120
一群；一束；一堆

10843
07:37:38,360 --> 07:37:42,440
就像整数一样穿过空间

10844
07:37:41,120 --> 07:37:43,798
运算 它已经被乘过了，并且

10845
07:37:42,440 --> 07:37:45,558
累积到了这样一个程度，即它所处的状态是…… 

10846
07:37:43,798 --> 07:37:47,798
我们想要它，然后就去做

10847
07:37:45,558 --> 07:37:50,160
从那里的一切，所以我们可以，如果我们

10848
07:37:47,798 --> 07:37:51,718
像跨越整整一个长度 K 那样大步迈进，它会前行

10849
07:37:50,160 --> 07:37:53,878
这里，然后是它的其余部分以及

10850
07:37:51,718 --> 07:37:56,718
最终它还是会回到原来的样子，但是

10851
07:37:53,878 --> 07:37:57,798
就像右下角的一个元素那样，所以

10852
07:37:56,718 --> 07:38:00,160
那……那真的就是我们正在做的全部了

10853
07:37:57,798 --> 07:38:02,680
现在在这里，如果我们再往下滚动

10854
07:38:00,160 --> 07:38:05,520
实际上就像这个学期末一样

10855
07:38:02,680 --> 07:38:07,200
那 那就像是期末的那个 嗯 那个

10856
07:38:05,520 --> 07:38:08,120
那就是那就是水平部分

10857
07:38:07,200 --> 07:38:11,280
对，所以那就是我们所处的部分。 

10858
07:38:08,120 --> 07:38:12,680
实际上是大步跨过，所以如果我们有，嗯

10859
07:38:11,280 --> 07:38:17,200
我们正在看 C

10860
07:38:12,680 --> 07:38:20,520
矩阵，我们有线程行乘以线程 M

10861
07:38:17,200 --> 07:38:23,360
对还是……或者商标（TM），哪个是…… 

10862
07:38:20,520 --> 07:38:26,398
8 加上资源索引，记住，我们……它是

10863
07:38:23,360 --> 07:38:27,440
和我们……呃……同样的想法

10864
07:38:26,398 --> 07:38:30,360
整理；打扫；修缮；打扮

不过 “did up” 在这里语义不太明确，它是 “do up” 的过去式，具体意思需结合语境确定。若这是一个完整的要求翻译的内容，那以上就是它可能的意思表述。 

10865
07:38:27,440 --> 07:38:32,718
就在那里，如此这般

10866
07:38:30,360 --> 07:38:35,120
当我们是

10867
07:38:32,718 --> 07:38:38,398
嗯，它本质上和这个是一样的。

10868
07:38:35,120 --> 07:38:41,760
只不过我们现在用的是“I”，所以你懂的

10869
07:38:38,398 --> 07:38:44,520
我是说你可以把我想象成直到……

不过原句 “I is you could think of i as like up to” 存在语法错误，正确的表达或许是 “You could think of me as up to...” 。 

10870
07:38:41,760 --> 07:38:45,920
嗯，你知道的，TM（可能是某个特定术语），这是类似的概念。

10871
07:38:44,520 --> 07:38:49,160
我们只是在遍历那个，就是这样

10872
07:38:45,920 --> 07:38:52,920
将会是那个里面的偏移量（这里“um”可能是口误，在书面语中一般不会这样表达） 

10873
07:38:49,160 --> 07:38:56,318
那么，从右边的瓦片来看，也就是相对于…… 

10874
07:38:52,920 --> 07:38:58,200
嗯，相对于实际的东南向拖曳情况而言

10875
07:38:56,318 --> 07:39:01,240
我们正在做的这件事将会是

10876
07:38:58,200 --> 07:39:02,680
就像相对偏移量，对吧，嗯，所以

10877
07:39:01,240 --> 07:39:05,000
那将会是

10878
07:39:02,680 --> 07:39:09,000
向下，时间，对，所以就是这样进行下去

10879
07:39:05,000 --> 07:39:11,638
给我们我们向下的，嗯，我们的

10880
07:39:09,000 --> 07:39:15,478
向下移动，然后继续推进

10881
07:39:11,638 --> 07:39:18,798
横向来看，我们有红色的列，即时间TN

10882
07:39:15,478 --> 07:39:21,160
好的，那么一个单独的线程，嗯

10883
07:39:18,798 --> 07:39:24,718
单个线程

10884
07:39:21,160 --> 07:39:26,718
倍数，乘以那个……那个TN的长度

10885
07:39:24,718 --> 07:39:29,760
八，对，所以从本质上来说我们要去……

10886
07:39:26,718 --> 07:39:32,160
有一堆，呃，一堆线索

10887
07:39:29,760 --> 07:39:34,160
像占据一个正方形那样，还有那些

10888
07:39:32,160 --> 07:39:37,600
线程正在运行

10889
07:39:34,160 --> 07:39:38,718
嗯，不是，不是那些线

10890
07:39:37,600 --> 07:39:40,760
占据着一个方格，但他们打算……

10891
07:39:38,718 --> 07:39:42,160
占据整个事物，然后是线程

10892
07:39:40,760 --> 07:39:45,080
每个线程都要进行迭代吗

10893
07:39:42,160 --> 07:39:46,958
通过那个TM和TN，没错，所以我们

10894
07:39:45,080 --> 07:39:49,558
有这个这个垂直偏移量，我们有

10895
07:39:46,958 --> 07:39:51,718
水平偏移量，然后再加上那个 

10896
07:39:49,558 --> 07:39:53,000
再稍微往右边踢一下

10897
07:39:51,718 --> 07:39:54,600
我们打算迭代，这就是我们……（原英文“iter”可能拼写有误，推测可能是“iterate” ，且句子不完整） 

10898
07:39:53,000 --> 07:39:57,638
实际上需要像这样大步跨越

10899
07:39:54,600 --> 07:39:59,600
我们迈的步子有多大 嗯 然后那个

10900
07:39:57,638 --> 07:40:01,080
最初 就像在那里面的里面

10901
07:39:59,600 --> 07:40:02,840
就像这些步骤中的某一步，这是怎么回事呢 

10902
07:40:01,080 --> 07:40:05,360
你实际上向前走了多远，对吧

10903
07:40:02,840 --> 07:40:07,360
你要往里面加多少？（注：原英文句子可能表述有误，正常应是“How much do you add to... ” ）

10904
07:40:05,360 --> 07:40:10,280
它，然后我们就用我们所拥有的……

注：原英文句子似乎不完整，以上翻译基于现有内容。 

10905
07:40:07,360 --> 07:40:12,398
已经计算好了，所以线程结果，嗯

10906
07:40:10,280 --> 07:40:15,840
这里采用同样的索引方案，应该是这样的

10907
07:40:12,398 --> 07:40:17,920
相当直观，嗯，我们只需相乘。

10908
07:40:15,840 --> 07:40:19,840
这种逐元素的（情况），为每个（元素）所知

10909
07:40:17,920 --> 07:40:22,000
循环中的迭代，然后我们有

10910
07:40:19,840 --> 07:40:24,080
我们的测试阶段，你知道的，是逐元素进行的。 

10911
07:40:22,000 --> 07:40:27,600
这实际上完全一样

10912
07:40:24,080 --> 07:40:29,478
我们在这里使用的索引方案，所以

10913
07:40:27,600 --> 07:40:31,760
希望那个块状帐篷内核

10914
07:40:29,478 --> 07:40:33,878
感觉现在我们要直接进入，嗯

10915
07:40:31,760 --> 07:40:36,638
实际上，在我们真正开始之前

10916
07:40:33,878 --> 07:40:41,558
我想运行的那个矢量化内核

10917
07:40:36,638 --> 07:40:44,478
这个，所以如果我们去斯耶姆，我们去斯耶姆04

10918
07:40:41,558 --> 07:40:48,160
对，这是，这是块ping

10919
07:40:44,478 --> 07:40:50,520
正常情况下，这是常规的一维块平铺。

10920
07:40:48,160 --> 07:40:55,440
那么，如果我们把这个提升到某个数量级

10921
07:40:50,520 --> 07:40:58,120
五，看看这个，496 上达到 4800 吉次浮点运算每秒

10922
07:40:55,440 --> 07:41:00,760
对，那还不错，但要是我们再提高点水平

10923
07:40:58,120 --> 07:41:03,200
差五分钟（通常用于表达时间，如“to five”可能是“差五分钟到某个整点” ，但此处未明确具体时间点）

10924
07:41:00,760 --> 07:41:09,798
我们加倍

10925
07:41:03,200 --> 07:41:14,120
所以如果我们使用 Python，我们会朝着……方向进行

（注：原文“it so”表述有误，推测可能是“So if” ） 

10926
07:41:09,798 --> 07:41:14,120
9162 /

10927
07:41:14,718 --> 07:41:21,520
4873 大约有 1.9 倍的提速，对吧，这（此处原英文句子不完整） 

10928
07:41:17,920 --> 07:41:23,080
现在真的很好，我们来和……作比较

10929
07:41:21,520 --> 07:41:24,878
结果

10930
07:41:23,080 --> 07:41:30,360
这里

10931
07:41:24,878 --> 07:41:32,520
嗯，所以大概在这个时候，大约1.9（这里“1.9”由于缺乏上下文，不清楚具体所指）

10932
07:41:30,360 --> 07:41:33,760
是不是差不多快到70了，对吧，所以我

10933
07:41:32,520 --> 07:41:36,200
意味着我们实际上正在得到……（此处原英文不完整，翻译仅基于现有内容） 

10934
07:41:33,760 --> 07:41:39,280
我这里也是同样的结果，呃，所以一切都是…… 

10935
07:41:36,200 --> 07:41:42,160
锻炼的时候我们刚刚把速度提高了一倍，通过…… （原句似乎不完整，“by”后应有内容）

10936
07:41:39,280 --> 07:41:44,360
使用二维块平铺而非一维，并且

10937
07:41:42,160 --> 07:41:46,718
现在我们已经完成了大约三分之二的路程

10938
07:41:44,360 --> 07:41:49,920
对郭（可能是特定人名）的表演，实际上我们真的…… 

10939
07:41:46,718 --> 07:41:51,160
真的在很高的地方，所以现在我们走吧

10940
07:41:49,920 --> 07:41:52,600
继续进行矢量化操作

10941
07:41:51,160 --> 07:41:55,160
内存访问，这将为我们带来…… 

10942
07:41:52,600 --> 07:41:58,360
额外的一点性能提升

10943
07:41:55,160 --> 07:41:59,760
好极了，那么现在我们有了这个新的

10944
07:41:58,360 --> 07:42:02,878
没有什么可担心的

注：你提供的“colel”可能有误，推测正确的是“nothing” 。若这并非你想要的内容，请提供准确原文。 

10945
07:41:59,760 --> 07:42:07,440
关于矢量化共享内容的第六点

10946
07:42:02,878 --> 07:42:10,558
内存加载，所以如果我们查看……内部

10947
07:42:07,440 --> 07:42:12,398
本质上，我们在这里是这样做的，我们

10948
07:42:10,558 --> 07:42:16,318
这里的一切都保持着

10949
07:42:12,398 --> 07:42:19,040
一样，只是我们有了这个新的四维浮点数

注：“float 4”常见于计算机图形学、编程等领域，一般指四维浮点数向量，这里可根据具体语境灵活调整表述。 

10950
07:42:16,318 --> 07:42:20,638
输入正确，所以注意一下我们是如何拥有这个的

10951
07:42:19,040 --> 07:42:22,520
这个四维浮点向量（float 4），我打算把它高亮显示一下。

10952
07:42:20,638 --> 07:42:25,398
查看它会出现在哪里，所以它

10953
07:42:22,520 --> 07:42:28,040
我们装载的时候它会出现在这里

10954
07:42:25,398 --> 07:42:30,318
当我们加载进入共享（状态）时……呃

10955
07:42:28,040 --> 07:42:32,760
记忆 所以A共享部分和B共享部分

10956
07:42:30,318 --> 07:42:35,160
对，这里也会出现这个情况。

10957
07:42:32,760 --> 07:42:37,878
就像我们在撰写结果时那样，所以

10958
07:42:35,160 --> 07:42:40,440
当我们从全局显存进入时

10959
07:42:37,878 --> 07:42:42,478
在共享内存中，我们使用浮点数用于

10960
07:42:40,440 --> 07:42:46,160
很多，然后当我们在书写的时候

10961
07:42:42,478 --> 07:42:47,958
从寄存器中我们加载，呃，我们用……加载

10962
07:42:46,160 --> 07:42:50,600
浮点型 FL 也是，没错，这就是……

10963
07:42:47,958 --> 07:42:52,318
在深入探讨之前，现在这里正在发生的情况

10964
07:42:50,600 --> 07:42:53,440
直接进入这个内容，我想接着谈一谈并……

10965
07:42:52,318 --> 07:42:55,040
评论 这到底是怎么回事啊

10966
07:42:53,440 --> 07:42:56,958
浮动板，这里有很多术语

10967
07:42:55,040 --> 07:42:58,638
就像强制类型转换 reinterpret_cast 以及诸如此类的所有情况

10968
07:42:56,958 --> 07:43:00,120
这些奇怪的符号之类的，所以让我们

10969
07:42:58,638 --> 07:43:02,360
就像去弄清楚这一切究竟是怎么回事

10970
07:43:00,120 --> 07:43:04,160
意味着我在这里写了一个单独的文件

10971
07:43:02,360 --> 07:43:05,440
为.cuu 调用了浮点类型，你可以编写这个

10972
07:43:04,160 --> 07:43:08,200
同样的事情，但我只是打算再讲一遍

10973
07:43:05,440 --> 07:43:12,520
这种循序渐进的方式，所以我们有一个

10974
07:43:08,200 --> 07:43:15,840
数组长度为 n，对，1、3、4 全部

10975
07:43:12,520 --> 07:43:18,398
浮点数，我们有一个主机输入和一个主机输出。

10976
07:43:15,840 --> 07:43:22,318
我们初始化设备的输入和输出，我们

10977
07:43:18,398 --> 07:43:24,558
比如那些具有 n * 浮点大小的，我们

10978
07:43:22,318 --> 07:43:26,520
库德·M 从主机复制到……

10979
07:43:24,558 --> 07:43:29,920
设备 主机 到

10980
07:43:26,520 --> 07:43:31,558
我们将和你一起用这个设备来推出这个（产品等，因原句表意不完整，“this”指代不明） 

10981
07:43:29,920 --> 07:43:33,318
呃，当网格大小为 1 时，有一个

10982
07:43:31,558 --> 07:43:34,840
单个区块，并且在那个区块内

10983
07:43:33,318 --> 07:43:37,398
只有一根线，所以就只有一个。

10984
07:43:34,840 --> 07:43:39,760
这里实际正在使用的线程

10985
07:43:37,398 --> 07:43:41,360
现在我们运行这个，然后再复制回来

10986
07:43:39,760 --> 07:43:45,398
然后我们根据它们的（情况）来展示这些（内容）

10987
07:43:41,360 --> 07:43:47,478
索引，所以是 0 1 2 3，然后是 0 1 2 3

10988
07:43:45,398 --> 07:43:49,080
输入和输出，现在怎么办

10989
07:43:47,478 --> 07:43:51,120
实际上这里面发生的事情是怎样的呢

10990
07:43:49,080 --> 07:43:52,840
我们想予以关注，这样我们就能通过

10991
07:43:51,120 --> 07:43:55,360
这个 这个设备输入以及该设备

10992
07:43:52,840 --> 07:43:59,920
在右侧输出
这些是指针 两个

10993
07:43:55,360 --> 07:44:01,478
数组，嗯，现在也有输出了，我们有了索引（idx） 

10994
07:43:59,920 --> 07:44:03,558
在这种情况下，哪个线程索引正在……

10995
07:44:01,478 --> 07:44:06,318
变为零，没错，它是从类似零的状态开始的

10996
07:44:03,558 --> 07:44:09,000
直至长度减一的任意长度

10997
07:44:06,318 --> 07:44:12,120
所以这将只是零，所以

10998
07:44:09,000 --> 07:44:13,478
当我们实际查看这个 idx 时

10999
07:44:12,120 --> 07:44:16,878
注意
别……别担心

11000
07:44:13,478 --> 07:44:21,080
然而，这个索引将是第4个时间点

11001
07:44:16,878 --> 07:44:24,558
所以 0 乘以 4，0 乘以 4，0 乘以 4，0 乘以 4，结果就只是

11002
07:44:21,080 --> 07:44:27,558
将会是 0、1、2 和 3

11003
07:44:24,558 --> 07:44:29,958
对，这些将是我们的 x、y、z。

11004
07:44:27,558 --> 07:44:31,840
以及 W 分量，现在让我们实际来看一下

11005
07:44:29,958 --> 07:44:33,840
对这里正在发生的事情感到惊讶，所以这个新的……

（注：原文可能并不完整，这样翻译是基于现有的内容尽量保证通顺连贯。） 

11006
07:44:31,840 --> 07:44:35,680
浮点 4 类型，它是……的一部分，它是……的一部分

11007
07:44:33,840 --> 07:44:37,000
关于CUDA运行时，它是……的一部分

11008
07:44:35,680 --> 07:44:39,798
嗯，它不是 CUDA 运行时的一部分。

11009
07:44:37,000 --> 07:44:43,558
如果我们真的审视一下，这是……的一部分

11010
07:44:39,798 --> 07:44:45,000
嗯，x86 对吧，我们有这些向量类型。

11011
07:44:43,558 --> 07:44:46,398
浮点4，我们有一堆不同的

11012
07:44:45,000 --> 07:44:49,600
其他属于设备类型的向量类型

11013
07:44:46,398 --> 07:44:52,080
内置功能，所以实际上我们不能，嗯，我们

11014
07:44:49,600 --> 07:44:53,398
实际上呃，看不清这些是什么

11015
07:44:52,080 --> 07:44:56,000
在幕后，它们只是以某种方式在运转。

11016
07:44:53,398 --> 07:44:58,318
对我们（美国）来说，如果我试着点击这些

11017
07:44:56,000 --> 07:45:00,920
没错，就是那样，真的就这么回事。

11018
07:44:58,318 --> 07:45:03,398
它是

11019
07:45:00,920 --> 07:45:06,280
所以这里面有很多这方面的内容

11020
07:45:03,398 --> 07:45:08,958
是内置的，由编译器处理等

11021
07:45:06,280 --> 07:45:11,760
所以当我们剖析……是什么的时候

11022
07:45:08,958 --> 07:45:13,718
这里正在发生的事情，嗯，我们注意到我们有

11023
07:45:11,760 --> 07:45:16,360
我们对几个部分进行了重新诠释

11024
07:45:13,718 --> 07:45:21,360
演员阵容以及拉利，所有这一切意味着

11025
07:45:16,360 --> 07:45:23,680
我们将把这个……重新诠释为……在……

注：原英文表述似乎不太完整和流畅，这样的翻译只能尽量贴合原文呈现。 

11026
07:45:21,360 --> 07:45:25,240
在实际的说明里，没错，所以这个

11027
07:45:23,680 --> 07:45:27,398
不会去操纵记忆或做

11028
07:45:25,240 --> 07:45:29,638
任何数据转换，这简直就是

11029
07:45:27,398 --> 07:45:32,160
只是打算呃

11030
07:45:29,638 --> 07:45:33,680
重新解释为一个四维浮点向量 就是 就是

11031
07:45:32,160 --> 07:45:35,840
这到底要告诉编译器什么

11032
07:45:33,680 --> 07:45:39,600
该做什么才是正确的，而这将会是

11033
07:45:35,840 --> 07:45:42,318
一个指向 float4 的指针，没错，所以我们现在

11034
07:45:39,600 --> 07:45:45,398
本质上，我们正在对这个进行改造。 

11035
07:45:42,318 --> 07:45:48,080
所以这是一个内存地址，这个 ENT 是

11036
07:45:45,398 --> 07:45:49,878
一个指向任意索引的内存地址

11037
07:45:48,080 --> 07:45:53,558
我们正在研究，所以在这个当中

11038
07:45:49,878 --> 07:45:57,040
在这种情况下，那将会是，你知道的，索引（idx）乘以 4

11039
07:45:53,558 --> 07:45:59,120
在这种情况下，这只会是，嗯

11040
07:45:57,040 --> 07:46:02,638
这就好比 idx 是 z

11041
07:45:59,120 --> 07:46:04,398
所以结果会是 0 呃 0 乘以 4 那就是

11042
07:46:02,638 --> 07:46:08,040
仅仅是起始元素，对吧，那就是

11043
07:46:04,398 --> 07:46:10,920
实际上，所有这一切仅仅是，呃

11044
07:46:08,040 --> 07:46:13,318
我们 我们正在对索引为零的位置进行输入操作

11045
07:46:10,920 --> 07:46:14,680
然后我们呃 我们正在获取……（这里句子不完整，“getting the”后面应该还有内容）

11046
07:46:13,318 --> 07:46:16,520
那个的内存地址，所以它是……（由于文本不完整，“所以它是”后面的内容只能按不完整状态呈现） 

11047
07:46:14,680 --> 07:46:18,040
内存地址，所以在……中的第一个元素

11048
07:46:16,520 --> 07:46:20,280
整个阵列，然后还有那个

11049
07:46:18,040 --> 07:46:25,478
以下是……的内存地址（原句“for for”可能有误）

11050
07:46:20,280 --> 07:46:28,318
额外的那些，然后我们，呃，我们我们我们我们

11051
07:46:25,478 --> 07:46:30,040
将其重新解释为用于指针的浮点数

11052
07:46:28,318 --> 07:46:32,000
所以我们得到了指向内存的指针

11053
07:46:30,040 --> 07:46:33,638
这里的地址，而且我们正在重新诠释

11054
07:46:32,000 --> 07:46:35,798
这是一个 float4 指针，所以我们只是

11055
07:46:33,638 --> 07:46:38,840
从浮点型指针转换为指针

11056
07:46:35,798 --> 07:46:41,040
作为一个四维浮点向量，而这个四维浮点向量呢，它仅仅是

11057
07:46:38,840 --> 07:46:43,958
本质上将会包含

11058
07:46:41,040 --> 07:46:45,798
起始索引再加上一个额外的，呃

11059
07:46:43,958 --> 07:46:47,958
三个之后

11060
07:46:45,798 --> 07:46:52,280
对，嗯，然后我们就有这个了

11061
07:46:47,958 --> 07:46:53,958
为此，将其存储为，呃，索引零，呃

11062
07:46:52,280 --> 07:46:55,558
我们不想成为的特定数据类型

11063
07:46:53,958 --> 07:46:57,200
你知道（它们）多余，还会占用额外的（空间等，需结合上下文确定） 

11064
07:46:55,558 --> 07:46:58,520
空间，所以我们将只索引到零

11065
07:46:57,200 --> 07:47:00,920
然后编译器就会知道

11066
07:46:58,520 --> 07:47:03,000
之后要怎么处理那个呢，嗯，它是……

11067
07:47:00,920 --> 07:47:05,080
真的就只会是 “thex” 了

注：“thex” 可能不是一个常见的英文单词，可能是特定语境、自创或拼写有误的词汇。 

11068
07:47:03,000 --> 07:47:08,120
组件将是索引 0，Y 是

11069
07:47:05,080 --> 07:47:09,878
将是索引一，Z 是二，然后

11070
07:47:08,120 --> 07:47:11,718
W 是三，没错，就是这样。

11071
07:47:09,878 --> 07:47:14,000
实际上，我们是如何安排的，我们又是怎样…… 

11072
07:47:11,718 --> 07:47:15,600
把这个东西摆在这里，然后呢

11073
07:47:14,000 --> 07:47:17,958
实际上所有的所有的浮点4数据

11074
07:47:15,600 --> 07:47:20,240
打字打得这么快，所以希望那样能说得通（这里“type is so”可能表述有误，推测想表达“打字速度很快”之类的意思，结合上下文可能更准确）

11075
07:47:17,958 --> 07:47:22,798
对你来说有意义，嗯，你知道当你阅读的时候

11076
07:47:20,240 --> 07:47:24,520
复杂的，呃，当你读起来有点像

11077
07:47:22,798 --> 07:47:26,120
像这样复杂的表达式，它是

11078
07:47:24,520 --> 07:47:27,680
一步一步地把它拆解开来就好。

11079
07:47:26,120 --> 07:47:29,160
对，所以你有这个，就像你有……

11080
07:47:27,680 --> 07:47:30,440
这个东西，它敞开着，而且它是…… 

11081
07:47:29,160 --> 07:47:31,840
关闭，然后你就遇到了这个情况，和……

11082
07:47:30,440 --> 07:47:33,558
它开着，接着又关上了，然后是这个

11083
07:47:31,840 --> 07:47:35,440
关于它有开着和关着的状态，你（这里句子似乎不太完整通顺）

11084
07:47:33,558 --> 07:47:37,440
就有点像你喜欢你的……（此处原文表意不完整）

11085
07:47:35,440 --> 07:47:39,478
运算顺序或简化形式

11086
07:47:37,440 --> 07:47:41,878
无论你想怎样，但是的，希望那……

11087
07:47:39,478 --> 07:47:43,840
有道理，而且如果我们能，呃，我是

11088
07:47:41,878 --> 07:47:46,840
实际上要去；实际上正在前往

注：“actually going”不是完整句子，这里根据字面进行了常规翻译，更准确的意思需结合具体语境确定。 

11089
07:47:43,840 --> 07:47:46,840
到；向；朝

11090
07:47:48,000 --> 07:47:57,318
哦，糟糕，SJM 光盘进入源内核以及……

（注：原文表述可能不太准确或完整，此翻译基于字面意思呈现。） 

11091
07:47:53,440 --> 07:48:00,200
那么如果我们去把它编译成……

11092
07:47:57,318 --> 07:48:03,718
浮点4，我们注意到我们得到了一切

11093
07:48:00,200 --> 07:48:05,520
正如所料，对吧，那么1、2、3、4，那就是……

11094
07:48:03,718 --> 07:48:08,718
发布输入，所以那就是我们初始化的方式

11095
07:48:05,520 --> 07:48:10,798
它在这儿，嗯，然后是主机输出

11096
07:48:08,718 --> 07:48:13,440
这，嗯，正是我们所期望的方式

11097
07:48:10,798 --> 07:48:14,280
所有东西都要存放起来 嗯，就这些了

11098
07:48:13,440 --> 07:48:17,520
正在检查

11099
07:48:14,280 --> 07:48:19,360
现在发布了，下一个内核真的很有趣

11100
07:48:17,520 --> 07:48:20,878
呃，它在一些事情上做了些尝试。

11101
07:48:19,360 --> 07:48:22,360
那些通常是被拿来摆弄的，并且

11102
07:48:20,878 --> 07:48:25,440
当你真正写作的时候尝试过的东西（这里原英文表述不太完整和清晰，此翻译是尽量按字面意思来）

11103
07:48:22,360 --> 07:48:29,040
真的，呃，性能达到最佳了，真糟

11104
07:48:25,440 --> 07:48:31,280
内核，没错，所以这里的想法是像

11105
07:48:29,040 --> 07:48:36,638
还记得之前我给你展示的时候吗

11106
07:48:31,280 --> 07:48:38,638
那些，呃，我们回到这里，呃，我是

11107
07:48:36,638 --> 07:48:42,360
准备迈步
即将行动（根据具体语境，“step”含义可能不同，“going to step” 较常见有这两种理解） 

11108
07:48:38,638 --> 07:48:47,680
出去然后前往SRC内核，接着我们

11109
07:48:42,360 --> 07:48:47,680
我们做了这个，而且我们看到了

11110
07:48:55,958 --> 07:49:03,520
嗯，我们上去了，我们看到了这些，嗯，像……

11111
07:49:00,398 --> 07:49:06,680
这个加载 这个 这个加载指令 这个

11112
07:49:03,520 --> 07:49:09,440
加载。E，然后就好像有一些……

11113
07:49:06,680 --> 07:49:12,120
加载，呃，128，就像先加载32，然后……

11114
07:49:09,440 --> 07:49:15,000
加载128秒，对，所以那就像是……

11115
07:49:12,120 --> 07:49:17,680
整个来说，这里的全部情况是

11116
07:49:15,000 --> 07:49:18,760
我们打算试着制作更多这样的东西。

11117
07:49:17,680 --> 07:49:21,280
加载；装载；负担；负荷；负载；大量；许多；工作量；负荷量；（尤指供电、供气等的）需求量；（枪的）一发子弹；（相机的）一卷胶卷
把…装上车（或船等）；装载；装入；使担负（任务、责任等）；使承受；给（枪）装子弹；给（相机）装胶卷；（计算机）加载，载入（程序、数据等）

11118
07:49:18,760 --> 07:49:26,160
128 秒 一个单精度浮点数是

11119
07:49:21,280 --> 07:49:29,680
32位，所以如果我们，嗯，如果我们这么做

11120
07:49:26,160 --> 07:49:33,000
这就像一种向量类型的含义

11121
07:49:29,680 --> 07:49:35,520
你知道我们只是放入了多个数字

11122
07:49:33,000 --> 07:49:37,318
彼此属于同一种类型，那么我们

11123
07:49:35,520 --> 07:49:38,920
可以拥有更多，而且我们可以装载更多

11124
07:49:37,318 --> 07:49:41,440
事物；东西；事情

11125
07:49:38,920 --> 07:49:43,840
那么，让我们继续，实际上往回跳一下

11126
07:49:41,440 --> 07:49:45,240
呃，到这里这部分了，让我们来解释一下。

11127
07:49:43,840 --> 07:49:47,000
这到底是怎么回事，我们……

11128
07:49:45,240 --> 07:49:50,760
正在做；从事；进行

11129
07:49:47,000 --> 07:49:54,200
所以在这一个里我们是

11130
07:49:50,760 --> 07:49:56,240
实际上，呃，我们实际上正在采取

11131
07:49:54,200 --> 07:49:59,040
这个瓷砖，所以它通常是这样的 

11132
07:49:56,240 --> 07:50:00,600
垂直的，所以它会像是倾斜的

11133
07:49:59,040 --> 07:50:03,200
向下，就像底部会在这儿一样

11134
07:50:00,600 --> 07:50:05,240
然后这部分会正好放在那里

11135
07:50:03,200 --> 07:50:08,080
我们只是在对它进行移项（或转置，需结合具体语境确定更准确意思）。 

11136
07:50:05,240 --> 07:50:10,200
对，然后这个移项将会

11137
07:50:08,080 --> 07:50:12,040
让我们稍微作弊一下 嗯 我们仍然

11138
07:50:10,200 --> 07:50:13,520
在那里面获取相同数量的内存

11139
07:50:12,040 --> 07:50:15,360
共享块，只是我们对其进行索引

11140
07:50:13,520 --> 07:50:19,398
以不同的方式，这将使我们能够

11141
07:50:15,360 --> 07:50:23,240
缓存内存访问，对，所以通常情况下

11142
07:50:19,398 --> 07:50:25,360
呃，如果我们回去的话，我们会……

11143
07:50:23,240 --> 07:50:29,638
带着这些，我们将会前进

11144
07:50:25,360 --> 07:50:31,920
在这边靠右，但注意是怎样的情况

11145
07:50:29,638 --> 07:50:34,520
嗯，例如，就像当我们实际上……

11146
07:50:31,920 --> 07:50:36,878
正在加载这个，呃，我们的线程正在运行

11147
07:50:34,520 --> 07:50:38,000
要从，嗯，从顶部开始加载到……

11148
07:50:36,878 --> 07:50:40,920
右下角，所以我们将会有类似……的东西

11149
07:50:38,000 --> 07:50:42,798
本质上以……形式组织的类似线程

（注：原英文句子似乎不完整，此翻译仅根据现有内容进行） 

11150
07:50:40,920 --> 07:50:45,200
零散的部分，而且我们打算

11151
07:50:42,798 --> 07:50:46,798
向下迭代以填充这个

11152
07:50:45,200 --> 07:50:51,080
好的，如果你还记得我们是如何填充（数据、内容等，需结合上下文确定具体含义）的

11153
07:50:46,798 --> 07:50:55,200
在这之前，嗯，这些坐标轴不是中欧夏令时（这里“axises”可能有误，推测可能是“axes”；且这里语境中“CEST”可能和坐标轴等内容结合不太合理，可能文本存在一定偏差） 

11154
07:50:51,080 --> 07:51:00,000
但是，呃，那个 B 字母牌，那个 B 字母牌是共用的

11155
07:50:55,200 --> 07:51:03,200
瓷砖嗯，这是中欧夏令时（CEST），因为我们的……线程（此处“threads”在该语境语义不太明确，需结合更多背景信息准确理解）

11156
07:51:00,000 --> 07:51:05,160
呃，我们是水平装载的，所以当我们的……

11157
07:51:03,200 --> 07:51:07,120
我们需要线程，比如线程一、线程二

11158
07:51:05,160 --> 07:51:08,878
线程三
线程四
就这些了

11159
07:51:07,120 --> 07:51:11,600
彼此相邻，所以CUDA将会

11160
07:51:08,878 --> 07:51:13,398
继续把那些加载进去，嗯，就像这样

11161
07:51:11,600 --> 07:51:14,600
如果你有四个它们相邻于…… 

11162
07:51:13,398 --> 07:51:16,638
彼此 它将加载所有那些

11163
07:51:14,600 --> 07:51:18,558
作为单次装载操作，而不是

11164
07:51:16,638 --> 07:51:21,120
四个分开的，所以这就是我们正在……（原句不完整） 

11165
07:51:18,558 --> 07:51:23,558
目标是这里，这里的想法是

11166
07:51:21,120 --> 07:51:25,280
而不是前进
而不是拥有

11167
07:51:23,558 --> 07:51:28,798
这个垂直的瓦片，然后拿起这个

11168
07:51:25,280 --> 07:51:32,000
并推进到……并且就像拥有索引（idx）一样 

11169
07:51:28,798 --> 07:51:33,478
到右边它会被翻转

11170
07:51:32,000 --> 07:51:35,000
并且我们将向下迭代，所以

11171
07:51:33,478 --> 07:51:37,680
我们的线将像这样配对：

11172
07:51:35,000 --> 07:51:39,798
这个紧挨着彼此，而且它正在……

11173
07:51:37,680 --> 07:51:41,760
向下迭代，没错，那就是……

11174
07:51:39,798 --> 07:51:44,280
那里的整个想法，嗯，但更……的是

11175
07:51:41,760 --> 07:51:45,718
重要的甚至不在于他们如何迭代

11176
07:51:44,280 --> 07:51:49,040
向下，这正是图表所呈现的

11177
07:51:45,718 --> 07:51:52,920
看起来更重要的是

11178
07:51:49,040 --> 07:51:55,398
实际上，嗯，我们是如何能够从……加载的

11179
07:51:52,920 --> 07:51:57,718
全球变为共享权益，那么我们该怎么做呢

11180
07:51:55,398 --> 07:51:59,478
乘坐A线……我们怎么乘坐A线地铁呢（这里“tile”可能是“train”拼写错误，推测原句想说乘坐A线列车）

11181
07:51:57,718 --> 07:52:02,280
单独进行，然后将其加载到

11182
07:51:59,478 --> 07:52:06,240
共享，然后像这样填充它

11183
07:52:02,280 --> 07:52:08,558
好的，所以我们回到这里，我们注意到一个

11184
07:52:06,240 --> 07:52:11,840
有几件事，首先，这是……

11185
07:52:08,558 --> 07:52:14,920
一样 这是一样的 这是一样的

11186
07:52:11,840 --> 07:52:17,120
但这些和这些是不同的，对吧

11187
07:52:14,920 --> 07:52:19,200
所以如果我们到这儿来，只需支付

11188
07:52:17,120 --> 07:52:22,080
关注内部的行和列

11189
07:52:19,200 --> 07:52:23,798
目前，注意这里这个是怎样的

11190
07:52:22,080 --> 07:52:25,398
这实际上非常熟悉，但是

11191
07:52:23,798 --> 07:52:27,558
注意看我们实际上并没有那个东西。

11192
07:52:25,398 --> 07:52:30,040
循环，所以如果我们回到呃分块平铺的话题

11193
07:52:27,558 --> 07:52:32,920
例如，我们采用的这种二方块平铺方式 

11194
07:52:30,040 --> 07:52:36,160
我们正在以四轮循环的方式加载，所以我们有

11195
07:52:32,920 --> 07:52:38,040
嗯，BM长128，然后是这个负载

11196
07:52:36,160 --> 07:52:40,160
偏移量将以……的增量增加

11197
07:52:38,040 --> 07:52:42,398
32 而且它会有四种不同的（情况/表现等，需结合上下文确定准确意思） 

11198
07:52:40,160 --> 07:52:44,840
四个循环的迭代总数

11199
07:52:42,398 --> 07:52:46,798
每个共计有八种不同的迭代版本

11200
07:52:44,840 --> 07:52:49,160
线程，所以每个线程当时在处理八个

11201
07:52:46,798 --> 07:52:50,680
不同的指令，或者我猜在……的时候 

11202
07:52:49,160 --> 07:52:53,080
高级别的八种不同指令

11203
07:52:50,680 --> 07:52:55,760
用于，呃，用于移动数据

11204
07:52:53,080 --> 07:52:57,280
四处，那有点像一种

11205
07:52:55,760 --> 07:52:59,760
有点形成瓶颈了，这样我们就可以

11206
07:52:57,280 --> 07:53:01,160
实际上，加快速度，注意这里

11207
07:52:59,760 --> 07:53:02,558
实际上我们并没有任何循环，这是……（此处“it's”后面内容缺失，译文表意可能不完整） 

11208
07:53:01,160 --> 07:53:04,920
实际上，我们只是存储这个临时数据

11209
07:53:02,558 --> 07:53:07,200
变量 嗯，这正在做，这已经完成了

11210
07:53:04,920 --> 07:53:09,878
顺便说一下，每个线程一次，所以这是

11211
07:53:07,200 --> 07:53:13,638
比如每个线程一次，嗯，但我们

11212
07:53:09,878 --> 07:53:16,398
本质上，我们进入……我们进入一个……我们

11213
07:53:13,638 --> 07:53:20,360
获取这个内部行，并且实际上我们

11214
07:53:16,398 --> 07:53:24,360
实际上我们只是在找，嗯，在哪里

11215
07:53:20,360 --> 07:53:26,398
确切地说，呃，这到底在哪里，以及

11216
07:53:24,360 --> 07:53:29,240
我们要把这个加载到共享区域。

11217
07:53:26,398 --> 07:53:30,478
记忆仿佛被彻底置换了，对吧

11218
07:53:29,240 --> 07:53:32,638
所以对于

11219
07:53:30,478 --> 07:53:35,240
例如，我在……上面写了这件事

11220
07:53:32,638 --> 07:53:37,920
在这块板子上，这是一块瓷砖，是我画的。 

11221
07:53:35,240 --> 07:53:39,558
底部有一个标有 1、2 的小区域

11222
07:53:37,920 --> 07:53:41,520
3 和 4，这是四个不同的（这里原文可能表述有误，推测是想说“3和4，这是两个不同的” ）

11223
07:53:39,558 --> 07:53:44,000
我们要当作……来计数的值

11224
07:53:41,520 --> 07:53:46,680
四个浮点数，好吧，所以当我们实际…… 

11225
07:53:44,000 --> 07:53:49,040
转置这个 当我们进行平铺操作时 然后

11226
07:53:46,680 --> 07:53:52,398
说你可能无法看到全部

11227
07:53:49,040 --> 07:53:54,200
那些，别担心了，嗯，我们

11228
07:53:52,398 --> 07:53:55,638
进行转置，本质上我们就像

11229
07:53:54,200 --> 07:53:59,318
翻转；轻抛；快速翻动；变卦（现在分词形式） 

11230
07:53:55,638 --> 07:54:01,120
越过 越过这里这条虚线 所以

11231
07:53:59,318 --> 07:54:04,638
这些会翻倒的，它们……

11232
07:54:01,120 --> 07:54:08,718
将要从这个开始

11233
07:54:04,638 --> 07:54:10,840
到这边来，那些会翻转

11234
07:54:08,718 --> 07:54:12,920
穿过那个；在那个的对面

11235
07:54:10,840 --> 07:54:17,558
排队，而且他们最终会变成像……这样的情况

11236
07:54:12,920 --> 07:54:17,558
那就是你将会拥有的

11237
07:54:19,200 --> 07:54:24,200
当这些时候你将会有……（原文表述不太符合正常语法逻辑） 

11238
07:54:21,440 --> 07:54:29,000
这些会翻转过来，它们将会是

11239
07:54:24,200 --> 07:54:29,000
订购了一、二

11240
07:54:29,798 --> 07:54:37,200
抱歉，“bottom bottom” 我 一 二 三

11241
07:54:39,760 --> 07:54:44,558
四

11242
07:54:41,600 --> 07:54:47,040
现在别太担心这些东西是如何……（这里原文不完整）

11243
07:54:44,558 --> 07:54:49,600
呃，这些是像排成一列那样排列的吗

11244
07:54:47,040 --> 07:54:52,040
格式 我们真正关心的仅仅是

11245
07:54:49,600 --> 07:54:55,080
我们正在以一种合作的方式加载这些（内容）。

注：你原文“coest”可能有误，推测可能是“co - est”想表达“co - exist（共存、合作）”之类相关的意思，如果这不是你想要的结果，请检查原文并再次向我提问。 

11246
07:54:52,040 --> 07:54:57,558
方式 没错，所以注意我是如何有点……

11247
07:54:55,080 --> 07:54:59,798
把这里差不多一半的瓷砖拿走，并且

11248
07:54:57,558 --> 07:55:03,160
实际上我这么做是有原因的，所以

11249
07:54:59,798 --> 07:55:05,638
如果我们 我们继续往前并回顾一下

11250
07:55:03,160 --> 07:55:08,120
这些内排和所有这些东西是怎么回事

11251
07:55:05,638 --> 07:55:11,878
是说它本质上和……是一样的

11252
07:55:08,120 --> 07:55:14,920
我们在二维世界里所拥有的东西，嗯

11253
07:55:11,878 --> 07:55:18,478
块平铺，不过不只是针对批量归一化（BN） 

11254
07:55:14,920 --> 07:55:20,680
或者用BK（可能是某个特定名称或变量），就是那样（可能指前面提到的某个计算步骤），然后除以四。

11255
07:55:18,478 --> 07:55:23,558
对，所以我是说，这是四个一组（这里“four for a”表述不太完整，结合语境可能有不同意思，仅按字面直译） 

11256
07:55:20,680 --> 07:55:26,000
原因很简单，仅仅是因为我们只是

11257
07:55:23,558 --> 07:55:29,200
我们只是，嗯，我们正在使用浮点型 4。

11258
07:55:26,000 --> 07:55:31,638
输入，所以如果我们要进行呃线程操作

11259
07:55:29,200 --> 07:55:33,080
索引，在这种情况下它将达到最大值

11260
07:55:31,638 --> 07:55:38,160
在……外面；到……外面

11261
07:55:33,080 --> 07:55:44,040
20 它将会达到最大值，嗯，比如说

11262
07:55:38,160 --> 07:55:50,718
255，然后 BK 是 8，所以结果会是

11263
07:55:44,040 --> 07:55:52,478
8 除以 4 等于 2
55 除以 2 得出 

11264
07:55:50,718 --> 07:55:57,440
索引 0 到

11265
07:55:52,478 --> 07:55:57,440
127 而另一方面，现在轮到这一个了

11266
07:55:58,760 --> 07:56:05,760
将会是，嗯，同样的思路，只是我们……

11267
07:56:01,558 --> 07:56:07,520
正确地进行取模运算，所以 255 对 2 取模，即 

11268
07:56:05,760 --> 07:56:08,958
意味着每两次它都会……

11269
07:56:07,520 --> 07:56:12,160
再次归零，所以我们只是要去…… 

11270
07:56:08,958 --> 07:56:14,638
要有两个数字，零和

11271
07:56:12,160 --> 07:56:17,200
本质上，这种索引方式使我们能够

11272
07:56:14,638 --> 07:56:19,398
将其视为一组四个，所以当……

11273
07:56:17,200 --> 07:56:21,718
我们进行划分，这意味着它正在缩小至一个…… 

11274
07:56:19,398 --> 07:56:23,440
它长度的四分之一，然后当我们继续 

11275
07:56:21,718 --> 07:56:24,680
到这里下面，然后再乘以四

11276
07:56:23,440 --> 07:56:26,638
你多少会明白其中的直觉（原理）

11277
07:56:24,680 --> 07:56:28,360
因为在一瞬间，当我们乘以……

11278
07:56:26,638 --> 07:56:29,600
又是四次，它只会继续拉长

11279
07:56:28,360 --> 07:56:32,520
那要恢复到它通常的使用状态

11280
07:56:29,600 --> 07:56:34,120
那么，这仅仅是在考虑，呃

11281
07:56:32,520 --> 07:56:36,958
这个小的Flo浮标用于索引

11282
07:56:34,120 --> 07:56:40,000
如果我们深入探究，我们现在所采用的方案是…… （原句不太完整，此处翻译结合常见语境进行适当补充以增强通顺度）

11283
07:56:36,958 --> 07:56:43,040
这里呢，呃，我们可以看到这个，我是……

11284
07:56:40,000 --> 07:56:46,080
实际上是有意让这次呃匹配成功

11285
07:56:43,040 --> 07:56:49,080
我们这里有一个标题，所以注意我们是如何拥有的

11286
07:56:46,080 --> 07:56:53,920
这一排内侧右边，以及内侧的A排

11287
07:56:49,080 --> 07:56:57,718
在 0 到 127 之间，所以这一行用于此

11288
07:56:53,920 --> 07:57:00,160
瓷砖（这里tile也可能有其他释义，需结合具体语境）在零之间，让我来放这个

11289
07:56:57,718 --> 07:57:00,160
目前在这里；暂时在这儿

11290
07:57:02,240 --> 07:57:08,680
Z 和 127，没错，所以你可能没办法

11291
07:57:05,280 --> 07:57:11,558
看到那个，但是 0 127，这非常长

11292
07:57:08,680 --> 07:57:14,760
这就像是较长的一边，嗯，然后

11293
07:57:11,558 --> 07:57:20,240
我们有 0 到 1，所以对于……有两个值

11294
07:57:14,760 --> 07:57:26,318
对于右列A列，所以是从0到

11295
07:57:20,240 --> 07:57:29,958
或者说，确切地讲是一个，而这一切都使得……

11296
07:57:26,318 --> 07:57:33,760
我们要做的只是更轻松地整理物品。

11297
07:57:29,958 --> 07:57:38,200
所以注意一下，我们是怎样……呃，我们是怎样的

11298
07:57:33,760 --> 07:57:40,240
这个通常具有一定大小的东西

11299
07:57:38,200 --> 07:57:43,958
128 乘以

11300
07:57:40,240 --> 07:57:47,878
8 和 128 除以 8，如果我们真的去做这个（运算）

11301
07:57:43,958 --> 07:57:47,878
为此进行乘法运算

11302
07:57:48,160 --> 07:57:52,558
嗯，那是1.24

11303
07:57:54,000 --> 07:58:00,478
好吧，那么

11304
07:57:56,920 --> 07:58:03,798
1，24 然后我们对这个数字进行化简

11305
07:58:00,478 --> 07:58:06,240
把这个除以四

11306
07:58:03,798 --> 07:58:10,120
对，那实际上减少了整个……（此处文本不完整，翻译可能无法准确传达完整意思）

11307
07:58:06,240 --> 07:58:10,120
从1024到……的事物

11308
07:58:10,240 --> 07:58:18,280
256 猜猜我们有多少个线程 256

11309
07:58:14,680 --> 07:58:21,680
结果非常完美，所以每根线都是

11310
07:58:18,280 --> 07:58:24,240
本质上是拿走了它自己的小……（此处原英文表述不太完整和清晰，翻译可能存在表意不精准的情况）

11311
07:58:21,680 --> 07:58:26,878
这些，没错，所以这就要……这是

11312
07:58:24,240 --> 07:58:29,080
从 127.0 延伸到 127，并且这是

11313
07:58:26,878 --> 07:58:31,478
前进01，就像分裂成…… 

11314
07:58:29,080 --> 07:58:36,240
答对了一半，所以你有，你有像1、2这样的（东西） 

11315
07:58:31,478 --> 07:58:37,638
3 4 5 6 7 对，8，而且我们只是

11316
07:58:36,240 --> 07:58:39,600
就像把这个一分为二，然后

11317
07:58:37,638 --> 07:58:42,360
它……它贯穿了整个长度，呃

11318
07:58:39,600 --> 07:58:45,878
跨越 向下跨越高度

11319
07:58:42,360 --> 07:58:47,760
没错，而我们所要做的仅仅是

11320
07:58:45,878 --> 07:58:49,878
将其存储为浮点数，所以这就是我们要做的

11321
07:58:47,760 --> 07:58:52,478
在这里，我们实际上呃拿这个……

不过你提供的内容似乎不完整且表述不太清晰。 

11322
07:58:49,878 --> 07:58:54,558
内排 我们那样做乘以（某个数） 在我们需要的情况下

11323
07:58:52,478 --> 07:58:56,840
你知道，四处踱步然后……然后得到

11324
07:58:54,558 --> 07:58:59,398
回到同样的，同样的，呃，到那个…… 

11325
07:58:56,840 --> 07:59:01,638
同样的列，再次操作，然后我们进行加法运算

11326
07:58:59,398 --> 07:59:04,280
内列 A 偏移 这一切都在

11327
07:59:01,638 --> 07:59:06,398
像这样一块瓷砖所处的情境

11328
07:59:04,280 --> 07:59:08,360
在需要的地方做到先进，所以我们是

11329
07:59:06,398 --> 07:59:09,760
实际上只是考虑到这一点加上“K” 

11330
07:59:08,360 --> 07:59:11,878
我们身处这个更大的母体之中，对吧，那就是……

11331
07:59:09,760 --> 07:59:13,718
我们所需要的一切就是它了

11332
07:59:11,878 --> 07:59:15,718
它行得通只是因为我们处于……我们处于（此处原文似乎表述不完整） 

11333
07:59:13,718 --> 07:59:18,280
只是针对这个特定的情况进行处理

11334
07:59:15,718 --> 07:59:21,558
作为更大整体一部分的瓷砖

11335
07:59:18,280 --> 07:59:23,200
矩阵现在的内列，实际上我们是

11336
07:59:21,558 --> 07:59:27,120
打算把这个再延长到四个（这里“四个”具体指代需结合上下文确定，可能是四个数量、四个时间单位等） 

11337
07:59:23,200 --> 07:59:28,680
再次，因为，呃，因为我们之前

11338
07:59:27,120 --> 07:59:30,718
把它缩小了，没错，所以我们只需要

11339
07:59:28,680 --> 07:59:33,920
把那个展开回去

11340
07:59:30,718 --> 07:59:35,760
再次强调，这只是用来做索引的，嗯

11341
07:59:33,920 --> 07:59:39,160
以老派的风格，就在我们所在之处

11342
07:59:35,760 --> 07:59:42,958
我们在哪里可以找到垂直偏移量

11343
07:59:39,160 --> 07:59:46,360
意思，呃，这里的意思，然后我们添加

11344
07:59:42,958 --> 07:59:49,360
那么就是垂直偏移量，然后我们加上

11345
07:59:46,360 --> 07:59:52,398
所以我们要找到我们所在的是哪一排

11346
07:59:49,360 --> 07:59:54,040
我们想要用K项来相乘

11347
07:59:52,398 --> 07:59:56,520
然后我们到达我们想去的地方，并且

11348
07:59:54,040 --> 07:59:58,920
然后我们加上水平偏移量

11349
07:59:56,520 --> 08:00:01,798
对，然后我们……我们必须乘以

11350
07:59:58,920 --> 08:00:03,478
四个，实际上呃，想涵盖那个范围

11351
08:00:01,798 --> 08:00:07,360
整个长度，所以如果你想

11352
08:00:03,478 --> 08:00:08,878
去到《黑客帝国》的结尾处 嗯 如果

11353
08:00:07,360 --> 08:00:10,840
你想走到……的尽头

注：原文“the very end of The”表述不完整，“The”后面似乎缺了内容。 

11354
08:00:08,878 --> 08:00:13,000
矩阵，在这里你实际上必须取

11355
08:00:10,840 --> 08:00:14,318
这两项，或者不管那是什么，乘以…… 

11356
08:00:13,000 --> 08:00:16,240
四个，而且它会把你们都搞定

11357
08:00:14,318 --> 08:00:18,878
通往终点的路，没错，就是那样

11358
08:00:16,240 --> 08:00:21,760
整个想法是这样的，嗯，但如果我们继续下去

11359
08:00:18,878 --> 08:00:25,040
来看看我们储存这些东西的方式

11360
08:00:21,760 --> 08:00:26,840
实际上这也不算太糟，所以在

11361
08:00:25,040 --> 08:00:28,240
我们有这四种不同的……（原英文句子似乎不完整，表述不太通顺）

11362
08:00:26,840 --> 08:00:30,920
他们有这四种不同的……（原文“stor”可能有误，推测可能是“store”等单词）

11363
08:00:28,240 --> 08:00:33,920
这是四个不同的组件中的每一个。

11364
08:00:30,920 --> 08:00:36,920
关于 float 4 变量，所以我们有这个

11365
08:00:33,920 --> 08:00:40,680
x、y、z 和 W 项，这是第一个。

11366
08:00:36,920 --> 08:00:44,520
索引零，然后索引一，索引二

11367
08:00:40,680 --> 08:00:46,798
等等，所以我们在那里所做的一切就是

11368
08:00:44,520 --> 08:00:48,440
我们正在查看内柱

11369
08:00:46,798 --> 08:00:51,000
无论那是哪一列，记住我们

11370
08:00:48,440 --> 08:00:52,478
有这种形状的新瓷砖，我们…… 

11371
08:00:51,000 --> 08:00:54,600
相对于这个来做这件事，因为这个

11372
08:00:52,478 --> 08:00:58,040
这就是我们……这就是我们的储存方式

11373
08:00:54,600 --> 08:00:59,080
一切，所以我们打算去，嗯，那个

11374
08:00:58,040 --> 08:01:02,520
内部的；里面的；内心的；内侧的

11375
08:00:59,080 --> 08:01:05,000
列，无论那是什么，所以在这种情况下

11376
08:01:02,520 --> 08:01:07,240
我们必须留在……这一列（原文“the the”表述有误，可能是多写了一个“the” ） 

11377
08:01:05,000 --> 08:01:10,280
上下文 我们是如何为此存储列的

11378
08:01:07,240 --> 08:01:14,360
在这种情况下，哪一列是那列呢？ 

11379
08:01:10,280 --> 08:01:17,680
这些之中，但既然我们

11380
08:01:14,360 --> 08:01:21,040
嗯，既然我们对它进行了移项，我们就得……

11381
08:01:17,680 --> 08:01:23,558
在……的背景下考虑这一列

11382
08:01:21,040 --> 08:01:26,558
就在这儿，所以实际上它有那么一点点…… 

11383
08:01:23,558 --> 08:01:28,120
不同，所以不是把行作为…… 

11384
08:01:26,558 --> 08:01:29,920
实际上这是一栏，因为我们

11385
08:01:28,120 --> 08:01:30,920
从最初的这个中解读出的列

11386
08:01:29,920 --> 08:01:32,040
那……那差不多就是正在发生的情况。

11387
08:01:30,920 --> 08:01:34,360
那里，希望如此，希望如此

11388
08:01:32,040 --> 08:01:37,280
易于理解

11389
08:01:34,360 --> 08:01:38,798
嗯，然后我们用这个乘以 4，这（这里原句不完整）

11390
08:01:37,280 --> 08:01:41,680
显然我们要把它拉长

11391
08:01:38,798 --> 08:01:44,080
按需输出，然后无论哪一个

11392
08:01:41,680 --> 08:01:47,280
索引 我们需要加上 对 我们是

11393
08:01:44,080 --> 08:01:48,798
把这个像这些一样存储起来

11394
08:01:47,280 --> 08:01:50,440
这些垂直方向的值，对吧，所以取而代之的是

11395
08:01:48,798 --> 08:01:52,600
不是将它们水平排列，我们是……

注：原文 “of horizontally laying them out” 可能前面缺失 “instead” 之类的词，导致句子不太完整，这里根据常见语境做了一定补充理解。 

11396
08:01:50,440 --> 08:01:54,718
将它们垂直存放，这就是原因。

11397
08:01:52,600 --> 08:01:56,440
你这里有这个额外的索引，就是这个

11398
08:01:54,718 --> 08:01:58,638
这将会像那个那个那个……

11399
08:01:56,440 --> 08:02:01,200
列偏移量，你可以这么说

11400
08:01:58,638 --> 08:02:03,520
呃，比如，哪个……抱歉，哪个，对，就是哪个

11401
08:02:01,200 --> 08:02:07,600
比如你在第几排，更确切地说

11402
08:02:03,520 --> 08:02:10,080
那么，那个 BM 项就是这个 

11403
08:02:07,600 --> 08:02:12,398
然后我们把它移到这里，这样它就

11404
08:02:10,080 --> 08:02:15,040
打算尽可能多次地大步走过

11405
08:02:12,398 --> 08:02:18,160
它需要，然后我们就可以加上那个“仅仅”了 

11406
08:02:15,040 --> 08:02:19,638
内排 呃 一部分 对吧 所以 这一排

11407
08:02:18,160 --> 08:02:21,558
最初来自这一地区，而现在

11408
08:02:19,638 --> 08:02:23,478
我们只是把它翻到这边来

11409
08:02:21,558 --> 08:02:24,638
所以我们在那里得到了实际的偏移量，并且

11410
08:02:23,478 --> 08:02:26,920
那真的，那真的就是我们……的方式（此处原句不完整，翻译按已有内容处理） 

11411
08:02:24,638 --> 08:02:29,840
把它存起来，真的就这么简单

11412
08:02:26,920 --> 08:02:29,840
嗯

11413
08:02:30,718 --> 08:02:35,920
那么接下来我们再深入探究，看看 B B 

11414
08:02:34,478 --> 08:02:36,958
实际上不应该太难 我不是

11415
08:02:35,920 --> 08:02:39,478
甚至要去解释这个，这是

11416
08:02:36,958 --> 08:02:42,160
简直就好像我们就是直截了当地……

11417
08:02:39,478 --> 08:02:46,600
添加内存列 呃 这里进行内存整理

11418
08:02:42,160 --> 08:02:48,718
就好像如果我回到这个，嗯，这叫什么来着

11419
08:02:46,600 --> 08:02:51,040
有人说编译器难道不应该仅仅是……

11420
08:02:48,718 --> 08:02:53,958
能够收集第二个版本并且

11421
08:02:51,040 --> 08:02:55,638
生成128位加载 嗯 以及

11422
08:02:53,958 --> 08:02:57,398
那么原因在于编译器有

11423
08:02:55,638 --> 08:03:00,240
无法验证浮点数B

11424
08:02:57,398 --> 08:03:02,478
指针被传递到内核用户模式，就像……

说明：原文“as as”表述有误，可能是不完整的“as...as...”结构，以上翻译是在现有文本基础上尽量通顺表达。 

11425
08:03:00,240 --> 08:03:04,840
128 位右对齐，这将是一个

11426
08:03:02,478 --> 08:03:06,440
对此的要求，所以从本质上来说

11427
08:03:04,840 --> 08:03:08,200
我们只是想说，就像在……里那样

11428
08:03:06,440 --> 08:03:10,000
我展示了所有内容的上一个例子

11429
08:03:08,200 --> 08:03:11,718
那里的着色器汇编可能有

11430
08:03:10,000 --> 08:03:13,638
有一些情况表明它并没有做到

11431
08:03:11,718 --> 08:03:16,798
实际上知道这样存储是可以的

11432
08:03:13,638 --> 08:03:20,280
一个 128 位的，是像浮点 Fort 那样吗？

11433
08:03:16,798 --> 08:03:22,398
就像一个隐式128位对齐类型 嗯

11434
08:03:20,280 --> 08:03:25,398
但在这种情况下，我们是明确地

11435
08:03:22,398 --> 08:03:27,398
传递 reinterpret（呃，强制类型转换），并且我们正在

11436
08:03:25,398 --> 08:03:29,160
我们明确地将其设置为浮点数。

11437
08:03:27,398 --> 08:03:31,638
为了 或者

11438
08:03:29,160 --> 08:03:33,160
128位，这对编译器来说是有前景的。

11439
08:03:31,638 --> 08:03:35,280
这是右对齐的，这是

11440
08:03:33,160 --> 08:03:36,558
告诉编译器你能，你可以做到

11441
08:03:35,280 --> 08:03:38,958
这是你处理这个所需的，我们已经安排好了（原文表述不太符合正常语法，此为尽力通顺的翻译） 

11442
08:03:36,558 --> 08:03:40,920
这句话表述不太符合正常语法，可能存在错误。大致翻译为：
把这个妥善处理好，你的…… 

11443
08:03:38,958 --> 08:03:42,398
魔法，而我们只是在帮忙处理这个（此处“the”后缺失内容）

11444
08:03:40,920 --> 08:03:44,440
以那种方式编写编译器，这样一来……就是那样的情况了。

注：原英文文本似乎表述不太完整或不太清晰，此翻译是基于字面尽量连贯处理。 

11445
08:03:42,398 --> 08:03:47,440
这里正在发生的事情，简直就是一模一样。

11446
08:03:44,440 --> 08:03:49,398
这个，这个相同的索引方案，嗯

11447
08:03:47,440 --> 08:03:51,840
这里真没什么可聊的

11448
08:03:49,398 --> 08:03:53,638
但是，呃，等这一切都结束后，记住…… 

11449
08:03:51,840 --> 08:03:56,840
注意，每个线程只执行一次这个操作，对吧？

11450
08:03:53,638 --> 08:03:58,398
所以我们先存储，然后再书写

11451
08:03:56,840 --> 08:04:01,958
对 对 对

11452
08:03:58,398 --> 08:04:04,600
而且它真的超级快，对吧，所以别……

11453
08:04:01,958 --> 08:04:06,478
别担心那个，呃，别担心

11454
08:04:04,600 --> 08:04:07,878
关于我们如何写这个，我们不……

11455
08:04:06,478 --> 08:04:10,000
实际上必须做出正确的选择

注：原文“coess”可能拼写有误，推测正确的是“choice” 。 

11456
08:04:07,878 --> 08:04:12,318
那么，这些权利就不必……嗯

11457
08:04:10,000 --> 08:04:14,760
你知道像这样相邻的，它们可以是

11458
08:04:12,318 --> 08:04:17,558
呃，像被……分隔开

11459
08:04:14,760 --> 08:04:20,080
行 呃 然后只要这些读数……

11460
08:04:17,558 --> 08:04:22,958
我不太理解“are coess”的准确意思，你可能有拼写错误。如果忽略这个问题，大致翻译为：
没问题，那么这些读物

11461
08:04:20,080 --> 08:04:24,760
从这里过来，然后我们就只是

11462
08:04:22,958 --> 08:04:26,398
我们只是把它翻过来，然后它就

11463
08:04:24,760 --> 08:04:28,878
降落在那里，那里是…… 

11464
08:04:26,398 --> 08:04:30,878
完美，然后我们实际上接着进行到……

11465
08:04:28,878 --> 08:04:33,080
正在计算那个小（事情）的结果

11466
08:04:30,878 --> 08:04:34,840
那个小线程块……那个……那个

11467
08:04:33,080 --> 08:04:38,718
本质上，里面的线程迷你瓷砖

11468
08:04:34,840 --> 08:04:41,920
那个更大的，然后我们逐一处理

11469
08:04:38,718 --> 08:04:43,360
使用 normal.idx，没错，是类似的方案

11470
08:04:41,920 --> 08:04:44,600
除了……回到我们以前的状态

11471
08:04:43,360 --> 08:04:48,080
索引方案有点……

11472
08:04:44,600 --> 08:04:50,040
不同的 嗯 我们记得我们……我们曾经怎样

11473
08:04:48,080 --> 08:04:52,080
就像这样，这个矩形，它在……（这里句子不完整） 

11474
08:04:50,040 --> 08:04:54,840
就像这个很短，而这个是……这个是……

11475
08:04:52,080 --> 08:04:56,878
长久以来，对，现在也是同样的方式 

11476
08:04:54,840 --> 08:05:00,120
我们已经对它进行了移调，这也有点像…… 

11477
08:04:56,878 --> 08:05:03,520
所以，这不是让 a 像这样…… 

11478
08:05:00,120 --> 08:05:05,318
现在它像这样翻过来了，对吧

11479
08:05:03,520 --> 08:05:08,000
所以我们要做的只是改变

11480
08:05:05,318 --> 08:05:09,798
向上，我们如何对其进行索引，那样就行得通了，所以

11481
08:05:08,000 --> 08:05:12,798
我甚至都不会去讲 b，b 是……

11482
08:05:09,798 --> 08:05:15,000
很明显能理解，但是呃

11483
08:05:12,798 --> 08:05:19,760
越过右边，我们该如何迭代

11484
08:05:15,000 --> 08:05:24,280
通过这个，所以索引对了，当我们看的时候

11485
08:05:19,760 --> 08:05:26,398
那我们开始吧 嗯 所以 不管哪个 不管哪个

11486
08:05:24,280 --> 08:05:29,120
索引 我们所在的这个 我们就无视它吧

11487
08:05:26,398 --> 08:05:32,040
目前呢，嗯，我们就说那是零。

11488
08:05:29,120 --> 08:05:33,398
也许，嗯，然后这个，既然这是

11489
08:05:32,040 --> 08:05:36,360
乘以零，那将会

11490
08:05:33,398 --> 08:05:41,360
化简为零，所以它将会

11491
08:05:36,360 --> 08:05:42,718
呃，是零加，然后我们要说，呃

11492
08:05:41,360 --> 08:05:47,440
也许

11493
08:05:42,718 --> 08:05:49,318
不管它处于哪一行线程，嗯

11494
08:05:47,440 --> 08:05:51,878
无论它处于哪一行线程，都在进行中

11495
08:05:49,318 --> 08:05:55,000
它将乘以 TM，而 TM 是

11496
08:05:51,878 --> 08:05:59,558
八，所以不管怎样它要大步前进了

11497
08:05:55,000 --> 08:05:59,558
它需要多少才行呢，嗯

11498
08:06:00,840 --> 08:06:05,600
然后我们只需在那上面加上 I，对吧

11499
08:06:03,040 --> 08:06:07,600
所以排排站，而不是待在这儿

11500
08:06:05,600 --> 08:06:09,920
线程行实际上在这里是因为它

11501
08:06:07,600 --> 08:06:11,318
之前是对的，你可以看看如何

11502
08:06:09,920 --> 08:06:13,478
那个翻译可行，这曾是个线程（此句“thread”含义需结合上下文，这里只是一种可能的理解） 

11503
08:06:11,318 --> 08:06:15,160
行 这很长 这是个线程 行 现在

11504
08:06:13,478 --> 08:06:17,318
现在这个挺长的，对吧，所以它是……它是那个

11505
08:06:15,160 --> 08:06:19,200
同样的想法，就是我们只是，我们只是

11506
08:06:17,318 --> 08:06:20,440
这让命名有点令人困惑

11507
08:06:19,200 --> 08:06:22,680
瞧，其实就这么回事，我们……

11508
08:06:20,440 --> 08:06:24,520
不管这是什么，只要保持一致就行。

11509
08:06:22,680 --> 08:06:28,280
术语意味着因为我们必须进行转置

11510
08:06:24,520 --> 08:06:30,718
没错，嗯，然后我们只需不断迭代。

11511
08:06:28,280 --> 08:06:32,760
通过 通过 嗯 通过 我 因为我们需要

11512
08:06:30,718 --> 08:06:35,080
向右；到右边

11513
08:06:32,760 --> 08:06:36,478
所以这应该是直观易懂的，我不…… 

11514
08:06:35,080 --> 08:06:37,920
真的觉得我也需要解释那件事吗

11515
08:06:36,478 --> 08:06:40,760
很多时候，这主要就是在付钱

11516
08:06:37,920 --> 08:06:42,638
注意，呃，命名方面

11517
08:06:40,760 --> 08:06:44,440
约定，所以线程行与线程

注：你提供的内容似乎不太完整或准确，可能存在表意不明的情况。如果有更多上下文信息，能让翻译更精准。 

11518
08:06:42,638 --> 08:06:48,200
栏目，比如为什么那些会不同呢，嗯

11519
08:06:44,440 --> 08:06:50,240
那是因为你，你呃

11520
08:06:48,200 --> 08:06:55,120
进行转置，然后你进行常规操作

11521
08:06:50,240 --> 08:06:58,600
写出来 嗯，所以如果我们回到这个呃

11522
08:06:55,120 --> 08:07:00,160
向上，它就只做这个，对吧，没错，所以

11523
08:06:58,600 --> 08:07:02,680
旋转索引

11524
08:07:00,160 --> 08:07:04,160
向下 所有这些 所有这些

11525
08:07:02,680 --> 08:07:06,280
线程有点像是彼此相邻的。

11526
08:07:04,160 --> 08:07:10,478
为了纪念，这就是我们大步前行的原因，嗯

11527
08:07:06,280 --> 08:07:13,718
商标 对 商标就是那个

11528
08:07:10,478 --> 08:07:16,000
嗯，这是TM，所以无论我们选择哪一行线程…… （这里原文似乎不完整）

11529
08:07:13,718 --> 08:07:17,080
呃，我们要大步向前了，TM

11530
08:07:16,000 --> 08:07:21,600
因为每个线程都将占用

11531
08:07:17,080 --> 08:07:21,600
照顾那些值中的多个值

11532
08:07:23,120 --> 08:07:28,360
嗯，是的，最后呢，我们最终只是

11533
08:07:26,798 --> 08:07:31,718
只是稍微看了看这个

11534
08:07:28,360 --> 08:07:31,718
不同地 呃 以及

11535
08:07:32,798 --> 08:07:37,080
然后，是的，再添加一些视觉元素

11536
08:07:35,080 --> 08:07:39,080
示例，而不是像这样拥有它 

11537
08:07:37,080 --> 08:07:44,318
这里，然后这些……这些就像英寸（此处原文语义不太完整和清晰） 

11538
08:07:39,080 --> 08:07:47,240
这些就像，呃，一点点向前推进

11539
08:07:44,318 --> 08:07:48,520
这是对的，但实际上这是反的。

11540
08:07:47,240 --> 08:07:50,600
结束了，所以这有点像是那种……

11541
08:07:48,520 --> 08:07:52,760
你所具备的空间推理能力的转换

11542
08:07:50,600 --> 08:07:56,200
不得不熬过去，然后这一切

11543
08:07:52,760 --> 08:07:58,520
喜欢这件事挺直接的，嗯，但是

11544
08:07:56,200 --> 08:08:01,080
是的，现在我们实际上可以去……

11545
08:07:58,520 --> 08:08:02,840
书写部分很棒，所以我们现在（此处“we're”后面缺失内容，推测可能想说“我们现在要做……”之类）

11546
08:08:01,080 --> 08:08:04,240
实际上差不多快完成了，我们只需要……

11547
08:08:02,840 --> 08:08:07,558
现在就把结果写出来，而且我们必须这么做。

11548
08:08:04,240 --> 08:08:10,240
确保这些……我们的……这些也是

11549
08:08:07,558 --> 08:08:15,478
呃，在这种情况下是用于类型的浮点型，所以同样地

11550
08:08:10,240 --> 08:08:17,840
呃，进入呃，那个呃，全球视野

11551
08:08:15,478 --> 08:08:20,840
拉姆，没错，所以我们有……呃，正常的……

11552
08:08:17,840 --> 08:08:22,440
遍历TM并遍历TN

11553
08:08:20,840 --> 08:08:25,760
只是我们稍微改变一下迭代器

11554
08:08:22,440 --> 08:08:27,760
有所不同，所以在TM（可能是某种特定术语，需结合上下文确定）里，我们的那些行…… 

11555
08:08:25,760 --> 08:08:29,520
迭代遍历 我们 我们在做 我们

11556
08:08:27,760 --> 08:08:32,200
每次递增 1，所以它会这样进行下去

11557
08:08:29,520 --> 08:08:36,040
一直向右走，然后

11558
08:08:32,200 --> 08:08:40,840
对于TN，我们每次都加4，所以

11559
08:08:36,040 --> 08:08:42,920
我们这里有八个数值，而且我们有，嗯

11560
08:08:40,840 --> 08:08:45,160
我们这里有两个值，对吧，那么当

11561
08:08:42,920 --> 08:08:47,318
你有这个完整的 8×8 的东西，你

11562
08:08:45,160 --> 08:08:49,040
通常情况下需要处理64个数值，但

11563
08:08:47,318 --> 08:08:53,398
因为我们正在处理 4 位浮点数 我们是

11564
08:08:49,040 --> 08:08:54,878
存储其中的四个，总共16个 

11565
08:08:53,398 --> 08:08:57,760
对，所以你大概能算出来了

11566
08:08:54,878 --> 08:09:01,120
这就像是四个数值乘以16种不同情况

11567
08:08:57,760 --> 08:09:03,000
呃，权限，嗯，所以它将执行四次。

11568
08:09:01,120 --> 08:09:04,958
为其中的16个权利分别估值，并且

11569
08:09:03,000 --> 08:09:08,798
我们要把那整整 64（个/份等，需结合具体语境确定）都装满。 

11570
08:09:04,958 --> 08:09:14,318
穿过TM和TN瓦片的东西

11571
08:09:08,798 --> 08:09:18,478
对，嗯，所以我们设置了这个临时的…… 

11572
08:09:14,318 --> 08:09:21,000
将变量设为当前的，呃，C，那个C，那个

11573
08:09:18,478 --> 08:09:24,360
当前的 C 值，没错，所以这个，不管怎样

11574
08:09:21,000 --> 08:09:26,080
呃，不管当前的 C 是什么

11575
08:09:24,360 --> 08:09:28,120
我们所关心的事情与我们过去的情况相关

11576
08:09:26,080 --> 08:09:29,840
通过这些进行索引，而这是

11577
08:09:28,120 --> 08:09:33,760
一切都要牢记我们身处何方

11578
08:09:29,840 --> 08:09:36,638
实际上，在整个……在整个……

11579
08:09:33,760 --> 08:09:39,798
C矩阵，整个C矩阵，对吧

11580
08:09:36,638 --> 08:09:43,040
线程行偏移量乘以这个

11581
08:09:39,798 --> 08:09:45,638
再加上资源索引（res idx），嗯，内存偏移量（M offset），然后

11582
08:09:43,040 --> 08:09:48,280
所有那些再乘以 n，而 n 就是步长

11583
08:09:45,638 --> 08:09:50,760
基于此，然后再加上我们的栏目

11584
08:09:48,280 --> 08:09:52,360
时间TN，然后是我们的res索引n 这……

注：“res idx”可能是特定领域的术语，由于缺乏更多背景信息，此处按字面进行了翻译。 

11585
08:09:50,760 --> 08:09:54,920
这种索引方式应该都能说得通。

11586
08:09:52,360 --> 08:09:57,000
应该几乎是一清二楚的

11587
08:09:54,920 --> 08:09:58,958
嗯，我们做过和这非常相似的事。

11588
08:09:57,000 --> 08:10:02,000
已经

11589
08:09:58,958 --> 08:10:03,760
嗯，而且很多语法也是

11590
08:10:02,000 --> 08:10:04,878
类似于我们在这里做的这个浮点数 4，所以

11591
08:10:03,760 --> 08:10:06,398
如果有什么不合理的地方，那就

11592
08:10:04,878 --> 08:10:09,040
回顾这一切，把事情拆解开来

11593
08:10:06,398 --> 08:10:11,638
再次强调，这是做这件事最简单的方法，嗯

11594
08:10:09,040 --> 08:10:15,040
但在这里，我们有这个，我们有这个

11595
08:10:11,638 --> 08:10:18,718
临时类型正确，现在临时保存于

11596
08:10:15,040 --> 08:10:22,080
注意，这原本就是 C 语言的样子，所以我们

11597
08:10:18,718 --> 08:10:25,040
实际上可以存储，呃，来自……的东西

11598
08:10:22,080 --> 08:10:26,718
现有的呃 TMP 或临时变量

11599
08:10:25,040 --> 08:10:29,080
在它里面，针对这个，我们实际上可以做

11600
08:10:26,718 --> 08:10:30,718
更多地靠近它，然后又径直回到它里面

11601
08:10:29,080 --> 08:10:32,120
因为我们不在乎那可怜的C等成绩

11602
08:10:30,718 --> 08:10:34,878
我们只是想计算出那个新的（数值/结果等，需结合上下文确定）。

11603
08:10:32,120 --> 08:10:36,798
好的，所以我们有这个……这个 x 部分，它

11604
08:10:34,878 --> 08:10:39,040
索引是零吗，所以我们不会去……

11605
08:10:36,798 --> 08:10:43,080
添加任何内容，然后索引第一个，接着

11606
08:10:39,040 --> 08:10:45,120
二，然后是三
这些全是 x、y、z、w

11607
08:10:43,080 --> 08:10:47,958
分别地，呃，所以我们有这个阿尔法

11608
08:10:45,120 --> 08:10:50,440
将与之相关的线程结果称为……

注：原英文文本似乎并不完整，这样的翻译可能需要结合更完整的上下文来准确理解。 

11609
08:10:47,958 --> 08:10:52,638
关于线程结果，呃

11610
08:10:50,440 --> 08:10:55,878
寄存器中的变量，所以它接下来会……

11611
08:10:52,638 --> 08:11:00,280
成为参考索引M，那么是哪一行呢

11612
08:10:55,878 --> 08:11:02,638
你是否正确，然后那个，嗯，还有

11613
08:11:00,280 --> 08:11:04,440
那么TN，也就是它是如何展开的

11614
08:11:02,638 --> 08:11:05,798
所以你要大步走过去然后拿到

11615
08:11:04,440 --> 08:11:08,680
到你想要的任意一行，然后你就（此处原句不完整）

11616
08:11:05,798 --> 08:11:11,040
前往异地，用这个来抵消，然后

11617
08:11:08,680 --> 08:11:13,600
基于你所处的哪个值（Val）、哪个索引（index）

11618
08:11:11,040 --> 08:11:16,478
在那个里面的四维浮点数组中

11619
08:11:13,600 --> 08:11:18,878
指定 那个 浮点数4 窗口 右侧

（注：原文可能存在表述不规范的情况，此翻译是基于字面逐词翻译） 

11620
08:11:16,478 --> 08:11:21,280
你要把，呃，这些加到……

11621
08:11:18,878 --> 08:11:22,920
实际的，呃，内存地址或者……或者那个

11622
08:11:21,280 --> 08:11:26,958
对它们自己进行索引，直接将其存储为类似……的形式 

11623
08:11:22,920 --> 08:11:29,200
有点像向量类型，所以，呃，用这种方式我们

11624
08:11:26,958 --> 08:11:31,200
实际上可以得到我们所……的那个值（此处原文不完整）

11625
08:11:29,200 --> 08:11:33,160
想要，然后我们只需把它加到……上

11626
08:11:31,200 --> 08:11:35,240
β 缩放因子，然后将其相乘

11627
08:11:33,160 --> 08:11:37,478
根据我们从……得到的现有 C 值

11628
08:11:35,240 --> 08:11:39,638
在这儿上面，对，所以那应该非常…… 

11629
08:11:37,478 --> 08:11:41,680
直截了当地说 嗯，幸运的是这仅仅是

11630
08:11:39,638 --> 08:11:43,558
处于对齐状态，所以索引不会太……（原句不完整）

11631
08:11:41,680 --> 08:11:46,958
复杂的，呃，然后我们就只是简单地

11632
08:11:43,558 --> 08:11:49,040
回信
没错，那么运用同样的思路

11633
08:11:46,958 --> 08:11:53,000
我们在这里做了同样的索引

11634
08:11:49,040 --> 08:11:57,200
方案 呃 然后我们只是 呃 写 写

11635
08:11:53,000 --> 08:11:58,200
出来，说实在的，在螺纹层面上那是

11636
08:11:57,200 --> 08:12:02,000
因子内存

11637
08:11:58,200 --> 08:12:04,478
行，好极了，那么现在，呃，我们可以

11638
08:12:02,000 --> 08:12:06,318
实际上，只需打印出这些东西的质量有多好

11639
08:12:04,478 --> 08:12:11,000
做得对，所以我们刚刚完成了……（这里原文似乎不完整）

11640
08:12:06,318 --> 08:12:13,520
向量V列，列级内存访问，呃

11641
08:12:11,000 --> 08:12:15,000
有了向量化内核，让我们继续前行

11642
08:12:13,520 --> 08:12:17,478
然后把它打印出来，效果会有多好呢

11643
08:12:15,000 --> 08:12:19,638
所以最后一个是，呃，二维块平铺

11644
08:12:17,478 --> 08:12:23,638
第五个内核，我们开始并打印这个

11645
08:12:19,638 --> 08:12:26,680
出去后，我们看到峰值大约是，呃，9000。

11646
08:12:23,638 --> 08:12:29,120
所以大约9100吉次浮点运算每秒，然后这个

11647
08:12:26,680 --> 08:12:29,120
一个；一

11648
08:12:30,600 --> 08:12:37,200
约10800吉咖浮点运算每秒，这相当是一个

11649
08:12:33,760 --> 08:12:38,160
与之前相比有大幅增长，所以大约是……

11650
08:12:37,200 --> 08:12:40,200
什么

11651
08:12:38,160 --> 08:12:42,638
大致上，呃

11652
08:12:40,200 --> 08:12:45,638
比之前多1600吉咖浮点运算每秒，这 

11653
08:12:42,638 --> 08:12:48,760
相当可靠，对吧？大概是15%、16% 

11654
08:12:45,638 --> 08:12:50,478
无论性能提升了多少百分比，嗯

11655
08:12:48,760 --> 08:12:52,958
那么现在，让我们接着来进行打印操作。 

11656
08:12:50,478 --> 08:12:54,878
再来一些，对吧，呃，我知道那个……那个

11657
08:12:52,958 --> 08:12:57,878
自动调参那次效果不错，所以我们去打印

11658
08:12:54,878 --> 08:12:57,878
09

注：由于“09”在没有特定语境下，直接以数字形式保留翻译，一般可理解为“零九” ，但单纯数字通常原样呈现更合适。 

11659
08:12:58,478 --> 08:13:03,318
这个大约有一万一千（这里“11,000”需结合语境确定具体所指，如数量、金额等），所以相对于…… 

11660
08:13:01,318 --> 08:13:05,200
这一个，你知道它的程度适中吗？ 

11661
08:13:03,318 --> 08:13:08,440
更好了，然后我们就可以把……打印出来

11662
08:13:05,200 --> 08:13:10,638
最后一个是库布洛斯，所以库布洛斯是

11663
08:13:08,440 --> 08:13:14,638
理应是我们所能达到的最快速度

11664
08:13:10,638 --> 08:13:17,398
实际上看到这个

11665
08:13:14,638 --> 08:13:19,160
11496与自动调音后的效果非常接近

11666
08:13:17,398 --> 08:13:20,680
内核 没错，所以如果我们真的回顾一下

11667
08:13:19,160 --> 08:13:23,360
和我们之前所做的事情相比，那就是

11668
08:13:20,680 --> 08:13:26,240
第六点，我们离政变很近了。

11669
08:13:23,360 --> 08:13:29,040
亏损了 1 万，那我们就记成 10800 吧

11670
08:13:26,240 --> 08:13:29,040
除以

11671
08:13:31,240 --> 08:13:36,718
嗯，10800，编号11，呃

11672
08:13:37,760 --> 08:13:45,040
11496，所以我们得到大约…… 

11673
08:13:40,120 --> 08:13:48,040
94% 呃，郭（可能人名）的表现，仅仅是利用了呃…… 

11674
08:13:45,040 --> 08:13:49,760
矢量化的，呃，就像 float4 那样

11675
08:13:48,040 --> 08:13:52,040
正在加载
没错，那太荒谬了

11676
08:13:49,760 --> 08:13:54,878
不错，而且我们仍可以进一步优化。

11677
08:13:52,040 --> 08:13:56,478
就用这些，没错，那么考虑一下这一点

11678
08:13:54,878 --> 08:13:59,160
如果我们要进一步优化这些，并且

11679
08:13:56,478 --> 08:14:00,718
也许可以用，呃，一些额外的技巧，那些……

11680
08:13:59,160 --> 08:14:02,080
你会在类似研究论文里找到，就像

11681
08:14:00,718 --> 08:14:03,958
这实际上可能会变得非常非常

11682
08:14:02,080 --> 08:14:07,638
快，对吧

11683
08:14:03,958 --> 08:14:09,040
所以呢，我们这样还挺酷的

11684
08:14:07,638 --> 08:14:10,280
仅在我们自己的硬件上就能做到这一点，并且

11685
08:14:09,040 --> 08:14:13,080
实际上，我们可以从头到尾看到它

11686
08:14:10,280 --> 08:14:14,398
完成并直观地理解它，嗯

11687
08:14:13,080 --> 08:14:17,200
我不打算详细说明的原因

11688
08:14:14,398 --> 08:14:18,958
再也不会这样了，是因为情况只会越来越……

注：原英文表述不完整，可能存在信息缺失，以上翻译根据现有内容尽力完成。 

11689
08:14:17,200 --> 08:14:20,958
随着你的深入探索，会有更多复杂的内容需要钻研

11690
08:14:18,958 --> 08:14:23,120
通过每一个，嗯，而且我想保存

11691
08:14:20,958 --> 08:14:24,318
为最后一个期末项目留出一些时间

注：原英文表述不太完整，推测可能还有后续内容。若有更完整的内容，可提供给我进行更准确的翻译。 

11692
08:14:23,120 --> 08:14:26,760
我们打算开展的课程

11693
08:14:24,318 --> 08:14:28,840
很快，嗯，但没错，我不会去做的。 

11694
08:14:26,760 --> 08:14:32,000
涵盖所有这些，我只是有点涉及到

11695
08:14:28,840 --> 08:14:33,718
主要的方面，所以，呃，缓存行（cols 推测为 cache lines）内存访问

11696
08:14:32,000 --> 08:14:36,160
来自 来自全球 就像一次提升

11697
08:14:33,718 --> 08:14:38,240
从天真无邪，然后呃，所有不同的…… 

11698
08:14:36,160 --> 08:14:40,680
平铺变体，然后我们如何能够怎样

11699
08:14:38,240 --> 08:14:43,878
我们可以对内存访问进行向量化

11700
08:14:40,680 --> 08:14:48,318
好的，既然如此，那我们实际上开始吧

11701
08:14:43,878 --> 08:14:51,120
去把那个，呃，装配说明打印出来

11702
08:14:48,318 --> 08:14:55,160
针对这个特定内核的说明，所以

11703
08:14:51,120 --> 08:14:58,920
如果我从这里跳出来，然后进入“源”（这里“Source”需结合具体语境确定更准确的译法，一般可能指某种软件里的“源”等）

11704
08:14:55,160 --> 08:15:03,440
SL内核会（做……）

注：由于文本简短且“do”后无内容，这里只能给出相对宽泛的翻译，可能需要结合更多上下文来准确理解含义。 

11705
08:14:58,920 --> 08:15:06,760
nvcc（NVIDIA CUDA编译器）并行线程执行（PTX），然后我们

11706
08:15:03,440 --> 08:15:06,760
出发，数字（注：“go number”单独看语义不太明确，需结合具体语境理解更准确含义）

11707
08:15:07,000 --> 08:15:14,160
出局六人，我们就可以走了

11708
08:15:11,318 --> 08:15:16,878
嗯，第六点。

11709
08:15:14,160 --> 08:15:18,318
PTX 好吧，所以不那样做的话，呃，我就……

11710
08:15:16,878 --> 08:15:20,440
记得我们这里有这个主文件

11711
08:15:18,318 --> 08:15:22,600
我们可以参考这些内容，所以如果我直接去

11712
08:15:20,440 --> 08:15:24,638
如果我愿意的话，就先把这个保存下来，然后拿走……（原英文文本似乎不完整或表述不太符合正常语序） 

11713
08:15:22,600 --> 08:15:27,878
……的标题；……的名称

需注意，“the title of”并非完整句子，一般后面要接相应内容，如“the title of the book（这本书的书名）” 。 

11714
08:15:24,638 --> 08:15:30,798
这个，然后我替换

11715
08:15:27,878 --> 08:15:33,600
我在那里面回复那个

注：原句 “I repl that in” 可能存在拼写错误，推测正确形式或许是 “I reply that in”  。 

11716
08:15:30,798 --> 08:15:36,440
在这里，呃，然后我们继续进行编译。

11717
08:15:33,600 --> 08:15:38,360
我们要拿到我们真正的呃Pentatonix（PTX可能是Pentatonix的缩写）相关的东西了。 

11718
08:15:36,440 --> 08:15:42,360
此处为说明。

11719
08:15:38,360 --> 08:15:45,558
所以，呃，看起来我们出了一些错误。

11720
08:15:42,360 --> 08:15:50,638
这是因为如果我真的进去

11721
08:15:45,558 --> 08:15:50,638
在这里我们得复制这个，把它复制下来

11722
08:15:50,760 --> 08:15:55,478
回来 哦，我们正在得到

11723
08:15:55,680 --> 08:16:00,238
Vim 与

11724
08:15:57,920 --> 08:16:02,238
那么，那里基本上发生了什么事

11725
08:16:00,238 --> 08:16:04,200
我本来已经正确地将它进口了，但我们

11726
08:16:02,238 --> 08:16:07,000
只是没有在结尾加上“TN” 

11727
08:16:04,200 --> 08:16:09,440
所以我刚刚加上了那个，嗯，现在它……

11728
08:16:07,000 --> 08:16:12,920
现在它已经成功编译了，所以我们

11729
08:16:09,440 --> 08:16:14,920
获取内核。PTX 我们打开这个，嗯，然后我们

11730
08:16:12,920 --> 08:16:18,000
可以继续看看，嗯，让我们看看是否我们

11731
08:16:14,920 --> 08:16:20,878
能找到任何的 128 都不在这里，所以

11732
08:16:18,000 --> 08:16:23,958
实际上我得进去，呃，然后

11733
08:16:20,878 --> 08:16:27,638
将这个转换为着色器汇编代码，我们可以开始了

11734
08:16:23,958 --> 08:16:32,318
接着做呃

11735
08:16:27,638 --> 08:16:36,318
在密件抄送中，达斯（Das 可能是人名）会做的是拱门（这里“Arch”表述不太明确，也可能有其他含义）。 

11736
08:16:32,318 --> 08:16:39,440
SM哦，Arch等于酸痛

注：这里“SM”“Arch”可能是特定的名称、术语等，如果有更多背景信息，可能会有更准确的翻译。 

11737
08:16:36,318 --> 08:16:43,160
86，然后我们来处理Q

11738
08:16:39,440 --> 08:16:43,160
二进制 嗯 主要的

11739
08:16:43,200 --> 08:16:47,600
先吸进去，然后呼出来，接着我们再来一次

注：原英文 “dosc” 可能拼写有误，推测是 “dose” （这里可能表达吸一口之类的意思 ），以上翻译根据推测进行。 

11740
08:16:46,280 --> 08:16:51,000
主要的；重要的；最大的
主体；要点；干线

注：“main”常见释义有以上这些，需结合具体语境准确判断其含义。若这不是你想要的内容，请提供更多上下文。 

11741
08:16:47,600 --> 08:16:56,398
主CUDA二进制文件，然后我们就开始

11742
08:16:51,000 --> 08:16:56,398
向前以及 C 对象对象转储

11743
08:16:58,318 --> 08:17:03,120
然后我们只做 main.key 二进制文件

11744
08:17:01,040 --> 08:17:06,958
像这样，我们继续并移动这个

11745
08:17:03,120 --> 08:17:13,958
起来，我们可以看到，如果我们去寻找

11746
08:17:06,958 --> 08:17:15,558
特定的加载数据全局内存（LDG）数据对象元素（DOE）指令 LDG

11747
08:17:13,958 --> 08:17:18,600
做；干；办（某事）；行动；表现；（问询或谈论时用）进展，进行

11748
08:17:15,558 --> 08:17:20,680
128 128

11749
08:17:18,600 --> 08:17:23,558
128

11750
08:17:20,680 --> 08:17:28,440
1288 128

11751
08:17:23,558 --> 08:17:31,120
128 等等诸如此类，这多酷啊

11752
08:17:28,440 --> 08:17:33,280
是我们实际上可以验证所有

11753
08:17:31,120 --> 08:17:36,120
在这些当中

11754
08:17:33,280 --> 08:17:40,558
嗯，我们也许能在这里找到一件32码的。 

11755
08:17:36,120 --> 08:17:40,558
某个地方 哦，那只会在……里面

11756
08:17:41,080 --> 08:17:47,280
呃，那是一个

11757
08:17:44,280 --> 08:17:49,638
登记
那也是一次登记

11758
08:17:47,280 --> 08:17:49,638
那是一个

11759
08:17:50,200 --> 08:17:55,920
注册，所以实际上我们没有任何（相关东西）

11760
08:17:52,680 --> 08:17:58,638
32位加载 任何32位传输均可

11761
08:17:55,920 --> 08:18:02,238
一切都很完美

11762
08:17:58,638 --> 08:18:02,238
嗯，一切都是

11763
08:18:03,638 --> 08:18:09,120
太棒了 怎么样

11764
08:18:06,040 --> 08:18:11,040
太棒了，那么现在，呃，既然是那种类型

11765
08:18:09,120 --> 08:18:13,958
我们能够做到这一点是有道理的。

11766
08:18:11,040 --> 08:18:16,478
真的看看那些呃说明



11767
08:18:13,958 --> 08:18:19,878
当我们提供优化方案时，看起来会是怎样的呢

11768
08:18:16,478 --> 08:18:21,718
优化 嗯，你知道的，我们可以，我们能够

11769
08:18:19,878 --> 08:18:23,080
实际上，我们实际上能感受到更多

11770
08:18:21,718 --> 08:18:24,600
对我们的能力充满信心，这不仅仅是

11771
08:18:23,080 --> 08:18:26,040
就像我告诉你这行得通，而且

11772
08:18:24,600 --> 08:18:28,200
相信它，就好像你真的可以

11773
08:18:26,040 --> 08:18:30,200
看，这就是正在……这就是

11774
08:18:28,200 --> 08:18:31,878
GPU 控制器上正在运行什么

11775
08:18:30,200 --> 08:18:34,238
里面的那些小型微控制器

11776
08:18:31,878 --> 08:18:38,040
发布指令

11777
08:18:34,238 --> 08:18:39,318
对，所以如果我们回到这里，嗯

11778
08:18:38,040 --> 08:18:41,398
有一件小事我想做

11779
08:18:39,318 --> 08:18:44,958
涵盖 这是一项额外的优化，它

11780
08:18:41,398 --> 08:18:48,360
正在使用张量核心，所以我们前往…… 

11781
08:18:44,958 --> 08:18:50,000
对张量核心进行编程 嗯 你

11782
08:18:48,360 --> 08:18:53,520
真的，只要搜索一下，它就在英伟达（平台）上。

11783
08:18:50,000 --> 08:18:57,318
博客：在CUDA 9中对张量核心进行编程

11784
08:18:53,520 --> 08:19:02,478
那么，CUDA 9，呃，我的意思是，实际上我们已经……

11785
08:18:57,318 --> 08:19:04,398
我到这里了吗？英伟达系统管理接口（Nvidia SMI），我们在用CUDA

11786
08:19:02,478 --> 08:19:07,238
12.5 所以没关系，我们不必（做某事）。 

11787
08:19:04,398 --> 08:19:09,398
担心兼容性问题 嗯

11788
08:19:07,238 --> 08:19:09,398
但是

11789
08:19:09,920 --> 08:19:15,000
本质上，这赋予了整个…… 

11790
08:19:12,398 --> 08:19:17,718
关于如何使用张量的指令集

11791
08:19:15,000 --> 08:19:21,798
核心，没错，所以

11792
08:19:17,718 --> 08:19:23,440
嗯，CA9提供了这些新功能，这些

11793
08:19:21,798 --> 08:19:25,798
张量核心本质上会像用于……（此处原英文句子似乎不完整） 

11794
08:19:23,440 --> 08:19:27,798
基于伏打架构的示例

11795
08:19:25,798 --> 08:19:30,398
你可以，你能做到这个，就好像是这样

11796
08:19:27,798 --> 08:19:32,680
你将这两个半精度浮点数（FP16）矩阵相乘，然后

11797
08:19:30,398 --> 08:19:35,040
然后你再添加一个，就在那个……那里

注：原文“right the the”表述有误，可能是不完整或有拼写错误。但我按要求进行了翻译。 

11798
08:19:32,680 --> 08:19:38,760
我们所见到的融合乘加运算

11799
08:19:35,040 --> 08:19:41,398
之前，嗯，除了在四驱车（4x4）这个层面上

11800
08:19:38,760 --> 08:19:45,280
张量，并且这些在……中得到支持

11801
08:19:41,398 --> 08:19:46,840
在CU损失库中，嗯，所以有两个张量

11802
08:19:45,280 --> 08:19:48,718
两个使用张量核心的CUDA库

11803
08:19:46,840 --> 08:19:50,680
库布罗斯和美国有线电视新闻网（CNN）是对的吗，我们中的那些人……

注：原英文句子似乎不太完整，表述有些模糊，以上翻译是尽量贴近字面意思呈现。 

11804
08:19:48,718 --> 08:19:53,280
我们之前提到过的那些，忽必烈的用途 

11805
08:19:50,680 --> 08:19:56,718
张量课程以加速通用矩阵乘法（GEM）矩阵运算

注：“gem” 一般在相关领域指 “General Matrix Multiply”（通用矩阵乘法） ，这里为了更准确表意进行了补充说明。 

11806
08:19:53,280 --> 08:20:00,920
乘法，呃，运算，而卷积神经网络（CNN）会用到它

11807
08:19:56,718 --> 08:20:02,600
为了加速卷积和循环神经网络，所以

11808
08:20:00,920 --> 08:20:04,120
那很酷，但要是我们想写呢

11809
08:20:02,600 --> 08:20:05,920
我们自己的 如果我们想写我们自己的呢

11810
08:20:04,120 --> 08:20:07,558
不依赖于CU损失的代码

11811
08:20:05,920 --> 08:20:08,840
对，因为CU损耗，我们可以直接称之为

11812
08:20:07,558 --> 08:20:11,040
就像一个独立的功能，但它可能

11813
08:20:08,840 --> 08:20:13,718
别这么慢，不然我们没法把……融合在一起了 

11814
08:20:11,040 --> 08:20:15,680
带有一个的实际张量核心指令

11815
08:20:13,718 --> 08:20:17,718
我们想要实现的特定内核，比如

11816
08:20:15,680 --> 08:20:19,798
例如，嗯，闪存注意力，对吧，如果

11817
08:20:17,718 --> 08:20:21,238
我们想写下，库布罗斯（可能是特定名称，可结合具体语境调整）也许不会

11818
08:20:19,798 --> 08:20:23,000
让我们那么做吧，因为这有点……

11819
08:20:21,238 --> 08:20:27,360
独立地 我们不能把那些通话算在内

11820
08:20:23,000 --> 08:20:30,238
在内核内部，嗯，所以如果我们想

11821
08:20:27,360 --> 08:20:31,280
实际上，看看该如何使用那个，嗯

11822
08:20:30,238 --> 08:20:34,478
它在哪里

注：原英文句子“where did it”不完整，可能存在信息缺失，但按照要求进行了翻译。完整的句子可能类似 “Where did it go” （它去哪里了） 等。 

11823
08:20:31,280 --> 08:20:36,000
往下滚动一点，张量

11824
08:20:34,478 --> 08:20:39,920
课程和

11825
08:20:36,000 --> 08:20:42,200
美国有线电视新闻网（CNN），然后呃，通过程序化方式访问…… 

11826
08:20:39,920 --> 08:20:44,920
张量核心，而这就是CUDA 9.0（推测ca可能是CUDA的误写）发挥作用的地方 

11827
08:20:42,200 --> 08:20:48,680
进来了，所以我们没问题了，嗯，基本上

11828
08:20:44,920 --> 08:20:52,040
有个新事物叫，呃，那个……

11829
08:20:48,680 --> 08:20:55,280
完整的命名空间是 NV，然后在 C++ 里

11830
08:20:52,040 --> 08:20:57,398
这就像那个 W 那个 W

11831
08:20:55,280 --> 08:20:59,398
综合格斗，呃

11832
08:20:57,398 --> 08:21:00,920
这意味着线程束矩阵乘法

11833
08:20:59,398 --> 08:21:02,798
积累，而我不会去（做积累这件事）

11834
08:21:00,920 --> 08:21:04,280
确切地说，没人知道那到底意味着什么，而且……（原文nor do后内容缺失，此处根据语境做了适当补充以体现连贯性）

11835
08:21:02,798 --> 08:21:09,718
我完全清楚下面正在发生什么

11836
08:21:04,280 --> 08:21:12,318
那边有个兜帽，不过，嗯，那就是那个…… 

11837
08:21:09,718 --> 08:21:14,600
张量核心，呃，我们能够进行的运算

11838
08:21:12,318 --> 08:21:16,440
好，打个电话，所以有一堆…… 

11839
08:21:14,600 --> 08:21:18,680
这里的例子我就不详细讲解了

11840
08:21:16,440 --> 08:21:22,478
这部分，但是，呃，这有点像是…… 

11841
08:21:18,680 --> 08:21:23,878
就像一个很不错的小，嗯，你知道的，供……用的码头

11842
08:21:22,478 --> 08:21:26,600
搞清楚到底该如何使用张量

11843
08:21:23,878 --> 08:21:28,000
核心业务，而且你可能，你可能

11844
08:21:26,600 --> 08:21:29,600
甚至可能想实施那些（方案、措施等，需结合具体语境确定）

11845
08:21:28,000 --> 08:21:31,558
在块平铺内核内部，对吧

11846
08:21:29,600 --> 08:21:34,600
所以我们刚刚写下的那些，你也许……

11847
08:21:31,558 --> 08:21:37,238
想说就像拿一根线一样

11848
08:21:34,600 --> 08:21:38,680
并且有像一根线或者它的一部分那样的东西

11849
08:21:37,238 --> 08:21:40,440
并尝试去屏蔽这些真实的……（由于文本不完整，这里只是大致的翻译呈现） 

11850
08:21:38,680 --> 08:21:42,040
张量核心操作，没错，并且进行

11851
08:21:40,440 --> 08:21:44,280
这些真的真的很快，这样一来

11852
08:21:42,040 --> 08:21:45,478
不只是这样，事情并非如此

11853
08:21:44,280 --> 08:21:46,840
然后遍历到八

11854
08:21:45,478 --> 08:21:49,760
再遍历八个并且拥有

11855
08:21:46,840 --> 08:21:52,040
总共要进行64次操作，但更确切地说

11856
08:21:49,760 --> 08:21:53,840
只拥有一个，对吧，所以这些是

11857
08:21:52,040 --> 08:21:56,360
真的会以三维形式进行组织

11858
08:21:53,840 --> 08:22:00,040
张量核心内部的结构在……（此处“on”后面似乎文本不完整）

11859
08:21:56,360 --> 08:22:03,120
这个……呃，GPU，而且它真的……

11860
08:22:00,040 --> 08:22:04,680
就像一个三维的东西或者一个二维的东西

11861
08:22:03,120 --> 08:22:07,160
取决于你所涉及的维度有多大

11862
08:22:04,680 --> 08:22:10,040
使用，嗯，因为你可以进行批量操作

11863
08:22:07,160 --> 08:22:13,238
按，呃，按频道和时间，如果您正在使用…… 

11864
08:22:10,040 --> 08:22:16,878
变形金刚，或者你也可以做到

11865
08:22:13,238 --> 08:22:19,160
嗯，是的，就在那里，有一个…… 

11866
08:22:16,878 --> 08:22:21,840
硬件方面有很多事情在进行，但你可以

11867
08:22:19,160 --> 08:22:23,520
实际上，你可以利用这些，所以

11868
08:22:21,840 --> 08:22:26,080
不管怎样，我不会在这件事上啰嗦了。

11869
08:22:23,520 --> 08:22:28,638
这是你所拥有的张量核心吗？

11870
08:22:26,080 --> 08:22:30,398
允许你尽情享受这个，嗯，我

11871
08:22:28,638 --> 08:22:31,798
鼓励你这样做，我可能还会补充一些内容

11872
08:22:30,398 --> 08:22:33,878
关于这门课程，稍后在……会有更多内容

11873
08:22:31,798 --> 08:22:35,798
你大概会了解的 GitHub 仓库

11874
08:22:33,878 --> 08:22:37,760
多谈谈张量课程，但这个

11875
08:22:35,798 --> 08:22:40,200
是

11876
08:22:37,760 --> 08:22:42,840
没关系，这样我们终于可以来一次

11877
08:22:40,200 --> 08:22:45,318
现在先歇口气，矩阵乘法是

11878
08:22:42,840 --> 08:22:47,120
差不多完成了 嗯 有……有……

11879
08:22:45,318 --> 08:22:49,238
稍后我们还会多做一点。

11880
08:22:47,120 --> 08:22:50,680
但目前你可以考虑矩阵

11881
08:22:49,238 --> 08:22:54,878
乘法运算完成，进行下一步

11882
08:22:50,680 --> 08:22:58,280
一两部分，嗯，现在我们进入关于海卫一的内容

11883
08:22:54,878 --> 08:23:00,798
本质上是采用了之前的，呃

11884
08:22:58,280 --> 08:23:02,478
引用上一章内容并说道

11885
08:23:00,798 --> 08:23:06,478
让我们对其进行抽象处理，让它变得更简单。

11886
08:23:02,478 --> 08:23:08,520
用嗯，所以，所以说，呃，你知道的

11887
08:23:06,478 --> 08:23:10,360
矩阵乘法或者类似分块的方式

11888
08:23:08,520 --> 08:23:12,280
你对事物进行分块处理的优化方法

11889
08:23:10,360 --> 08:23:13,520
分成块，然后你知道

11890
08:23:12,280 --> 08:23:15,958
更多地将它们相乘

11891
08:23:13,520 --> 08:23:18,080
实际上，我们可以高效地处理那个。 

11892
08:23:15,958 --> 08:23:22,520
并且用 Python 来做会简单得多

11893
08:23:18,080 --> 08:23:22,520
语法 所以这就是Triton

11894
08:23:22,760 --> 08:23:28,798
嗯，Triton和CUDA有点不同。

11895
08:23:25,718 --> 08:23:30,318
好的，那么在我真正开始之前

11896
08:23:28,798 --> 08:23:32,238
这里的整个设计以及……什么（这里原文表述不太完整，“the the”可能有误） 

11897
08:23:30,318 --> 08:23:34,638
特里同大概是我希望你支付……

注：原英文句子似乎表述不完整，翻译可能不太能准确传达完整意思。 

11898
08:23:32,238 --> 08:23:36,040
关注某件事，所以如果我发出“哔”的声音

11899
08:23:34,638 --> 08:23:40,000
安装

11900
08:23:36,040 --> 08:23:42,478
火炬 你会发现我们得到了所有的

11901
08:23:40,000 --> 08:23:44,718
这些 所有这些 所有这些英伟达的东西

11902
08:23:42,478 --> 08:23:49,638
这我们之前见过，然后我们得到

11903
08:23:44,718 --> 08:23:52,958
这款海神（Triton）3.0 对吧，还有海神（Triton） 

11904
08:23:49,638 --> 08:23:54,798
在底层被 PyTorch 使用，或者

11905
08:23:52,958 --> 08:23:57,558
加速并让事情进展得更快

11906
08:23:54,798 --> 08:24:00,160
使用 Python 语法，没错，Tron 也是

11907
08:23:57,558 --> 08:24:02,238
快得就像CUDA，所以那儿，那儿

11908
08:24:00,160 --> 08:24:06,318
它们之间存在一些差异，这些差异……（原句不完整） 

11909
08:24:02,238 --> 08:24:10,398
我想我应该强调一下，嗯，所以如果我们

11910
08:24:06,318 --> 08:24:12,638
去一下……去一下……

11911
08:24:10,398 --> 08:24:14,600
Triton网站，搜索Triton文档或者

11912
08:24:12,638 --> 08:24:17,520
三叉戟网站之类的，呃，这会……

11913
08:24:14,600 --> 08:24:21,040
过来，他们也有一个 GitHub 呢。

11914
08:24:17,520 --> 08:24:25,360
所以，你知道的，GitHub有很多呃

11915
08:24:21,040 --> 08:24:26,798
你知道一些有用的东西，嗯，是的，只是

11916
08:24:25,360 --> 08:24:29,280
摆弄着它，所以正在设置

11917
08:24:26,798 --> 08:24:31,080
配置Tridon（可能是某个特定名称，如软件、系统等），进行自定义操作

11918
08:24:29,280 --> 08:24:33,798
呃，但你可以直接用PP安装Tridon（可能是某个软件或工具名称）。 

11919
08:24:31,080 --> 08:24:36,280
像那样做，它会以同样的方式起作用，嗯

11920
08:24:33,798 --> 08:24:38,718
但如果你确实去观察海卫一的话

11921
08:24:36,280 --> 08:24:41,440
在网站上你会看到一系列板块

11922
08:24:38,718 --> 08:24:43,600
那么，嗯，你要怎么安装它呢？

11923
08:24:41,440 --> 08:24:46,080
关于如何使用Triton的教程，所以

11924
08:24:43,600 --> 08:24:47,760
这里好像有一堆，我不太…… 

11925
08:24:46,080 --> 08:24:51,120
在这门课程中不一定会涉及，但你

11926
08:24:47,760 --> 08:24:54,760
你能再详细讲一下这些吗，呃，如果……

11927
08:24:51,120 --> 08:24:56,558
你想嗯，然后还有那个

11928
08:24:54,760 --> 08:24:59,080
我们如此在意的重要的那些（事物）

11929
08:24:56,558 --> 08:25:02,318
特里同（Triton），呃，特里同文档是指什么呢？

11930
08:24:59,080 --> 08:25:04,200
这里有像即时（JIT）自动调音之类的所有东西

11931
08:25:02,318 --> 08:25:07,558
嗯，正要走

11932
08:25:04,200 --> 08:25:10,360
通过经历

11933
08:25:07,558 --> 08:25:11,680
函数 um，然后我们进入 Triton 的内容

11934
08:25:10,360 --> 08:25:14,760
哪种语言是最重要的

11935
08:25:11,680 --> 08:25:16,680
嗯，总的来说，我们有一堆……

11936
08:25:14,760 --> 08:25:18,000
在这里与特里登公司有不同的业务操作

11937
08:25:16,680 --> 08:25:19,958
然后我将深入探讨……的整体设计

（由于原文未完整，“of”后面的内容缺失，所以只能这样翻译到“……”处） 

11938
08:25:18,000 --> 08:25:22,120
马上就到《创：战纪》相关内容了，但这只是…… 

11939
08:25:19,958 --> 08:25:25,318
这样就真的很容易看出那一点了。

11940
08:25:22,120 --> 08:25:27,878
所有的操作都在这里，所以

11941
08:25:25,318 --> 08:25:32,200
嗯，就像编程模型，呃

11942
08:25:27,878 --> 08:25:34,440
了解创造操作的行动，嗯，所以如果

11943
08:25:32,200 --> 08:25:36,080
如果你有一个 X 张量，就像…… 

11944
08:25:34,440 --> 08:25:37,798
你想做个“y”的动作，但你没做

11945
08:25:36,080 --> 08:25:39,080
想往里面填充点什么东西，还是你……

11946
08:25:37,798 --> 08:25:42,040
你可以说，只想让它归零。

11947
08:25:39,080 --> 08:25:44,600
零，就像在创造的那一刻，嗯，形状

11948
08:25:42,040 --> 08:25:46,840
操作 线性代数 所以点积

11949
08:25:44,600 --> 08:25:50,920
产品

11950
08:25:46,840 --> 08:25:52,398
嗯，指针操作 呃，内存指针操作

11951
08:25:50,920 --> 08:25:55,200
一堆和数学有关的东西，有很多呢

11952
08:25:52,398 --> 08:25:56,798
数学运算
归约运算
比如求最大值

11953
08:25:55,200 --> 08:25:58,878
或者你有一个数组，并且你正在尝试

11954
08:25:56,798 --> 08:26:00,840
找到它的最大值，然后你进行化简

11955
08:25:58,878 --> 08:26:04,040
它只是返回一个单一的（这里句子不完整，语义不太明确）

11956
08:26:00,840 --> 08:26:06,280
值 呃 扫描和排序操作

11957
08:26:04,040 --> 08:26:08,398
像我们之前所说的原子现象

11958
08:26:06,280 --> 08:26:10,238
随机数生成等等，对吧

11959
08:26:08,398 --> 08:26:12,798
这里有……这里有很多东西呢，甚至……甚至呃

11960
08:26:10,238 --> 08:26:14,000
调试和打印也是如此，所以尝试并

11961
08:26:12,798 --> 08:26:16,160
这就是 这就是所有的……所在之处（这里原文表意不完整，可根据上下文补充完整表述）

11962
08:26:14,000 --> 08:26:18,318
操作是你将会发现

11963
08:26:16,160 --> 08:26:23,160
嗯，这让出行变得非常容易。

11964
08:26:18,318 --> 08:26:27,238
嗯，但是如果我们穿过……呃，哪里呢

11965
08:26:23,160 --> 08:26:31,958
这是引言部分吗？是的，所以整个想法

11966
08:26:27,238 --> 08:26:36,558
在这里，如果我去，呃，特里同（海王星最大的卫星）

11967
08:26:31,958 --> 08:26:39,160
论文，是的，就是这篇，所以我要看看这篇。

11968
08:26:36,558 --> 08:26:41,120
马上就好，但本质上这是

11969
08:26:39,160 --> 08:26:43,398
特里同（Triton）的灵感来源就是这个，这个

11970
08:26:41,120 --> 08:26:45,000
这里有关于 tille 神经网络的论文

11971
08:26:43,398 --> 08:26:48,160
像我们在……中进行的那种计算

11972
08:26:45,000 --> 08:26:50,638
上一章，对，嗯，还有这个

11973
08:26:48,160 --> 08:26:53,600
这就是这里的整体想法，即你有…… 

11974
08:26:50,638 --> 08:26:55,280
标量Pro Cuda有一个标量程序，并且

11975
08:26:53,600 --> 08:26:57,238
阻塞线程与特伦特（Trent）相比，特伦特（Trent）有一个…… 

11976
08:26:55,280 --> 08:26:58,718
阻塞程序和标量线程，这就像

11977
08:26:57,238 --> 08:27:01,760
好吧，这是什么意思？这太棒了。

11978
08:26:58,718 --> 08:27:03,920
奇怪，嗯，有很多类似几何图形的东西

11979
08:27:01,760 --> 08:27:06,718
这里正在发生的事情，那么我们该怎么做呢

11980
08:27:03,920 --> 08:27:08,958
实际上把这个分解一下

11981
08:27:06,718 --> 08:27:12,878
嗯

11982
08:27:08,958 --> 08:27:15,440
现在来阐明为什么 CUDA 是一个…… （原文此处似乎未完整）

11983
08:27:12,878 --> 08:27:17,798
使用块线程扩展标量程序

11984
08:27:15,440 --> 08:27:19,878
是因为你编写了一个内核来进行操作

11985
08:27:17,798 --> 08:27:21,638
在线程或定标器的层面上于

11986
08:27:19,878 --> 08:27:23,638
这种情况，所以这就是为什么它是一个标量

11987
08:27:21,638 --> 08:27:27,600
程序 每个单独的内核在一个（此处原文不完整，推测后面还有内容）上运行

11988
08:27:23,638 --> 08:27:29,600
线程 嗯，但你需要意识到你

11989
08:27:27,600 --> 08:27:31,558
需要潜意识地意识到那些

11990
08:27:29,600 --> 08:27:35,160
内核也在……层面上运行

11991
08:27:31,558 --> 08:27:36,680
群体也是如此，所以当你有，呃，就像对于…… 

11992
08:27:35,160 --> 08:27:39,478
例如像那样的共享内存

11993
08:27:36,680 --> 08:27:42,638
你现在需要担心的事情

11994
08:27:39,478 --> 08:27:45,760
嗯，CUDA（统一计算设备架构）

11995
08:27:42,638 --> 08:27:47,478
CUDA 是否有阻塞线程，因此是标量的情况呢

注：原英文句子表述似乎不太符合常规语法，翻译是基于尽量理解其可能表达的意思进行的。 

11996
08:27:45,760 --> 08:27:49,398
对其进行编程，这就像是实际的内核，即那个……

注：原英文句子似乎不完整，这里根据现有内容进行了尽量通顺的翻译。 

11997
08:27:47,478 --> 08:27:51,520
你先撰写，然后用……阻塞线程

11998
08:27:49,398 --> 08:27:53,160
当你真正开始书写时的那种想法

11999
08:27:51,520 --> 08:27:54,558
在内核线程上运行的内核本身

12000
08:27:53,160 --> 08:27:55,798
它必须了解所有其他的……

注：原文“of of”表述有误，可能多了一个“of” 。正常表达或许是 “it has to be aware of all the other” 。 

12001
08:27:54,558 --> 08:27:57,878
还有那些线程，那有点就是我……

12002
08:27:55,798 --> 08:28:01,638
走出去，然后海卫一（特里同）是

12003
08:27:57,878 --> 08:28:04,840
抽象到线程块层面，因此

12004
08:28:01,638 --> 08:28:06,280
嗯，这本质上意味着编译器

12005
08:28:04,840 --> 08:28:09,478
处理所有这些线程级别

12006
08:28:06,280 --> 08:28:11,520
操作，呃，对我们来说，所以当你写的时候

12007
08:28:09,478 --> 08:28:13,238
在海卫一（Triton）里有某种东西，而不是拥有它

12008
08:28:11,520 --> 08:28:15,200
在每个单独的线程上运行并拥有

12009
08:28:13,238 --> 08:28:16,478
让他们交流并意识到这一点

注：原英文文本 “them communicate” 语法上可能存在省略，一般完整表达可以是 “let them communicate” 等，以上翻译是根据整体语义做的推测性翻译。 

12010
08:28:15,200 --> 08:28:19,200
它将在……的层面上进行书写

12011
08:28:16,478 --> 08:28:21,040
积木以及所有类似线状物的东西

12012
08:28:19,200 --> 08:28:22,558
层级说明和优化措施是

12013
08:28:21,040 --> 08:28:24,040
将由编译器来处理，用于

12014
08:28:22,558 --> 08:28:26,600
所以你实际上不必担心

12015
08:28:24,040 --> 08:28:30,280
关于那些，嗯

12016
08:28:26,600 --> 08:28:32,520
然后当我们谈到，嗯，当我们

12017
08:28:30,280 --> 08:28:32,520
交谈；谈话；说话；讨论

12018
08:28:32,680 --> 08:28:38,638
关于当我们谈论标量线程时

12019
08:28:36,200 --> 08:28:41,638
这意味着你不必呃像……

12020
08:28:38,638 --> 08:28:43,760
担心他们交谈，呃，像……

12021
08:28:41,638 --> 08:28:45,920
彼此相互关联，你不……

12022
08:28:43,760 --> 08:28:47,600
必须要留意，因为实际上 CUDA 

12023
08:28:45,920 --> 08:28:49,760
负责那部分，所以既然你是

12024
08:28:47,600 --> 08:28:51,478
在块的层面上书写，你不会

12025
08:28:49,760 --> 08:28:53,000
实际上还得担心线程间的问题

12026
08:28:51,478 --> 08:28:55,478
交流方面，你只需担心

12027
08:28:53,000 --> 08:28:57,878
关于这个区块具体在做什么，嗯

12028
08:28:55,478 --> 08:28:59,638
把那个的操作说明清楚，并且

12029
08:28:57,878 --> 08:29:03,398
然后TR实际上会在……之下处理那个

12030
08:28:59,638 --> 08:29:05,160
那个兜帽，所以你看到了，嗯，那里有…… 

12031
08:29:03,398 --> 08:29:07,478
在……里的手术操作非常少。（由于原文不完整，“in the”后面缺少内容，可能会影响更准确的理解和表述） 

12032
08:29:05,160 --> 08:29:09,280
特隆涉及语言板块，这是因为

12033
08:29:07,478 --> 08:29:11,558
编译器能够处理很多的……（原句不完整）

12034
08:29:09,280 --> 08:29:13,840
那些额外的操作，那些

12035
08:29:11,558 --> 08:29:16,398
考虑到性能提升

12036
08:29:13,840 --> 08:29:18,920
嗯，对，所以……所以那就是全部了。

12037
08:29:16,398 --> 08:29:21,680
嗯，背后的想法，那就是整个想法。

12038
08:29:18,920 --> 08:29:25,280
在海卫一后面，还有那整个呃，被挡住了

12039
08:29:21,680 --> 08:29:27,040
与标量 呃 分块的与分块的相对比

12040
08:29:25,280 --> 08:29:30,040
以及标量线程

12041
08:29:27,040 --> 08:29:30,040
哲学

12042
08:29:30,238 --> 08:29:35,600
那么我们为什么不能跳过CUDA直接进行呢

12043
08:29:32,718 --> 08:29:38,160
直接前往海卫一，为什么我们不能这么做

12044
08:29:35,600 --> 08:29:42,080
嗯，波场（Tron）是基于……之上的一种抽象概念 

12045
08:29:38,160 --> 08:29:43,798
因此，你有一些底层的东西，那就是

12046
08:29:42,080 --> 08:29:46,680
提供优化方案，并且你可以成为（这里句子似乎不完整，可根据完整内容进一步调整）

12047
08:29:43,798 --> 08:29:47,558
向英伟达编译器明确说明

12048
08:29:46,680 --> 08:29:50,558
这；那；这些；那些

注：“the”是定冠词，具体含义需结合具体语境，这里给出常见释义。 

12049
08:29:47,558 --> 08:29:53,160
加拿大国家广播公司（NBCC）嗯，而特里顿公司（Triton）利用了……

12050
08:29:50,558 --> 08:29:54,638
那些，然后将它提升几层，呃，到……

12051
08:29:53,160 --> 08:29:56,238
某种你可以在一定程度上……的东西

12052
08:29:54,638 --> 08:29:58,798
易于理解，且书写量少

12053
08:29:56,238 --> 08:30:00,520
样板代码，所以我们仍然需要

12054
08:29:58,798 --> 08:30:01,520
要理解CUDA是如何工作的以确保

12055
08:30:00,520 --> 08:30:03,520
我们正在采用正确的（方法/措施等，需结合上下文确定具体内容）

12056
08:30:01,520 --> 08:30:05,600
你无法轻易编写出来的优化方法

12057
08:30:03,520 --> 08:30:07,238
特riton代码，却不知道呃……是什么……

12058
08:30:05,600 --> 08:30:11,160
在低水平状态下持续进行，这是有帮助的。 

12059
08:30:07,238 --> 08:30:13,478
帮助你避免千篇一律的内容

12060
08:30:11,160 --> 08:30:16,200
嗯，你可能还想优化你的

12061
08:30:13,478 --> 08:30:17,440
在CUDA中使用自己的内核，没错，那么回到之前的话题

12062
08:30:16,200 --> 08:30:19,958
关于我之前说的，你某种程度上需要

12063
08:30:17,440 --> 08:30:21,520
了解低爆炸下限（LEL）操作，呃，在……

12064
08:30:19,958 --> 08:30:24,760
为了确保一切都是

12065
08:30:21,520 --> 08:30:27,000
按预期运行，对吧，嗯，如果你

12066
08:30:24,760 --> 08:30:30,200
想在 Tri 的基础上进行构建，或者进行构建

12067
08:30:27,000 --> 08:30:31,920
像它这样的事物，或者是在CUDA之上的抽象概念

12068
08:30:30,200 --> 08:30:33,398
这是“shr”（此处可能有误，推测可能是“so”之类的词），你需要学习CUDA。 

12069
08:30:31,920 --> 08:30:35,680
你需要了解什么是CUDA。

12070
08:30:33,398 --> 08:30:37,280
这样做以便你可以在其基础上进行构建

12071
08:30:35,680 --> 08:30:40,280
所以你可以利用它所包含的内容

12072
08:30:37,280 --> 08:30:42,760
已经对了；已经可以了（根据语境，“right” 有不同表意，这里给出较常见的两种） 

12073
08:30:40,280 --> 08:30:45,280
嗯，所以如果我们来看《Triton》这篇论文

12074
08:30:42,760 --> 08:30:47,318
这里是中间语言和编译器

12075
08:30:45,280 --> 08:30:49,280
用于瓦片神经网络

12076
08:30:47,318 --> 08:30:51,958
计算结果表明这就是 这是

12077
08:30:49,280 --> 08:30:54,440
本质上仅仅是

12078
08:30:51,958 --> 08:30:57,958
嗯

12079
08:30:54,440 --> 08:31:02,120
它能做库布罗斯能做的一切，并且……

（原句似乎不完整，这里按现有内容翻译并补充了“并且”以体现可能的语义延续） 

12080
08:30:57,958 --> 08:31:05,000
而美国有线电视新闻网（CNN）会这么做，但它大致是像……这样做吗

12081
08:31:02,120 --> 08:31:06,360
快速且无需大量样板代码

12082
08:31:05,000 --> 08:31:08,160
所以，整个想法就是这样

12083
08:31:06,360 --> 08:31:10,440
你有这些分块计算，它们

注：原句似乎不完整，“that”后可能还有内容。如果还有其他文本，请继续提供，以便我更准确地完成翻译。 

12084
08:31:08,160 --> 08:31:12,840
你得在库布罗斯（Kublos 可能是特定名称，需结合语境准确判断）和 CDNN（可能是特定缩写，需结合语境准确判断）那里完成这件事。 

12085
08:31:10,440 --> 08:31:14,840
照顾好那些人，所以我不会去（做别的事）了

12086
08:31:12,840 --> 08:31:17,238
浏览一下这个，嗯，这个就像是这个是

12087
08:31:14,840 --> 08:31:20,398
一门涵盖所有内容的单独课程

12088
08:31:17,238 --> 08:31:22,360
特里同，但我们接下来要详细讨论一下

12089
08:31:20,398 --> 08:31:24,638
比如，这些基础原理是如何运作的，对吧，那么

12090
08:31:22,360 --> 08:31:27,200
你明白呃，海卫一可能是怎样的情况

注：“Triton”常见为海王星最大卫星“海卫一”的英文名称，具体需结合上下文判断。 

12091
08:31:24,638 --> 08:31:30,958
申请了，嗯，也许它会给你一些

12092
08:31:27,200 --> 08:31:33,680
关于之后要做什么的想法，好的，那么

12093
08:31:30,958 --> 08:31:36,318
现在我们实际上要来看一个……的例子

12094
08:31:33,680 --> 08:31:37,840
《三位一体》中的矢量版内核，没问题

12095
08:31:36,318 --> 08:31:40,120
所以我打算试着把这个分解一下

12096
08:31:37,840 --> 08:31:41,360
尽可能高效地

需要说明的是，原英文“as kind of as as efficiently as possible”表述有误，推测可能是“as efficiently as possible” ，以上是按正确理解给出的翻译。 

12097
08:31:40,120 --> 08:31:43,040
呃，这东西不太难，它是

12098
08:31:41,360 --> 08:31:44,600
本应是一种从……中暂时解脱的方式

12099
08:31:43,040 --> 08:31:47,238
做呃像《黑客帝国》那样的事情

12100
08:31:44,600 --> 08:31:48,798
乘法，所以，呃，你，你会，你会

12101
08:31:47,238 --> 08:31:51,200
可能会找到这个 你可能会找到

12102
08:31:48,798 --> 08:31:52,318
这最终会变成你将会……

不过原英文文本 “this is a end up end up being you'll” 表述不太符合常见语法规则，可能存在错误。 

12103
08:31:51,200 --> 08:31:54,798
可能会发现这最终会成为一个

12104
08:31:52,318 --> 08:31:57,520
微风 呃，所以一开始，你知道的，我们

12105
08:31:54,798 --> 08:31:59,600
导入torch 所以Triton非常紧密地

12106
08:31:57,520 --> 08:32:02,120
与火把相连 呃 所以我们最终……

12107
08:31:59,600 --> 08:32:04,238
用那个来处理其他一些事情

12108
08:32:02,120 --> 08:32:07,160
比如初始化数组和矩阵以及

12109
08:32:04,238 --> 08:32:08,878
我们进口的东西 特里同号 特里同号

12110
08:32:07,160 --> 08:32:12,558
语言，然后是……的简写版本

12111
08:32:08,878 --> 08:32:15,000
然后我们再往下走，嗯，我们

12112
08:32:12,558 --> 08:32:16,600
初始化，呃，一个种子，以便让结果

12113
08:32:15,000 --> 08:32:19,000
当我们……当你……时是可重复的

12114
08:32:16,600 --> 08:32:20,238
随机初始化一些东西，嗯，以确保

12115
08:32:19,000 --> 08:32:22,478
你知道我们不会出错误，或者说

12116
08:32:20,238 --> 08:32:25,638
不管怎样，这是一次很好的实践，然后

12117
08:32:22,478 --> 08:32:28,958
我们有一个大小为 2 的 25 次方，所以如果我们

12118
08:32:25,638 --> 08:32:32,478
进去 我们走

12119
08:32:28,958 --> 08:32:35,798
呃，这个有 3300 万个元素那么长。

12120
08:32:32,478 --> 08:32:35,798
对，所以如果我们走

12121
08:32:37,558 --> 08:32:44,600
这3350万个元素

12122
08:32:41,478 --> 08:32:46,600
嗯，很长一段时间，然后我们就初始化我们的

12123
08:32:44,600 --> 08:32:49,000
X和Y，我们接下来要处理的这两个（这里“两个”指代不明，需结合上下文明确所指） 

12124
08:32:46,600 --> 08:32:50,718
添加在那些随机的设备上

12125
08:32:49,000 --> 08:32:52,638
已初始化，呃，然后我们就有

12126
08:32:50,718 --> 08:32:54,120
下面有些基准测试相关的内容，别（怎样这里语义不完整）

12127
08:32:52,638 --> 08:32:56,440
担心这个，这只是为了……

12128
08:32:54,120 --> 08:32:58,760
测试并看看表现如何，哪一个…… 

12129
08:32:56,440 --> 08:33:00,920
我们 我们马上就会看到 嗯

12130
08:32:58,760 --> 08:33:02,680
但当我们实际进行相加时数值在上升

12131
08:33:00,920 --> 08:33:04,760
把它们放在一起 这就是当你……当你……

12132
08:33:02,680 --> 08:33:06,958
嗯，当你实际把它们相加的时候

12133
08:33:04,760 --> 08:33:08,360
你要把X和Y相加，它们是

12134
08:33:06,958 --> 08:33:10,920
张量，然后你要返回

12135
08:33:08,360 --> 08:33:14,520
一个张量，对吧，所以它只是 X 加 y

12136
08:33:10,920 --> 08:33:17,000
返回输出，就是这样，非常简单，嗯

12137
08:33:14,520 --> 08:33:19,120
这本质上，呃，是一种更简单的方式来……（原句不完整，此处根据文意推测添加省略号）

12138
08:33:17,000 --> 08:33:23,760
使用库达·马利克（Cuda Malik），所以不用库达（Cuda）了 

12139
08:33:19,120 --> 08:33:25,478
马利克和C语言，或者是C++，你是…… 

12140
08:33:23,760 --> 08:33:27,440
打算去……空的，就像这样，所以它是

12141
08:33:25,478 --> 08:33:29,718
将会和 X 有相同的形状，但是

12142
08:33:27,440 --> 08:33:31,558
它将被零填充，呃

12143
08:33:29,718 --> 08:33:33,798
我们进行一次断言，这样我们就能确保所有的

12144
08:33:31,558 --> 08:33:36,760
我们所有的张量都在……（原句似乎不完整）

12145
08:33:33,798 --> 08:33:39,360
设备 我们实际上将元素数量设置为

12146
08:33:36,760 --> 08:33:41,398
只需对输出的元素进行编号，那么该如何操作呢

12147
08:33:39,360 --> 08:33:45,360
很多 这个的长度是多少

12148
08:33:41,398 --> 08:33:48,798
数组，嗯，然后我们有这个奇怪的，呃

12149
08:33:45,360 --> 08:33:50,318
呃，关于我们如何……的配置

12150
08:33:48,798 --> 08:33:52,318
我们实际上是如何启动一个内核的，以及我们

注：原英文文本似乎不完整，这样的翻译是基于现有内容进行的。 

12151
08:33:50,318 --> 08:33:55,398
定义 就像 那个 那个 三维的 并且 并且

注：你提供的英文文本存在表述不太清晰和语法可能有误的情况，以上是按字面逐词翻译。 

12152
08:33:52,318 --> 08:33:57,440
网格大小以及所有那些东西，嗯，所以

12153
08:33:55,398 --> 08:33:58,798
我们这里有一个 Lambda 函数，对吧

12154
08:33:57,440 --> 08:34:01,000
顺便说一下，别太担心这个。

12155
08:33:58,798 --> 08:34:02,920
这个 这个 你在乎的不是性能

12156
08:34:01,000 --> 08:34:06,878
不像理解语法那样

12157
08:34:02,920 --> 08:34:08,878
在幕后运作，嗯，但这是一个

12158
08:34:06,878 --> 08:34:10,840
只是一个 Lambda 函数，并且在……里面

12159
08:34:08,878 --> 08:34:12,840
在这里，所有你需要担心的就是这些了（此句原英文表述不太符合常规语法，翻译尽量贴合表意）

12160
08:34:10,840 --> 08:34:16,360
问题在于我们正在设置上限

注：原句 “about is that” 表述有误，正确的可能是 “The problem is that” 之类的，这里按大致语义翻译。 

12161
08:34:12,840 --> 08:34:18,920
n个元素的划分，那么假设n

12162
08:34:16,360 --> 08:34:21,280
元素就像24，你有一个数组

12163
08:34:18,920 --> 08:34:22,718
1024个元素，而你想把它们相加

12164
08:34:21,280 --> 08:34:25,360
以块的形式组合在一起，以及你的块大小

12165
08:34:22,718 --> 08:34:28,280
是 256，所以你要做的是你会

12166
08:34:25,360 --> 08:34:33,000
将那 1024 分配到四个不同的块上

12167
08:34:28,280 --> 08:34:35,638
大小为 256，没错，但如果你有，比如说

12168
08:34:33,000 --> 08:34:37,280
1,25个元素，然后你要确保

12169
08:34:35,638 --> 08:34:38,760
你给它额外加了一块，这样

12170
08:34:37,280 --> 08:34:39,920
它也没有错过那个元素，对吧？

12171
08:34:38,760 --> 08:34:41,718
否则你不会得到正确的（结果/答案等，需结合上下文确定“right”指代的内容）

12172
08:34:39,920 --> 08:34:44,718
回答 所以你实际上得做一个

12173
08:34:41,718 --> 08:34:46,558
向上取整 嗯 所以它会向上舍入到

12174
08:34:44,718 --> 08:34:48,000
五个街区，而不是直接拐弯

12175
08:34:46,558 --> 08:34:50,160
回到四个，因为那样你就会

12176
08:34:48,000 --> 08:34:52,760
最后还是漏掉了那额外的一个，对吧，呃

12177
08:34:50,160 --> 08:34:55,200
所以这就是我们在这里所做的一切，嗯，还有

12178
08:34:52,760 --> 08:34:58,000
然后只是为了启动内核，你，我

12179
08:34:55,200 --> 08:35:00,318
知道是你喜欢这样 这样 这样 呃

12180
08:34:58,000 --> 08:35:02,478
这个函数，然后你用……进行索引

12181
08:35:00,318 --> 08:35:04,160
这个网格术语，然后你传入你的

12182
08:35:02,478 --> 08:35:07,238
在它之后的变量，就好像，嗯，那是……

12183
08:35:04,160 --> 08:35:10,318
有点奇怪，嗯，但别……别……别担心

12184
08:35:07,238 --> 08:35:13,238
关于这个说得太多了，所以我们就略过吧。 

12185
08:35:10,318 --> 08:35:15,920
像那样的网格，呃，那些类似的（东西）

12186
08:35:13,238 --> 08:35:18,280
那些像鳄鱼标志之类的 嗯 那是

12187
08:35:15,920 --> 08:35:20,238
这就是全部了
这就是你的核心内容

12188
08:35:18,280 --> 08:35:22,120
启动配置，然后你就有了

12189
08:35:20,238 --> 08:35:25,558
因此，实际参数本身

12190
08:35:22,120 --> 08:35:25,558
而不是去

12191
08:35:26,398 --> 08:35:28,840
我们只是

12192
08:35:45,840 --> 08:35:50,638
走吧，我们就那么做，非常……所以就是……就是这样

12193
08:35:48,878 --> 08:35:52,638
就像一个句法方面的东西

12194
08:35:50,638 --> 08:35:55,600
对；正确；是的；好吧

12195
08:35:52,638 --> 08:35:57,760
嗯，不管怎样，就是那样，就是那样

12196
08:35:55,600 --> 08:35:59,200
应该不会有太大问题，我……

12197
08:35:57,760 --> 08:36:01,360
我这么做并不是因为我们在乎

12198
08:35:59,200 --> 08:36:03,398
关于表现，而不是像……那样

12199
08:36:01,360 --> 08:36:06,200
搞什么鬼 搞什么鬼 所有这些

12200
08:36:03,398 --> 08:36:09,280
这语法到底是怎么回事，嗯，不过，对

12201
08:36:06,200 --> 08:36:13,040
那么，接下来讲讲实际的原理

12202
08:36:09,280 --> 08:36:16,840
一个内核内部的（表述似乎有误，可能想说“内核的”）以及比较那种类型

12203
08:36:13,040 --> 08:36:18,200
与 CUDA 并排，嗯，我们

12204
08:36:16,840 --> 08:36:20,760
我们有吗 我们有

12205
08:36:18,200 --> 08:36:22,920
X 我们 我们实际上得……我忘了

12206
08:36:20,760 --> 08:36:24,520
要说我们在……添加了这个特隆喷气式飞机装饰器

12207
08:36:22,920 --> 08:36:26,160
顶端说我们想要它到我们这里来

注：原文句子似乎不太符合常规语法逻辑，但已按照要求进行字面翻译。 

12208
08:36:24,520 --> 08:36:28,000
希望它能由特里登进行即时编译

12209
08:36:26,160 --> 08:36:28,920
如果你要留意那个古巴比索（注：CU可能是Cuban Peso的缩写，需结合具体语境确定准确含义）

注：原句似乎表述不太完整。 

12210
08:36:28,000 --> 08:36:31,520
别加这个，你会得到……（这里原文未完整表达“得到”的内容） 

12211
08:36:28,920 --> 08:36:33,238
错误 嗯 但对于所有不同的…… 

12212
08:36:31,520 --> 08:36:35,080
变量，你知道有X和Y

12213
08:36:33,238 --> 08:36:37,878
你的输出，你的标称元素，然后

12214
08:36:35,080 --> 08:36:40,680
块大小，嗯，你知道的

12215
08:36:37,878 --> 08:36:42,440
进入这里，XY 输出，输出元素

12216
08:36:40,680 --> 08:36:45,958
以及元素块

12217
08:36:42,440 --> 08:36:48,318
现在，我们将这些作为指针

注：原英文句子“size now we have these as pointers”可能存在表述不太准确的情况，“size”在此处似乎和句子整体逻辑不连贯，若有上下文或许能更精准翻译。 

12218
08:36:45,958 --> 08:36:51,440
因为在记忆里它将会是它就是

12219
08:36:48,318 --> 08:36:54,600
将会被布置成第一个

12220
08:36:51,440 --> 08:36:56,680
那个数组中的元素将会或者

12221
08:36:54,600 --> 08:36:58,558
本质上，这个“this”指针正在

12222
08:36:56,680 --> 08:37:00,040
成为那个数组中的第一个元素，所以

12223
08:36:58,558 --> 08:37:02,318
你想从 你想

注：原英文文本表述不太完整和清晰，这样的翻译可能不太符合正常语义逻辑，但是按照原文逐字逐句的翻译。 

12224
08:37:00,040 --> 08:37:04,318
以整个事情的开端为基础

12225
08:37:02,318 --> 08:37:05,840
张量或数组，并且你想继续

12226
08:37:04,318 --> 08:37:07,680
从那里开始，没错，所以这就是海卫一的情况。

12227
08:37:05,840 --> 08:37:11,798
打算去解读那个，呃，然后你

12228
08:37:07,680 --> 08:37:14,160
对呃……y输出指针也做同样的操作，嗯

12229
08:37:11,798 --> 08:37:17,440
然后我们就继续下去

12230
08:37:14,160 --> 08:37:21,718
那么，稍微往下看，我们会发现

12231
08:37:17,440 --> 08:37:24,200
呃，p 并且所以 P 本质上是在说哪个

12232
08:37:21,718 --> 08:37:29,440
我们要在网格的右边添加哪个方块呢

12233
08:37:24,200 --> 08:37:32,638
嗯，现在我们得小心处理这个问题。

12234
08:37:29,440 --> 08:37:34,558
所以，一种思考哪个（事物）的好方法是…… （这里原英文表述不完整） 

12235
08:37:32,638 --> 08:37:36,520
我们所在的网格区域实际上是要……（注：原英文句子似乎不完整） 

12236
08:37:34,558 --> 08:37:39,280
到这里来，看看这是怎么回事。 

12237
08:37:36,520 --> 08:37:42,360
马上应用，所以当我们实际处于……时

12238
08:37:39,280 --> 08:37:46,160
这个数组，嗯，假设块大小是 64

12239
08:37:42,360 --> 08:37:49,120
并且这个数组中有256个元素

12240
08:37:46,160 --> 08:37:50,760
嗯，你不想就直接说零，还是……

12241
08:37:49,120 --> 08:37:52,478
一两个，因为那些将会是

12242
08:37:50,760 --> 08:37:54,440
单个元素，就在我们……的时候

12243
08:37:52,478 --> 08:37:56,478
看看实际数据，因为记住

12244
08:37:54,440 --> 08:37:59,878
这就是我们实际对数据进行索引的方式

12245
08:37:56,478 --> 08:38:02,040
我们想确保，呃，我们……

12246
08:37:59,878 --> 08:38:03,878
记住这个块长度，CU

12247
08:38:02,040 --> 08:38:06,120
块大小很大，对吧，所以我们要开始了

12248
08:38:03,878 --> 08:38:09,798
推进；前进；发展；促进

12249
08:38:06,120 --> 08:38:11,558
嗯，块大小乘以块的数量

12250
08:38:09,798 --> 08:38:13,760
然后这些偏移量实际上是什么呢

12251
08:38:11,558 --> 08:38:16,040
重要的是，这就好像不管那是什么

12252
08:38:13,760 --> 08:38:20,398
数字是，然后我们要去……

12253
08:38:16,040 --> 08:38:24,878
安排02区块的另一项事务

12254
08:38:20,398 --> 08:38:26,600
大小，所以比如说从 64 到 128，你是……

12255
08:38:24,878 --> 08:38:28,878
要开始，开始这个街区，开始是

12256
08:38:26,600 --> 08:38:32,238
就要64岁了，然后我们打算

12257
08:38:28,878 --> 08:38:35,440
安排一堆不同的呃指标

12258
08:38:32,238 --> 08:38:38,360
在64呃，这实际上仅仅是……

12259
08:38:35,440 --> 08:38:41,840
将是一个从 1 到 64 的数组 

12260
08:38:38,360 --> 08:38:43,318
到右边 128 （单位，此处结合语境可能是距离、数值等），呃，那将会……

12261
08:38:41,840 --> 08:38:45,318
这就是我们将如何对数据进行索引的方式。

12262
08:38:43,318 --> 08:38:47,200
所以我们使用特里同语言。范围为零

12263
08:38:45,318 --> 08:38:48,520
到块大小，那就是它的含义

12264
08:38:47,200 --> 08:38:50,718
然后我们只需添加任何模块

12265
08:38:48,520 --> 08:38:52,478
开始就是那样，所以希望是那种类型

12266
08:38:50,718 --> 08:38:54,878
现在在你脑子里好像说得通了

12267
08:38:52,478 --> 08:38:57,238
跳回到P这里，你可能想

12268
08:38:54,878 --> 08:38:59,558
注意，所以要注意这个术语

12269
08:38:57,238 --> 08:39:02,200
在这里我们有轴，而构建器没有

12270
08:38:59,558 --> 08:39:08,718
担心这个
只担心轴心（这里“axis”根据语境可能有不同含义，需结合具体场景确定准确释义）

12271
08:39:02,200 --> 08:39:13,280
所以轴就像是，呃，块索引（block idx）之类的，对吧

12272
08:39:08,718 --> 08:39:17,558
嗯，像 X 这样的块和……是一样的

12273
08:39:13,280 --> 08:39:20,840
轴零，呃，块索引 Y 是一样的

12274
08:39:17,558 --> 08:39:23,520
以其一轴，且 Z 等于三

12275
08:39:20,840 --> 08:39:26,000
对，所以我们必须牢记这一点。

12276
08:39:23,520 --> 08:39:28,840
当我们书写的时候，更像是你知道的二维书写方式 

12277
08:39:26,000 --> 08:39:31,718
你知道3D空间呃内核，然后我们

12278
08:39:28,840 --> 08:39:33,680
所以必须牢记这个访问条款

12279
08:39:31,718 --> 08:39:34,718
幸运的是，现在这非常简单。

12280
08:39:33,680 --> 08:39:36,558
但这是我们将要去做的事情

12281
08:39:34,718 --> 08:39:39,280
如果你要结束的话，想记住这一点

注：原英文句子表述不太符合常规语法，可能存在信息缺失或表述有误的情况，此翻译是基于现有内容尽量通顺地译出。 

12282
08:39:36,558 --> 08:39:41,080
向上写，呃，这是你想要的东西

12283
08:39:39,280 --> 08:39:45,360
如果你最终要写的话，要记住啊

12284
08:39:41,080 --> 08:39:47,718
你对 2D、3D 方面的东西了解得越多，嗯，现在要开始了

12285
08:39:45,360 --> 08:39:51,360
往下一点，嗯，我们有这个面具。

12286
08:39:47,718 --> 08:39:54,680
术语，所以“mask”等于

12287
08:39:51,360 --> 08:39:57,958
偏移掩码等于任意布尔值

12288
08:39:54,680 --> 08:40:01,040
呃，我猜……那个……布尔输出的（此处原句未完整表达意思）

12289
08:39:57,958 --> 08:40:04,638
不管呃，如果偏移量小于

12290
08:40:01,040 --> 08:40:08,478
元素数量，那么从本质上来说这……

12291
08:40:04,638 --> 08:40:11,840
我们有这些偏移量，它们是

12292
08:40:08,478 --> 08:40:14,280
实际数组本身中的索引

12293
08:40:11,840 --> 08:40:16,558
所以输入和输出，点输入

12294
08:40:14,280 --> 08:40:18,318
抱歉，不管是 X 指针还是 Y 指针

12295
08:40:16,558 --> 08:40:20,878
我们在那些里所处的索引，我们想要……（此英文表述不太完整或准确，这样的翻译仅供参考） 

12296
08:40:18,318 --> 08:40:22,120
确保那些不要超过，呃

12297
08:40:20,878 --> 08:40:25,558
我们不……我们想确保那些

12298
08:40:22,120 --> 08:40:27,000
不要做不等于，或者呃，传递数字 

12299
08:40:25,558 --> 08:40:29,558
元素，没错，它接下来会变为零

12300
08:40:27,000 --> 08:40:31,878
到元素数量减一，所以我们想要

12301
08:40:29,558 --> 08:40:34,120
确保我们把所有东西都遮挡好

12302
08:40:31,878 --> 08:40:36,398
那是元素数量，或者在那个点之后

12303
08:40:34,120 --> 08:40:38,718
没错，这就是它的意义所在，所以口罩是……

12304
08:40:36,398 --> 08:40:41,160
本质上会是一个数组

12305
08:40:38,718 --> 08:40:43,398
它打算做，呃，就像它……

12306
08:40:41,160 --> 08:40:44,840
基本上打算呃说你知道的，我们

12307
08:40:43,398 --> 08:40:47,318
我们有所有这些偏移量，我们有这个

12308
08:40:44,840 --> 08:40:51,318
内存里有个巨大的数组，而且我们正在……

12309
08:40:47,318 --> 08:40:56,398
去看看呃，要是我们有个你（这种情况）会怎样 

12310
08:40:51,318 --> 08:40:58,440
知道 64 65 67 122 无论我们想（表达）的是什么

12311
08:40:56,398 --> 08:41:01,160
确保那些数字更小

12312
08:40:58,440 --> 08:41:02,680
而不是一堆麻木的元素，对吧，嗯，所以我们想要

12313
08:41:01,160 --> 08:41:04,200
从本质上来说，只是要确保 

12314
08:41:02,680 --> 08:41:06,360
我们无法获取某个东西，那个东西是……（这里原英文句子不完整）

12315
08:41:04,200 --> 08:41:08,160
在呃我们的数据结构之外于……

注：原英文文本表述似乎不完整，此翻译仅按照字面内容进行。 

12316
08:41:06,360 --> 08:41:10,958
记忆，我们拥有这片我们所渴望的完整空间

12317
08:41:08,160 --> 08:41:13,360
将其遮罩到这一部分

12318
08:41:10,958 --> 08:41:15,920
没错，这就是它的作用，所以我们

12319
08:41:13,360 --> 08:41:17,840
得到一个新的数组，它是掩码，并且就是这样

12320
08:41:15,920 --> 08:41:20,360
仅仅是一堆，实际上仅仅是一堆

12321
08:41:17,840 --> 08:41:21,760
由 1 和 0 组成的，嗯，还有这个这个

12322
08:41:20,360 --> 08:41:25,440
表现方式与这个“if”相同

12323
08:41:21,760 --> 08:41:28,040
语句在加法运算内部的操作情况

（注：此句英文表意不太清晰，翻译可能不是特别精准贴合原意） 

12324
08:41:25,440 --> 08:41:32,080
向量版内核在CUDA中完全一样

12325
08:41:28,040 --> 08:41:35,600
想法，嗯，现在再往深了说，嗯，我们

12326
08:41:32,080 --> 08:41:38,958
实际上要将这些高效地加载到一个……

12327
08:41:35,600 --> 08:41:41,718
共享内存，所以不要

12328
08:41:38,958 --> 08:41:43,920
嗯，别担心它实际上是怎样的

12329
08:41:41,718 --> 08:41:45,398
特里同（Triton）如何处理数据，你知道的

注：这里的“Triton”可根据具体语境进行更合适的专有名词翻译，常见的如“特里同”（希腊神话中的海神）、“海卫一”等。 

12330
08:41:43,920 --> 08:41:46,958
传输数据，那是一个……那是一个

12331
08:41:45,398 --> 08:41:49,238
优化，这方面已经处理好了，针对…… 

12332
08:41:46,958 --> 08:41:52,398
所以你就假定这些东西要…… 

12333
08:41:49,238 --> 08:41:56,398
要加载，嗯，就从……开始

12334
08:41:52,398 --> 08:42:00,160
就像X的开头一直到……

12335
08:41:56,398 --> 08:42:02,638
嗯，直到最后，所以它将会

12336
08:42:00,160 --> 08:42:04,238
本质上只是每一个点 每一个

12337
08:42:02,638 --> 08:42:05,760
内存中的某个点，它会逐个逐个地……

注：原文可能表述不太完整或存在一些语病，以上是尽量通顺的翻译。 

12338
08:42:04,238 --> 08:42:08,200
内存中的数据点，它将会加载

12339
08:42:05,760 --> 08:42:10,080
那些在里面，而且它打算做个面膜，并且……（此英文表述不太符合常规语法逻辑，翻译可能会有表意不精准的情况） 

12340
08:42:08,200 --> 08:42:12,000
它会问我们是否真的想……

12341
08:42:10,080 --> 08:42:14,160
计算这些值还是不计算，这就是问题所在（注：原句表述似乎不太完整准确，更完整可能类似 “To compute these values or not, that's what the question is” 这种，这里按字面直接翻译）

12342
08:42:12,000 --> 08:42:16,238
无论它处于哪个点，它都在这样做。

12343
08:42:14,160 --> 08:42:17,760
从一直到所有的……开始

注：原文“starts at all the way up to all the”表述不太符合常规英语表达习惯，翻译时尽量贴合字面意思呈现。 

12344
08:42:16,238 --> 08:42:19,398
不同的偏移量，所以情况是这样的

12345
08:42:17,760 --> 08:42:21,878
指向，然后它就被复制了，然后就全部搞定了 

12346
08:42:19,398 --> 08:42:23,840
不同的偏移量，嗯，然后你

12347
08:42:21,878 --> 08:42:25,558
也对那些（事物）应用一个蒙版来…… 

12348
08:42:23,840 --> 08:42:27,718
说，我们想要哪些呢

12349
08:42:25,558 --> 08:42:30,200
计算 所以如果这些算是额外的

12350
08:42:27,718 --> 08:42:31,760
就像计算这一部分，嗯，那个

12351
08:42:30,200 --> 08:42:33,040
这就是……这就是这堆东西是什么

12352
08:42:31,760 --> 08:42:37,120
要去做，而且将会

12353
08:42:33,040 --> 08:42:39,680
高效地将这个加载到呃共享区里

12354
08:42:37,120 --> 08:42:42,160
内存，所以……在……上的高速内存

12355
08:42:39,680 --> 08:42:44,160
GPU，就是实际那个，呃，用于直播的GPU

12356
08:42:42,160 --> 08:42:46,360
多处理器，那就是……那就是……

12357
08:42:44,160 --> 08:42:49,760
这正在为你处理的事情以及

12358
08:42:46,360 --> 08:42:53,718
然后我们对 y 做完全相同的事情

12359
08:42:49,760 --> 08:42:55,558
现在尝试逐块地实现这些（内容）。

12360
08:42:53,718 --> 08:42:57,760
高效地执行操作，这样你就不会

12361
08:42:55,558 --> 08:43:00,080
实际上需要做任何高级的事情

12362
08:42:57,760 --> 08:43:03,440
你实际上就只是，呃，把这些东西装上了。

12363
08:43:00,080 --> 08:43:05,680
加载到静态随机存取存储器（SRAM）上，然后它会进行一个呃 逐元素的操作

12364
08:43:03,440 --> 08:43:08,680
此外，所以它会……它会逐个进行

12365
08:43:05,680 --> 08:43:10,440
一，然后把它们加起来，留意一下如何…… 

12366
08:43:08,680 --> 08:43:12,760
这是蓝色而不是红色，这意味着

12367
08:43:10,440 --> 08:43:15,718
就好像它由呃……特隆来照料一样

12368
08:43:12,760 --> 08:43:19,080
所以，嗯，那实际上就是你……的方式

12369
08:43:15,718 --> 08:43:21,798
计算输出值 um，然后我们只需

12370
08:43:19,080 --> 08:43:23,798
再把这个和另一个，嗯，一起放回去

12371
08:43:21,798 --> 08:43:25,760
你知道，再加上另一份数据
再加上另一份数据 

12372
08:43:23,798 --> 08:43:27,718
转移操作

12373
08:43:25,760 --> 08:43:30,440
找到，所以那将仅仅是那个

12374
08:43:27,718 --> 08:43:32,878
和这里的想法一样，所以呃，开始……

12375
08:43:30,440 --> 08:43:35,680
在内存中的位置加上你知道的偏移量

12376
08:43:32,878 --> 08:43:37,718
对于那个的所有偏移索引

12377
08:43:35,680 --> 08:43:40,238
街区；障碍物；大块；阻挡；堵塞；阻止；限制；阻碍；一批；一大片；（时间）段；大楼；大厦；（儿童玩的）积木；滑轮；滑轮组；股票交易单位；（尤指一地区的）一大片建筑群；一组；一批货物；一组数据；（字母的）大写体；版画；印版；砧板；断头台的垫头；滑轮装置；滑轮组；（铁路）区段；（戏院、电影院等的）成排座位；（火箭发动机的）试验台；使成块状；用木片或石块等支撑；使交通堵塞；用模子使（帽子等）成形；把（蔬菜等）切成方块

12378
08:43:37,718 --> 08:43:43,318
嗯，输出本身，所以我们打算

12379
08:43:40,238 --> 08:43:46,600
只需存储输出结果

12380
08:43:43,318 --> 08:43:49,200
嗯，然后像我们之前那样戴上这个面罩。

12381
08:43:46,600 --> 08:43:51,920
在这里，这就是三内核的工作原理。

12382
08:43:49,200 --> 08:43:53,600
所以希望这能讲得通，随意（做你想做的事） 

12383
08:43:51,920 --> 08:43:56,238
如果他们没看明白的话就重新观看某些部分

12384
08:43:53,600 --> 08:43:57,398
完全地，你知道，在你脑子里灵光一闪，呃

12385
08:43:56,238 --> 08:44:01,520
但现在我们实际上要跳了

12386
08:43:57,398 --> 08:44:04,238
进入呃Softmax三叉戟函数

12387
08:44:01,520 --> 08:44:05,840
好的，那么现在我们来探讨一下 softmax 以及

12388
08:44:04,238 --> 08:44:07,398
而不是直接一头扎进代码里

12389
08:44:05,840 --> 08:44:09,920
我打算像用手操作那样做个手册。

12390
08:44:07,398 --> 08:44:11,600
用这个举例

12391
08:44:09,920 --> 08:44:13,318
嗯

12392
08:44:11,600 --> 08:44:17,238
那么让（这里原文不完整，语义不太明确，完整表述可能是“那么让……” ）

12393
08:44:13,318 --> 08:44:18,958
我马上删掉那个 嗯 基本上

12394
08:44:17,238 --> 08:44:20,638
我们在这里要做的是，我有一个 C 文件

12395
08:44:18,958 --> 08:44:23,958
我们只是用 C 语言来做这件事，以便理解。

12396
08:44:20,638 --> 08:44:26,798
从直观上来说它在做什么呢，嗯，我们有

12397
08:44:23,958 --> 08:44:31,798
一个包含从 1 到 3 的浮点数的数组，所以它…… 

12398
08:44:26,798 --> 08:44:31,798
实际上就长这样，嗯

12399
08:44:31,878 --> 08:44:37,558
某某就是那样，所以我们打算……

12400
08:44:34,280 --> 08:44:37,558
计算……的soft Max

注：“soft Max”通常是“softmax”，是机器学习领域常用术语，可直译为“软最大值” ，在中文里一般也直接用英文表述。 

12401
08:44:42,760 --> 08:44:45,760
X

由于 “X” 本身可能代表很多含义，在没有更多上下文的情况下，一般就直接保留 “X”，或根据常见情况简单翻译为 “未知数”“未知项”“X元素” 等，这里仅按原文保留呈现。 

12402
08:44:46,238 --> 08:44:53,638
嗯，所以通常的情况是，如果我们

12403
08:44:49,798 --> 08:44:57,200
在，呃，在……上面搜索这个

12404
08:44:53,638 --> 08:44:59,478
谷歌软最大激活函数它

12405
08:44:57,200 --> 08:45:01,798
看起来是这样的，没错，所以你有这个

12406
08:44:59,478 --> 08:45:04,920
对这个输入进行幂运算，这样你就得到一个

12407
08:45:01,798 --> 08:45:07,478
输入向量 um，还有这个这个这个

12408
08:45:04,920 --> 08:45:09,718
符号是一个softmax函数，然后你继续

12409
08:45:07,478 --> 08:45:11,120
在每一个上面，呃，然后你

12410
08:45:09,718 --> 08:45:13,798
本质上是看看每个有多少

12411
08:45:11,120 --> 08:45:16,280
指数化的值对……有贡献

12412
08:45:13,798 --> 08:45:19,200
呃，所有这些的总和

12413
08:45:16,280 --> 08:45:24,120
指数 所有取指数后的值

12414
08:45:19,200 --> 08:45:27,638
对，所以如果我们这么做，如果我们在这里打开，呃，如果

12415
08:45:24,120 --> 08:45:27,638
我刚刚打开 我

12416
08:45:28,360 --> 08:45:35,558
Python，如果我们导入`math`模块，然后假设我们

12417
08:45:31,920 --> 08:45:38,040
求……的数学指数函数值（这里“of”后面缺少内容，“math.exp”一般指数学里的指数函数） 

12418
08:45:35,558 --> 08:45:39,558
1.0 我们将会得到 2.71，因为

12419
08:45:38,040 --> 08:45:43,920
那就是 e，对吧，它将会是……

12420
08:45:39,558 --> 08:45:46,718
e 的 1 次方 嗯，所以我们的第一个

12421
08:45:43,920 --> 08:45:48,638
值将会是

12422
08:45:46,718 --> 08:45:52,238
呃

12423
08:45:48,638 --> 08:45:57,238
2.71，然后是第二个

12424
08:45:52,238 --> 08:45:57,238
一个会变成两个，所以是 7 ，这么说

12425
08:45:58,200 --> 08:46:05,760
7.39，然后是第三个数字，呃

12426
08:46:01,520 --> 08:46:05,760
三将会是20.1

12427
08:46:08,600 --> 08:46:14,760
大致来说，现在我们把这些 Aₗ 加起来。

12428
08:46:15,840 --> 08:46:22,558
所以它在试图为我自动补全

12429
08:46:19,200 --> 08:46:26,478
2.71 +

12430
08:46:22,558 --> 08:46:30,520
7.39 + 20.10，然后我们得到

12431
08:46:26,478 --> 08:46:32,638
目前是30.2，为了得到…… 

12432
08:46:30,520 --> 08:46:34,200
实际的softmax输出，我们可以看到有多少

12433
08:46:32,638 --> 08:46:36,520
这些中的每一个 这些中的每一个

12434
08:46:34,200 --> 08:46:39,360
指数化的值对……有贡献（由于文本不完整，这里“对……有贡献”的“……”具体内容缺失）

12435
08:46:36,520 --> 08:46:40,958
它们所有数的指数和，嗯，好吧

12436
08:46:39,360 --> 08:46:42,520
不是指数和，而是当你

12437
08:46:40,958 --> 08:46:46,120
对它们全部进行取幂运算，你要取 

12438
08:46:42,520 --> 08:46:47,440
那些数值的总和，是 32.2 或者 30.2，并且

12439
08:46:46,120 --> 08:46:50,600
然后你看看每个有多少

12440
08:46:47,440 --> 08:46:57,280
因此做出贡献

12441
08:46:50,600 --> 08:47:01,120
2.71 除以 30.2，那么大约是 9%，大致如此

12442
08:46:57,280 --> 08:47:03,120
我们打算去，嗯

12443
08:47:01,120 --> 08:47:06,798
0.09

12444
08:47:03,120 --> 08:47:10,478
嗯，然后我们走

12445
08:47:06,798 --> 08:47:10,478
7.39 是

12446
08:47:10,920 --> 08:47:17,600
0.24，然后最后一个会是

12447
08:47:13,520 --> 08:47:21,238
67 如果我们去做这件事

12448
08:47:17,600 --> 08:47:22,958
呃，如果你四舍五入的话就是 67，所以你有

12449
08:47:21,238 --> 08:47:29,398
没错，然后如果我们把这些都加起来

12450
08:47:22,958 --> 08:47:32,958
把这些数字加起来 0.009 + 0.24 +

12451
08:47:29,398 --> 08:47:35,440
0.67 你得到 1.0 是正确的，并且这些全都是

12452
08:47:32,958 --> 08:47:38,160
当然是四舍五入啦，嗯，但是，但是，那个

12453
08:47:35,440 --> 08:47:39,760
这里的要点是，这是softmax注意事项

12454
08:47:38,160 --> 08:47:41,798
我们最初是如何有了这个（东西、想法等，需结合语境确定） 

12455
08:47:39,760 --> 08:47:44,000
这里进行分发，然后我们去了一个

12456
08:47:41,798 --> 08:47:46,958
新的那个，某种程度上刚刚制作出来的

12457
08:47:44,000 --> 08:47:49,680
所有的一切加起来等于一，呃，然后给了它

12458
08:47:46,958 --> 08:47:52,478
稍微给它增加了一点分量

12459
08:47:49,680 --> 08:47:55,440
到右边三个，所以注意一下就像一个……

12460
08:47:52,478 --> 08:47:59,040
就像三是那个数的三倍

12461
08:47:55,440 --> 08:48:04,760
1.0 嗯，那个

12462
08:47:59,040 --> 08:48:06,478
6.67 远远超过 0.09 的 3 倍，所以

12463
08:48:04,760 --> 08:48:07,958
你多少有些额外的等待要经历（这里原句表意不太完整清晰，只能大致按字面翻译）

12464
08:48:06,478 --> 08:48:10,600
更大的值，对吧，而那就是……

12465
08:48:07,958 --> 08:48:12,238
softmax函数嘛，嗯，它会……

12466
08:48:10,600 --> 08:48:14,840
本质上就是要找到最大的那个（东西）

注：这里“biggest”后缺少具体所指内容，句子翻译只能根据已有英文大致表达其意思。 

12467
08:48:12,238 --> 08:48:16,638
数字，还有，嗯，非常重视

12468
08:48:14,840 --> 08:48:20,478
它 或者 突出显示它 那个

12469
08:48:16,638 --> 08:48:23,280
大多数，嗯，但这存在一个缺陷。

12470
08:48:20,478 --> 08:48:26,040
方法，我要解释一下这个。

12471
08:48:23,280 --> 08:48:30,878
现在，所以从本质上来说，这里存在的问题是

12472
08:48:26,040 --> 08:48:33,318
是，如果你有，比如说，嗯，如果你有

12473
08:48:30,878 --> 08:48:36,200
正如所说的X（这里原文表述不太符合常见英语表达习惯，推测可能是想说“As X says”之类的）

12474
08:48:33,318 --> 08:48:37,798
1

12475
08:48:36,200 --> 08:48:39,718
一千

12476
08:48:37,798 --> 08:48:42,718
零

12477
08:48:39,718 --> 08:48:42,718
和；并且；而且；那么；就；然后；接着；又

12478
08:48:44,200 --> 08:48:50,878
呃，负1000，所以其中一些

12479
08:48:48,680 --> 08:48:52,638
这些的总和是零，对吧，你有

12480
08:48:50,878 --> 08:48:55,360
你对此有意见，而且……

12481
08:48:52,638 --> 08:48:58,840
从本质上讲，这意味着这正在进行 

12482
08:48:55,360 --> 08:49:01,958
嗯，这将起到很大的作用

12483
08:48:58,840 --> 08:49:04,798
这的一部分，或者至少应该是这样

12484
08:49:01,958 --> 08:49:06,398
它应该把所有的都贡献出来。

12485
08:49:04,798 --> 08:49:09,040
嗯，但这不会发生，因为你

12486
08:49:06,398 --> 08:49:11,760
无法做出贡献，就好像就是做不到一样

12487
08:49:09,040 --> 08:49:13,280
有道理，你怎么能像这样做出贡献呢

12488
08:49:11,760 --> 08:49:14,958
什么 一个……占比多少（这里“a th”表述不完整，可能有信息缺失）

12489
08:49:13,280 --> 08:49:17,718
为归零做贡献
这就像无穷大一样

12490
08:49:14,958 --> 08:49:22,440
好的，所以如果你最终要对……进行softmax操作

12491
08:49:17,718 --> 08:49:25,958
这个，嗯，就好比就算你试着去算一算。

12492
08:49:22,440 --> 08:49:27,920
1000的指数运算，你会用到数学知识

12493
08:49:25,958 --> 08:49:29,680
溢出错误
数学范围错误

12494
08:49:27,920 --> 08:49:31,238
因为这个数字实在太大了

12495
08:49:29,680 --> 08:49:34,798
对；正确；好的；行

12496
08:49:31,238 --> 08:49:37,920
所以你实际上能做的是，你可以

12497
08:49:34,798 --> 08:49:40,440
用所有这些中的最大值进行相减

12498
08:49:37,920 --> 08:49:44,360
没错，所以我们可以看到

12499
08:49:40,440 --> 08:49:46,160
嗯，什么是最大值，呃，什么是…… 

12500
08:49:44,360 --> 08:49:49,040
这里的最大数量，所以是最大的那个

12501
08:49:46,160 --> 08:49:51,798
是一个 th ，所以我们能做的是我们可以

12502
08:49:49,040 --> 08:49:55,160
用每个数字减去那个值，这样我们

12503
08:49:51,798 --> 08:49:57,238
行，我们可以说 x，我们就说像 X2 这样的

12504
08:49:55,160 --> 08:49:58,920
等于；等同于；比得上

12505
08:49:57,238 --> 08:50:04,520
嗯

12506
08:49:58,920 --> 08:50:07,920
0，然后是0 - 1000

12507
08:50:04,520 --> 08:50:13,120
是th000，然后1.00减去th000等于

12508
08:50:07,920 --> 08:50:13,120
2000 没错，所以如果我们继续

12509
08:50:15,478 --> 08:50:22,238
嗯，我们对……取指数函数（注：math.exp一般指数学中的指数函数操作）

12510
08:50:22,638 --> 08:50:29,318
零通知 我们只得到这么个情况

12511
08:50:25,520 --> 08:50:31,200
1000 的数学指数函数（exp）运算结果将为我们得出

12512
08:50:29,318 --> 08:50:32,600
嗯，非常接近零了，但还不完全是。

12513
08:50:31,200 --> 08:50:34,200
将会是零，但它将会是

12514
08:50:32,600 --> 08:50:37,200
非常非常，这将会是非常小的一个（东西） 

12515
08:50:34,200 --> 08:50:38,760
数字没错，然后当然，情况相同

12516
08:50:37,200 --> 08:50:40,760
2000这个数值所对应的事物仅仅会是那个

12517
08:50:38,760 --> 08:50:43,280
同样的，没错，它会非常小。

12518
08:50:40,760 --> 08:50:45,680
所以你注意到，如果我们……如果我们……

12519
08:50:43,280 --> 08:50:48,120
最初只是，如果我们只做这一件事

12520
08:50:45,680 --> 08:50:51,398
通常情况下，使用这些大数字会

12521
08:50:48,120 --> 08:50:55,080
实际上给我们带来了错误，所以我们可以

12522
08:50:51,398 --> 08:50:56,840
尽可能减去我们所能减去的最大值，我们可以，嗯

12523
08:50:55,080 --> 08:50:58,280
你知道按点减去最大值

12524
08:50:56,840 --> 08:51:00,080
数字，然后我们得到了某个东西，它…… （注：原英文句子不完整，此为结合前文可能情况补充的表述方式）

若你提供完整内容，我会为你准确翻译。当前仅就这部分翻译为：
数字，然后我们得到了某个东西

按照格式严格呈现为：
数字，然后我们得到了某个东西
然后（若句子后续还有内容可接着对应翻译下去） 

12525
08:50:58,280 --> 08:51:01,760
更有意义，所以你知道零

12526
08:51:00,080 --> 08:51:05,160
对这一切都有贡献，因为那是

12527
08:51:01,760 --> 08:51:08,160
那是什么，那就是总和

不过原英文表述 “what the that's what the the sum” 存在语法错误，可能影响了准确表意。规范一些也许是 “That's what the sum is” ，准确意思会是 “那就是总和” 。上述翻译是按照原文语序和格式进行的。 

12528
08:51:05,160 --> 08:51:10,558
于是，这就是我们实际遵循的方式。

12529
08:51:08,160 --> 08:51:12,638
通过用C语言实现softmax函数，所以

12530
08:51:10,558 --> 08:51:15,160
我们这里有三个独立的 for 循环。

12531
08:51:12,638 --> 08:51:17,558
第一个在……中找到最大值（原文句子不完整）

12532
08:51:15,160 --> 08:51:19,840
数组，所以我们只需设置初始最大值

12533
08:51:17,558 --> 08:51:22,120
将第一个数设为值，然后我们

12534
08:51:19,840 --> 08:51:23,398
从这个，呃，从……开始进行迭代

12535
08:51:22,120 --> 08:51:24,680
下一个我们不想从其开始的数字

12536
08:51:23,398 --> 08:51:26,080
首先，我们不想从……开始

12537
08:51:24,680 --> 08:51:27,398
第一个我们开始了，接着是它后面的那个

12538
08:51:26,080 --> 08:51:29,680
因为我们已经，我们已经知道这是什么了

12539
08:51:27,398 --> 08:51:31,958
一个是，嗯，而且实际上我们只是

12540
08:51:29,680 --> 08:51:34,878
比较一下，如果新的那个比……大的话

12541
08:51:31,958 --> 08:51:36,798
我们把最大值设为那个，嗯

12542
08:51:34,878 --> 08:51:39,558
然后我们得到了这个最大项

12543
08:51:36,798 --> 08:51:42,200
你知道的，这和我们在这里所做的一样

12544
08:51:39,558 --> 08:51:45,200
然后我们有这个，我们有…… 

12545
08:51:42,200 --> 08:51:49,318
累加和，所以我们要遍历 

12546
08:51:45,200 --> 08:51:52,760
数组的长度，然后我们来做那件事

12547
08:51:49,318 --> 08:51:55,120
索引减去最大值，然后我们……

12548
08:51:52,760 --> 08:51:57,318
把那个总数加到这个总和上，对吧，我们，我们

12549
08:51:55,120 --> 08:51:58,920
把不管这是什么的东西加到总和里，这样一来

12550
08:51:57,318 --> 08:52:02,080
我们可以，你知道的，把所有这些都积累起来，并且

12551
08:51:58,920 --> 08:52:05,120
然后我们就写出来

12552
08:52:02,080 --> 08:52:06,440
嗯，我们只是把相同的值写出来，我们

12553
08:52:05,120 --> 08:52:09,000
本质上，我们只是获取输入，然后

12554
08:52:06,440 --> 08:52:12,040
然后一个一个地替换它，呃，然后我们设置

12555
08:52:09,000 --> 08:52:14,798
把它变成，呃，无论那个取了指数之后的数

12556
08:52:12,040 --> 08:52:19,000
价值是，呃

12557
08:52:14,798 --> 08:52:21,360
呃，不是减去，抱歉，应该说我们……

12558
08:52:19,000 --> 08:52:23,558
有那个指数化的值，我们

12559
08:52:21,360 --> 08:52:24,958
用那个除以总和，呃，非常简单，我

12560
08:52:23,558 --> 08:52:27,160
可能本可以用……来解释那件事 （原文“in in”表述有误，这里按正确理解来整体翻译，原错误表述保留）

12561
08:52:24,958 --> 08:52:29,160
时间稍微短了点，但我只想要你

12562
08:52:27,160 --> 08:52:30,318
为了获得关于那方面的直觉

12563
08:52:29,160 --> 08:52:32,878
你可能已经编写好软件了。

12564
08:52:30,318 --> 08:52:34,920
马克斯和皮（这里可能是特定人名，需结合上下文），火炬（torch可能在编程语境指PyTorch库）和NumPy（Python科学计算库），我明白了，呃

12565
08:52:32,878 --> 08:52:36,878
但只是为了进行那种回顾

12566
08:52:34,920 --> 08:52:39,200
至于它在底层是如何运作的，以及

12567
08:52:36,878 --> 08:52:42,000
这个，呃，你知道的，数值稳定性

12568
08:52:39,200 --> 08:52:46,398
附加组件，我们有，嗯，所以

12569
08:52:42,000 --> 08:52:49,638
现在我在呃 CUDA 方面也有一个例子

12570
08:52:46,398 --> 08:52:53,200
所以我不打算详细讲这个，嗯，但是

12571
08:52:49,638 --> 08:52:55,238
这里的想法是，呃，在CUDA里的意思是，是的，你

12572
08:52:53,200 --> 08:52:57,040
你本可以做的

12573
08:52:55,238 --> 08:53:00,160
嗯，你可以回顾一下，你知道的，（关于）长度这方面

12574
08:52:57,040 --> 08:53:01,360
一个单一数组的，但在深度学习中

12575
08:53:00,160 --> 08:53:02,680
你实际上并不打算那么做。

12576
08:53:01,360 --> 08:53:04,238
通常情况下，你会有一批（东西）

12577
08:53:02,680 --> 08:53:05,798
尺寸，并且这个批量大小将会

12578
08:53:04,238 --> 08:53:07,160
有一堆这样的东西，它会

注：原英文文本不太完整，所以翻译可能在语义连贯性上存在一定局限。 

12579
08:53:05,798 --> 08:53:08,600
是一批你打算用的数组

12580
08:53:07,160 --> 08:53:10,718
对其进行softmax操作，然后你要做的是

12581
08:53:08,600 --> 08:53:13,840
对它们逐行进行softmax操作，你即将

注：原英文句子似乎未完整表述，此翻译是按照现有内容进行的处理。 

12582
08:53:10,718 --> 08:53:15,238
在这里做这里这里呃，对，而不是

12583
08:53:13,840 --> 08:53:17,520
就像针对每个元素一样，所以它正在进行 

12584
08:53:15,238 --> 08:53:19,120
穿过一排排（东西），而这里就是……

12585
08:53:17,520 --> 08:53:21,680
实际上，我们可以从CUDA中获得速度提升。

12586
08:53:19,120 --> 08:53:23,680
因为我们可以给每一个……中的每一个

12587
08:53:21,680 --> 08:53:26,958
我们知道我们有很多批处理大小的线程

12588
08:53:23,680 --> 08:53:29,520
线程，然后我们给它们每一个呃我们

12589
08:53:26,958 --> 08:53:31,600
给他们每个人分配一项softmax任务，对吧

12590
08:53:29,520 --> 08:53:33,760
我们在……里看到

12591
08:53:31,600 --> 08:53:36,600
这里

12592
08:53:33,760 --> 08:53:41,160
我们在这里如何看待
我们实际上如何给予

12593
08:53:36,600 --> 08:53:43,878
一人一个 嗯 我们 我们 我们给每人…… 我们

12594
08:53:41,160 --> 08:53:46,120
给每个线程一个单独的softmax丢弃

12595
08:53:43,878 --> 08:53:48,798
那将会持续
它将会贯穿

12596
08:53:46,120 --> 08:53:51,200
1. 24次迭代，或者达到长度上限 

12597
08:53:48,798 --> 08:53:53,520
嗯，正如我们在这些当中看到的，所以

12598
08:53:51,200 --> 08:53:55,680
理论上来说，这将需要3（此处3后面可能缺失单位等内容）

12599
08:53:53,520 --> 08:53:57,958
一次迭代，因为必须进行三次 

12600
08:53:55,680 --> 08:53:59,398
不同的 for 循环 嗯 那就是 那就是

12601
08:53:57,958 --> 08:54:00,718
有点像那边的运作方式，所以我们想要

12602
08:53:59,398 --> 08:54:03,280
我们要关注批次。

12603
08:54:00,718 --> 08:54:05,238
尺寸合适，嗯，但有……有一个

12604
08:54:03,280 --> 08:54:07,120
这里有一个在 CUDA 里的示例，你可以…… 

12605
08:54:05,238 --> 08:54:10,000
自己去检查一下，然后参与进来

12606
08:54:07,120 --> 08:54:12,440
对批量的圣马克斯（这里“St Max”推测可能是特定名称）的直觉，但它是

12607
08:54:10,000 --> 08:54:16,520
和我们没选的那个非常相似

12608
08:54:12,440 --> 08:54:19,360
看，现在我们要进入特里同（海卫一）上的那个（东西，需结合上下文明确）了。 

12609
08:54:16,520 --> 08:54:22,000
好的，那么现在我们实际上要进入，呃

12610
08:54:19,360 --> 08:54:23,798
Softmax Trion内核本身，呃，有一点点（不太明确“一点点”后面省略的内容，需结合上下文理解） 

12611
08:54:22,000 --> 08:54:25,878
在矢量版中会更高级一些，但

12612
08:54:23,798 --> 08:54:28,718
我们将一步一步地进行。

12613
08:54:25,878 --> 08:54:30,798
所以显然我们在顶部进行导入，我是……

12614
08:54:28,718 --> 08:54:32,000
打算从这里的底部开始着手

12615
08:54:30,798 --> 08:54:34,398
解释一下正在发生什么，然后呢

12616
08:54:32,000 --> 08:54:37,318
我们正在进行，我们正在计算那个…… 

12617
08:54:34,398 --> 08:54:41,160
输出 嗯，所以我们设置了手动种子，我们

12618
08:54:37,318 --> 08:54:45,280
随机生成呃 通常情况下

12619
08:54:41,160 --> 08:54:49,200
呃，正态分布的随机张量，其……（这里原英文句子不完整，推测后面还有内容） 

12620
08:54:45,280 --> 08:54:52,080
浮点数，嗯，所以均值为零，方差为一

12621
08:54:49,200 --> 08:54:55,398
所以这是一个正态分布，并且所有的

12622
08:54:52,080 --> 08:55:00,718
呃，从本质上来说，这个形状是批量的。（注：原句可能表述不太准确或完整，“is is”可能有误，“batch”在这里“批量”的意思在这个语境里也稍显奇怪，需结合更准确的原文理解。） 

12623
08:54:55,398 --> 08:55:04,398
尺寸为 um 乘以 n，所以批量大小 B 乘以 n 为

12624
08:55:00,718 --> 08:55:08,600
256 n 是 124 个元素长，我们只是

12625
08:55:04,398 --> 08:55:10,760
进入softmax层，嗯，那些1024个元素

12626
08:55:08,600 --> 08:55:13,558
行，呃，我们要在……上做这个。 

12627
08:55:10,760 --> 08:55:16,000
现在我们要用CUDA进行计算，并且

12628
08:55:13,558 --> 08:55:17,440
确保火炬（torch，这里结合语境可能有其他合适译法）和TR现在把……

12629
08:55:16,000 --> 08:55:20,120
同样的事情，所以通常你会这样做

12630
08:55:17,440 --> 08:55:23,160
torch.softmax 或者 或者 f.softmax 或者

12631
08:55:20,120 --> 08:55:26,478
不管怎样，然后你会说“嗯，德姆”

12632
08:55:23,160 --> 08:55:27,920
等于 1，对吧，然后我们要做

12633
08:55:26,478 --> 08:55:30,638
对三叉戟也做同样的事情，然后

12634
08:55:27,920 --> 08:55:31,878
确保你知道最大值。

12635
08:55:30,638 --> 08:55:33,120
这是不是太荒谬了，我们要去……

12636
08:55:31,878 --> 08:55:35,318
把那个打印出来，然后我们要去制作……

12637
08:55:33,120 --> 08:55:40,318
当然，这一切都与之紧密相关。 

12638
08:55:35,318 --> 08:55:42,920
torch.allclose 对吧，嗯，所以我们来做这个

12639
08:55:40,318 --> 08:55:45,920
特里顿 特里顿 执行Softmax函数 我们开始

12640
08:55:42,920 --> 08:55:48,920
在这里以及这里，我们有，呃，排以及

12641
08:55:45,920 --> 08:55:53,160
列，所以当我们打印出来的时候，嗯，我只是

12642
08:55:48,920 --> 08:55:56,238
打算打印出呃输入形状，所以我们

12643
08:55:53,160 --> 08:55:56,238
到这里来
去这里

12644
08:55:59,160 --> 08:56:05,200
输入形状正是我们想要的，对吧

12645
08:56:05,520 --> 08:56:11,680
嗯，输出方面我们就做一个苹果酸相关的（这里“malic”常见是指“苹果酸的”，但不太明确“do a malic”确切语境含义，可根据实际情况调整）

12646
08:56:08,478 --> 08:56:13,798
基本上就在那时那地，呃

12647
08:56:11,680 --> 08:56:15,798
而不是做一些像元（概念）这样奇怪的事情

12648
08:56:13,798 --> 08:56:17,638
参数，呃，就像处理整个…… 

12649
08:56:15,798 --> 08:56:19,360
就像在进行 Lambda 函数计算，我们正在（这里句子似乎不完整，但按要求翻译了）

12650
08:56:17,638 --> 08:56:22,120
接下来先玩《创：战纪》，然后再玩下一个。 

12651
08:56:19,360 --> 08:56:24,238
2的幂，所以这里所说的是它

12652
08:56:22,120 --> 08:56:26,280
返回最小的 2 的幂次方

12653
08:56:24,238 --> 08:56:27,440
大于或等于 n，因此与……相似

12654
08:56:26,280 --> 08:56:29,440
我们之前在做的事情，但仅仅是一件（此处句子似乎不完整）

12655
08:56:27,440 --> 08:56:31,680
简单一点，嗯，然后我们要走了。

12656
08:56:29,440 --> 08:56:37,558
那么我们要把块大小设置为相等

12657
08:56:31,680 --> 08:56:39,238
到最小值 1024，然后这边，嗯

12658
08:56:37,558 --> 08:56:42,238
所以你多少能明白我们……你能（此处原英文表述不太完整和清晰） 

12659
08:56:39,238 --> 08:56:46,798
有点明白为什么我们，为什么我们要那么做了

12660
08:56:42,238 --> 08:56:49,398
现在我们把网格设置为 n 行，因为在

12661
08:56:46,798 --> 08:56:51,718
我们的网格
我们希望每行都有一个方块

12662
08:56:49,398 --> 08:56:54,200
就在我们进行并行处理的时候

12663
08:56:51,718 --> 08:56:57,160
我们想要……我们……呃，我们不能……我们不能分开一个（这里原文“split a”表述不太完整清晰，只能按字面直译） 

12664
08:56:54,200 --> 08:56:59,280
在多个呃，或者在……之中的单行

12665
08:56:57,160 --> 08:57:01,798
至少不能天真地把它分割开来

12666
08:56:59,280 --> 08:57:04,878
多个线程，所以我们想这么做，呃

12667
08:57:01,798 --> 08:57:06,718
对于每个区块，所以每个不同的，嗯，每个

12668
08:57:04,878 --> 08:57:08,280
不同的行将拥有其各自的块

12669
08:57:06,718 --> 08:57:10,558
本质上，那就是我们启动……的方式

注：原句似乎不完整，“launch the”后面可能还有内容。 

12670
08:57:08,280 --> 08:57:13,798
这里有网格，嗯，然后你可以假设

12671
08:57:10,558 --> 08:57:16,878
你知道为什么我们会有这个，嗯，为什么我们…… 

12672
08:57:13,798 --> 08:57:18,878
有这个拖尾现象仅仅是因为……（这里原文表述不太完整和清晰，可能存在信息缺失）

12673
08:57:16,878 --> 08:57:21,398
尾随维度，你可以直接假设

12674
08:57:18,878 --> 08:57:23,680
你说得对，这就是像圆周率那样的情况。

不过原英文句子表述比较口语化且似乎不太完整准确，正常更符合语法的表达可能会有所不同。 

12675
08:57:21,398 --> 08:57:26,920
如果你这样做，torch shap的形状是可行的

12676
08:57:23,680 --> 08:57:28,958
批量逗号，它会像B乘以1然后…… 

12677
08:57:26,920 --> 08:57:30,760
所以它就会像一个列向量一样

12678
08:57:28,958 --> 08:57:33,680
有点像，你可以那样去想它

12679
08:57:30,760 --> 08:57:35,280
嗯，然后我们来处理softmax内核。

12680
08:57:33,680 --> 08:57:37,360
我们用和之前一样的方式来称呼这个。

12681
08:57:35,280 --> 08:57:41,120
向量广告，只不过我们再添加两样东西

12682
08:57:37,360 --> 08:57:42,680
所以我们把这个 x 加进来。按步长处理这个……这个

12683
08:57:41,120 --> 08:57:44,718
仅仅是某个事物的一个输入参数吗

12684
08:57:42,680 --> 08:57:48,360
这里楼上会是什么样呢，所以我们

12685
08:57:44,718 --> 08:57:52,040
得到了 x 步长，它本质上是

12686
08:57:48,360 --> 08:57:54,840
这段英文存在重复和不太连贯的表述，可能有误，以下是勉强翻译的内容：
那划船的步伐 所以我们 当…… 

12687
08:57:52,040 --> 08:57:56,920
我们，嗯，当我们穿过它的时候，感觉就好像它是……

12688
08:57:54,840 --> 08:57:59,280
在内存中堆叠，就像第一行，一行

12689
08:57:56,920 --> 08:58:01,000
两行，三行，四行，对，嗯，但是那个

12690
08:57:59,280 --> 08:58:03,280
步幅就像是你得走多远

12691
08:58:01,000 --> 08:58:05,840
缠绕到一个新的上面，所以当我们

12692
08:58:03,280 --> 08:58:07,680
比如说我们想去第四排，嗯，你

12693
08:58:05,840 --> 08:58:09,680
实际上我得走了
好吧
那么是什么

12694
08:58:07,680 --> 08:58:11,440
什么是合适的步幅，步幅应该多长？

12695
08:58:09,680 --> 08:58:12,638
你必须穿过去才能到达……吗？

注：原英文句子似乎不完整，“get to the”后面缺少内容。 

12696
08:58:11,440 --> 08:58:17,120
下一个，基本上就像是……

12697
08:58:12,638 --> 08:58:19,440
长度（单位：微米），而且你知道的，我们……我们……我们

12698
08:58:17,120 --> 08:58:21,920
我们可以说有 n 列，但我们只是

12699
08:58:19,440 --> 08:58:25,238
打算使用，嗯，你知道的，那个目标

12700
08:58:21,920 --> 08:58:27,840
属性 x. 步长

12701
08:58:25,238 --> 08:58:31,878
嗯，传球、排成纵队，然后进行封堵

12702
08:58:27,840 --> 08:58:34,520
尺寸，没错，所以我们往上走，然后我们看到了那个

12703
08:58:31,878 --> 08:58:39,520
我们拿到了，呃，它在哪儿呢？

12704
08:58:34,520 --> 08:58:45,718
执行输出 X，步长，步长以及列数

12705
08:58:39,520 --> 08:58:45,718
然后是块大小，呃，输出

12706
08:58:47,440 --> 08:58:53,398
输入步长、步幅和列块

12707
08:58:50,238 --> 08:58:56,718
尺寸 现在我们做同样的事 我们 我们 我们做这个

12708
08:58:53,398 --> 08:58:59,638
和婴儿车编号一样，还有开始部分

12709
08:58:56,718 --> 08:59:02,478
指针以同样的方式

12710
08:58:59,638 --> 08:59:04,478
嗯，我们通常是这样计算的，那么哪个（这里原文“which”表意不太明确，需结合上下文）

12711
08:59:02,478 --> 08:59:07,478
街区，我们现在在右边，然后我们有

12712
08:59:04,478 --> 08:59:10,680
将若干索引向前推进

12713
08:59:07,478 --> 08:59:13,520
在记忆里，所以就好像我们……本质上

12714
08:59:10,680 --> 08:59:14,878
我们获取初始的，呃，输入指针，所以

12715
08:59:13,520 --> 08:59:19,120
它从哪里开始呢 哪里 哪里

12716
08:59:14,878 --> 08:59:22,600
在记忆中有一个起始点，然后

12717
08:59:19,120 --> 08:59:26,958
呃，我们加上那个

12718
08:59:22,600 --> 08:59:31,520
对于我们我们我们拿走那个，然后我们加上

12719
08:59:26,958 --> 08:59:33,200
呃，行索引，那么它是第几行乘以……

12720
08:59:31,520 --> 08:59:36,680
行的长度，没错，那么接下来我们可以

12721
08:59:33,200 --> 08:59:39,398
获取起始行所在的是哪一行

12722
08:59:36,680 --> 08:59:40,840
在那一批里面，对吧，那么是哪一行呢

12723
08:59:39,398 --> 08:59:42,558
我们想去，然后是这整个…… 

12724
08:59:40,840 --> 08:59:44,120
实际上，这件事从更宏观的角度来看

12725
08:59:42,558 --> 08:59:45,478
这就是全部的记忆，对吧，那是……

12726
08:59:44,120 --> 08:59:47,718
那就是我们当时在那里所做的事情

12727
08:59:45,478 --> 08:59:49,238
输出的思路也是一样的，呃，开始

12728
08:59:47,718 --> 08:59:50,680
指针，所以从本质上来说我们只是

12729
08:59:49,238 --> 08:59:54,638
在记忆中寻找那个地方，在那里我们

12730
08:59:50,680 --> 08:59:57,398
基于，基于这三个，嗯，开始

12731
08:59:54,638 --> 09:00:01,360
然后我们装进去，所以，呃，你知道的，我们会这么做

12732
08:59:57,398 --> 09:00:04,000
典型的负载，所以，呃，指针，然后

12733
09:00:01,360 --> 09:00:05,798
我们想，呃，加载所有的索引。

12734
09:00:04,000 --> 09:00:09,360
和我们之前的做法如此相似

12735
09:00:05,798 --> 09:00:10,638
之前，然后我们的口罩呢，呃，我们……

12736
09:00:09,360 --> 09:00:13,440
只是要确保这是

12737
09:00:10,638 --> 09:00:15,638
少于 n 列，嗯，对，正在制作

12738
09:00:13,440 --> 09:00:18,040
确保我们不会越界，并且

12739
09:00:15,638 --> 09:00:19,958
那么，这个这个重要的术语“其他”是

12740
09:00:18,040 --> 09:00:23,958
有点关键，因为

12741
09:00:19,958 --> 09:00:23,958
那么；好吧

注：“well so”并不是一个固定的、常见的短语搭配，“well”常见作感叹词、副词等，“so”有“那么；所以”等含义，这里这样翻译是结合语境可能的常见理解，你可以提供更多上下文信息，以便我更准确翻译。 

12742
09:00:25,318 --> 09:00:29,878
另一个术语的意思是，如果你有

12743
09:00:28,638 --> 09:00:33,558
嗯，为了

12744
09:00:29,878 --> 09:00:36,360
例如，如果你在一个（这里文本不完整，可能后面还有内容）中有 1000 个元素

12745
09:00:33,558 --> 09:00:39,040
行，并且块大小是24，所以它是

12746
09:00:36,360 --> 09:00:40,478
会稍微长一点，嗯，比那个（时间等）

注：原英文表述不是很规范，这里按照意思大致翻译。 

12747
09:00:39,040 --> 09:00:41,798
意味着你要处理一些

12748
09:00:40,478 --> 09:00:44,080
额外的元素，它会去思考

12749
09:00:41,798 --> 09:00:46,360
最后还有额外的24个，所以

12750
09:00:44,080 --> 09:00:47,520
你能做什么，我的意思是，这不是这个（意思）。 

12751
09:00:46,360 --> 09:00:49,000
在我们的情况中是不会发生的

12752
09:00:47,520 --> 09:00:51,318
因为我们在如何……方面非常客观

12753
09:00:49,000 --> 09:00:53,280
我们定义事物，但在某些情况下，这

12754
09:00:51,318 --> 09:00:56,440
留意……将会很重要

12755
09:00:53,280 --> 09:00:58,718
呃，你实际上想明确地……

12756
09:00:56,440 --> 09:01:00,680
设置边缘，这样它就不会乱了。

12757
09:00:58,718 --> 09:01:03,200
如果情况是那样的话，其他一切都没问题

12758
09:01:00,680 --> 09:01:04,600
举个例子，然后在我们整个……（这里文本似乎不完整） 

12759
09:01:03,200 --> 09:01:06,718
会进行的softmax计算

12760
09:01:04,600 --> 09:01:08,920
对它做出相当显著的贡献

12761
09:01:06,718 --> 09:01:11,398
因为你知道，这不仅仅是

12762
09:01:08,920 --> 09:01:13,440
就像大规模的稀疏整数，它就像一个

12763
09:01:11,398 --> 09:01:16,238
这就像周围存在的小数位一样。

12764
09:01:13,440 --> 09:01:18,638
零，对，嗯，所以去做这件事很重要。

12765
09:01:16,238 --> 09:01:20,558
当我们进行取幂运算的时候，当你…… 

12766
09:01:18,638 --> 09:01:24,520
做；干；从事；进行；算出；解答

12767
09:01:20,558 --> 09:01:30,238
嗯，如果我们在这里进入，呃，Python（编程环境）

12768
09:01:24,520 --> 09:01:31,920
导入，呃，导入数学模块 我们开始 嗯 可以直接

12769
09:01:30,238 --> 09:01:36,080
说

12770
09:01:31,920 --> 09:01:37,920
x xal 负浮点数，然后

12771
09:01:36,080 --> 09:01:42,680
无穷大；无限大（通常为Infinity的缩写） 

12772
09:01:37,920 --> 09:01:45,718
对，然后我们使用，嗯，math.exp

12773
09:01:42,680 --> 09:01:48,958
X 我们注意到恰好在（此处）我们得到零

12774
09:01:45,718 --> 09:01:51,200
我们 我们做了数学。我们会得到 e 的一次方（注：“exp of one”常见数学表达为“e 的一次方”，即 e）

12775
09:01:48,958 --> 09:01:52,318
我们会得到这个数字，所以我们只是想

12776
09:01:51,200 --> 09:01:54,160
以确保那不是

12777
09:01:52,318 --> 09:01:56,920
做出任何贡献，那就是……

12778
09:01:54,160 --> 09:02:00,318
我们在那里所做的一切

12779
09:01:56,920 --> 09:02:01,638
嗯，所以所有其他额外的值，如果

12780
09:02:00,318 --> 09:02:03,238
它们发生了，我们可不希望那些事发生。 

12781
09:02:01,638 --> 09:02:06,160
根本没有做出贡献，只是起到一种安全保障作用

12782
09:02:03,238 --> 09:02:08,238
我觉得留意这个挺好的，嗯

12783
09:02:06,160 --> 09:02:09,958
然后我们就按照常规的做法

注：这里原文 “the the the” 可能存在表述错误，但按照要求进行了翻译。 

12784
09:02:08,238 --> 09:02:12,318
实际上是softmax计算

12785
09:02:09,958 --> 09:02:15,920
只需要四行代码，嗯，所以我们来计算

12786
09:02:12,318 --> 09:02:18,958
你知道的，那一行里的最大值



12787
09:02:15,920 --> 09:02:21,080
然后我们得到分子，它是

12788
09:02:18,958 --> 09:02:23,840
记住，我们要从……中减去最大值。（这里原文“from”后面内容缺失） 

12789
09:02:21,080 --> 09:02:25,718
那个，呃，我们对这个取指数，所以我们

12790
09:02:23,840 --> 09:02:26,760
对无论什么……无论什么……进行乘方运算

12791
09:02:25,718 --> 09:02:29,160
结果

12792
09:02:26,760 --> 09:02:31,160
然后我们得到分母，这个分母……

12793
09:02:29,160 --> 09:02:33,920
是一个总和

12794
09:02:31,160 --> 09:02:36,440
跨越每一个人 每一个人

12795
09:02:33,920 --> 09:02:38,920
其一，所以会有一些

12796
09:02:36,440 --> 09:02:40,398
求和，然后我们要去做…… 

12797
09:02:38,920 --> 09:02:42,958
本质上，这个数组将会是

12798
09:02:40,398 --> 09:02:45,600
一组元素，并且我们打算

12799
09:02:42,958 --> 09:02:47,160
将其除以一个标量值，这样它就是

12800
09:02:45,600 --> 09:02:49,760
打算就拿走这个，而且它是…… 

12801
09:02:47,160 --> 09:02:51,718
将要分割 分割 分割 分割

12802
09:02:49,760 --> 09:02:53,520
正确划分，这就是我们……（原句表述不太完整，此处“how we”后似乎缺少内容）

12803
09:02:51,718 --> 09:02:56,000
获取我们的softmax输出，然后我们将

12804
09:02:53,520 --> 09:02:58,478
看看我们把这个存起来了

12805
09:02:56,000 --> 09:03:01,440
嗯，类似于我们实际加载的方式

12806
09:02:58,478 --> 09:03:03,760
起初的事情，所以而不是……（此英文文本似乎表述不太完整和准确，翻译可能存在理解上的局限性）

12807
09:03:01,440 --> 09:03:07,318
行起始指针，它是输出行

12808
09:03:03,760 --> 09:03:10,280
起始指针，同样的思路，嗯，我们想

12809
09:03:07,318 --> 09:03:12,000
存储一个经过softmax处理后的值

12810
09:03:10,280 --> 09:03:14,080
输出，也就是我们在这里计算出的结果

12811
09:03:12,000 --> 09:03:18,280
所以这就是里面的实际数值，呃

12812
09:03:14,080 --> 09:03:20,080
呃，然后我们的口罩和我们自己的情况一样（这里原文表述不太符合常规，可能语义不太准确） 

12813
09:03:18,280 --> 09:03:22,520
在这儿做了，所以我们要确保

12814
09:03:20,080 --> 09:03:24,558
我们没有在进行阅读和写作（这里“wrs”推测可能是“writes”之类的词，但不太明确，可根据实际情况调整）

12815
09:03:22,520 --> 09:03:26,200
出界了，在右侧，然后……就是这样

12816
09:03:24,558 --> 09:03:30,000
几乎整个软X计算

12817
09:03:26,200 --> 09:03:31,238
在特里同（Triton，可能是地名、项目名等，需结合上下文确定具体含义），所以你知道，我鼓励你去……

12818
09:03:30,000 --> 09:03:34,760
呃，你知道的，摆弄摆弄这个，你

12819
09:03:31,238 --> 09:03:36,920
能做到，你实际上可以做到

12820
09:03:34,760 --> 09:03:43,558
嗯，实际上你可以

12821
09:03:36,920 --> 09:03:47,238
去，呃，设备打印，然后我们就可以继续了

12822
09:03:43,558 --> 09:03:48,920
嗯，就像 P，然后就写上类似行索引这样的东西

12823
09:03:47,238 --> 09:03:53,920
或者我们可以

12824
09:03:48,920 --> 09:03:53,920
像这样处理行索引

12825
09:03:56,238 --> 09:04:01,360
而且我们实际上可以把它打印出来

12826
09:03:58,680 --> 09:04:04,040
这样你就能知道最大的差异了

12827
09:04:01,360 --> 09:04:06,680
在TR TR PyTorch和Tron的结果之间

12828
09:04:04,040 --> 09:04:09,000
数值非常小，结果相近。

注：原文 “is is” 可能有误，推测可能是 “值” 相关的 “it is” 之类表述，这里按合理语义进行理解翻译。 

12829
09:04:06,680 --> 09:04:12,040
没错，嗯，然后我们可以看到每一个……

12830
09:04:09,000 --> 09:04:14,958
其中一个个体，所以就像P ID是

12831
09:04:12,040 --> 09:04:18,200
你知道，255 这是在 X 维度里

12832
09:04:14,958 --> 09:04:20,280
好吧，所以如果你有……就好像你有……

12833
09:04:18,200 --> 09:04:24,558
一个；某个；一（用于辅音音素前）

12834
09:04:20,280 --> 09:04:27,958
嗯，这是轴，所以我们对Z轴也做同样的操作。

12835
09:04:24,558 --> 09:04:30,238
我们获取某样东西，然后你知道的

12836
09:04:27,958 --> 09:04:33,238
这个会在这个，在这个位置上

12837
09:04:30,238 --> 09:04:36,440
而不是 而不是X

12838
09:04:33,238 --> 09:04:39,200
对，所以，没错，我们把所有东西都打印出来。 

12839
09:04:36,440 --> 09:04:40,958
那个值是，然后我们得到，呃，我们可以

12840
09:04:39,200 --> 09:04:44,558
如果我这么做的话，就在终端里输出内容

12841
09:04:40,958 --> 09:04:44,558
像平常一样，就像

12842
09:04:45,040 --> 09:04:50,478
现在保存，这可能是个好主意。

12843
09:04:47,520 --> 09:04:52,120
实际上是否要深入研究 PyTorch 甚至都…… 

12844
09:04:50,478 --> 09:04:54,040
深入探究它，而是要理解如何…… 

12845
09:04:52,120 --> 09:04:56,120
你可以在它上面添加内容，让事情变得……

12846
09:04:54,040 --> 09:04:59,040
稍微快一点，呃，按照你自己的习惯

12847
09:04:56,120 --> 09:05:01,120
用例之类的，所以我们只是

12848
09:04:59,040 --> 09:05:02,798
结束了《三叉戟》这一章，呃，我

12849
09:05:01,120 --> 09:05:04,558
希望你喜欢刚才的内容，但现在我们要…… （原文似乎未完整，此处按照常规表达补充省略部分）

12850
09:05:02,798 --> 09:05:07,398
接下来会更深入地探讨一下

12851
09:05:04,558 --> 09:05:10,160
Python，并且更多地涉及 PyTorch 方面，所以

12852
09:05:07,398 --> 09:05:14,238
我在这里写了几个文件，我确实写了

12853
09:05:10,160 --> 09:05:16,478
一些关于正在发生之事的描述

12854
09:05:14,238 --> 09:05:19,160
呃，所有这些到底是怎么回事啊，就像…… 

12855
09:05:16,478 --> 09:05:21,120
不同的类型、名称之类的，在……

12856
09:05:19,160 --> 09:05:22,680
呃，在自述文件里以及一些……

12857
09:05:21,120 --> 09:05:24,200
我们要讲的内容的直观例子

12858
09:05:22,680 --> 09:05:27,600
正在看着；正在考虑；正在研究（需结合语境确定准确含义） 

12859
09:05:24,200 --> 09:05:30,120
我为 just 写了一个安装脚本。

12860
09:05:27,600 --> 09:05:31,318
编译一个单独的 Python 扩展 呃

12861
09:05:30,120 --> 09:05:34,440
一个我们将要用到的独立函数

12862
09:05:31,318 --> 09:05:38,600
用来做一个多项式，这非常简单。

12863
09:05:34,440 --> 09:05:41,878
操作，嗯，然后，呃，一个CUDA脚本

12864
09:05:38,600 --> 09:05:43,760
那将，呃，进行编译和绑定

12865
09:05:41,878 --> 09:05:46,280
将其转换为 PyTorch，这样我们实际上就可以使用

12866
09:05:43,760 --> 09:05:49,080
它，嗯，用 Python 编写，然后是 Python 相关的（部分表述不太明确，需结合更多语境理解） 

12867
09:05:46,280 --> 09:05:52,280
我们用来进行基准测试的脚本本身

12868
09:05:49,080 --> 09:05:55,200
呃，简单的 PyTorch，所以我们所做的全部就是……

12869
09:05:52,280 --> 09:05:58,840
实际上这里做的是 x² + x + 1，那就是

12870
09:05:55,200 --> 09:06:00,160
我们所做的一切，所以来到这里，我们有

12871
09:05:58,840 --> 09:06:02,200
这包括，而这正在给予我们

12872
09:06:00,160 --> 09:06:04,840
有错误，但别担心这个，呃

12873
09:06:02,200 --> 09:06:06,718
当我们搭建（设备等，需结合语境）的时候，实际上它会呃

12874
09:06:04,840 --> 09:06:09,040
它会妥善处理这件事的，所以我们

12875
09:06:06,718 --> 09:06:11,800
实际上并不需要呃一个专门的（此处“dedicated”后面内容缺失，翻译可能不够精准）

12876
09:06:09,040 --> 09:06:14,000
包含文件或  或任何用于……的参数

12877
09:06:11,800 --> 09:06:17,598
这个我们不需要指定……的位置

（这里英文句子不完整，“where the”后面应该还有内容，只能根据现有内容尽量翻译通顺） 

12878
09:06:14,000 --> 09:06:20,558
扩展名。.H 文件是嗯，但是要进入……（注：原英文表述不太完整和清晰） 

12879
09:06:17,598 --> 09:06:22,278
实际的内核本身，嗯，所以就像

12880
09:06:20,558 --> 09:06:24,078
从上到下，我们有了这个新事物

12881
09:06:22,278 --> 09:06:28,278
叫做模板
我没有详细讲解过这个

12882
09:06:24,078 --> 09:06:32,320
然而，但是，呃，好吧，我……我确实，我想我确实做了。

12883
09:06:28,278 --> 09:06:33,960
在，呃，手动部分，但，呃

12884
09:06:32,320 --> 09:06:37,040
模板

12885
09:06:33,960 --> 09:06:38,800
如果我们继续下去，这基本上是……它会…… 

12886
09:06:37,040 --> 09:06:41,558
帮忙 如果 如果我们稍微往下 然后 然后

12887
09:06:38,800 --> 09:06:44,078
看看这些物资都放在哪儿了，嗯，那么当……的时候

12888
09:06:41,558 --> 09:06:46,040
我们把这个叫做内核，我们这样做，然后

12889
09:06:44,078 --> 09:06:48,598
我们提出了我们的论点，对吧，我们有（这样做）

12890
09:06:46,040 --> 09:06:50,160
这里的内核配置，然后

12891
09:06:48,598 --> 09:06:52,238
我们有这个 这个 这就是……的地方

12892
09:06:50,160 --> 09:06:56,398
模板进来了，所以我们指定这个

12893
09:06:52,238 --> 09:06:59,718
标量 t 类型，这本质上意味着

12894
09:06:56,398 --> 09:07:03,122
嗯，我们只是要确保

12895
09:06:59,718 --> 09:07:07,480
那个，呃，这个

注：原英文“that this uh the”表述比较零散且不太符合常规完整句子表达，这样的翻译只是按字面逐词对应。 

12896
09:07:03,122 --> 09:07:10,438
X、y 或者输入、输出，呃

12897
09:07:07,480 --> 09:07:11,878
属于这种类型，所以这种类型是

12898
09:07:10,438 --> 09:07:13,918
基本上将由 P 来处理

12899
09:07:11,878 --> 09:07:17,598
火炬，并且不是像指定一个……这样做 

12900
09:07:13,918 --> 09:07:19,160
浮点数或者双精度浮点数，或者像我也不太清楚

12901
09:07:17,598 --> 09:07:22,960
了解其他一些 其他一些 比如也许

12902
09:07:19,160 --> 09:07:24,918
像 fp16 类型那样进行量化，嗯，它将会……

12903
09:07:22,960 --> 09:07:26,520
帮我们处理好那件事，然后它将会

12904
09:07:24,918 --> 09:07:28,078
只需自动识别是哪一个

12905
09:07:26,520 --> 09:07:29,918
是的，它会对其进行编译。

12906
09:07:28,078 --> 09:07:31,278
冷静下来并妥善处理，所以

12907
09:07:29,918 --> 09:07:33,718
这是PyTorch内置的功能。

12908
09:07:31,278 --> 09:07:35,278
而且这是我们拥有的自定义类型，呃，所以

12909
09:07:33,718 --> 09:07:38,040
这有点就像是默认的……到（这里“to”表意不完整，需结合上下文确定确切含义） 

12910
09:07:35,278 --> 09:07:41,758
用这里，嗯，最简单的，然后我们有

12911
09:07:38,040 --> 09:07:43,878
这太受限了，简而言之就是太受限了。

12912
09:07:41,758 --> 09:07:46,320
从本质上来说，这意味着我们不会成为（或“不会去做” ，需结合上下文确定准确含义）

12913
09:07:43,878 --> 09:07:49,122
重叠的记忆 呃 我们不会去（做某事，此处原文未明确）

12914
09:07:46,320 --> 09:07:52,558
会有重叠的内存访问，所以我们

12915
09:07:49,122 --> 09:07:54,480
呃，我们这里有 X，我们有一个输出

12916
09:07:52,558 --> 09:07:57,598
在这里，我们所做的一切就是在进行一项

12917
09:07:54,480 --> 09:08:00,160
对这个东西进行手术，然后我们就

12918
09:07:57,598 --> 09:08:02,200
把那个存放在这里 嗯 我们不……我们是

12919
09:08:00,160 --> 09:08:04,238
不要把事情搞混，我们没在做（那些事）。 

12920
09:08:02,200 --> 09:08:06,160
两件事在差不多相同的位置，并且

12921
09:08:04,238 --> 09:08:08,238
然后有一些被存储的输出

12922
09:08:06,160 --> 09:08:10,718
我们不会做那样乱七八糟的事情。

12923
09:08:08,238 --> 09:08:12,840
所以我们可以直接说“限制”，然后那会

12924
09:08:10,718 --> 09:08:15,918
允许编译器积极地

12925
09:08:12,840 --> 09:08:19,480
优化U 本质上就是二进制的……（此句英文不完整，译文表意可能不准确） 

12926
09:08:15,918 --> 09:08:22,360
代码，代码是，嗯，所以在这里我们，我们

12927
09:08:19,480 --> 09:08:26,238
简单地做一个，呃，我们在……上面做这个

12928
09:08:22,360 --> 09:08:29,040
对典型的库达（Kuda）内核进行X维度处理

12929
09:08:26,238 --> 09:08:33,238
索引，嗯，然后我们做，你知道那个……

12930
09:08:29,040 --> 09:08:35,480
对这个“加”的部分进行平方，然后再加上一，所以

12931
09:08:33,238 --> 09:08:36,840
呃，我的意思是，那就是内核是……

12932
09:08:35,480 --> 09:08:38,520
出奇地简单，这里只有一些

12933
09:08:36,840 --> 09:08:43,200
新的颜色和新的待支付关键词

12934
09:08:38,520 --> 09:08:44,640
注意 呃 要注意 但是 呃

12935
09:08:43,200 --> 09:08:47,480
然后我们向下滚动一点，接着我们

12936
09:08:44,640 --> 09:08:50,278
出现了一些 C++ 语法，这是怎么回事

12937
09:08:47,480 --> 09:08:52,320
这到底有什么用呢？嗯，我们有这个自动功能

12938
09:08:50,278 --> 09:08:54,640
本质上是要弄清楚像哪种

12939
09:08:52,320 --> 09:08:56,122
要把这个打成哪种类型，所以它会…… 

12940
09:08:54,640 --> 09:08:57,840
认识到这将会是一些

12941
09:08:56,122 --> 09:08:59,640
张量类型，并且它将会

12942
09:08:57,840 --> 09:09:01,278
自动选择那个，并且这是

12943
09:08:59,640 --> 09:09:04,360
只是使用 torch.empty ，所以它将会

12944
09:09:01,278 --> 09:09:07,320
与输入 X 具有相同的形状 嗯

12945
09:09:04,360 --> 09:09:08,918
这是一个 PyTorch 张量类型，所以“自动”是（这里表述不太完整，结合上下文可能会有更准确的意思） 

12946
09:09:07,320 --> 09:09:12,320
会意识到它即将……

12947
09:09:08,918 --> 09:09:14,558
基本上要呃 它将会

12948
09:09:12,320 --> 09:09:16,078
它要这么做的话，我们就离开

12949
09:09:14,558 --> 09:09:18,878
目前将其设为自动模式，因为它看起来

12950
09:09:16,078 --> 09:09:21,438
更好些，嗯，然后我们有了我们的线。

12951
09:09:18,878 --> 09:09:24,000
每……通常有10,24个线程
（注：原英文文本似乎不完整，这样的翻译只能基于现有内容进行推测性表述） 

12952
09:09:21,438 --> 09:09:26,360
按照最大值进行分组，然后我们

12953
09:09:24,000 --> 09:09:28,122
你知道我们有麻木的元素再加上……

（不过原英文表述似乎不太符合常见的语法规范，可能存在信息不完整或表述有误的情况。） 

12954
09:09:26,360 --> 09:09:29,718
线程数减一除以……的数量

12955
09:09:28,122 --> 09:09:31,000
线程 所以这就是典型的我们

12956
09:09:29,718 --> 09:09:33,520
已经讨论过这个了，这应该是

12957
09:09:31,000 --> 09:09:37,558
非常琐碎的事情

12958
09:09:33,520 --> 09:09:40,878
嗯，然后实际上我们仅仅有…… 

12959
09:09:37,558 --> 09:09:43,598
一些 关于……的额外内容

12960
09:09:40,878 --> 09:09:45,320
呃，内核将如何被调用

12961
09:09:43,598 --> 09:09:49,558
那么，我们要处理哪些事情呢（此处原英文句子不完整，根据一般语境猜测补充了“要处理”）

12962
09:09:45,320 --> 09:09:52,840
向它输入数据，嗯，我们得到一个输出。

12963
09:09:49,558 --> 09:09:57,000
基于那个，嗯，然后在下面这里我们

12964
09:09:52,840 --> 09:09:58,758
只是我们有 Python 绑定，所以，呃

12965
09:09:57,000 --> 09:10:01,878
别太担心这个，只是

12966
09:09:58,758 --> 09:10:04,758
有点相信这个过程，嗯，我能…… 

12967
09:10:01,878 --> 09:10:08,122
读出我所能获取的内容之类的 

12968
09:10:04,758 --> 09:10:13,320
呃，确切地了解一下这件事。

12969
09:10:08,122 --> 09:10:16,122
所以，嗯，Pi绑定11模块

12970
09:10:13,320 --> 09:10:19,078
这 这是一个定义了……的宏

12971
09:10:16,122 --> 09:10:21,238
Python 模块 um 的入口点

12972
09:10:19,078 --> 09:10:24,320
PyTorch扩展

12973
09:10:21,238 --> 09:10:26,800
名称，呃，它是由……定义的一个宏

12974
09:10:24,320 --> 09:10:29,360
PyTorch，其全称为……（原英文句子似乎不完整） 

12975
09:10:26,800 --> 09:10:31,680
扩展，所以通常是从……来定义的

12976
09:10:29,360 --> 09:10:35,238
setup.py 文件结束

12977
09:10:31,680 --> 09:10:38,598
那么在这里我们有一个 m 和一个

12978
09:10:35,238 --> 09:10:41,758
m. 因此，这为……添加了一个新功能（此处原文“to the”后面似乎缺少内容）

12979
09:10:38,598 --> 09:10:43,800
模块 所以第一个参数是多项式

12980
09:10:41,758 --> 09:10:46,000
激活，呃，是……的名称

12981
09:10:43,800 --> 09:10:48,320
Python 中的函数，所以那就是……

12982
09:10:46,000 --> 09:10:51,160
我们最终调用的函数记为 P

12983
09:10:48,320 --> 09:10:54,598
多项式激活 开启 关闭

12984
09:10:51,160 --> 09:10:58,200
括号 嗯

12985
09:10:54,598 --> 09:11:02,000
多项式激活的CUDA指针

12986
09:10:58,200 --> 09:11:05,160
呃，或者它是一个指向 C++ 的指针

12987
09:11:02,000 --> 09:11:07,040
要调用的函数，然后是最后一个

12988
09:11:05,160 --> 09:11:08,960
参数是用于……的文档字符串（由于原文不完整，“for the”后面内容缺失，可能影响准确理解，此翻译供参考） 

12989
09:11:07,040 --> 09:11:11,000
函数，所以这就像一个 一个

12990
09:11:08,960 --> 09:11:14,360
简单的文档字符串，它并非完全如此

12991
09:11:11,000 --> 09:11:16,398
需要的，但我们还是把它放在了那里

12992
09:11:14,360 --> 09:11:19,122
不管怎样；反正

12993
09:11:16,398 --> 09:11:20,598
所以不管怎样，这就是，这就是全部内容。

12994
09:11:19,122 --> 09:11:22,640
CUDA脚本，本质上是这样的

12995
09:11:20,598 --> 09:11:25,480
就这么简单，你真的做不到

12996
09:11:22,640 --> 09:11:27,122
有比这更简单的吗，呃，所以

12997
09:11:25,480 --> 09:11:31,200
这有点像一个模板，你可以

12998
09:11:27,122 --> 09:11:33,878
根据……开展工作，然后在这里我们，呃，我们

12999
09:11:31,200 --> 09:11:35,438
导入我们编译好的多项式 CUDA

13000
09:11:33,878 --> 09:11:38,800
我们马上就要编译的函数

13001
09:11:35,438 --> 09:11:42,200
这里我们有一个类，所以我们使用 PyTorch

注：“torch”一般在编程语境里指“PyTorch”这个深度学习框架。 

13002
09:11:38,800 --> 09:11:44,078
自动求导，并且默认情况下，当我们……当我们……

13003
09:11:42,200 --> 09:11:45,758
当我们进行自动求导时，当我们进行一个…… 

13004
09:11:44,078 --> 09:11:47,758
自动求导函数，我们必须包含一个

13005
09:11:45,758 --> 09:11:49,758
前向和后向方法 嗯，这些是

13006
09:11:47,758 --> 09:11:51,480
两者都将是静态的，所以我们只需相加

13007
09:11:49,758 --> 09:11:54,040
这个装饰器表明这是

13008
09:11:51,480 --> 09:11:57,640
在其他地方编译 嗯

13009
09:11:54,040 --> 09:12:00,438
然后接下来我们要做，嗯

13010
09:11:57,640 --> 09:12:03,122
只是这个多项式激活函数就这样出现了

13011
09:12:00,438 --> 09:12:07,122
从我们编译的二进制错误以及

13012
09:12:03,122 --> 09:12:11,000
那么，呃，对X进行多项式激活，对吧

13013
09:12:07,122 --> 09:12:12,598
就像我们之前说的，然后再倒回去，呃

13014
09:12:11,000 --> 09:12:14,200
向后，我们目前还不支持，所以

13015
09:12:12,598 --> 09:12:16,878
我们可以直接说未实现。 

13016
09:12:14,200 --> 09:12:18,200
错误：反向传播未实现 嗯

13017
09:12:16,878 --> 09:12:20,800
然后在这儿，我们实际上要做的是

13018
09:12:18,200 --> 09:12:22,398
我们的 n 和执行模块，这个 Python（推测“py”指 Python）应该是 

13019
09:12:20,800 --> 09:12:24,200
当然，这个……这个应该很熟悉

13020
09:12:22,398 --> 09:12:27,398
看，这应该超级容易去（此处原句不完整）

13021
09:12:24,200 --> 09:12:30,918
明白，嗯，从一个……从一个单独的（角度等，需结合上下文确定“separate”后省略的内容） 

13022
09:12:27,398 --> 09:12:34,680
立场 嗯 但我们只是进行初始化 我们

13023
09:12:30,918 --> 09:12:37,122
在这里做前向动作，我们，我们说你

13024
09:12:34,680 --> 09:12:38,918
知道实施将会是那个P（此处“P”指代不明，需结合上下文理解）

13025
09:12:37,122 --> 09:12:41,878
我们只是将其设置为字符串 P Tor，所以它是

13026
09:12:38,918 --> 09:12:44,438
有点容易阅读，嗯，然后如果那个

13027
09:12:41,878 --> 09:12:48,278
实现使用的是 PyTorch，我们直接这样做

13028
09:12:44,438 --> 09:12:50,680
如果不是这样，那我们就这么做，呃，如果……如果

13029
09:12:48,278 --> 09:12:52,480
那是CUDA，然后我们处理这个，还有另一个

13030
09:12:50,680 --> 09:12:53,960
我们在这里已经明确指定了，所以它会这样进行 

13031
09:12:52,480 --> 09:12:57,398
要做到这一点

13032
09:12:53,960 --> 09:12:59,878
嗯，它将把那个应用到 X 上，并且

13033
09:12:57,398 --> 09:13:02,480
那么，要不然我们就只是，我们就只是说，哦，要是你

13034
09:12:59,878 --> 09:13:05,520
就好像，呃，要是你没注意到那个“T”它……

13035
09:13:02,480 --> 09:13:07,558
就好像哦，你，皮尔彻，不是……

注：“Pi orch”可能是“Pilcher”之类的人名拼写有误，需结合具体语境确定。 

13036
09:13:05,520 --> 09:13:10,640
实施正确
未知

13037
09:13:07,558 --> 09:13:12,438
实施，然后我们继续往下推进

13038
09:13:10,640 --> 09:13:14,480
让我们直接进入主函数

13039
09:13:12,438 --> 09:13:15,680
首先，然后到基准测试这里，所以在这儿

13040
09:13:14,480 --> 09:13:18,680
随机的；随意的；任意的

13041
09:13:15,680 --> 09:13:19,800
生成正态分布的随机张量

13042
09:13:18,680 --> 09:13:22,398
在……之上；关于

（这里“on”有多种释义，具体需结合语境确定，若有完整句子可提供以便更精准翻译） 

13043
09:13:19,800 --> 09:13:25,040
基于PyTorch的设备实现

13044
09:13:22,398 --> 09:13:28,000
在CUDA上的实现，我们将这些移到

13045
09:13:25,040 --> 09:13:30,558
该设备，所以对于CUDA来说，这就像

13046
09:13:28,000 --> 09:13:32,078
本质上，呃，是在说这个函数

13047
09:13:30,558 --> 09:13:33,758
你将因此被处决

13048
09:13:32,078 --> 09:13:37,918
或许之前就该察觉到这一点了

13049
09:13:33,758 --> 09:13:40,598
还不算太糟，嗯，然后我们会，嗯，我们

13050
09:13:37,918 --> 09:13:42,078
实际上可以直接打印出，呃，任何东西

13051
09:13:40,598 --> 09:13:47,438
那个输入

13052
09:13:42,078 --> 09:13:49,278
嗯，然后在这里，我们这样做，就像在这儿一样

13053
09:13:47,438 --> 09:13:51,558
实际上我们只是在做基准测试，所以我们

13054
09:13:49,278 --> 09:13:53,840
嗯，实际的激活函数

13055
09:13:51,558 --> 09:13:55,680
它本身就是我们正在处理的输入

13056
09:13:53,840 --> 09:13:58,320
嗯，然后只是一个我们正在处理的字符串

13057
09:13:55,680 --> 09:14:01,878
打算以……呃……以这个名字进行打印

13058
09:13:58,320 --> 09:14:03,438
所以在这里我们只是设定了一个时间，然后出发

13059
09:14:01,878 --> 09:14:06,360
若干；许多

13060
09:14:03,438 --> 09:14:08,238
运行，呃，然后我们，我们用CUDA（一种并行计算平台和编程模型）

13061
09:14:06,360 --> 09:14:10,520
进行同步，这样我们就能确保一切都

13062
09:14:08,238 --> 09:14:12,598
一切都处理好了，然后我们结束这段时光

13063
09:14:10,520 --> 09:14:15,718
然后我们基本上就返回这个名称

13064
09:14:12,598 --> 09:14:20,480
所以，不管是这些中的哪一个

13065
09:14:15,718 --> 09:14:22,238
关于那个德尔塔时间，就像那个…… 

13066
09:14:20,480 --> 09:14:24,398
本质上不是那个时间差，而是

13067
09:14:22,238 --> 09:14:25,598
差值，嗯，然后我们进行除法运算

13068
09:14:24,398 --> 09:14:28,558
那要根据得分的次数来判断，因为我们是

13069
09:14:25,598 --> 09:14:31,238
做平均次数乘以一个……所以我们

13070
09:14:28,558 --> 09:14:32,718
可以以毫秒格式获取它，嗯，并且

13071
09:14:31,238 --> 09:14:36,878
那正好，那对我们来说正好行得通

13072
09:14:32,718 --> 09:14:41,480
现在预计要实际编译这个

13073
09:14:36,878 --> 09:14:43,480
嗯，我们去……我们去看“自述文件”，然后

13074
09:14:41,480 --> 09:14:47,558
实际上你所要做的仅仅是

13075
09:14:43,480 --> 09:14:47,558
Python 呃，运行 setup.py 文件

13076
09:14:50,360 --> 09:14:57,438
安装
等一下，它马上就要（完成）了

13077
09:14:53,398 --> 09:14:57,438
使用忍者构建（注：这里“ninja”若在特定编程等语境中常指构建工具“忍者”，如果脱离该语境，“ninja”本意是“忍者” ）

13078
09:14:58,480 --> 09:15:04,278
嗯，所以我们先等一会儿，嗯

13079
09:15:02,238 --> 09:15:08,878
但这将会带来一个成果（此处“build”表意不明确，根据语境可有不同准确表述）

13080
09:15:04,278 --> 09:15:08,878
在这里建一个构建文件夹

13081
09:15:24,718 --> 09:15:28,520
然后我们会打印出来，嗯，向前以及

13082
09:15:27,122 --> 09:15:31,320
一秒钟后我们就要往回走了，我们就要……

13083
09:15:28,520 --> 09:15:33,758
打算把这两个都打印出来

13084
09:15:31,320 --> 09:15:36,558
那么，好极了，它刚刚写完了。 

13085
09:15:33,758 --> 09:15:38,718
把那个弄好，所以现在我们可以继续了 

13086
09:15:36,558 --> 09:15:42,000
Python多项式

13087
09:15:38,718 --> 09:15:45,360
激活，然后它会……它会做这些事

13088
09:15:42,000 --> 09:15:47,360
CUDA激活。x的前向传播，呃，以及

13089
09:15:45,360 --> 09:15:50,160
然后它将打印出任何那个输出内容

13090
09:15:47,360 --> 09:15:51,878
然后我们就得到了一个张量，并且它

13091
09:15:50,160 --> 09:15:53,640
它实际上能正确地对这个进行格式化，而（此处原句不完整，which后面内容缺失）

13092
09:15:51,878 --> 09:15:56,480
你就像在说“哦，我的天呐，我们刚刚……我们写了”

13093
09:15:53,640 --> 09:15:58,360
这在在在CUDA和C语言里，而现在它

13094
09:15:56,480 --> 09:16:00,598
像这样打印得非常好，是啊，那就是

13095
09:15:58,360 --> 09:16:03,122
PyTorch 能为你做些什么，嗯，然后我们

13096
09:16:00,598 --> 09:16:07,000
可以看到，PyTorch 内置函数大约达到了 

13097
09:16:03,122 --> 09:16:09,278
10.47毫秒，呃，超过了th000 

13098
09:16:07,000 --> 09:16:11,078
平均运行，然后是CUDA

13099
09:16:09,278 --> 09:16:13,960
扩展程序大约获得

13100
09:16:11,078 --> 09:16:16,640
0.0 243

13101
09:16:13,960 --> 09:16:20,000
毫秒，所以如果我们实际进行比较

13102
09:16:16,640 --> 09:16:24,598
这些，所以如果我走

13103
09:16:20,000 --> 09:16:26,960
嗯，用这个除以，呃，这个，我们拭目以待。

13104
09:16:24,598 --> 09:16:28,918
我们从KUD中获得的加速，所以我们

13105
09:16:26,960 --> 09:16:31,640
大约得到一个

13106
09:16:28,918 --> 09:16:34,278
431倍的加速，这相当不错，如果

13107
09:16:31,640 --> 09:16:37,360
你特别问我关于更大张量的问题

13108
09:16:34,278 --> 09:16:40,480
对，这太棒了 呃，所以，所以

13109
09:16:37,360 --> 09:16:43,278
就这样了，如果我们真的进行一次点积运算

13110
09:16:40,480 --> 09:16:45,000
向后看，你会发现它两者兼具。

13111
09:16:43,278 --> 09:16:46,918
你知道它变成了白色，这样

13112
09:16:45,000 --> 09:16:49,320
这是一个很好很好的迹象，表明它不会（那样）。

13113
09:16:46,918 --> 09:16:53,238
工作，如果我们真的运行这个，它会

13114
09:16:49,320 --> 09:16:56,320
说，呃，没有“backward”属性，对吧

13115
09:16:53,238 --> 09:17:00,000
嗯，所以本质上是提升属性

13116
09:16:56,320 --> 09:17:02,718
错误，嗯，行不通，然后我们

13117
09:17:00,000 --> 09:17:02,718
默认回到

13118
09:17:04,320 --> 09:17:10,558
向前操作，它会弹回到这个界面

注：由于原文表述不太完整或准确，此翻译是在尽量贴合原文意思的基础上进行的，若有更完整的上下文信息，可能会有更精准的翻译。 

13119
09:17:07,360 --> 09:17:12,878
这个神经网络模块，呃，很棒，好的，那么

13120
09:17:10,558 --> 09:17:14,918
那，那是PyTorch的扩展，用于……（原句未完整，这里根据语境补充了省略部分的示意表述）

13121
09:17:12,878 --> 09:17:17,918
你 你可以随意添加任何内容

13122
09:17:14,918 --> 09:17:19,718
你想做这个，嗯，所以你知道，如果你

13123
09:17:17,918 --> 09:17:21,558
拥有你自己类似那样的定制研究

13124
09:17:19,718 --> 09:17:23,320
你想添加它，并且让这一切变得超级简单

13125
09:17:21,558 --> 09:17:25,598
为了他人，也为了你自己，还有你的……

注：原英文文本表述不太准确和完整，以上是尽力按原文格式翻译。 

13126
09:17:23,320 --> 09:17:27,360
组织可以使用，呃，完全可以随意使用。

13127
09:17:25,598 --> 09:17:28,718
要走这条路，复制这个，复制

13128
09:17:27,360 --> 09:17:30,960
这个模板代码可以让你为所欲为。

13129
09:17:28,718 --> 09:17:33,360
有了它，嗯，这只是简单的……这个（这里原文似乎表述不完整） 

13130
09:17:30,960 --> 09:17:38,480
我找到的最简单的例子，嗯，说给你们俩听

13131
09:17:33,360 --> 09:17:42,238
知道、书写和解释，所以，呃，是的，就是这样

13132
09:17:38,480 --> 09:17:44,800
呃，基本上就是那个…… 

13133
09:17:42,238 --> 09:17:46,800
首先，第一个，呃，我甚至都不知道我是……

13134
09:17:44,800 --> 09:17:49,278
不会统一一个百分比，但那个

13135
09:17:46,800 --> 09:17:51,758
现在这门课程的大部分内容……我们

注：原英文句子不太完整通顺，以上是按照字面意思逐词翻译并尽量保持连贯。 

13136
09:17:49,278 --> 09:17:54,598
实际上还有一个期末项目要去完成

13137
09:17:51,758 --> 09:17:57,438
所以这个最终项目超级令人兴奋。

13138
09:17:54,598 --> 09:17:59,878
这将帮助你理解，呃

13139
09:17:57,438 --> 09:18:03,398
从头开始构建神经网络：方法

13140
09:17:59,878 --> 09:18:05,122
也对它们进行性能优化 嗯

13141
09:18:03,398 --> 09:18:06,680
就像数据加载器一样，我们打算添加

13142
09:18:05,122 --> 09:18:09,200
一堆东西 一堆

13143
09:18:06,680 --> 09:18:11,918
将优化措施应用于打造现实世界

13144
09:18:09,200 --> 09:18:11,918
训练跑

13145
09:18:12,718 --> 09:18:19,238
工作 我对这一部分真是兴奋极了

13146
09:18:17,360 --> 09:18:21,598
在课程的最后这一部分，我们将……（这里英文句子不完整，“we're”后应有后续内容） 

13147
09:18:19,238 --> 09:18:23,718
这周要做最终项目了（这里原句“this”后面应该缺了时间相关的词，比如“week”等，根据意思推测补充翻译）

13148
09:18:21,598 --> 09:18:27,480
期末项目太棒了，我们要去…… 

13149
09:18:23,718 --> 09:18:29,078
从……进行一次MNIST多层感知器（MLP）训练运行

13150
09:18:27,480 --> 09:18:31,000
刮一下，它会进入那个（里面）

注：由于原英文表述比较口语化且信息不太完整，翻译可能存在一定局限性。 

13151
09:18:29,078 --> 09:18:33,918
按照顺序，我们将从……开始

13152
09:18:31,000 --> 09:18:35,918
Python和PyTorch超级简单，对吧，接着

注：由于你提供的文本不太符合常见规范表述，此翻译是尽量按照字面意思呈现。 

13153
09:18:33,918 --> 09:18:37,360
我们打算使用NumPy来实现它 

13154
09:18:35,918 --> 09:18:40,078
稍微难了点，但明白是什么……

13155
09:18:37,360 --> 09:18:42,480
引擎盖下面正在发生的情况，然后我们就……

13156
09:18:40,078 --> 09:18:44,040
打算去把我们的NumPy代码进行移植

13157
09:18:42,480 --> 09:18:45,758
把那个交给C，对，它要运行了

13158
09:18:44,040 --> 09:18:47,878
在 CPU 上这将超级容易去（做某事，这里原句不完整）

13159
09:18:45,758 --> 09:18:49,200
阅读、领会并理解，对吧

13160
09:18:47,878 --> 09:18:51,160
然后我们要把那个推到……

13161
09:18:49,200 --> 09:18:55,918
CUDA，然后我们要对它进行排名

13162
09:18:51,160 --> 09:18:57,520
在CUDA中速度很快，太棒了，所以导航到

13163
09:18:55,918 --> 09:18:59,200
我们要对这个文件夹进行一次（此处后面内容缺失，推测可能表述不完整）

13164
09:18:57,520 --> 09:19:00,878
不同的一个，所以它不会是，呃

13165
09:18:59,200 --> 09:19:02,918
SL Cuda课程将是斜杠（这里“slash”表述较模糊，需结合具体语境理解，它常见意思是“斜杠” ）

13166
09:19:00,878 --> 09:19:04,520
而且，CUDA 就像是一个独立的（此处“mnus”可能有误，推测是“and” ）

13167
09:19:02,918 --> 09:19:05,758
有助于更好地整理物品的东西

13168
09:19:04,520 --> 09:19:08,360
也许你想把这个给一个朋友看看

13169
09:19:05,758 --> 09:19:09,398
或者其他什么，或者以某个人的身份出现，并且

13170
09:19:08,360 --> 09:19:10,918
这样一来，你某种程度上就可以拥有

13171
09:19:09,398 --> 09:19:12,840
东西被整理得井井有条

13172
09:19:10,918 --> 09:19:14,520
组织得很好，所以你可以考虑这个

13173
09:19:12,840 --> 09:19:16,120
作为一种相对独立的部分，我们是

13174
09:19:14,520 --> 09:19:18,720
只是在我们之前所做的基础上进行拓展

13175
09:19:16,120 --> 09:19:20,276
之前，呃，所以如果我们复制这个，我们就……

13176
09:19:18,720 --> 09:19:22,960
接下来实际上要进行克隆操作

13177
09:19:20,276 --> 09:19:24,800
把这个放到，呃，一个新目录里，然后我会

13178
09:19:22,960 --> 09:19:26,680
给你大致介绍一下情况是怎样的

13179
09:19:24,800 --> 09:19:29,240
要走了，所以我会继续并且全力以赴

13180
09:19:26,680 --> 09:19:29,240
筛查这个
筛选这个
检查这个 （需结合具体语境确定“screen”最合适的释义） 

13181
09:19:31,596 --> 09:19:39,720
向上 肯定已经保存了 现在我要去……

13182
09:19:35,240 --> 09:19:42,400
进入那个目录，打算去呃，UV、VNV 之类的 

13183
09:19:39,720 --> 09:19:43,640
就像那样，我打算激活这个，我

13184
09:19:42,400 --> 09:19:44,916
只需创建一个类似 Python 的虚拟环境

13185
09:19:43,640 --> 09:19:48,880
环境，那就是我真正所做的一切

13186
09:19:44,916 --> 09:19:54,560
在那儿，呃，然后我们要去……皮普（“pip”可能是人名、地名或特定事物名称，需结合上下文确定更准确译法 ）

13187
09:19:48,880 --> 09:19:56,320
呃，使用UV（这里可能表述有误，通常是`pip`安装相关，推测想表达`pip`），执行`pip install d r`（这里`d r`可能也是有误的输入，应该是具体的包名） 

13188
09:19:54,560 --> 09:20:00,120
要求，并且它会继续推进

13189
09:19:56,320 --> 09:20:04,120
然后安装我们所需的一切，嗯

13190
09:20:00,120 --> 09:20:06,360
好啦，亲爱的，现在我们要突然进入……

13191
09:20:04,120 --> 09:20:10,160
呃，实际上我们马上就要开始了。

13192
09:20:06,360 --> 09:20:14,680
在 VS Code 中打开这个，接着去做那件事。

13193
09:20:10,160 --> 09:20:18,200
嗯，现在如果我们进入，呃，让我把它弄完整

13194
09:20:14,680 --> 09:20:20,800
屏蔽这个，没问题。好的，那么如果我们继续

13195
09:20:18,200 --> 09:20:22,360
进入这个 Python 文件夹，只是为了像……

13196
09:20:20,800 --> 09:20:23,480
帮助你了解这个的结构

13197
09:20:22,360 --> 09:20:26,240
所以我们，我们打算去做我们要做的事

13198
09:20:23,480 --> 09:20:27,756
要做的是，我们将从……逐步推进

13199
09:20:26,240 --> 09:20:31,320
呃，Python，所以我们接下来要深入探讨一下

13200
09:20:27,756 --> 09:20:34,160
PyTorch，呃，如……中所见

13201
09:20:31,320 --> 09:20:36,360
这里，呃，所以那差不多就像一个

13202
09:20:34,160 --> 09:20:37,560
整个 PyTorch 训练运行用于一个

13203
09:20:36,360 --> 09:20:40,400
多层的

13204
09:20:37,560 --> 09:20:42,560
感知机，呃，然后还有个小木星

13205
09:20:40,400 --> 09:20:45,040
笔记本，那和那个差不多，呃

13206
09:20:42,560 --> 09:20:47,960
但只是换成了笔记本的形式而已

13207
09:20:45,040 --> 09:20:50,720
然后我们有一个NumPy脚本，所以只要

13208
09:20:47,960 --> 09:20:53,120
呃，把所有内容都写下来

13209
09:20:50,720 --> 09:20:55,560
从头开始以及使用NumPy

13210
09:20:53,120 --> 09:20:57,200
嗯，到时候这可能看起来不太一样了。 

13211
09:20:55,560 --> 09:21:00,080
当你看到这个的时候，但那将会是

13212
09:20:57,200 --> 09:21:02,200
非常相似，也很容易理解

13213
09:21:00,080 --> 09:21:04,080
嗯，至少对于 Python 相关的内容来说，所以我

13214
09:21:02,200 --> 09:21:05,840
意思是你可能已经写好了

13215
09:21:04,080 --> 09:21:07,840
你已经有一些 PyTorch 相关的（内容）了，或者至少你…… 

13216
09:21:05,840 --> 09:21:09,480
明白，就像你知道的那些基础知识一样。

13217
09:21:07,840 --> 09:21:11,680
线性层，没错，你可能

13218
09:21:09,480 --> 09:21:14,560
已经明白了，所以我们现在所做的…… 

13219
09:21:11,680 --> 09:21:16,000
实际上在这一个里所做的，而这是

13220
09:21:14,560 --> 09:21:18,960
我最初要演示的是

13221
09:21:16,000 --> 09:21:22,680
我们只是，呃，我们真的只是

13222
09:21:18,960 --> 09:21:24,800
从头开始使用……训练一个MNIST多层感知机

13223
09:21:22,680 --> 09:21:28,840
基础的 PyTorch （此处可能原表述有误，推测是 PyTorch），所以我导入所有内容

13224
09:21:24,800 --> 09:21:31,720
最初，就像时间、麻木、火炬，对吧

13225
09:21:28,840 --> 09:21:34,400
呃，数据加载器和torchvision库

13226
09:21:31,720 --> 09:21:38,276
对于数据集本身，呃，这是……（这里“mest”可能是拼写错误，不太能准确表意） 

13227
09:21:34,400 --> 09:21:41,276
我们在这里指定混合参数，所以，嗯

13228
09:21:38,276 --> 09:21:43,080
你知道学习率，呃，批量大小

13229
09:21:41,276 --> 09:21:44,400
轮数 我觉得好像有一个……

13230
09:21:43,080 --> 09:21:47,720
这里多了一个，我不知道为什么会这样。

13231
09:21:44,400 --> 09:21:50,040
嗯，你知道的，就像火车的尺寸那样

13232
09:21:47,720 --> 09:21:51,436
训练集中元素的数量以及

13233
09:21:50,040 --> 09:21:54,520
然后我们要去调整这个

13234
09:21:51,436 --> 09:21:54,520
数据目录

13235
09:21:58,520 --> 09:22:02,320
呃，把这个打印出来就行。

13236
09:22:05,320 --> 09:22:12,436
实际上采取；实际上拿取 

13237
09:22:08,560 --> 09:22:12,436
将它注入到……

注：你提供的内容不完整，这可能不是完整的表达。“inject... into...”是“把……注入到……”的意思。 

13238
09:22:13,160 --> 09:22:19,916
在这里，然后我们将执行斜杠 SL Python 所有操作 

13239
09:22:18,120 --> 09:22:24,680
对；没错；好的

13240
09:22:19,916 --> 09:22:27,000
现在，呃，当然是关于 SL 数据，为什么呢

13241
09:22:24,680 --> 09:22:29,040
现在不行
这是为了确保

13242
09:22:27,000 --> 09:22:31,520
我们正在使用TF32，所以这将会用到

13243
09:22:29,040 --> 09:22:33,200
张量核心，让一切变得非常快速

13244
09:22:31,520 --> 09:22:35,040
嗯，这将初始化数据。

13245
09:22:33,200 --> 09:22:37,160
适当地设定，就像你知道的那样，意味着以及

13246
09:22:35,040 --> 09:22:39,400
标准差，嗯，这只是一种类型

13247
09:22:37,160 --> 09:22:41,200
关于菜单的最佳、最佳实践

13248
09:22:39,400 --> 09:22:43,840
所以这里的很多内容，我有点只是……

13249
09:22:41,200 --> 09:22:46,680
接着，呃，一些样板代码

13250
09:22:43,840 --> 09:22:49,400
模板示例之类的东西，呃

13251
09:22:46,680 --> 09:22:51,640
现在我们再往下走，并且

13252
09:22:49,400 --> 09:22:54,880
你知道的，我们初始化了我们的数据

13253
09:22:51,640 --> 09:22:57,436
集合，我们初始化我们的加载器，我们加载

13254
09:22:54,880 --> 09:22:59,360
在所有的数据中，呃，而且我们有这个

13255
09:22:57,436 --> 09:23:02,560
存在于 CPU 上，所以注意我们是如何没有……

13256
09:22:59,360 --> 09:23:04,160
做，嗯，设备等于CUDA还是使用CUDA

13257
09:23:02,560 --> 09:23:09,560
然而我们并没有那么做，就是这样，就是这个情况 

13258
09:23:04,160 --> 09:23:14,720
只是存在于 CPU 上，对吧，呃，也就是系统随机存取存储器

13259
09:23:09,560 --> 09:23:18,276
所以我们把所有行李装上火车，然后上车

13260
09:23:14,720 --> 09:23:19,800
对 我们的测试数据中有很多 我们……

注：原英文句子表述不太符合常规语法逻辑，以上是尽量逐词翻译的结果。 

13261
09:23:18,276 --> 09:23:22,800
只是在每一步打印一些内容

13262
09:23:19,800 --> 09:23:25,560
这里是每个轮次的数据，所以每个轮次我们有……

13263
09:23:22,800 --> 09:23:27,800
打算进行规模为 10000 的训练

13264
09:23:25,560 --> 09:23:30,640
除以批量大小，在这种情况下

13265
09:23:27,800 --> 09:23:32,480
是四，所以大概会是 2500

13266
09:23:30,640 --> 09:23:36,000
每个训练轮次的迭代次数，并且我们打算

13267
09:23:32,480 --> 09:23:39,080
呃，涉及三个不同的时代，所以

13268
09:23:36,000 --> 09:23:42,276
7500呃，步

13269
09:23:39,080 --> 09:23:44,240
现在总计，我们再往下看，然后我们有

13270
09:23:42,276 --> 09:23:47,880
其本身的实际架构

13271
09:23:44,240 --> 09:23:49,200
对，嗯，所以我们接收一个 X

13272
09:23:47,880 --> 09:23:53,276
哪个是我们的，哪个是我们的输入，我们

13273
09:23:49,200 --> 09:23:56,160
将其重塑为批量大小乘以 784 的形状

13274
09:23:53,276 --> 09:23:59,800
嗯，我们先做第一层，再做第二层。

13275
09:23:56,160 --> 09:24:02,520
第三个右拐，所以它就像一号垫子一样

13276
09:23:59,800 --> 09:24:05,276
激活M2，并且其组织形式如下

13277
09:24:02,520 --> 09:24:06,800
比如，嗯，在特性方面，隐藏特性

13278
09:24:05,276 --> 09:24:08,640
隐藏的 隐藏的功能，然后是那

13279
09:24:06,800 --> 09:24:12,560
输出维度或数量

13280
09:24:08,640 --> 09:24:15,916
呃，在我们的课程里，我们把……设置成了特定功能（这里“in feature set to”表述不完整，只能大致按语义推测翻译） 

13281
09:24:12,560 --> 09:24:20,916
784 所以，呃，这样的话就会像

13282
09:24:15,916 --> 09:24:24,160
呃，我喜欢按……批次大小来说，批次大小是

13283
09:24:20,916 --> 09:24:28,040
X 然后重量将是 784

13284
09:24:24,160 --> 09:24:29,276
乘以256，对，所以就是那样。 

13285
09:24:28,040 --> 09:24:31,520
这就是它的样子，它将会……

13286
09:24:29,276 --> 09:24:33,000
乘以这个线性层，然后

13287
09:24:31,520 --> 09:24:34,160
我们将举行一场集会，它即将举行

注：原英文表述从语义完整性来看似乎不太完整，这里尽量按原文格式和内容进行了翻译。 

13288
09:24:33,000 --> 09:24:35,720
而且它接下来要走那条路了。（注：“Rue”一般是法语“街道”的意思，这里由于缺乏更多语境，这样翻译供参考 ） 

13289
09:24:34,160 --> 09:24:36,840
关于它的激活，你可以去搜索一下。

13290
09:24:35,720 --> 09:24:40,560
如果你还不知道那是什么

13291
09:24:36,840 --> 09:24:42,840
理解这个是非常非常基础的，嗯

13292
09:24:40,560 --> 09:24:45,756
实际上它仅仅是一个

13293
09:24:42,840 --> 09:24:48,480
图表以及在……里。线性的，同样的概念，我们正在…… 

13294
09:24:45,756 --> 09:24:50,520
打算用上一批（物料、批次等，需结合具体语境确定“batch”所指）

13295
09:24:48,480 --> 09:24:52,320
按隐藏特征进行分类，我们打算…… 

13296
09:24:50,520 --> 09:24:53,680
将其乘以一个隐藏特征

13297
09:24:52,320 --> 09:24:55,916
按类别数量划分特征，然后我们继续

13298
09:24:53,680 --> 09:24:57,480
最终得到按类别数量划分的 B，对吧？

13299
09:24:55,916 --> 09:25:01,080
B 通过输出维度，输出你想要的任何内容

13300
09:24:57,480 --> 09:25:02,800
可以这么说，而且我们的想法就是……

13301
09:25:01,080 --> 09:25:04,160
只是想进退往复

13302
09:25:02,800 --> 09:25:06,360
在其中传播并形成（这里“making the”表述不太完整，可能后面还有内容）

13303
09:25:04,160 --> 09:25:07,880
更明智地组网，我们要向前推进了 

13304
09:25:06,360 --> 09:25:10,400
并将模型转移到

13305
09:25:07,880 --> 09:25:12,840
卡达（此处“Cuda”可能有误，若为“Cuda”一般指英伟达的并行计算平台和编程模型，这里按字面音译；若有其他上下文可调整），我们打算……我们能行，我们能做到

13306
09:25:10,400 --> 09:25:13,960
为更快的版本进行编译，但是

13307
09:25:12,840 --> 09:25:15,680
我们不会仅仅因为那个原因就那么做。

13308
09:25:13,960 --> 09:25:18,916
这好像要多花一点额外的时间

13309
09:25:15,680 --> 09:25:21,596
要做到那一点，嗯，我们打算用交叉法

13310
09:25:18,916 --> 09:25:24,040
整个过程的熵轻量级服务器（这里“lws”可能是“Lightweight Web Server”等特定术语的缩写，需结合具体语境确定准确含义）



13311
09:25:21,596 --> 09:25:28,756
这里的项目交叉熵损失是是

13312
09:25:24,040 --> 09:25:31,276
至关重要的是，呃，要理解

13313
09:25:28,756 --> 09:25:33,000
嗯，我打算回顾一下其中的一些内容，就像

注：原句“as”之后内容不完整，此译文按已有内容进行。 

13314
09:25:31,276 --> 09:25:34,360
嗯，要是这个不行的话，别担心。

13315
09:25:33,000 --> 09:25:36,480
有道理，不过我们会喜欢……

13316
09:25:34,360 --> 09:25:37,916
直接用 C 语言来写这个，所以别担心。

13317
09:25:36,480 --> 09:25:39,880
如果这不完全说得通，我（这里句子未完整，可能还有后续内容）

13318
09:25:37,916 --> 09:25:42,040
只是给你大致介绍一下，就像

注：你提供的内容似乎不完整，可能存在信息缺失。若有完整内容可继续让我翻译。 

13319
09:25:39,880 --> 09:25:43,480
去喜欢一切事物所基于的东西

13320
09:25:42,040 --> 09:25:45,720
我们将使用随机梯度

13321
09:25:43,480 --> 09:25:47,960
下降，所以那只是你的字面意思（表述不太通顺，需结合更多语境来准确理解）

13322
09:25:45,720 --> 09:25:50,480
你的优化器，所以它接下来只会

13323
09:25:47,960 --> 09:25:52,596
轻推一下，呃，你知道的，当你计算的时候

13324
09:25:50,480 --> 09:25:55,596
比如一个梯度或者那个 S 形曲线，所以出现了误差

13325
09:25:52,596 --> 09:25:58,680
对于给定的重量，呃，它将会仅仅

13326
09:25:55,596 --> 09:26:01,200
实际上就是用学习率乘以那个（值）。

13327
09:25:58,680 --> 09:26:03,040
然后从……中减去那个结果

13328
09:26:01,200 --> 09:26:07,400
从实际重量来看

13329
09:26:03,040 --> 09:26:09,560
就其本身而言，呃，从某种意义上来说是随机速率

13330
09:26:07,400 --> 09:26:12,840
听起来有，呃，有点复杂，但它……

13331
09:26:09,560 --> 09:26:16,080
不，没那么糟，呃，然后我们

13332
09:26:12,840 --> 09:26:18,000
我们的训练循环就在这里，嗯，还有

13333
09:26:16,080 --> 09:26:20,880
我会 我会 我会再详细说说

13334
09:26:18,000 --> 09:26:23,756
确切地说，这在……之中意味着什么

13335
09:26:20,880 --> 09:26:25,640
马上就来一个 NumPy 脚本，不过……

13336
09:26:23,756 --> 09:26:28,596
重要的是，我们有点……

13337
09:26:25,640 --> 09:26:31,200
明白，呃，这个样板文件，这是

13338
09:26:28,596 --> 09:26:33,120
设计得相当简约

13339
09:26:31,200 --> 09:26:37,120
嗯，只是大致配合一下我们正在做的事情

13340
09:26:33,120 --> 09:26:38,520
其他任何地方，呃，是的，我不是（那样）。 

13341
09:26:37,120 --> 09:26:40,720
不过也不想对此过多强调

13342
09:26:38,520 --> 09:26:45,360
我们接着来运行这个，呃，就……就（这样）

13343
09:26:40,720 --> 09:26:48,240
只是为了好玩，你知道的，把光盘放进去

13344
09:26:45,360 --> 09:26:50,000
我们将以 Python 作为参考，并且

13345
09:26:48,240 --> 09:26:51,840
实际上，这将会做的是……它是

13346
09:26:50,000 --> 09:26:54,240
只是打算安装我们的Nness数据，所以

13347
09:26:51,840 --> 09:26:57,240
注意我们是如何在 Python 数据中获取它的

13348
09:26:54,240 --> 09:26:57,240
目录；名录；指南；电话号码簿；公司名录；地址录；董事会；（计算机文件或程序的）目录

13349
09:26:59,276 --> 09:27:05,040
嗯，太棒了，现在它正在初始化。

13350
09:27:02,040 --> 09:27:07,960
一切都在加载所有的数据，嗯

13351
09:27:05,040 --> 09:27:11,480
所以我们可以看到，这就是学习结束了 

13352
09:27:07,960 --> 09:27:13,880
三个时期，每个时期总共25200，并且我们

13353
09:27:11,480 --> 09:27:16,960
最终得到的平均批次准确率为

13354
09:27:13,880 --> 09:27:19,120
90%，这真的很不错，所以当它是……的时候

13355
09:27:16,960 --> 09:27:20,916
对那些数字进行分类，它正在做这件事

13356
09:27:19,120 --> 09:27:23,360
大约每10次猜测中有n次

13357
09:27:20,916 --> 09:27:25,400
没错，这真的很不错，呃，而且我们

13358
09:27:23,360 --> 09:27:30,200
从这里的损失就能看出来，对吧，这个…… 

13359
09:27:25,400 --> 09:27:33,000
损失是如果我把这个往上移，我们的损失…… 

13360
09:27:30,200 --> 09:27:36,480
从你知道的开始，加载一切

13361
09:27:33,000 --> 09:27:39,680
从大约2.38的亏损开始，这

13362
09:27:36,480 --> 09:27:43,560
如果我们打开……如果我们打开 Chrome 浏览器

13363
09:27:39,680 --> 09:27:46,960
从阿尔法出发前往沃尔，只是为了

13364
09:27:43,560 --> 09:27:49,080
比如提供一个参考

13365
09:27:46,960 --> 09:27:53,240
嗯

13366
09:27:49,080 --> 09:27:56,360
-2的指数。是这样吗

13367
09:27:53,240 --> 09:28:02,040
2.38，如果是这样的话，那大约是0.92 

13368
09:27:56,360 --> 09:28:04,320
我们向下取整，然后说 -2.3 大约是呃

13369
09:28:02,040 --> 09:28:06,916
0.1 如果你把它转换为一个……（这里原文不完整） 

13370
09:28:04,320 --> 09:28:08,840
准确率大约是 10%，这……

13371
09:28:06,916 --> 09:28:11,360
这正是我们想要的，他们……他们的

13372
09:28:08,840 --> 09:28:13,800
图像排列方式或者标签是

13373
09:28:11,360 --> 09:28:16,436
在零和N9之间，所以像零这样

13374
09:28:13,800 --> 09:28:19,160
实际上，那里有 10 个数值，所以

13375
09:28:16,436 --> 09:28:20,640
在初始化时应该有 10%

13376
09:28:19,160 --> 09:28:23,240
因为有答对一个的可能性

13377
09:28:20,640 --> 09:28:24,640
它是随机初始化的，对，对，嗯

13378
09:28:23,240 --> 09:28:27,840
而这正是我们想要的

13379
09:28:24,640 --> 09:28:32,720
那里的一切都已正确初始化。

13380
09:28:27,840 --> 09:28:34,916
嗯，现在在我真正开始讲……之前

13381
09:28:32,720 --> 09:28:36,560
像NumPy那样的NumPy实现就像是

13382
09:28:34,916 --> 09:28:39,720
拿着P火炬，然后看着，就像在想“这是什么”

13383
09:28:36,560 --> 09:28:41,916
见鬼，那是在幕后做的事，嗯，只是

13384
09:28:39,720 --> 09:28:43,916
有点像从头开始的方法，我

13385
09:28:41,916 --> 09:28:48,200
建议你暂停视频

13386
09:28:43,916 --> 09:28:51,040
现在就来看看，嗯，安德烈·卡尔波的……

13387
09:28:48,200 --> 09:28:52,640
微指南视频，所以他制作了这个微（视频） 

13388
09:28:51,040 --> 09:28:55,160
大约两年前的指南视频，它是

13389
09:28:52,640 --> 09:28:57,240
做得非常非常好，而且真的

13390
09:28:55,160 --> 09:28:58,840
只是解释了“后面”“背部”“回去”等“back”这个概念（需结合具体语境确定“back”准确含义） 

13391
09:28:57,240 --> 09:29:01,560
标量层面的传播

13392
09:28:58,840 --> 09:29:03,240
价值观，所以在这个里面我们正在使用呃

13393
09:29:01,560 --> 09:29:06,480
我们正在对……使用反向传播算法

13394
09:29:03,240 --> 09:29:09,276
张量的层级，但理解这一点

13395
09:29:06,480 --> 09:29:12,360
呃，这对于提升张量的维度至关重要。 

13396
09:29:09,276 --> 09:29:13,916
所以在你完成这件事之后，而且它是

13397
09:29:12,360 --> 09:29:15,720
还是有点不太明白关于……

13398
09:29:13,916 --> 09:29:18,040
我们要怎么把这个提升到类似……的程度呢

13399
09:29:15,720 --> 09:29:20,596
对于更大的矩阵，我建议那……

注：原文此句不完整，以上翻译是根据现有内容结合语境推测的大致表述。 

13400
09:29:18,040 --> 09:29:22,240
你，呃，也看一下我的后背。

13401
09:29:20,596 --> 09:29:24,560
宣传视频，这只是关于我的 

13402
09:29:22,240 --> 09:29:27,756
这里是YouTube频道，埃利奥特编程，嗯

13403
09:29:24,560 --> 09:29:31,320
目前大约有5700名订阅者 

13404
09:29:27,756 --> 09:29:33,720
你应该能找到我，嗯，还有我

13405
09:29:31,320 --> 09:29:35,596
只是想了个有点搞笑的标题，嗯

13406
09:29:33,720 --> 09:29:37,680
因为反向传播很烦人，以至于…… （原句不完整，此为结合常见语境推测的表述）

13407
09:29:35,596 --> 09:29:40,756
有时能理解，所以我，我做了一个我

注：你提供的文本似乎并不完整或存在表述不清晰的问题，但我按照要求进行了翻译。 

13408
09:29:37,680 --> 09:29:42,640
尽力做好我的工作来剖析，呃

13409
09:29:40,756 --> 09:29:44,916
这到底在“在……上”这件事上意味着什么鬼啊

13410
09:29:42,640 --> 09:29:48,520
白板上张量的级别 嗯

13411
09:29:44,916 --> 09:29:50,756
这个确实有，这个确实有，呃，1440p分辨率

13412
09:29:48,520 --> 09:29:54,040
质量，这样你实际上可以，你可以，你……（这段英文表述不太完整和清晰，翻译可能存在表意不确切的情况） 

13413
09:29:50,756 --> 09:29:55,560
能看到一些东西，嗯，不过没错，然后在那儿

13414
09:29:54,040 --> 09:29:56,720
就有超多的内容。

13415
09:29:55,560 --> 09:29:58,240
你可以看，没错，我不（能看/想看等，需结合语境确定具体含义）

13416
09:29:56,720 --> 09:30:00,360
鼓励你把所有的都消费掉

13417
09:29:58,240 --> 09:30:02,480
外面的内容，但这些是

13418
09:30:00,360 --> 09:30:04,720
三个，我觉得是最简单的，呃

13419
09:30:02,480 --> 09:30:06,880
去培养一种关于什么是“回”（此处back含义需结合上下文确定）的直觉

13420
09:30:04,720 --> 09:30:09,360
传播嘛，我们接下来要探讨的是…… （注：原英文句子似乎不完整，这样的翻译只是尽量表意通顺） 

13421
09:30:06,880 --> 09:30:10,276
也在回顾反向传播，嗯

13422
09:30:09,360 --> 09:30:13,160
但这个

13423
09:30:10,276 --> 09:30:15,560
呃，这是你想去的地方吗？ 

13424
09:30:13,160 --> 09:30:18,756
从如果这就像一个完全……开始

13425
09:30:15,560 --> 09:30:22,756
这对你来说是个陌生的概念 嗯 那么……安特拉罗伊（“Entre aroy”可能并不是正确英文表达，疑似拼写有误） 

13426
09:30:18,756 --> 09:30:26,436
我真的做得很好 我超越了安德烈·阿尔波

13427
09:30:22,756 --> 09:30:27,960
嗯，先讲课，然后讲到张量，接着

13428
09:30:26,436 --> 09:30:29,040
三个蓝色和棕色的，你已经……（这里原文表述不完整）

13429
09:30:27,960 --> 09:30:32,520
可能听说过

13430
09:30:29,040 --> 09:30:35,276
已经 呃 做 做一个 一个快速的 小的

13431
09:30:32,520 --> 09:30:37,480
关于……关于反向传播的讲座

13432
09:30:35,276 --> 09:30:38,480
直观地说，那么让我们行动起来，跳吧。 

13433
09:30:37,480 --> 09:30:41,640
进入；到……里面

13434
09:30:38,480 --> 09:30:43,756
NumPy 好极了，那么现在，呃，咱们开始吧。

13435
09:30:41,640 --> 09:30:45,800
阿哈德，来看看究竟是什么

13436
09:30:43,756 --> 09:30:48,000
这个图表应该是，嗯，我

13437
09:30:45,800 --> 09:30:51,276
我能走过去然后稍微……

13438
09:30:48,000 --> 09:30:52,680
就像解释一下到底发生了什么呃

13439
09:30:51,276 --> 09:30:54,916
就像实际上正在发生的事情一样

13440
09:30:52,680 --> 09:30:56,520
在这里一步一步来，但首先我想

13441
09:30:54,916 --> 09:30:57,880
让这一点变得明显，我们的神经网络是如何……（此处句子似乎不完整）

13442
09:30:56,520 --> 09:30:59,960
建筑是如何构建的以及

13443
09:30:57,880 --> 09:31:02,320
神经元实际上是如何工作的呢，什么是……

13444
09:30:59,960 --> 09:31:06,360
神经元，诸如此类的东西

13445
09:31:02,320 --> 09:31:07,520
嗯，所以我画了这个小示意图来帮忙。

13446
09:31:06,360 --> 09:31:09,640
让我们了解正在发生的事情，而且我是

13447
09:31:07,520 --> 09:31:11,880
把这个摆在这里，这样我们

13448
09:31:09,640 --> 09:31:14,916
本质上就是取一张图片，这是，呃

13449
09:31:11,880 --> 09:31:16,080
手写数字
它是28×28的，并且

13450
09:31:14,916 --> 09:31:17,960
我们将批量处理这个。

13451
09:31:16,080 --> 09:31:20,160
好的，那么它将是 28 乘 28，并且

13452
09:31:17,960 --> 09:31:22,916
那么深度就是我们的批次，批次大小你（这里原文表述不太符合常规英文语法和表达逻辑，翻译可能不太通顺） 

13453
09:31:20,160 --> 09:31:26,000
可以说，嗯，就是一堆窗格

13454
09:31:22,916 --> 09:31:28,800
本质上是相互叠加的

13455
09:31:26,000 --> 09:31:30,596
我们把这些（图像）展平，所以是 28 * 28，这就意味着…… 

13456
09:31:28,800 --> 09:31:32,120
将要拥有这整个……

你提供的内容似乎不太完整或表述不太清晰，如果还有后续内容或需要进一步完善翻译，请随时补充。 

13457
09:31:30,596 --> 09:31:33,756
图像，然后我们要选取一行，并且

13458
09:31:32,120 --> 09:31:35,120
我们只是打算把它加到末尾。

13459
09:31:33,756 --> 09:31:37,400
直到它完全伸展

13460
09:31:35,120 --> 09:31:40,240
长度方面，会有28行这样的（东西） 

13461
09:31:37,400 --> 09:31:42,276
那些被添加到右边边缘以及

13462
09:31:40,240 --> 09:31:46,640
然后我们把这个代入第一个（式子）

13463
09:31:42,276 --> 09:31:52,916
权重，所以 X1 乘以 W1，那将会是 b b

13464
09:31:46,640 --> 09:31:53,880
用 784 除，所以 B 除以 784，然后乘以 784

13465
09:31:52,916 --> 09:31:58,240
通过；被；由；在……旁边；在……之前；按照；以……计；经过；在……期间

因这里“by”没有具体语境，它有多个常见释义，以上为较常见的释义列举 。如果“by”处于特定句子中，可提供完整句子以获得更准确合适的翻译。 

13466
09:31:53,880 --> 09:32:01,080
256 所以一列呃，那个大小

13467
09:31:58,240 --> 09:32:04,360
权重矩阵中某一列的元素数量是784

13468
09:32:01,080 --> 09:32:06,720
然后 X 中一行的长度是

13469
09:32:04,360 --> 09:32:08,360
还有784，所以它会层层叠加。

13470
09:32:06,720 --> 09:32:10,720
在那些之中的顶部；那些当中最重要的
注：由于“top of those”单独出现语义较模糊，需结合上下文准确理解其含义。上述翻译仅为常见理解。 

13471
09:32:08,360 --> 09:32:13,960
对，嗯，我们最终会得到

13472
09:32:10,720 --> 09:32:15,640
P除以256，然后我们处理下一个，并且

13473
09:32:13,960 --> 09:32:16,916
我们明白这一点，本质上我们只是投喂（这里“feed”根据语境可能有不同更合适的表达，需结合更多内容确定，目前按字面译） 

13474
09:32:15,640 --> 09:32:18,680
穿过这条街，所以它将会…… 

13475
09:32:16,916 --> 09:32:21,480
只是它会进行这场集会。

13476
09:32:18,680 --> 09:32:24,360
对每个值执行函数，相当简单

13477
09:32:21,480 --> 09:32:26,800
然后我们计算 X2 乘以 W2，这将……

13478
09:32:24,360 --> 09:32:28,916
将 B 除以从“ The ”输出的 256 （这里原文“The”表述可能不完整，推测意思是这样） 

13479
09:32:26,800 --> 09:32:32,200
鲁伊，它要对那个进行矩阵乘法运算了。

13480
09:32:28,916 --> 09:32:34,720
256 乘以 10
10 是我们的输出尺寸

13481
09:32:32,200 --> 09:32:37,596
对，所以我们有这个由海登（Headden 可能音译为海登）设计的 B 尺寸的（物品，这里因缺少语境不确定“this B”具体是什么东西） 

13482
09:32:34,720 --> 09:32:39,840
也就是 256，嗯，这是每……这是每……

13483
09:32:37,596 --> 09:32:42,120
神经元输出，那，那，呃，那是…… 

13484
09:32:39,840 --> 09:32:46,040
本质上我们有多少个……神经元

13485
09:32:42,120 --> 09:32:48,880
256 是在我们的隐藏层里吗

13486
09:32:46,040 --> 09:32:51,596
就在那时那地，我们只需确保

13487
09:32:48,880 --> 09:32:53,320
确保广播工作正确无误，这样

13488
09:32:51,596 --> 09:32:56,160
呃，我是说你随时都可以，你可以突然出现

13489
09:32:53,320 --> 09:32:58,436
转向像 PyTorch 这样的（工具）呃

13490
09:32:56,160 --> 09:33:01,560
广播 广播节目；广播（行为）

13491
09:32:58,436 --> 09:33:03,080
这里的规则广播语义，所以

13492
09:33:01,560 --> 09:33:05,116
这基本上就是你现在的样子

13493
09:33:03,080 --> 09:33:06,960
被允许去做类似乘法运算之类的事情，还有……

13494
09:33:05,116 --> 09:33:10,400
当张量处于（某种状态）时对它们进行运算

13495
09:33:06,960 --> 09:33:12,080
特定的尺寸，没错，所以，嗯，你知道如果

13496
09:33:10,400 --> 09:33:14,400
你还没有经历过这个呢

13497
09:33:12,080 --> 09:33:17,200
这——这可能是个好主意，嗯，这是

13498
09:33:14,400 --> 09:33:19,360
学习 PyTor （可能是 PyTorch 拼写有误）并不太难，它能处理这个。 

13499
09:33:17,200 --> 09:33:21,360
东西整理得相当好了，所以只是有一点点（问题之类，需结合语境） 

13500
09:33:19,360 --> 09:33:22,560
短短地读一下，就为了做那种……

13501
09:33:21,360 --> 09:33:24,596
明白那里正在发生什么事

13502
09:33:22,560 --> 09:33:25,960
但是，嗯，本质上你只是想制作

13503
09:33:24,596 --> 09:33:27,160
当然，那些内在价值观是相同的，并且

13504
09:33:25,960 --> 09:33:29,960
那么外面的那些将是你的

13505
09:33:27,160 --> 09:33:33,596
输出形状，没错，所以我们有这个 B

13506
09:33:29,960 --> 09:33:35,596
将这个B乘以256，然后就是这里的这个256

13507
09:33:33,596 --> 09:33:38,240
将要 它将要做

13508
09:33:35,596 --> 09:33:39,916
产品 它将对每一列进行操作

13509
09:33:38,240 --> 09:33:43,720
并且在那里生产产品，然后你打算

13510
09:33:39,916 --> 09:33:47,240
最终总共得到呃 10 个值用于

13511
09:33:43,720 --> 09:33:50,360
每一个批量元素，没错，这就是

13512
09:33:47,240 --> 09:33:53,960
本质上，呃，这里的这个 10 是

13513
09:33:50,360 --> 09:33:56,596
一个概率分布，所以概率

13514
09:33:53,960 --> 09:34:00,040
批量概率分布以及

13515
09:33:56,596 --> 09:34:02,880
在一批里，嗯，那些将会…… 

13516
09:34:00,040 --> 09:34:05,560
成为我们关于……的预测概率

13517
09:34:02,880 --> 09:34:08,000
它是哪个数字，所以如果屏幕显示

13518
09:34:05,560 --> 09:34:10,400
像个零

注：在常见语境中，“像个零”可能表达“像个无足轻重的人；像个毫无价值的事物” 。 

13519
09:34:08,000 --> 09:34:13,480
嗯，那么在我们……之后会发生什么呢？ 

13520
09:34:10,400 --> 09:34:16,560
如果我们继续，网络真的很智能。

不过你提供的英文句子语序似乎比较混乱，可能存在一些表述问题。若你能提供更准确的原文，翻译效果会更好。 

13521
09:34:13,480 --> 09:34:18,916
要说任何一批元素，所以任何任何

13522
09:34:16,560 --> 09:34:21,720
本质上是一排，然后我们到第一个

13523
09:34:18,916 --> 09:34:22,756
那个带索引的零，嗯，那是……

13524
09:34:21,720 --> 09:34:24,436
很有可能会是最高的

13525
09:34:22,756 --> 09:34:27,240
整个分布中的数字，对吧

13526
09:34:24,436 --> 09:34:29,040
那差不多就是那边正在发生的情况，嗯，还有

13527
09:34:27,240 --> 09:34:30,720
然后我们只需对……执行一个损失函数操作

13528
09:34:29,040 --> 09:34:32,840
这被称为交叉熵损失，它

（注：原英文句子不完整，“which”引导的从句未结束。这里只能按原文呈现翻译内容并保留不完整状态。） 

13529
09:34:30,720 --> 09:34:35,720
我马上解释，CR十字

13530
09:34:32,840 --> 09:34:37,240
熵损失不算太糟，嗯，它是

13531
09:34:35,720 --> 09:34:38,756
与均方误差（MSE）损失不同，但它更好

13532
09:34:37,240 --> 09:34:41,400
对于批次以及我们正在做的这类事情

13533
09:34:38,756 --> 09:34:43,720
这里，嗯

13534
09:34:41,400 --> 09:34:44,960
所以我们得到了我们的损失，最初它是

13535
09:34:43,720 --> 09:34:48,116
会在附近；会在周围；会在身边（根据具体语境可能有不同更贴合的表达） 

13536
09:34:44,960 --> 09:34:50,320
2.3 微米，基于源自阿尔法的工作波长（这里“wol”推测是“working optical wavelength”的缩写，需结合具体语境） 

13537
09:34:48,116 --> 09:34:53,480
从阿尔法计算方面来看你在W狼（这里“W wol”可能存在拼写错误，推测可能是有其他准确表述）上……

注：原英文表述可能有误，导致翻译较难呈现精准且通顺的结果。 

13538
09:34:50,320 --> 09:34:57,596
在你去的地方就能做到，呃，就像

13539
09:34:53,480 --> 09:35:00,320
对负的，呃，负X进行指数运算，所以

13540
09:34:57,596 --> 09:35:03,800
嗯，对 -2.3 进行指数运算，你会得到

13541
09:35:00,320 --> 09:35:06,080
那个大概是 0.1，嗯，也就是 10%

13542
09:35:03,800 --> 09:35:08,320
精度，然后求导数

13543
09:35:06,080 --> 09:35:09,800
即将到来的损失

13544
09:35:08,320 --> 09:35:12,360
本质上是逐元素相减

13545
09:35:09,800 --> 09:35:13,916
将softmax概率与真实概率进行比较（注：原英文表意不太完整准确，“by the true one”这里推测是和真实概率对比的意思）

如果原英文准确表述为“compare softmax probabilities by the true one” ，那么完整译文就是：
将softmax概率与真实概率进行比较 

13546
09:35:12,360 --> 09:35:16,560
热门概率，我会对这些进行解释。

13547
09:35:13,916 --> 09:35:17,916
同样，“独热编码”是什么意思，然后我们

13548
09:35:16,560 --> 09:35:19,320
只需进行反向传播，对吧，所以这是

13549
09:35:17,916 --> 09:35:22,116
这里有点像前向传播，在这个过程中我们

13550
09:35:19,320 --> 09:35:24,960
去，嗯，马特一号（由于“um”常为语气词，“matl”可能是拼写错误，推测是人名“马特”等情况，这里按大致逻辑翻译） 

13551
09:35:22,116 --> 09:35:28,240
激活 M2
计算损失以及

13552
09:35:24,960 --> 09:35:30,116
然后我们朝这个方向往回走，嗯，所以我们这样做

13553
09:35:28,240 --> 09:35:32,040
损失的导数 导数以及

13554
09:35:30,116 --> 09:35:35,596
然后我们进行连锁回滚

13555
09:35:32,040 --> 09:35:37,480
传播，所以我们计算 dw2 以及

13556
09:35:35,596 --> 09:35:39,960
那只是……要记住

13557
09:35:37,480 --> 09:35:42,360
权重的梯度应该是

13558
09:35:39,960 --> 09:35:46,596
以匹配重物本身的形状

13559
09:35:42,360 --> 09:35:49,960
注意这里的 W2 是 26256 行 10 列的情况。 

13560
09:35:46,596 --> 09:35:52,160
在这里我们进行 256 倍的 B 矩阵运算，将 B 与……相乘（原句“matal”可能拼写错误，推测是“multiply”） 

13561
09:35:49,960 --> 09:35:56,200
10 这样我们最终得到了这些维度

13562
09:35:52,160 --> 09:35:58,916
256乘以10，然后结果是相符的，嗯，接着我们

13563
09:35:56,200 --> 09:36:01,040
进行 dx2，这是你所需要的，你知道的

13564
09:35:58,916 --> 09:36:04,276
持续地反向传播 反向传播

13565
09:36:01,040 --> 09:36:07,080
穿过鲁埃外层嗯，所以在这里

13566
09:36:04,276 --> 09:36:08,916
实际上只是取 dx2 然后

13567
09:36:07,080 --> 09:36:10,756
然后，呃，进行逐元素操作

13568
09:36:08,916 --> 09:36:13,400
与……相乘，与……相乘

13569
09:36:10,756 --> 09:36:16,320
所以，X的r函数的导数

13570
09:36:13,400 --> 09:36:17,756
不管是什么，不管是什么，呃，输入内容

13571
09:36:16,320 --> 09:36:19,756
热衷于；对……感兴趣；喜欢

13572
09:36:17,756 --> 09:36:22,360
那样的话，最后我们会得到相同的结果

13573
09:36:19,756 --> 09:36:25,160
我们在这里得到的形状，我们只需代入

13574
09:36:22,360 --> 09:36:26,436
我们把这个数值代入到两个（式子）中

13575
09:36:25,160 --> 09:36:28,320
这些我们实际上并不需要去做。

13576
09:36:26,436 --> 09:36:29,880
对于DX1，但它就只是在这里而已

13577
09:36:28,320 --> 09:36:33,160
万一，万一你有那种更深入的…… 

13578
09:36:29,880 --> 09:36:34,160
网络，并且你想修改一些东西，嗯

13579
09:36:33,160 --> 09:36:38,640
但是

13580
09:36:34,160 --> 09:36:42,160
dw1 这将会非常 x x1。t 没错，所以

13581
09:36:38,640 --> 09:36:43,840
我们正在对 X1 进行转置，X1 在这里，所以

13582
09:36:42,160 --> 09:36:47,480
只是翻转那些，翻转那些

13583
09:36:43,840 --> 09:36:52,080
尺寸不是 B 乘以 784

13584
09:36:47,480 --> 09:36:54,276
现在将会是，嗯，784 除以 B，所以你

13585
09:36:52,080 --> 09:36:57,560
每一列都是一张图像，对吧

13586
09:36:54,276 --> 09:37:01,240
不是让每一行代表一张图像

13587
09:36:57,560 --> 09:37:03,276
嗯，我们将其与B按256进行映射，这……

13588
09:37:01,240 --> 09:37:07,240
是Rue的输出，所以那就像是…… 

13589
09:37:03,276 --> 09:37:11,360
最后一个输出，呃，梯度，嗯，然后

13590
09:37:07,240 --> 09:37:15,000
我们把我们的体重数值弄对了。

13591
09:37:11,360 --> 09:37:18,320
所以，呃，从这里开始我们基本上

13592
09:37:15,000 --> 09:37:20,080
只是，呃，修改一下权重值，我们

13593
09:37:18,320 --> 09:37:22,160
在那里得到相同的形状，所以那种…… 

13594
09:37:20,080 --> 09:37:23,916
经核查情况属实；检查通过

13595
09:37:22,160 --> 09:37:26,560
然后是 dx1，我的意思是我们实际上并没有

13596
09:37:23,916 --> 09:37:30,276
这里需要 dx1，但我只是把它包含进来，呃，仅仅是…… 

13597
09:37:26,560 --> 09:37:34,960
嗯，万一……关键在于，呃……

13598
09:37:30,276 --> 09:37:36,756
你知道DX1依赖于，呃，依赖于

13599
09:37:34,960 --> 09:37:39,756
W1

13600
09:37:36,756 --> 09:37:41,400
所以，呃，我们实际上并不需要

13601
09:37:39,756 --> 09:37:43,756
就像为这个更新任何东西，它只是

13602
09:37:41,400 --> 09:37:46,840
如果有个像……如果有的话，有个dw0（这里“dw0”可能是特定术语、名称或拼写错误，需结合具体语境准确理解） 

13603
09:37:43,756 --> 09:37:51,880
就像在那之前还有一层，嗯，因为注意到

13604
09:37:46,840 --> 09:37:53,880
呃，抱歉，注意看这个钌（Ru）层

13605
09:37:51,880 --> 09:37:57,880
依赖于这项权利，所以如果你有像……

13606
09:37:53,880 --> 09:38:00,360
比如，如果我们有一个Ru（此处可能拼写有误）嗯，如果我们有一个ra（此处可能拼写有误）

13607
09:37:57,880 --> 09:38:02,200
就像之前那样，如果我们有一条轨道的话 

13608
09:38:00,360 --> 09:38:05,116
这里的某个层面，然后你就会

13609
09:38:02,200 --> 09:38:08,720
实际上需要例如喜欢 dx0

13610
09:38:05,116 --> 09:38:11,000
而且你实际上需要呃

13611
09:38:08,720 --> 09:38:12,640
用这个，但既然我们不用，我们可以……

13612
09:38:11,000 --> 09:38:14,000
只是要明白这是某件事

13613
09:38:12,640 --> 09:38:15,560
如果更深一些，你本来是会有的。

13614
09:38:14,000 --> 09:38:17,520
网络，但实际上你并不需要它

13615
09:38:15,560 --> 09:38:19,200
使网络在……方面得到改善

13616
09:38:17,520 --> 09:38:21,240
表演权 它就像一个

13617
09:38:19,200 --> 09:38:22,596
额外的计算，那是多余的，所以

13618
09:38:21,240 --> 09:38:25,560
你 你可以在某种程度上把它排除在外

13619
09:38:22,596 --> 09:38:26,960
除非你想修改它，嗯，但我……

13620
09:38:25,560 --> 09:38:28,880
不会再为此事长篇大论了

13621
09:38:26,960 --> 09:38:31,916
太长了，咱们还是实际聊聊……是什么事儿吧

13622
09:38:28,880 --> 09:38:35,800
见鬼，这些神经元正在做所有的（事情）

13623
09:38:31,916 --> 09:38:38,200
对，所以我有了这个类似小编辑器的东西

13624
09:38:35,800 --> 09:38:41,320
在这里打开 这就像是我第一次用

13625
09:38:38,200 --> 09:38:44,040
它，但本质上是什么，什么是H，怎样一个……

注：你提供的英文文本似乎不太完整或存在一些不太清晰的表述，可能会影响准确理解和完整通顺的翻译。 

13626
09:38:41,320 --> 09:38:46,720
神经元的工作方式是，我们打算就像

13627
09:38:44,040 --> 09:38:48,240
放大来看，一个神经元的工作原理是，我们正在…… 

13628
09:38:46,720 --> 09:38:49,520
打算取一堆 X 值 全部的

13629
09:38:48,240 --> 09:38:53,320
那么，没错

13630
09:38:49,520 --> 09:38:53,320
X1 X2

13631
09:38:54,200 --> 09:38:59,720
X3，呃，这些要去看看

13632
09:38:58,480 --> 09:39:02,960
这些正在离去
（注：“are going”常见有“正在离开；正在去；快要发生”等意思，这里需结合具体语境判断更合适的含义，暂按“正在离去”给出译文 ） 

13633
09:38:59,720 --> 09:39:06,000
向前，呃，进入一个神经元

13634
09:39:02,960 --> 09:39:09,276
好了，接下来这里要发生的事情是

13635
09:39:06,000 --> 09:39:12,160
这些要……嗯，也许我应该

13636
09:39:09,276 --> 09:39:12,160
把这些稍微画一下

13637
09:39:15,000 --> 09:39:18,480
这样更好，这里就是我们的神经元，我们现在（这里“we're”缺少后续内容，翻译只能结合前文推测大致意思）

13638
09:39:17,360 --> 09:39:20,560
就在那里加个加号，然后

13639
09:39:18,480 --> 09:39:23,560
你马上就会明白为什么会这样了

13640
09:39:20,560 --> 09:39:26,080
神经元将会有许多不同的……（原句似乎不完整） 

13641
09:39:23,560 --> 09:39:28,240
权重 好的，这个神经元将会有

13642
09:39:26,080 --> 09:39:32,320
这个神经元将有一个权重

13643
09:39:28,240 --> 09:39:34,240
对于这些 X 值中的每一个，所以 w

13644
09:39:32,320 --> 09:39:37,880
W1

13645
09:39:34,240 --> 09:39:39,480
W2和W3，而所有这些所起到的作用仅仅是

13646
09:39:37,880 --> 09:39:41,916
只是打算生产这些，所以它是

13647
09:39:39,480 --> 09:39:43,720
将要去；打算去

13648
09:39:41,916 --> 09:39:46,276
W1

13649
09:39:43,720 --> 09:39:49,436
X1 加号
注：更常见的可能是“X1 增强版” 或 “X1 加” 等表达，需结合具体语境判断准确含义。

13650
09:39:46,276 --> 09:39:49,436
W2 呃

13651
09:39:49,480 --> 09:39:56,560
X2 加 W

13652
09:39:52,276 --> 09:40:00,160
3 乘以 3，那将会得到

13653
09:39:56,560 --> 09:40:04,680
我们输出正确

13654
09:40:00,160 --> 09:40:06,436
所以这个 这个乘以这个 这个乘以这个

13655
09:40:04,680 --> 09:40:08,400
然后这个乘以这个，对吧，那就是一个……

13656
09:40:06,436 --> 09:40:11,756
单个神经元，以及我们接下来要做的……

13657
09:40:08,400 --> 09:40:12,800
最终得到的是，呃，当我们把这些相加时

13658
09:40:11,756 --> 09:40:18,436
我们一起最终会得到一个

13659
09:40:12,800 --> 09:40:18,436
单一值
最终得到一个单一值

13660
09:40:22,916 --> 09:40:25,916
一

13661
09:40:26,116 --> 09:40:32,360
瓦尔，一个价值

13662
09:40:28,756 --> 09:40:37,680
现在，当我们跳到一堆……的时候

13663
09:40:32,360 --> 09:40:40,160
神经元，所以如果我们说，嗯，比如

13664
09:40:37,680 --> 09:40:42,320
X

13665
09:40:40,160 --> 09:40:48,400
X1

13666
09:40:42,320 --> 09:40:50,720
X2，并且我们有，比如说，1、2、3

13667
09:40:48,400 --> 09:40:52,160
神经元，这一个将会有每一个（注：原英文表述不太符合常见语境逻辑，翻译可能存在表意不够精准的情况） 

13668
09:40:50,720 --> 09:40:56,560
这些当中会有两个神经元

13669
09:40:52,160 --> 09:40:58,960
好的，那么这个将会有，嗯，一个

13670
09:40:56,560 --> 09:41:03,276
二 一

13671
09:40:58,960 --> 09:41:05,116
二又二分之一，这看起来很眼熟

13672
09:41:03,276 --> 09:41:06,800
与你之前见过的某样东西有关，那就是

13673
09:41:05,116 --> 09:41:08,040
我之前给你展示过的多层感知器

13674
09:41:06,800 --> 09:41:10,240
就在那里，那些你可能见过的画面

13675
09:41:08,040 --> 09:41:11,916
就像你知道的那种标题党缩略图

13676
09:41:10,240 --> 09:41:15,116
有了这些之前的（情况），而这恰恰就是

13677
09:41:11,916 --> 09:41:17,916
这是什么，没错，所以你将会有

13678
09:41:15,116 --> 09:41:20,240
呃，这里有两个砝码，两个砝码在

13679
09:41:17,916 --> 09:41:22,720
这里，还有两个砝码在

13680
09:41:20,240 --> 09:41:24,800
在这里，所以它将与……进行乘积运算

13681
09:41:22,720 --> 09:41:28,480
这些中的每一个你都要把 G 变成……（原文似乎不完整）

13682
09:41:24,800 --> 09:41:31,756
有这个，它将会是

13683
09:41:28,480 --> 09:41:34,240
嗯，你知道，就像一个

13684
09:41:31,756 --> 09:41:36,276
W1

13685
09:41:34,240 --> 09:41:38,116
X1 加 a

13686
09:41:36,276 --> 09:41:40,560
W2（表格）；W2（也可能是某种特定代码、编号等，具体含义需结合语境确定） 

注：“W2”常见指美国用于报告工资和预扣税信息的“W-2表格” ，若此处有特定背景请提供更多信息以精准翻译。 

13687
09:41:38,116 --> 09:41:42,800
乘以2，然后对这些也进行同样的操作

13688
09:41:40,560 --> 09:41:44,520
没错，它将完成所有这些事情，并且

13689
09:41:42,800 --> 09:41:45,756
你最终会得到总共三个。

13690
09:41:44,520 --> 09:41:49,880
数值，所以最终你会得到

13691
09:41:45,756 --> 09:41:51,680
一 二 三 中的数值在……

（注：原英文文本似乎表述不完整，此翻译仅按字面直译） 

13692
09:41:49,880 --> 09:41:53,596
现在输出

13693
09:41:51,680 --> 09:41:55,640
如果我们真的深入到线性代数领域，并且

13694
09:41:53,596 --> 09:41:56,880
试着理解这个概念相关的事物

13695
09:41:55,640 --> 09:42:00,436
实际上会制造出更多的……

13696
09:41:56,880 --> 09:42:04,276
感觉还行，那么我们来学习线性代数。

13697
09:42:00,436 --> 09:42:06,640
比如说我们有一个尺寸为一的东西

13698
09:42:04,276 --> 09:42:10,720
呃，通过……（这里“by uh”表述不太完整和常规，“by”有“通过；被；在……旁边”等多种意思，“uh”是语气词） 

13699
09:42:06,640 --> 09:42:13,756
说 784 全部

13700
09:42:10,720 --> 09:42:17,360
对，然后我们用这个把它（此处“matal”可能是拼写错误，推测可能是“mate”之类的词，因没有准确信息按原文直译难以通顺表意）与……搭配 

13701
09:42:13,756 --> 09:42:17,360
有一定规模的事物

13702
09:42:18,436 --> 09:42:24,756
784 乘以 256
好吧，别在意我的字迹

13703
09:42:21,880 --> 09:42:27,520
这太糟糕了，嗯，但这就是，这就是

13704
09:42:24,756 --> 09:42:30,200
将是每个 x 值

13705
09:42:27,520 --> 09:42:31,880
对；没错；好的

13706
09:42:30,200 --> 09:42:36,320
X1 和

13707
09:42:31,880 --> 09:42:36,320
那么X，嗯

13708
09:42:39,276 --> 09:42:47,596
784，并且我们将有256个神经元

13709
09:42:42,640 --> 09:42:52,916
好的，所以这是一号，这是

13710
09:42:47,596 --> 09:42:52,916
呃，256，好的

13711
09:42:53,160 --> 09:43:00,400
现在我们要做的实际上就是

13712
09:42:56,916 --> 09:43:03,436
拿着这个，这会是像……这样的情况

注：原英文句子可能表述不太完整和准确，此翻译是尽力按字面呈现。 

13713
09:43:00,400 --> 09:43:05,800
本质上，它将会有，这是……（原英文表述不太符合常规语法，此为尽量通顺的翻译） 

13714
09:43:03,436 --> 09:43:07,400
呃，它所拥有的行数，就是这个（所指的）行数

13715
09:43:05,800 --> 09:43:08,520
这就是《黑客帝国》的精髓所在吗？

注：原英文句子可能表述有误，“is the this”正确的可能是 “Is this” ，这里推测 “the Matrix” 是指经典电影《黑客帝国》，结合常见表达给出了以上译文，以保证语句通顺合理。 

13716
09:43:07,400 --> 09:43:10,916
所以从本质上来说，它看起来只会是……

13717
09:43:08,520 --> 09:43:12,000
就像一个向量，它将会是它的 

13718
09:43:10,916 --> 09:43:12,880
会是这样，而且只会是这样

13719
09:43:12,000 --> 09:43:15,756
成为一个；是一个

13720
09:43:12,880 --> 09:43:17,436
一行，而且这一行会相当……

13721
09:43:15,756 --> 09:43:21,200
很高，所以实际上它看起来会像

13722
09:43:17,436 --> 09:43:21,200
这将会是

13723
09:43:25,480 --> 09:43:33,916
现在就是这样，784 乘以 256

13724
09:43:30,080 --> 09:43:33,916
这个，这个专栏，对吧

13725
09:43:34,400 --> 09:43:39,320
这里将会有一个单个的神经元

13726
09:43:37,240 --> 09:43:42,116
没错，这将会是

13727
09:43:39,320 --> 09:43:44,116
嗯，说

13728
09:43:42,116 --> 09:43:46,000
一；一个；某个；一体

13729
09:43:44,116 --> 09:43:48,720
神经元，这将是一组…… （由于原文似乎不完整，翻译可能存在一定局限性） 

13730
09:43:46,000 --> 09:43:50,560
权重，它将映射其每一个（此处原文表述可能不太完整或准确，翻译尽量贴合字面意思）

13731
09:43:48,720 --> 09:43:53,436
那些权重值中的每一个都将

13732
09:43:50,560 --> 09:43:58,080
用单个 x 值相乘，对吧，所以

13733
09:43:53,436 --> 09:44:00,276
W1 要和这个相乘，嗯

13734
09:43:58,080 --> 09:44:01,560
W2 接下来要与 X2 相乘

13735
09:44:00,276 --> 09:44:04,680
从这里一直到……

注：由于原文没有表述完整，翻译后的内容可能存在表意不明确的情况。 

13736
09:44:01,560 --> 09:44:06,916
不管n是什么，或者……抱歉，说到下面了（注：原文表述不太清晰，此翻译尽力贴合字面意思） 

13737
09:44:04,680 --> 09:44:09,680
到 784，这是长度

13738
09:44:06,916 --> 09:44:11,080
它的……或者……或者这列的长度

13739
09:44:09,680 --> 09:44:13,200
我猜你（知道）柱子的高度。

注：原句可能存在表述错误，正确的或许是 “I guess you know the height of the column” 。 

13740
09:44:11,080 --> 09:44:16,596
无论你想把那解读成什么

13741
09:44:13,200 --> 09:44:19,520
嗯，这是一个单个的神经元，对吧

13742
09:44:16,596 --> 09:44:21,320
只要这一点清楚了，我们现在就没问题了。

13743
09:44:19,520 --> 09:44:22,756
我们有一堆这样的神经元作为一个（此处原文表述似乎不完整）

13744
09:44:21,320 --> 09:44:25,800
事实上，我们有

13745
09:44:22,756 --> 09:44:28,800
256种不同的

13746
09:44:25,800 --> 09:44:28,800
神经元

13747
09:44:31,080 --> 09:44:34,960
对，我不知道该怎么用我的（此处原句似乎不完整）来书写

13748
09:44:33,040 --> 09:44:38,000
一方面，然而我仍在慢慢习惯

13749
09:44:34,960 --> 09:44:41,960
但我们有256个不同的神经元

13750
09:44:38,000 --> 09:44:43,360
没错，而且它们都在进行点积运算。 

13751
09:44:41,960 --> 09:44:47,200
带着输入

注：由于缺乏上下文，“input”可根据具体语境有不同译法，如“输入内容；投入；投入物”等。 

13752
09:44:43,360 --> 09:44:49,756
它自身，然后我们得到一个最终输出

13753
09:44:47,200 --> 09:44:52,916
所以注意到这些，你知道的，它们相互抵消了，并且

13754
09:44:49,756 --> 09:44:52,916
我们最终得到

13755
09:44:55,916 --> 09:45:04,000
1 除以 256，所以举个例子，我们打算

13756
09:45:00,200 --> 09:45:06,480
现在要得到256个神经元的输出，如果你

13757
09:45:04,000 --> 09:45:11,200
把这想象成

13758
09:45:06,480 --> 09:45:13,840
说，嗯，以 2 为一组处理 784 个，而不是一次处理一个

13759
09:45:11,200 --> 09:45:16,276
图像被扁平化了，它是一堆……

13760
09:45:13,840 --> 09:45:17,276
扁平图像，对，每次扁平化处理

13761
09:45:16,276 --> 09:45:20,520
图像是一个

13762
09:45:17,276 --> 09:45:24,000
然后实际上你最终得到的全部就是…… 

13763
09:45:20,520 --> 09:45:26,916
这个B只是替换了那个，所以你

13764
09:45:24,000 --> 09:45:26,916
你 你摆脱掉

不过这句话表述不太完整或准确，从现有内容看语义不是很清晰。正常语境可能是“you get rid of...”，表示“你摆脱……” 。 

13765
09:45:28,080 --> 09:45:34,400
那样的话，你最后会在这里得到这个 B，并且

13766
09:45:31,116 --> 09:45:35,916
这只是呃 一批神经元

13767
09:45:34,400 --> 09:45:38,800
输出结果，没错，所以就好像觉得它是……

13768
09:45:35,916 --> 09:45:40,960
就想象一下，思考这整个…… 

13769
09:45:38,800 --> 09:45:42,560
这里的这种建筑，在其中你有

13770
09:45:40,960 --> 09:45:45,200
每个 x 值都代入到类似一个（的式子中）

13771
09:45:42,560 --> 09:45:47,200
不同的神经元，只需想象一下这个，但是

13772
09:45:45,200 --> 09:45:48,880
但是你喜欢把它们一层一层地叠加在……上面

13773
09:45:47,200 --> 09:45:51,240
彼此，所以你就像你有

13774
09:45:48,880 --> 09:45:53,276
就好比说你有这个，就像它是……一样

13775
09:45:51,240 --> 09:45:56,320
它正看着屏幕前的你，并且

13776
09:45:53,276 --> 09:45:58,520
然后你就像这样把它放下，接着

13777
09:45:56,320 --> 09:46:00,116
你在批量元素上再放一个。

13778
09:45:58,520 --> 09:46:02,200
一个批次元素
两个批次元素

13779
09:46:00,116 --> 09:46:05,880
三个批次元素四以及每个（这里“each of”表述不完整，翻译可能不够准确） 

13780
09:46:02,200 --> 09:46:07,916
这会给你带来一些东西，所以

13781
09:46:05,880 --> 09:46:11,640
所有这些输出都将提供

13782
09:46:07,916 --> 09:46:12,770
你喜欢说，呃，这将会带来

13783
09:46:11,640 --> 09:46:14,000
你；你们

13784
09:46:12,770 --> 09:46:18,000
[音乐]

13785
09:46:14,000 --> 09:46:19,756
嗯，它叫什么来着，有256种不同的（情况/样式等，需结合上下文确定）

13786
09:46:18,000 --> 09:46:22,880
输出，而且你将会拥有这些

13787
09:46:19,756 --> 09:46:24,800
在一个批次中，批次大小，对吧，所以这里是256

13788
09:46:22,880 --> 09:46:28,000
输出结果都在这里分层展示，并且

13789
09:46:24,800 --> 09:46:30,840
然后每一个堆叠在上面的仅仅是

13790
09:46:28,000 --> 09:46:33,520
另一组 256，对，我就是这么做的（此处“that's how I”后面内容缺失，只能按一般逻辑意译） 

13791
09:46:30,840 --> 09:46:35,320
有点像是要通过推理来弄明白

13792
09:46:33,520 --> 09:46:36,680
在我脑海里，你或许想讲道理

13793
09:46:35,320 --> 09:46:38,720
以不同的方式经历它，但我发现

13794
09:46:36,680 --> 09:46:40,240
这会是一个相当酷的把戏来…… 

13795
09:46:38,720 --> 09:46:43,200
了解这些是如何……

13796
09:46:40,240 --> 09:46:46,436
现在正在工作，还有另一个

13797
09:46:43,200 --> 09:46:49,400
我确实有点遗漏的术语，以及

13798
09:46:46,436 --> 09:46:52,680
这就是偏差，对吧，所以这个

13799
09:46:49,400 --> 09:46:54,596
使这些中的每一个、每一个小的都产生偏差

13800
09:46:52,680 --> 09:46:56,720
这些神经元中的每一个都将拥有它的……（由于原文不完整，翻译可能不太能完全表意）

13801
09:46:54,596 --> 09:47:00,160
自己的偏见，对吧

13802
09:46:56,720 --> 09:47:03,320
所以你知道

13803
09:47:00,160 --> 09:47:07,560
X X1 X

13804
09:47:03,320 --> 09:47:07,560
呃，现在这些小的……（“xn”可能是无意义字符或拼写错误）

13805
09:47:07,916 --> 09:47:12,320
神经元将有其自身的偏差，所以

13806
09:47:10,560 --> 09:47:14,040
我们要去做，你知道的，做一个产品

13807
09:47:12,320 --> 09:47:20,560
像我们通常那样进行行动，我们会……

13808
09:47:14,040 --> 09:47:23,240
打算像计算 X2 或者 X1 * 嗯，X1 * W1 那样去做

13809
09:47:20,560 --> 09:47:24,400
加上 X2 乘以 W2，一直这样计算下去 

13810
09:47:23,240 --> 09:47:26,560
一个里面所有不同的重量

13811
09:47:24,400 --> 09:47:29,360
神经元，然后一旦我们得到那个，我们就……

13812
09:47:26,560 --> 09:47:30,640
要给那个加上一个偏置，并且这个偏置

13813
09:47:29,360 --> 09:47:32,200
将只是一个单一的数字

13814
09:47:30,640 --> 09:47:34,640
因为它当然是一个标量值

13815
09:47:32,200 --> 09:47:35,960
对，所以本质上会是这样

13816
09:47:34,640 --> 09:47:40,000
它看起来会像

13817
09:47:35,960 --> 09:47:41,840
这个 W * X 我们打算做，我们要去做

13818
09:47:40,000 --> 09:47:44,880
去完成所有这些我们需要做的事情

13819
09:47:41,840 --> 09:47:48,240
产品 本质上就像 就像

13820
09:47:44,880 --> 09:47:49,596
向量 一个向量 向量乘法

13821
09:47:48,240 --> 09:47:52,240
并且我们要添加一个单一的偏置项

13822
09:47:49,596 --> 09:47:55,360
赋予那项权利以价值

13823
09:47:52,240 --> 09:47:57,000
所以向量，嗯，向量 X 将会

13824
09:47:55,360 --> 09:48:00,116
看起来像

13825
09:47:57,000 --> 09:48:02,040
这个，并且向量 W 将会看起来

13826
09:48:00,116 --> 09:48:05,720
像这样，这将会是一个

13827
09:48:02,040 --> 09:48:07,916
列，所以我们拿这一列，然后我们…… 

13828
09:48:05,720 --> 09:48:09,360
本质上进行一次矩阵乘法运算

13829
09:48:07,916 --> 09:48:11,240
但它们是向量，所以就好像

13830
09:48:09,360 --> 09:48:14,520
字面意思就是它看起来的样子

13831
09:48:11,240 --> 09:48:17,320
是，然后你只需拿起这个元素，并且

13832
09:48:14,520 --> 09:48:19,000
你 你用这个数相乘，对吧，所以

13833
09:48:17,320 --> 09:48:21,640
你有点，你有点像放了个……

13834
09:48:19,000 --> 09:48:23,160
坚持到底，你行的

13835
09:48:21,640 --> 09:48:25,596
而且它就像是被切成了一堆

13836
09:48:23,160 --> 09:48:28,916
做一些小的乘法运算，然后把它们相加

13837
09:48:25,596 --> 09:48:31,276
在一起，然后你做你的

13838
09:48:28,916 --> 09:48:33,116
偏见，而且我们可以重新振作起来挺过去

13839
09:48:31,276 --> 09:48:34,960
那也是，所以，希望那个……

13840
09:48:33,116 --> 09:48:37,436
只是澄清了一些直觉，就像

13841
09:48:34,960 --> 09:48:40,200
关于我们实际上是如何构建的，嗯

13842
09:48:37,436 --> 09:48:43,200
这边这个部分，所以我刚刚说的那个规则

13843
09:48:40,200 --> 09:48:45,640
向你展示的内容同样适用于X2，并且

13844
09:48:43,200 --> 09:48:47,400
W2 没错，关键是我们只是在尝试

13845
09:48:45,640 --> 09:48:48,960
要理解……的整体设计是什么

13846
09:48:47,400 --> 09:48:51,040
神经元是什么以及我们如何进行抽象

13847
09:48:48,960 --> 09:48:53,240
一直到线性代数，然后撰写

13848
09:48:51,040 --> 09:48:55,800
真的真的很快，C、C++ 和 CUDA

13849
09:48:53,240 --> 09:48:57,400
用于让这个运行得更快的代码

13850
09:48:55,800 --> 09:48:59,840
而不是仅仅考虑每一个小的（这里文本似乎不完整）

13851
09:48:57,400 --> 09:49:01,680
神经元独立运作，我们可以

13852
09:48:59,840 --> 09:49:04,400
构建 我们可以添加一层抽象

13853
09:49:01,680 --> 09:49:06,680
站起来说“这就是我们，我们已经证明了”

13854
09:49:04,400 --> 09:49:09,200
这是，呃，这就是这里面的运作方式在……（原句表述似乎不太完整） 

13855
09:49:06,680 --> 09:49:10,916
线性 线性代数，现在我们可以

13856
09:49:09,200 --> 09:49:12,596
向前一步，努力真正做到优化

13857
09:49:10,916 --> 09:49:13,960
基于我们对矩阵的了解

13858
09:49:12,596 --> 09:49:16,520
乘法，没错，这是……其中之一

13859
09:49:13,960 --> 09:49:17,880
如此强调梅尔（Mel）的原因是

13860
09:49:16,520 --> 09:49:19,360
因为这极其重要

13861
09:49:17,880 --> 09:49:21,240
所有这些深度学习中的算法

13862
09:49:19,360 --> 09:49:24,400
东西，嗯

13863
09:49:21,240 --> 09:49:26,880
不过，是的，现在我们可以，呃，现在让我们来看看

13864
09:49:24,400 --> 09:49:29,080
我们怎么能，就像你知道的那样，理解交叉熵呢

13865
09:49:26,880 --> 09:49:32,840
损失以及通过所有的……进行反向传播

13866
09:49:29,080 --> 09:49:34,756
这一切都很好，太棒了，那么现在我们接下来……

13867
09:49:32,840 --> 09:49:36,916
必须要处理损失函数以及…… 

13868
09:49:34,756 --> 09:49:40,080
损失函数实际上并没有那么糟糕，所以

13869
09:49:36,916 --> 09:49:43,040
如果我们跳到这里，注意我们是如何……

13870
09:49:40,080 --> 09:49:44,680
呃，有这个交叉熵损失，对吧

13871
09:49:43,040 --> 09:49:48,276
这是我们的 这是我们的损失函数

13872
09:49:44,680 --> 09:49:50,916
一旦我们得到“我们做”的模式。来自福尔博（注：这里“forbo”推测是特定名称“福尔博”，具体需结合更多语境确定） 

13873
09:49:48,276 --> 09:49:53,040
我们的X批次，并且我们得到了Y预测结果

13874
09:49:50,916 --> 09:49:54,880
然后是一个缓存，对吧，呃，别担心

13875
09:49:53,040 --> 09:49:58,800
关于 C，只担心这些就行了。 

13876
09:49:54,880 --> 09:50:01,400
y 公关以及那个批次 y 没错，所以我们继续

13877
09:49:58,800 --> 09:50:02,800
接下来是我们的交叉熵损失以及

13878
09:50:01,400 --> 09:50:05,116
在这里面，我们要剖析这个。

13879
09:50:02,800 --> 09:50:07,596
顺便说一下，别太担心。

13880
09:50:05,116 --> 09:50:09,160
在这个东西里面，我们有批量大小。

13881
09:50:07,596 --> 09:50:10,756
嗯，所以基本上我们只是拿一个……

13882
09:50:09,160 --> 09:50:12,320
来自形状的元素 我们的……

（注：原英文文本不太完整且表意不太清晰，这样的翻译只能尽量呈现字面意思） 

13883
09:50:10,756 --> 09:50:15,000
来自softmax函数的概率

13884
09:50:12,320 --> 09:50:19,756
这一点我们在有这个之前确实讨论过了

13885
09:50:15,000 --> 09:50:21,240
这里的一件工作 呃 然后 呃 以及

13886
09:50:19,756 --> 09:50:24,800
然后我们通过计算来完成它

13887
09:50:21,240 --> 09:50:25,916
损失，没错，所以假设我们

13888
09:50:24,800 --> 09:50:27,596
理解我们的softmax函数是如何工作的 （原句可能不完整，推测完整语义是理解softmax函数如何工作，按要求只提供此翻译内容） 

13889
09:50:25,916 --> 09:50:29,320
工程我们实际上可以继续并挖掘

13890
09:50:27,596 --> 09:50:32,960
进入这个
（注：由于“into this”语义较模糊，需结合具体语境才能更准确理解。这里按字面直译呈现。） 

13891
09:50:29,320 --> 09:50:32,960
所以我打算打开

13892
09:50:33,000 --> 09:50:40,560
向上，在这里打开一个木星笔记本（通常指Jupyter Notebook，可译为“朱庇特笔记本”或“Jupyter 笔记本” ），所以

13893
09:50:38,116 --> 09:50:43,160
接下来要继续进行导入操作

13894
09:50:40,560 --> 09:50:47,916
NumPy，然后我们要走了

13895
09:50:43,160 --> 09:50:50,040
来定义交叉熵损失，呃

13896
09:50:47,916 --> 09:50:51,160
函数本身和softmax，那么让我们开始吧

13897
09:50:50,040 --> 09:50:54,916
向前并采取

13898
09:50:51,160 --> 09:50:57,080
这些，呃，把这些放进……

13899
09:50:54,916 --> 09:51:00,680
那么在这里我们要说设置我们的

13900
09:50:57,080 --> 09:51:03,680
批量大小为 2，然后我们就……

13901
09:51:00,680 --> 09:51:08,276
打算设置呃

13902
09:51:03,680 --> 09:51:08,276
将类别数量全部设置为五个

13903
09:51:08,880 --> 09:51:13,720
那么接下来我们要去做一个

13904
09:51:12,040 --> 09:51:16,560
形状 我们接下来要去做我们的

13905
09:51:13,720 --> 09:51:19,480
我们这两个用于交叉接种的输入物

注：原句表述不太常规，“um”可能是口语中的语气词，在书面翻译里可灵活处理。 

13906
09:51:16,560 --> 09:51:22,916
Y预测值（Y PR）和Y真实值，好的，那么

13907
09:51:19,480 --> 09:51:26,360
呃，我们要让这个等于，呃

13908
09:51:22,916 --> 09:51:27,840
这个麻木的，呃，随机数（rand），按数量（num）划分批次大小

13909
09:51:26,360 --> 09:51:30,400
课程 没错，所以那将是我们的

13910
09:51:27,840 --> 09:51:32,080
预测 我们有一堆 呃 我们

13911
09:51:30,400 --> 09:51:35,240
有一堆批量元素，每个元素都带有

13912
09:51:32,080 --> 09:51:37,436
一个关于……的概率分布

13913
09:51:35,240 --> 09:51:40,116
它认为应该是哪个输出呢

注：原英文句子存在一些口语化表达且语法可能不太规范，以上翻译尽量贴合原文语义。 

13914
09:51:37,436 --> 09:51:43,160
那些就是预测，对吧，然后呢

13915
09:51:40,116 --> 09:51:47,080
我们有一个真实的 y，它将是

13916
09:51:43,160 --> 09:51:47,080
随机整数

13917
09:51:48,880 --> 09:51:52,840
嗯，我打算把这些打印出来，所以

13918
09:51:50,960 --> 09:51:56,596
你可以

13919
09:51:52,840 --> 09:52:00,116
看，所以 y 看起来是这样的，我们有一批（数据/样本等，需结合具体语境确定“batch”含义）

13920
09:51:56,596 --> 09:52:01,480
两个的尺寸，所以是 1、2，而且我们有一堆

13921
09:52:00,116 --> 09:52:03,520
在这些元素当中，没错，这就是我们的

13922
09:52:01,480 --> 09:52:05,596
概率 呃 实际上这些不是

13923
09:52:03,520 --> 09:52:07,520
我们的 我们的概率分布

13924
09:52:05,596 --> 09:52:09,800
然而这些实际上被称为“lits”，所以我

13925
09:52:07,520 --> 09:52:12,756
这里跳过了一步，但灯是……

13926
09:52:09,800 --> 09:52:15,160
在softmax之前的步骤，没错，softmax是

13927
09:52:12,756 --> 09:52:16,640
要确保一切呃都是

13928
09:52:15,160 --> 09:52:19,240
零上，没错，它会确保

13929
09:52:16,640 --> 09:52:21,040
在零与……之间，一切都如同零。

注：原文“between zero and”后面似乎缺少内容，不过按照要求完成了翻译。 

13930
09:52:19,240 --> 09:52:22,756
有一种观点认为，那个想法在……（原句表述不太完整和清晰）

13931
09:52:21,040 --> 09:52:24,436
它将充满自信地表达。

13932
09:52:22,756 --> 09:52:25,756
哪些数字应该高呢

13933
09:52:24,436 --> 09:52:29,080
没错，因为它是

13934
09:52:25,756 --> 09:52:32,800
取幂，嗯，这些是列表，因为

13935
09:52:29,080 --> 09:52:35,116
这就好像，嗯，就像那小屋，我猜

13936
09:52:32,800 --> 09:52:37,080
你可以说它就像那个原木，就像那个…… 

13937
09:52:35,116 --> 09:52:38,800
对数概率，所以因为你必须…… 

13938
09:52:37,080 --> 09:52:40,276
进行指数运算以得到softmax函数，它是

13939
09:52:38,800 --> 09:52:42,840
像日志一样，因为你走了

13940
09:52:40,276 --> 09:52:44,756
往下它要进行自然对数运算，实际上并非如此

13941
09:52:42,840 --> 09:52:47,756
以 2 为底的对数，或者是以 10 为底的对数

13942
09:52:44,756 --> 09:52:48,756
它将会是对数，以 2 为底，以 e 为底

13943
09:52:47,756 --> 09:52:51,040
或者

13944
09:52:48,756 --> 09:52:55,640
2.71，我们可以继续把它打印出来

13945
09:52:51,040 --> 09:52:57,720
你提供的内容“our y true”可能存在拼写错误，推测正确内容并翻译如下：

哦，的确，所以这是…… 

13946
09:52:55,640 --> 09:53:02,000
嗯，这是一个

13947
09:52:57,720 --> 09:53:02,916
数组 这非常 是啊 你 你

13948
09:53:02,000 --> 09:53:04,240
你会看到这个的 你会……

13949
09:53:02,916 --> 09:53:07,520
马上你就会明白这为什么重要了

13950
09:53:04,240 --> 09:53:11,800
这里，嗯，但如果我们真的去我们的……

13951
09:53:07,520 --> 09:53:14,116
下一步，我们可以计算概率等于……

13952
09:53:11,800 --> 09:53:16,040
Y_PR的softmax函数，所以我们接下来会看到

13953
09:53:14,116 --> 09:53:19,200
这些值被取指数后，我们可以

13954
09:53:16,040 --> 09:53:21,800
打印出我们的概率，这样我们就可以

13955
09:53:19,200 --> 09:53:23,800
将其视为这其中重视……的一部分（此处“which values”表述不太完整，可根据具体语境补充完整“values”后的内容） 

13956
09:53:21,800 --> 09:53:25,880
我们是最棒的，对吧，所以这个是

13957
09:53:23,800 --> 09:53:28,160
你知道的，最接近……的最大的（这里句子不完整，语义不太明确） 

13958
09:53:25,880 --> 09:53:30,040
正无穷大，嗯，然后这是

13959
09:53:28,160 --> 09:53:31,360
就像消极、消极、消极、消极

13960
09:53:30,040 --> 09:53:33,200
对，所以这就像是最大的这个

13961
09:53:31,360 --> 09:53:35,000
是第二大的，对吧，所以我们可以

13962
09:53:33,200 --> 09:53:36,276
看，这是最大的数字，这是

13963
09:53:35,000 --> 09:53:37,960
第二大的，而且这就像

13964
09:53:36,276 --> 09:53:41,400
这些……这些数字好像更小些

13965
09:53:37,960 --> 09:53:44,116
对，嗯，这个也是，我们注意到

13966
09:53:41,400 --> 09:53:46,320
哎呀，这个 1.95 可真够大的，然后呢

13967
09:53:44,116 --> 09:53:48,640
我们有一个 1.2，所以就好像这是…… 

13968
09:53:46,320 --> 09:53:51,680
最大的 第二大的 对 就是那种

13969
09:53:48,640 --> 09:53:54,800
关于那会如何发展

13970
09:53:51,680 --> 09:54:00,240
然后我们要去做正确的呃

13971
09:53:54,800 --> 09:54:01,800
正确的对数概率将会是，嗯，或者

13972
09:54:00,240 --> 09:54:05,116
正确 正确

13973
09:54:01,800 --> 09:54:06,480
很可能我们要做，嗯，这部分。

13974
09:54:05,116 --> 09:54:07,756
我们要在这里做这部分，所以

13975
09:54:06,480 --> 09:54:10,240
概率，然后我们要去……

13976
09:54:07,756 --> 09:54:12,916
把这两个都插到里面去，好的

13977
09:54:10,240 --> 09:54:12,916
那么当我们这么做的时候

13978
09:54:15,700 --> 09:54:22,116
[音乐]

13979
09:54:17,640 --> 09:54:27,320
这时我们注意到，这所起到的作用是它

13980
09:54:22,116 --> 09:54:30,040
给我们，嗯，它给我们……的索引

13981
09:54:27,320 --> 09:54:32,960
里面正确的概率

注：你提供的内容可能不完整，这样的翻译可能与准确语义有偏差。 

13982
09:54:30,040 --> 09:54:34,756
预测中的预测

13983
09:54:32,960 --> 09:54:39,040
呃，矩阵

13984
09:54:34,756 --> 09:54:44,520
对，所以在这儿里面，如果我们实际上

13985
09:54:39,040 --> 09:54:47,200
打印出来 嗯 如果我们打印出来 你知道的

13986
09:54:44,520 --> 09:54:47,200
没问题。（注：“np.”常见为“no problem”的缩写，这里按常见理解翻译） 

13987
09:54:47,240 --> 09:54:51,360
整理好，然后我们就得到了我们的 y

13988
09:54:49,596 --> 09:54:53,360
真实的；正确的；忠实的；真正的

13989
09:54:51,360 --> 09:54:56,320
从本质上来说，我们可以把这四个（事物）看作……  （这里“this four”表述不太准确规范，推测可能想说“these four” ）

13990
09:54:53,360 --> 09:54:59,040
并且一个作为我们的正确标签，所以在……里在……里

13991
09:54:56,320 --> 09:55:01,560
批次号，在这个批次里，呃，在……这个里面

13992
09:54:59,040 --> 09:55:04,960
第一批元素的正确索引

13993
09:55:01,560 --> 09:55:08,560
呃，正确答案是……是

13994
09:55:04,960 --> 09:55:10,080
第四，没错，所以它从 0 开始，1、2、3、4

13995
09:55:08,560 --> 09:55:11,720
如果……这应该接近 1。

13996
09:55:10,080 --> 09:55:13,000
这和我们正在做的那个很接近，我们做得不错

13997
09:55:11,720 --> 09:55:14,400
那份工作意味着损失即将到来

13998
09:55:13,000 --> 09:55:16,560
右下角 这就是 这就是

13999
09:55:14,400 --> 09:55:18,560
正确答案，所以如果一切都像……

14000
09:55:16,560 --> 09:55:20,960
如果这是……的话，这里倾向于使用这个指数

14001
09:55:18,560 --> 09:55:22,640
正确地说，选个班级

14002
09:55:20,960 --> 09:55:25,640
嗯，那正是我们想要优化的。

14003
09:55:22,640 --> 09:55:27,000
因为到那时，这一个正在挑选出…… 

14004
09:55:25,640 --> 09:55:28,680
同样的事情，但针对第二个元素

14005
09:55:27,000 --> 09:55:32,116
对，所以这就是我们上去之后要做的事。

14006
09:55:28,680 --> 09:55:34,560
对于Y来说，这里我们正在做……嗯，这就是原因。

14007
09:55:32,116 --> 09:55:36,960
我们在这里设置了这个批量大小，所以它正在进行

14008
09:55:34,560 --> 09:55:39,680
要跨越元素，……的总数

14009
09:55:36,960 --> 09:55:42,040
批量大小为微米级的元素，而且它正在进行 

14010
09:55:39,680 --> 09:55:44,000
只是选择这些索引，对吧，所以

14011
09:55:42,040 --> 09:55:46,000
我们就在这里随便选个数字吧。

14012
09:55:44,000 --> 09:55:48,916
因为它介于零和麻木之间

14013
09:55:46,000 --> 09:55:52,720
课程，所以你知道它是从零基础开始的到…… 

14014
09:55:48,916 --> 09:55:55,276
本质上是四个，所以是 1、2、3、4、5 或者 0、1、2

14015
09:55:52,720 --> 09:55:56,520
3 4 嗯，所以那就是……

14016
09:55:55,276 --> 09:56:00,756
那里正在发生的事情，我们只是进行初始化

14017
09:55:56,520 --> 09:56:02,680
事情很随机，嗯，但我们看到我们

14018
09:56:00,756 --> 09:56:06,160
选了四号，所以它要去采摘了

14019
09:56:02,680 --> 09:56:08,160
数出第一个里面的第四（个），所以是 1

14020
09:56:06,160 --> 09:56:09,756
0.165，然后第二个也是同样的情况

14021
09:56:08,160 --> 09:56:12,160
好，我们有，我们有索引 1，所以它是

14022
09:56:09,756 --> 09:56:15,160
将要去；打算去

14023
09:56:12,160 --> 09:56:15,160
0.227

14024
09:56:16,840 --> 09:56:24,080
现在我们有这个了，我们有这个是正确的。

14025
09:56:19,720 --> 09:56:27,276
我刚刚在这里解释过的问题

注：“probs” 通常是 “problems” 的口语化缩写。 

14026
09:56:24,080 --> 09:56:29,680
如果我们失败了，或者抱歉，如果我们……

14027
09:56:27,276 --> 09:56:31,680
再往上一点，我们会看到 

14028
09:56:29,680 --> 09:56:34,520
我们刚刚完成了这部分，对吧，所以现在如果我

14029
09:56:31,680 --> 09:56:40,520
在那周围包裹上`np.log`

14030
09:56:34,520 --> 09:56:44,436
术语 np. 对数 我们就这么说

14031
09:56:40,520 --> 09:56:47,640
嗯，我们就说正确的呃对数概率

14032
09:56:44,436 --> 09:56:51,200
我们只需要对其取 np.log（自然对数）。

14033
09:56:47,640 --> 09:56:54,116
嗯，然后如果我们进行正确的记录

14034
09:56:51,200 --> 09:56:56,276
很可能，呃，我们注意到我们只是在做

14035
09:56:54,116 --> 09:56:59,560
这些当中每一个的记录

（注：原英文表述 “the log of each of these of each of” 不太符合常规语法，存在重复多余的 “of each of”，可能原文有误，但按照要求进行了翻译） 

14036
09:56:56,276 --> 09:57:01,800
这些数字是正确的，所以如果我们进行进口

14037
09:56:59,560 --> 09:57:07,720
数学课，然后我们就走

14038
09:57:01,800 --> 09:57:07,720
嗯，数学。……的对数

14039
09:57:08,080 --> 09:57:14,596
0.165 我们得到了这个正确的数字，所以，呃 -

14040
09:57:12,640 --> 09:57:16,960
1.8 我们只是针对每一个……来做这件事

14041
09:57:14,596 --> 09:57:20,720
这些元素，没错，然后我们

14042
09:57:16,960 --> 09:57:24,000
继续向前，我们出发

14043
09:57:20,720 --> 09:57:27,756
损失即总和

14044
09:57:24,000 --> 09:57:29,320
损失是，呃，所有那些的总和，所以

14045
09:57:27,756 --> 09:57:30,800
正确的对数问题将归结为求和

14046
09:57:29,320 --> 09:57:33,160
把这些都加在一起，所以它将会……

14047
09:57:30,800 --> 09:57:35,880
就像，呃，负1.8，然后

14048
09:57:33,160 --> 09:57:38,400
否定，我们在1.5（可能是某个参数、数值或频道等），所以他们要走了

14049
09:57:35,880 --> 09:57:43,116
此外，他们将会得到大约 -

14050
09:57:38,400 --> 09:57:44,880
3.3 微米至 3.47 微米或

14051
09:57:43,116 --> 09:57:47,160
3.27

14052
09:57:44,880 --> 09:57:48,840
嗯，然后我们用所有这些除以……

14053
09:57:47,160 --> 09:57:50,320
批量大小，以便进行某种归一化操作

14054
09:57:48,840 --> 09:57:51,640
交流交叉批次，我们不希望它……（原文“to to”表述有误，这里按原文格式呈现翻译） 

14055
09:57:50,320 --> 09:57:53,480
变得过于庞大，就像如果你增加……

14056
09:57:51,640 --> 09:57:54,880
那么把你的批量大小设置成大概一千

14057
09:57:53,480 --> 09:57:55,840
你的损失将会高得离谱

14058
09:57:54,880 --> 09:57:57,116
而且你会得到数值化的结果

14059
09:57:55,840 --> 09:57:59,276
那种不稳定状态，你根本就不会…… 

14060
09:57:57,116 --> 09:58:01,360
想要它，所以你想对……进行归一化处理

14061
09:57:59,276 --> 09:58:02,436
你所拥有的样本数量超出了（此处句子似乎不完整）

14062
09:58:01,360 --> 09:58:04,276
实际上这批里有多少，而且那是

14063
09:58:02,436 --> 09:58:06,400
会帮助我们稳定局势

14064
09:58:04,276 --> 09:58:08,200
后来在训练过程中，我们

14065
09:58:06,400 --> 09:58:10,640
不想让事情像这样升级然后

14066
09:58:08,200 --> 09:58:12,800
每一个训练步骤都变得更糟了，嗯

14067
09:58:10,640 --> 09:58:15,880
所以如果我们继续并打印出损失

14068
09:58:12,800 --> 09:58:21,520
我们注意到，嗯，我们注意到我们是如何得到这个的

14069
09:58:15,880 --> 09:58:26,680
1.64 对，所以回去，回到这里上面来

14070
09:58:21,520 --> 09:58:28,960
嗯，你知道的，这挺离谱的。

14071
09:58:26,680 --> 09:58:30,560
这次偏差稍微小了一点，但它还是…… 

14072
09:58:28,960 --> 09:58:33,520
仍然相当高，就像这些仍然是

14073
09:58:30,560 --> 09:58:37,560
就好像这有 16%、177%的概率，而且

14074
09:58:33,520 --> 09:58:39,400
这有23%的可能性，所以那并不是

14075
09:58:37,560 --> 09:58:43,436
非常好，所以我们的损失将是

14076
09:58:39,400 --> 09:58:45,800
更高，但如果我们的……如果我们是正确的

14077
09:58:43,436 --> 09:58:45,800
大概；很可能（probabilities 的缩写，非正式用法）

14078
09:58:45,960 --> 09:58:54,320
数组 抱歉 我们正确的概率数组是

14079
09:58:50,840 --> 09:58:59,800
嗯，看看 NumPy 怎么做

14080
09:58:54,320 --> 09:58:59,800
数组，然后我们接着说

14081
09:58:59,840 --> 09:59:02,840
嗯

14082
09:59:02,960 --> 09:59:06,116
0.9 和

14083
09:59:06,480 --> 09:59:12,400
0.8，然后我们，呃，你知道的，继续去……

14084
09:59:09,200 --> 09:59:16,840
经历这个，所以没错，呃，没错

14085
09:59:12,400 --> 09:59:20,160
对数概率 呃 等于 然后 然后我们

14086
09:59:16,840 --> 09:59:22,000
正确处理我们的损失，然后我们就能成功输出。

注：原英文句子 “do our loss right and we print out out” 表述不太符合常见的英语表达习惯，“print out out” 可能有误，正常或许是 “print out” ，以上翻译是基于整体语义尽量通顺来进行的。 

14087
09:59:20,160 --> 09:59:24,800
我们的损失，再次的损失将会是

14088
09:59:22,000 --> 09:59:28,916
显著降低，因为这些数值

14089
09:59:24,800 --> 09:59:31,840
呃，……之间的区别

注：原英文文本表述可能不太完整或存在重复用词情况，但按照要求进行了翻译。 

14090
09:59:28,916 --> 09:59:34,560
我们的预测之间的差异

14091
09:59:31,840 --> 09:59:36,400
准确率和实际标签之间的情况非常（这里句子不完整，可根据上下文补充更合适的内容） 

14092
09:59:34,560 --> 09:59:38,360
对，没错，所以我们当时以为有一个…… 

14093
09:59:36,400 --> 09:59:39,916
这个指数有90%的可能性会

14094
09:59:38,360 --> 09:59:41,596
不管是否正确，而我们当时……我们当时……我们当时…… 

14095
09:59:39,916 --> 09:59:42,800
是正确的，没错，所以那是一个非常高的（水平/数值等，需结合上下文确定准确语义）

14096
09:59:41,596 --> 09:59:44,800
我们坚信自己是正确的，并且

14097
09:59:42,800 --> 09:59:46,160
那是件好事，这也相当……

14098
09:59:44,800 --> 09:59:48,040
我们非常确信自己是正确的，所以

14099
09:59:46,160 --> 09:59:50,480
我们想为此犒劳一下自己，或者

14100
09:59:48,040 --> 09:59:52,640
最小化损失，对吧，所以如果我们有

14101
09:59:50,480 --> 09:59:55,160
像 10% 的概率或 5% 的概率这样的值，我们的 

14102
09:59:52,640 --> 09:59:57,116
损失会高得离谱，但呃

14103
09:59:55,160 --> 09:59:58,960
如果我们越来越接近……什么……什么……

14104
09:59:57,116 --> 10:00:01,276
我们在某种程度上在最小化差异

14105
09:59:58,960 --> 10:00:03,560
在模型认为它是什么和……之间

14106
10:00:01,276 --> 10:00:04,640
实际情况是那是件好事

14107
10:00:03,560 --> 10:00:06,160
这……这就是我们正在努力去做的事情

14108
10:00:04,640 --> 10:00:09,480
为……优化

14109
10:00:06,160 --> 10:00:12,276
现在这里还有小小的一步

14110
10:00:09,480 --> 10:00:15,240
这与这个一同而来

14111
10:00:12,276 --> 10:00:18,480
而那就是损失函数的导数

14112
10:00:15,240 --> 10:00:20,960
好的，所以如果你到这里的格罗这边来，

14113
10:00:18,480 --> 10:00:23,080
呃，说……

14114
10:00:20,960 --> 10:00:27,080
什么 什么

14115
10:00:23,080 --> 10:00:29,680
“cross”（叉积、十字、交叉等意思）在这里表意不明确，句子不太通顺。大致翻译为：
什么是“cross”的导数？ 

14116
10:00:27,080 --> 10:00:29,680
熵

14117
10:00:32,360 --> 10:00:38,480
损失，所以它被定义成这样，也就是我们……

14118
10:00:35,040 --> 10:00:41,276
刚检查过，所以易才是真正的标签

14119
10:00:38,480 --> 10:00:41,276
要么为零，要么是

14120
10:00:43,560 --> 10:00:49,240
这是一种预测，那么，易（这里不太明确“Yi”具体所指，可能是人名等） 

14121
10:00:47,080 --> 10:00:51,400
不戴帽子才是真正的标志，还有Y

14122
10:00:49,240 --> 10:00:53,400
我不太理解“hat I”是什么意思，你可能输入有误。如果按照现有内容勉强翻译是：
帽子我 是什么是防护概率以及 

14123
10:00:51,400 --> 10:00:54,800
我们把这个过一遍，我们做一些，我们做……

14124
10:00:53,400 --> 10:00:57,960
一些；某些；某个

14125
10:00:54,800 --> 10:00:59,360
求导，嗯，我们进行几个步骤

14126
10:00:57,960 --> 10:01:01,000
稍后我不会真正涉及到……

14127
10:00:59,360 --> 10:01:02,960
这一求导部分背后的数学原理

14128
10:01:01,000 --> 10:01:04,560
这部分呢，你知道的，你是可以做到的。

14129
10:01:02,960 --> 10:01:06,480
如果你真的觉得这是……你可以自己去做这件事（由于原文不完整，这里是结合语境合理推测的表述，仅供参考） 

14130
10:01:04,560 --> 10:01:10,480
有必要，嗯，但实际上我们关心的是…… 

14131
10:01:06,480 --> 10:01:12,320
关于这个，答案就是这样，所以实际情况是…… （由于原英文表述不太完整通顺，翻译可能会有些不太精准地传达完整语义） 

14132
10:01:10,480 --> 10:01:15,436
导数，所以把这一切综合起来

14133
10:01:12,320 --> 10:01:18,436
看看这个梯度，嗯，我们……我们……

14134
10:01:15,436 --> 10:01:24,960
真正在乎的是

14135
10:01:18,436 --> 10:01:27,320
嗯，为什么是 ŷ 减去 y 呢，并且要注意 ŷ 是…… 

14136
10:01:24,960 --> 10:01:30,916
呃，预测概率，所以这个，所以

14137
10:01:27,320 --> 10:01:33,360
那个经过softmax处理的，呃，经过softmax处理的对数几率

14138
10:01:30,916 --> 10:01:35,240
对，呃，概率分布

14139
10:01:33,360 --> 10:01:39,720
然后，通常用 Y 表示真实标签。

14140
10:01:35,240 --> 10:01:41,800
所以如果我们回到这里的代码，嗯，然后

14141
10:01:39,720 --> 10:01:45,116
我们看看那是怎样的

14142
10:01:41,800 --> 10:01:47,200
经过计算，我们下去看看，结果发现它是

14143
10:01:45,116 --> 10:01:49,520
softmax概率分布

14144
10:01:47,200 --> 10:01:52,480
减去真实标签，对吧，所以那就是

14145
10:01:49,520 --> 10:01:54,480
正是我们所期望的样子，嗯，而且还很多

14146
10:01:52,480 --> 10:01:56,080
关于我们在这里所做的这件事，这是

14147
10:01:54,480 --> 10:02:01,200
主要只是把东西转换为……

14148
10:01:56,080 --> 10:02:03,720
实际的独热向量 嗯 所以 呃 是的

14149
10:02:01,200 --> 10:02:05,160
就是这样，差不多就是这样

14150
10:02:03,720 --> 10:02:07,680
差不多就是你如何进行 SoftMax（软最大值函数），然后……

14151
10:02:05,160 --> 10:02:10,756
导数，或者抱歉，交叉熵损失

14152
10:02:07,680 --> 10:02:14,960
以及它现在正在进行的导数（这里表述不太清晰，根据语境“导数”可能需要调整为更合适的表达） 

14153
10:02:10,756 --> 10:02:16,880
呃，接下来呢，那么现在我们有……现在

14154
10:02:14,960 --> 10:02:22,320
实际上我们必须要经历并

14155
10:02:16,880 --> 10:02:26,596
计算我们的W2的梯度

14156
10:02:22,320 --> 10:02:29,400
我们的X2，甚至可能是福特的产品，以及

14157
10:02:26,596 --> 10:02:32,916
偏差，对吧。那么，让我们去看看

14158
10:02:29,400 --> 10:02:35,880
我要举一个例子，在这个例子里我们

14159
10:02:32,916 --> 10:02:37,916
差不多就是这样，呃，我们计算 dw1 以及

14160
10:02:35,880 --> 10:02:39,596
然后我们就有点像是把呃这个…… 

14161
10:02:37,916 --> 10:02:41,960
从那直觉延伸到其他一切事物

14162
10:02:39,596 --> 10:02:44,720
然后就接着把它用上，没错吧

14163
10:02:41,960 --> 10:02:47,520
在 DW1 里 我打算 实际上我

14164
10:02:44,720 --> 10:02:51,200
马上就去做这个



14165
10:02:47,520 --> 10:02:55,040
嗯，但我会带上我的

14166
10:02:51,200 --> 10:02:58,400
怀特巴，再靠近一点，所以我不知道

14167
10:02:55,040 --> 10:03:00,880
如果你能看到这个，但我差不多

14168
10:02:58,400 --> 10:03:04,116
呃，是基于你所知道的那个微……（这里“micr”不完整，推测可能是“MICR”即“磁性墨水字符识别” ，但仅根据现有内容无法准确完整翻译） 

14169
10:03:00,880 --> 10:03:08,116
教程 我做了呃 就像这样一个输出 这就是

14170
10:03:04,116 --> 10:03:10,596
一个神经元的输出，没错，所以是 X1 * W1 + X2 *

14171
10:03:08,116 --> 10:03:12,560
W2，在那里就好像每个 X 值

14172
10:03:10,596 --> 10:03:18,040
进去然后

14173
10:03:12,560 --> 10:03:19,840
那么，嗯，那个神经元会像两个……

14174
10:03:18,040 --> 10:03:22,596
x 值输入进去，然后会有一个唯一的

14175
10:03:19,840 --> 10:03:25,436
有两个权重的神经元

注：这里“uh”“um”是语气词，在翻译中一般不体现其意思，以保证译文的自然流畅。 

14176
10:03:22,596 --> 10:03:30,880
W1 和 W2，然后它通过……输出这些 

14177
10:03:25,436 --> 10:03:35,360
通过在……之间进行点积运算

14178
10:03:30,880 --> 10:03:38,596
所以它先计算 X1 乘以 W1，然后将其结果加上…… 

14179
10:03:35,360 --> 10:03:40,916
X2 乘以 W2，我刚刚在……里写下了这个。

注：原文最后“in the”后面似乎缺少内容，这里只能按照已有原文翻译。 

14180
10:03:38,596 --> 10:03:44,436
微 G 梯度的上下文，所以这里有数据

14181
10:03:40,916 --> 10:03:46,436
并且针对这个有一个梯度属性，这里有一个

14182
10:03:44,436 --> 10:03:48,800
为此有一个数据属性和一个梯度属性



14183
10:03:46,436 --> 10:03:51,276
注意我是如何做的，这是一个加分项 

14184
10:03:48,800 --> 10:03:54,116
标志 我知道你看不见它，因为

14185
10:03:51,276 --> 10:03:56,480
嗯，它非常小，但我……做了一个

14186
10:03:54,116 --> 10:03:58,436
加号，所以那两个相加在一起

14187
10:03:56,480 --> 10:04:00,560
并且梯度会朝着这个方向

14188
10:03:58,436 --> 10:04:03,840
就在这里毕业的两人，那将会……

14189
10:04:00,560 --> 10:04:07,040
流向这两个节点的是这个 X1 * W1

14190
10:04:03,840 --> 10:04:09,960
并且 X2 * W2 那将流向

14191
10:04:07,040 --> 10:04:12,640
这些，嗯，是一样的，所以当你……当你

14192
10:04:09,960 --> 10:04:15,880
比如，呃，举个例子，当你试图……

14193
10:04:12,640 --> 10:04:17,756
对一个常数求导，嗯，它……结束了（这里表述不太符合正常逻辑，推测可能原文表述有误，但按照原文内容逐字翻译） 

14194
10:04:15,880 --> 10:04:19,116
最终它就变成了一个整体

14195
10:04:17,756 --> 10:04:22,560
对，所以实际上当……的时候并没有变化

14196
10:04:19,116 --> 10:04:24,720
你有，嗯，就像一个图表，是哪个图表呢

14197
10:04:22,560 --> 10:04:27,160
你给它加上类似偏差的东西，然后进行偏移

14198
10:04:24,720 --> 10:04:29,436
那条向上弯曲的曲线，它仍然具有相同的……（这里原文没说完，“相同的”后面的内容缺失）

14199
10:04:27,160 --> 10:04:31,320
倾斜，没错，所以本质上就是……

14200
10:04:29,436 --> 10:04:33,560
这里正在发生的事情，然后我们继续

14201
10:04:31,320 --> 10:04:37,800
向前，现在这就变成了一个

14202
10:04:33,560 --> 10:04:39,596
乘法，所以 W2，呃，或者抱歉，X1 *

14203
10:04:37,800 --> 10:04:41,520
W1，然后我们有一个数据和一个梯度

14204
10:04:39,596 --> 10:04:43,240
那些的属性，所以那就像

14205
10:04:41,520 --> 10:04:45,520
有点像神经元会变成的样子

14206
10:04:43,240 --> 10:04:50,520
在……的背景下构建

14207
10:04:45,520 --> 10:04:53,596
显微照片，现在，呃，如果我们切换到……

14208
10:04:50,520 --> 10:04:55,800
嗯，如果我们转到这个

14209
10:04:53,596 --> 10:05:00,800
例子，其中

14210
10:04:55,800 --> 10:05:04,116
在这里，所以这个DW1

14211
10:05:00,800 --> 10:05:08,116
输出 我基本上所做的就是我们去

14212
10:05:04,116 --> 10:05:11,240
呃，784乘以B，那么咱们就把它画出来。 

14213
10:05:08,116 --> 10:05:14,240
很快就出去了（这里需结合具体语境，“out”含义可能更丰富，比如“结束”“完成”等，这里只是较常见的“出去”） 

14214
10:05:11,240 --> 10:05:14,240
嗯

14215
10:05:17,360 --> 10:05:23,116
所以 784 乘以

14216
10:05:20,436 --> 10:05:29,116
通过；由；被；在……旁边；在……之前；不迟于；根据；按照；以……计；靠；用；乘（交通工具）

14217
10:05:23,116 --> 10:05:29,116
B，然后我们有，嗯，B 除以 256

14218
10:05:29,560 --> 10:05:33,756
对，这是一个“@”符号，它真的……

14219
10:05:31,960 --> 10:05:36,160
糟糕的；坏的；劣质的；有害的；不道德的；严重的；不舒服的；遗憾的；笨拙的；不擅长的；变质的；不正确的；不利的；缺乏的；不适合的；不新鲜的；不诚实的；不合法的

14220
10:05:33,756 --> 10:05:38,400
绘画；绘图；图画；素描画

14221
10:05:36,160 --> 10:05:41,480
B 乘

注：这里“by”常见有“乘”的意思，不过由于内容简短，可能“B by”在具体语境中有不同含义，以上翻译仅供参考。 

14222
10:05:38,400 --> 10:05:43,756
256 好的，那么我们实际上该怎么做

14223
10:05:41,480 --> 10:05:45,360
这里进行矩阵乘法，嗯，我们取一个

14224
10:05:43,756 --> 10:05:47,720
……的列；……的纵队

注：由于“column of”后面缺少内容，这样的翻译只是一般情况下对该短语的理解，完整准确的翻译需要结合具体语境。 

14225
10:05:45,360 --> 10:05:50,520
这个，然后我们用一排……来绘制产品（这里原文“a row of”后面缺少内容） 

14226
10:05:47,720 --> 10:05:51,960
这个对，注意看这是怎么回事

14227
10:05:50,520 --> 10:05:53,400
批次，没错，所以这将是一个

14228
10:05:51,960 --> 10:05:54,960
批量元素
这是一个批量元素

14229
10:05:53,400 --> 10:05:58,080
这是一个批量元素，所以它将要……

14230
10:05:54,960 --> 10:06:01,800
这就是我们实际上正在做的事情

14231
10:05:58,080 --> 10:06:03,436
嗯，我们正在取第一个像素。

14232
10:06:01,800 --> 10:06:05,320
跨越第一批元素，所以如果我们

14233
10:06:03,436 --> 10:06:06,520
要是就去这儿，那会是一次…… （这里“an”后面内容缺失，可补充完整后继续让我翻译）

14234
10:06:05,320 --> 10:06:07,640
整个图像，对，那会是那个

14235
10:06:06,520 --> 10:06:09,800
第一批元素，它会是一个

14236
10:06:07,640 --> 10:06:12,116
整幅图像，但我们正在处理第一部分

14237
10:06:09,800 --> 10:06:13,880
整个批次的像素，对吧，所以

14238
10:06:12,116 --> 10:06:15,436
在所有不同的批次元素中

14239
10:06:13,880 --> 10:06:20,360
我们正在进行……我们正在生产……

（原英文文本表述不太准确和完整，以上是尽量按原文意思的翻译） 

14240
10:06:15,436 --> 10:06:23,640
像素值，嗯，比如说 X

14241
10:06:20,360 --> 10:06:23,640
嗯，x。

14242
10:06:24,276 --> 10:06:30,000
数据在

14243
10:06:26,400 --> 10:06:32,960
索引0 没错，然后在这种语境下

14244
10:06:30,000 --> 10:06:35,160
这是 B 除以 256，这与……相同

14245
10:06:32,960 --> 10:06:39,160
呃，输出层，所以如果我们像这样做

14246
10:06:35,160 --> 10:06:41,040
例如，……的经典输入

14247
10:06:39,160 --> 10:06:44,520
嗯，你回到这个，就好像是B乘以…… 

14248
10:06:41,040 --> 10:06:47,800
784乘以784再除以256，最终得到B乘以…… 

14249
10:06:44,520 --> 10:06:49,720
256，这就是我们的输出梯度，对吧

14250
10:06:47,800 --> 10:06:51,680
所以实际上我们只是……只是

14251
10:06:49,720 --> 10:06:53,960
拿着这个，我们正在挪动它。

14252
10:06:51,680 --> 10:06:56,000
所以我们正在做，我们正在用这个B乘以…… （注：原文“by”后内容缺失，此句不太完整） 

14253
10:06:53,960 --> 10:06:58,880
256 保持不变，但我们是

14254
10:06:56,000 --> 10:07:02,320
对输入进行转置，使其形如 x.t

14255
10:06:58,880 --> 10:07:05,040
或者抱歉 x。数据

14256
10:07:02,320 --> 10:07:06,800
转置呃 矩阵，然后将其与……相乘

14257
10:07:05,040 --> 10:07:08,640
输出输出梯度，并且我们正在

14258
10:07:06,800 --> 10:07:12,960
计算权重的梯度

14259
10:07:08,640 --> 10:07:14,720
好的，DW1 值，嗯，所以如果我们往回查看

14260
10:07:12,960 --> 10:07:19,040
到这里

14261
10:07:14,720 --> 10:07:21,080
256 记住，嗯，784 是多少个砝码（重量单位可能需根据具体语境确定）

14262
10:07:19,040 --> 10:07:22,480
在单个神经元中，但256是那个（这里“256是那个”表述不太完整，需结合更多语境明确其具体所指）

14263
10:07:21,080 --> 10:07:26,116
我们实际拥有的神经元数量在……（由于文本不完整，此翻译供参考） 

14264
10:07:22,480 --> 10:07:27,400
那个隐藏层，所以256将会是

14265
10:07:26,116 --> 10:07:29,200
像这样，这，这些全都是

14266
10:07:27,400 --> 10:07:31,640
神经元排列正确，但我们所面临的是…… （注：原文未完整，此为根据现有内容的翻译） 

14267
10:07:29,200 --> 10:07:34,240
要做的是，而不是像拿一个…… 

14268
10:07:31,640 --> 10:07:36,240
单一 单一的一组所有神经元

14269
10:07:34,240 --> 10:07:38,640
从单个批量元素开始，我们将继续……（原句未完整表达意思，这里根据一般语境适当做了补充，若原句有特定含义，可根据实际情况调整） 

14270
10:07:36,240 --> 10:07:41,720
获取所有的……所有的索引

14271
10:07:38,640 --> 10:07:45,000
零梯度，呃，贯穿

14272
10:07:41,720 --> 10:07:47,360
呃，穿过……

（由于文本不完整，此翻译可能不太符合完整语境的需求） 

14273
10:07:45,000 --> 10:07:50,520
穿过；越过；从表面穿过；在……对面；遍及；在……各处；跨度为；横跨；从……的一端到另一端

注：“across”是个多义词，具体含义需结合语境确定，以上是常见释义列举。如果你有其所在的完整句子，请提供给我以便更精准翻译。 

14274
10:07:47,360 --> 10:07:53,360
本质上，呃，批量元素

14275
10:07:50,520 --> 10:07:55,756
不，抱歉，不能批量运输零号元素跨越（此处across后面似乎信息不完整） 

14276
10:07:53,360 --> 10:07:57,560
我们要取出第一批神经元。

14277
10:07:55,756 --> 10:08:01,400
在整批当中就是那样

14278
10:07:57,560 --> 10:08:06,000
我们正在做这件事，所以最终结果会是，嗯

14279
10:08:01,400 --> 10:08:06,000
我们就说它是y。

14280
10:08:06,916 --> 10:08:09,916
毕业生；学位；坡度；（温度、压力等的）梯度；分等级；逐渐变化

14281
10:08:14,720 --> 10:08:20,276
嗯，在索引为零处的 y 梯度，我们正在处理它

14282
10:08:18,596 --> 10:08:22,276
在整个 B 批次范围内，所以它仅仅是一个

14283
10:08:20,276 --> 10:08:24,000
单个神经元，没错，它仅仅是一个（单个的）

14284
10:08:22,276 --> 10:08:26,520
神经元，但我们正在对其进行概括

14285
10:08:24,000 --> 10:08:28,200
在整批（货物/样本等，需结合上下文确定）中都是如此，所以我们有了这个

14286
10:08:26,520 --> 10:08:29,560
在……上进行泛化的 x 分量

14287
10:08:28,200 --> 10:08:31,480
整批以及这个y分量

14288
10:08:29,560 --> 10:08:33,800
对整个批次进行泛化，我们

14289
10:08:31,480 --> 10:08:37,000
运用我们从……获得的相同直觉

14290
10:08:33,800 --> 10:08:39,200
微电网讲座，然后我们直接应用它

14291
10:08:37,000 --> 10:08:41,520
这里，除非我们得到那个普遍化的结论

14292
10:08:39,200 --> 10:08:42,756
使用批处理的能力

14293
10:08:41,520 --> 10:08:44,116
这就是关键所在了。

14294
10:08:42,756 --> 10:08:47,200
因为我们实际上正在做的是

14295
10:08:44,116 --> 10:08:48,756
在这里做，呃，列，与……做乘积

14296
10:08:47,200 --> 10:08:51,320
行并注意到这些形状是有方向的

14297
10:08:48,756 --> 10:08:51,320
在某种程度上

14298
10:08:51,680 --> 10:08:55,800
是啊；是的

14299
10:08:52,640 --> 10:09:00,320
这……这确实很难一下子接受，但在

14300
10:08:55,800 --> 10:09:03,040
最后我们得到，嗯，所以这是

14301
10:09:00,320 --> 10:09:04,640
这就像是一个 784 行 B 列的矩阵，然后是一个 B 行 256 列的矩阵 （注：这里因为不清楚上下文，推测是在说矩阵维度情况，“B” 应根据实际情况理解，可能是某个变量代表的数字等。按照任务要求不添加解释，这里只是补充可能的理解供参考）

准确的翻译是：这就像 784 乘以 B，然后 B 乘以 256 

14302
10:09:03,040 --> 10:09:07,320
所以 B 相互抵消了，然后剩下……

14303
10:09:04,640 --> 10:09:07,320
和……在一起；具有；用；随着；因为；关于

14304
10:09:08,040 --> 10:09:12,160
嗯，我知道这些形状超出了……（原文“out of”后面似乎缺失内容） 

14305
10:09:10,040 --> 10:09:17,276
比例；部分；均衡；面积；规模

14306
10:09:12,160 --> 10:09:19,720
784 乘以 256，没错，所以这个 784 就是那个…… 

14307
10:09:17,276 --> 10:09:22,116
第一个像素值，所以这些中的每一个或者

14308
10:09:19,720 --> 10:09:23,520
抱歉，这些元素中的每一个，那是

14309
10:09:22,116 --> 10:09:25,436
一个像素

14310
10:09:23,520 --> 10:09:28,320
对，那总体来说就是一个像素。

14311
10:09:25,436 --> 10:09:31,800
将图像扁平化，这些就是全部内容了

14312
10:09:28,320 --> 10:09:34,040
神经元，所以我们最终要计算这些东西

14313
10:09:31,800 --> 10:09:36,276
嗯，以一种我们能够……我们能够……的方式

14314
10:09:34,040 --> 10:09:38,240
实际上，更新呃所有的权重

14315
10:09:36,276 --> 10:09:40,880
没错，那么当所有这些……

14316
10:09:38,240 --> 10:09:43,720
摆出来之后，你有，嗯，用于……的渐变（这里“for”后面缺内容，句子不太完整通顺） 

14317
10:09:40,880 --> 10:09:47,040
第一个……整个的每个神经元

14318
10:09:43,720 --> 10:09:49,040
第一个像素值，并且那是这个

14319
10:09:47,040 --> 10:09:51,276
这和我们最初的方式是一样的

14320
10:09:49,040 --> 10:09:53,560
权重矩阵排列正确，所以在……中

14321
10:09:51,276 --> 10:09:56,200
我们的权重矩阵 它正在处理这些

14322
10:09:53,560 --> 10:09:58,960
一列列的，就像一个单独的神经元的……

注：原文“Columns of of”可能存在重复使用“of”的错误，可能原文是“Columns of” 。 

14323
10:09:56,200 --> 10:10:02,360
权重，并将其与……进行相乘操作（原文“producting”有误，正确形式可能是“multiplying” ；“with with”表述有误） 

14324
10:09:58,960 --> 10:10:04,560
一张呃，一张单独的图片

14325
10:10:02,360 --> 10:10:06,680
对，而且它正在那样做，并且

14326
10:10:04,560 --> 10:10:10,680
这非常直观，而且很有道理。

14327
10:10:06,680 --> 10:10:10,680
呃，但在这个例子中

14328
10:10:10,960 --> 10:10:15,596
嗯，你知道的，我们最后会得到那些东西。

14329
10:10:14,160 --> 10:10:17,520
我们最终得到了和我们……相同的那些东西（这里句子不完整，翻译可能不太精准） 

14330
10:10:15,596 --> 10:10:19,756
我们是否想对那些进行更新呢，用……（这里“with”后面缺少内容，译文表述受此影响会不太完整） 

14331
10:10:17,520 --> 10:10:21,596
所以你可以大致翻译一下然后看看

14332
10:10:19,756 --> 10:10:23,160
比如这里这一列是什么，它表示……（原句似乎不完整）

14333
10:10:21,596 --> 10:10:26,640
那由什么组成，这一行又是什么呢

14334
10:10:23,160 --> 10:10:31,160
这里由……组成，并且我们可以把它代入进去

14335
10:10:26,640 --> 10:10:33,680
并且我们可以看到我们的权重更新

14336
10:10:31,160 --> 10:10:35,880
实际上在这里会说得通，所以

14337
10:10:33,680 --> 10:10:39,400
在这一个（情况、事物等，需结合上下文确定）中，我们本质上最终……

14338
10:10:35,880 --> 10:10:43,360
有这个有256个值的东西以及那个

14339
10:10:39,400 --> 10:10:46,400
本质上将会仅仅是那个……

（由于原句不完整，翻译可能不太能精准表达确切含义） 

14340
10:10:43,360 --> 10:10:48,960
所有神经元的梯度与

14341
10:10:46,400 --> 10:10:51,080
尊重单个像素，没错，就因为这个

14342
10:10:48,960 --> 10:10:52,436
是整个批次中的单个像素

14343
10:10:51,080 --> 10:10:55,160
我们又在使用批量处理了。

14344
10:10:52,436 --> 10:10:56,480
这里的泛化思路，嗯，我们只是

14345
10:10:55,160 --> 10:10:58,276
就像对整个批次进行概括一样

14346
10:10:56,480 --> 10:10:59,560
而不是使用一个特定的样本

14347
10:10:58,276 --> 10:11:02,800
那样的话，对……来说会更好

14348
10:10:59,560 --> 10:11:04,360
稳定训练，嗯，而且我们正在…… 

14349
10:11:02,800 --> 10:11:08,040
只是我们正在接受那个，而且我们只是

14350
10:11:04,360 --> 10:11:12,116
把一切都摊开来说是为了……（原句不完整，这里按一般语境补充一种理解）

14351
10:11:08,040 --> 10:11:15,680
嗯，对于across a（这里across a表述不完整）的所有神经元来说

14352
10:11:12,116 --> 10:11:17,040
单个，嗯，跨越单个像素，对吧

14353
10:11:15,680 --> 10:11:19,040
我们就是这样计算这些的，所以

14354
10:11:17,040 --> 10:11:21,756
这个，这个，呃，事情会是这样的

14355
10:11:19,040 --> 10:11:23,960
行，这是我们的像素交流电，就像所有的…… （此处“pixel AC”可能表述不太准确，结合语境看“AC”如果是“Alternating Current”即“交流电”，“pixel”和“AC”的搭配可能是特定领域概念，需根据更多背景明确其确切含义） 

14356
10:11:21,756 --> 10:11:27,400
像素，就像对于所有的第一个（像素）那样 

14357
10:11:23,960 --> 10:11:30,520
所有批次的像素，然后我们

14358
10:11:27,400 --> 10:11:33,040
有我们的单曲

注：原英文 “have our our single” 存在表述错误，推测可能是 “have our single”  ，以上是按可能正确的语义进行的翻译。 

14359
10:11:30,520 --> 10:11:35,320
嗯，我们有了我们的第一个神经元，而且它是…… 

14360
10:11:33,040 --> 10:11:36,880
准备先让第一个神经元启动，它开始了

14361
10:11:35,320 --> 10:11:39,200
把第一个值放在那里，然后

14362
10:11:36,880 --> 10:11:41,916
第二个神经元激增，一路达到 256 个

14363
10:11:39,200 --> 10:11:44,680
神经元，然后它会把这个输出出来

14364
10:11:41,916 --> 10:11:48,116
排成一列；成纵队；成一排

在特定语境下，“in a column” 可能会有更符合场景的释义，比如 “在一个专栏里” 等。你可以提供更完整的句子或上下文，以便我更精准地翻译。若就 “in a column” 这一短语而言，上述为常见释义。 

14365
10:11:44,680 --> 10:11:50,400
对，这些就是所有的神经元了，嗯，用于…… 

14366
10:11:48,116 --> 10:11:52,840
整个第一个……

（不过原英文 “the for the entire first” 并不是一个完整合理的表达，可能存在输入错误） 

14367
10:11:50,400 --> 10:11:53,960
像素，然后如果我们看看它是如何发展的

14368
10:11:52,840 --> 10:11:57,320
向下；在下面；倒下；下降；沿着……向下；向下游；在较低的位置；减少；低于；往南；在南方；（坐、躺、放）下；（表示范围或顺序）从……到；（情绪）低落；向下的；沮丧的；（计算机）停机的；打倒；击败；吃下；喝下；放下；吞下；使倒下；把……放下；（尤指在困境中）使失望；下降；向下的移动；绒毛；软毛；汗毛；开阔的高地

需注意，“down”含义丰富，要结合具体语境来确定最恰当的释义。若你能提供更多上下文，我能给出更精准的翻译。 

14369
10:11:53,960 --> 10:11:59,080
按列处理，然后我们得到，嗯，然后我们得到

14370
10:11:57,320 --> 10:12:01,560
第二个像素的所有神经元以及

14371
10:11:59,080 --> 10:12:03,000
第三个像素和第四个像素，对吧

14372
10:12:01,560 --> 10:12:06,116
所以我们在某种程度上可以

14373
10:12:03,000 --> 10:12:07,840
看看这又如何与，呃……联系起来

14374
10:12:06,116 --> 10:12:10,916
最初的前向传播示例，即

14375
10:12:07,840 --> 10:12:12,800
我们当时在做，嗯，如果这个，如果这个不行的话

14376
10:12:10,916 --> 10:12:16,160
有道理 我知道我的解释可能

14377
10:12:12,800 --> 10:12:18,360
不太好 嗯，你知道的，你也许想离开

14378
10:12:16,160 --> 10:12:20,840
回来，我的意思是你，你可以画画

14379
10:12:18,360 --> 10:12:22,720
把这个弄出来，你自己，嗯，那确实管用

14380
10:12:20,840 --> 10:12:25,436
然后在你的脑海中大致想象一下它的样子

14381
10:12:22,720 --> 10:12:27,000
嘿，那是个好主意，去做……嗯，就是这样。

14382
10:12:25,436 --> 10:12:29,680
尝试去理解如何……是个好主意

14383
10:12:27,000 --> 10:12:31,756
这行得通 嗯，或者你可以

14384
10:12:29,680 --> 10:12:33,640
你可以看看我的张量，呃，我的张量

14385
10:12:31,756 --> 10:12:35,800
水平回推宣传视频，我觉得我做了一个

14386
10:12:33,640 --> 10:12:38,560
干得不错，嗯，大概是30

14387
10:12:35,800 --> 10:12:41,436
几分钟长，所以呃

14388
10:12:38,560 --> 10:12:44,116
不管怎样，嗯，我们，如果，如果这不行的话

14389
10:12:41,436 --> 10:12:49,400
完全说得通，我们打算用

14390
10:12:44,116 --> 10:12:49,400
我们有这个 784 的这种直觉

14391
10:12:49,840 --> 10:12:54,240
通过；被；由；在……旁边；在……之前；按照；以……计；经过；在……期间

14392
10:12:50,960 --> 10:12:59,000
256，这和我们的……是一样的 

14393
10:12:54,240 --> 10:12:59,000
这段英文“W um our w. dat”可能并不是一个有准确表意的正常语句，从现有内容看较难准确翻译，勉强逐字处理可译为：
W 嗯 我们的 w. 那个

14394
10:13:00,116 --> 10:13:04,116
好的，那么我们的工作组（这里 w.g. 推测是 working group 的缩写 ）

14395
10:13:08,200 --> 10:13:14,436
毕业生和我们的

14396
10:13:11,040 --> 10:13:17,916
w. 那有相同的（这里“w.”可能是缩写或有特定含义，原文表意不太清晰）

14397
10:13:14,436 --> 10:13:19,960
形状 那么本质上我们能做的是

14398
10:13:17,916 --> 10:13:22,880
我们可以带走；我们可以拿；我们可以乘坐（具体含义需结合语境） 

14399
10:13:19,960 --> 10:13:25,116
嗯，说在……在梯度里

14400
10:13:22,880 --> 10:13:27,880
例如，我们可以采用这个数值。

14401
10:13:25,116 --> 10:13:30,240
将它乘以一个例如 LR 的学习率

14402
10:13:27,880 --> 10:13:33,880
相等的；平等的；胜任的；同样的

使相等；比得上

同等的人；相等物

14403
10:13:30,240 --> 10:13:36,520
0.1，然后我们可以从……中减去这个数。

14404
10:13:33,880 --> 10:13:38,480
原来的那个，对，所以如果

14405
10:13:36,520 --> 10:13:40,200
梯度非常大，这意味着

14406
10:13:38,480 --> 10:13:43,240
存在很多错误，而且如果…… 

14407
10:13:40,200 --> 10:13:46,800
梯度真的很低，嗯，这意味着

14408
10:13:43,240 --> 10:13:48,000
会有……嗯，那个

14409
10:13:46,800 --> 10:13:49,240
意味着误差将会更小

14410
10:13:48,000 --> 10:13:51,200
没错，这就是为什么它被叫做一个…… 

14411
10:13:49,240 --> 10:13:53,596
随机梯度下降，因为你是

14412
10:13:51,200 --> 10:14:01,360
沿着梯度下降，嗯，所以它正在进行

14413
10:13:53,596 --> 10:14:05,880
本质上，呃，w. 数据等于 LR

14414
10:14:01,360 --> 10:14:08,756
次数 嗯，为了次数学习就做 X

14415
10:14:05,880 --> 10:14:11,840
被评估者；被评价者；被评级者

14416
10:14:08,756 --> 10:14:16,080
乘以梯度元素

14417
10:14:11,840 --> 10:14:19,560
对，然后我们进行，嗯，减法运算

14418
10:14:16,080 --> 10:14:21,756
等于，这样如果梯度值

14419
10:14:19,560 --> 10:14:23,116
非常高，学习率为 0.1

14420
10:14:21,756 --> 10:14:25,200
那么接下来将会是一段美好的时光

14421
10:14:23,116 --> 10:14:26,640
负的，然后这将会变成

14422
10:14:25,200 --> 10:14:30,200
如果，则向负方向调整

14423
10:14:26,640 --> 10:14:32,520
坡度真的很陡，嗯，而且如果

14424
10:14:30,200 --> 10:14:34,720
这个梯度真的……如果它真的…… 

14425
10:14:32,520 --> 10:14:37,596
负梯度实际上是

14426
10:14:34,720 --> 10:14:41,560
负面的；消极的；否定的；负面情况；否定的观点；底片

14427
10:14:37,596 --> 10:14:43,756
嗯，那么这将会……这就要……

14428
10:14:41,560 --> 10:14:45,276
用这个相乘，它会得出

14429
10:14:43,756 --> 10:14:47,116
一个负值，然后因为我们正在

14430
10:14:45,276 --> 10:14:49,560
减去一个负数，它会朝着（某个方向变化，这里原文表述不完整未明确具体情况） 

14431
10:14:47,116 --> 10:14:50,560
上升以及它即将上升的方式，所以

14432
10:14:49,560 --> 10:14:52,960
那……那实际上就是我们正在做的全部事情。

14433
10:14:50,560 --> 10:14:55,560
在渐变中

14434
10:14:52,960 --> 10:14:57,960
下降，并且我们正在为每一个（情况/对象等，需结合上下文确定）都这么做

14435
10:14:55,560 --> 10:15:01,240
元素 现在我们可以在某种程度上利用那个

14436
10:14:57,960 --> 10:15:05,560
直觉，然后将其发散出去，你懂的

14437
10:15:01,240 --> 10:15:08,520
dw2 没错，而且我们可以将其应用于

14438
10:15:05,560 --> 10:15:10,720
DX2 嗯，你知道这其实不是一个……（此处原文不完整）

14439
10:15:08,520 --> 10:15:12,436
关于反向传播的课程，所以也别太担心

14440
10:15:10,720 --> 10:15:14,436
如果那并没有完全达成（这里“make”含义不太明确，需结合更多语境准确理解）
 

14441
10:15:12,436 --> 10:15:16,116
感觉它很重要，但如果它不重要

14442
10:15:14,436 --> 10:15:19,080
完全说得通，你还在继续

14443
10:15:16,116 --> 10:15:19,916
没关系的，嗯，因为我们要去…… 

14444
10:15:19,080 --> 10:15:21,240
实施这个，然后你将会

14445
10:15:19,916 --> 10:15:23,160
实际上能够看到网络

14446
10:15:21,240 --> 10:15:24,880
学习，而且你实际上可以打印出来

14447
10:15:23,160 --> 10:15:26,800
去理解正在发生的事情的要点

14448
10:15:24,880 --> 10:15:29,596
在……之下

请注意，“under the”并不是一个完整表意的短语，一般后面还会接名词。如果这是文本的一部分，你可以提供完整内容以便我更准确翻译。 

14449
10:15:26,800 --> 10:15:32,436
社区，当然我们确实需要这些呃

14450
10:15:29,596 --> 10:15:34,480
这些，这些用于计算……的 X 值

14451
10:15:32,436 --> 10:15:37,560
中间
这些中间层

14452
10:15:34,480 --> 10:15:39,960
没错，关于激活函数，嗯，还有

14453
10:15:37,560 --> 10:15:42,160
像字面意义上的激活函数

14454
10:15:39,960 --> 10:15:45,400
如果你想让我把那个画出来

14455
10:15:42,160 --> 10:15:45,400
会起作用；会工作；会奏效

注：“would work”具体含义需结合语境判断，以上是常见释义。 

14456
10:15:47,400 --> 10:15:50,916
嗯，鲁厄

（注：“Rue”可能是人名、地名等，具体含义需结合语境确定） 

14457
10:15:51,116 --> 10:15:55,680
事情是这样的

14458
10:15:52,596 --> 10:15:59,720
对，这就好像，这就像一条线，而且

14459
10:15:55,680 --> 10:16:01,436
然后它就那样上升了，那又怎样

14460
10:15:59,720 --> 10:16:03,916
你能为此做的是，你可以说如果我的

14461
10:16:01,436 --> 10:16:05,360
值为零或更小，我将设置

14462
10:16:03,916 --> 10:16:07,040
将梯度设为零，因为没有……

14463
10:16:05,360 --> 10:16:09,756
坡度，这个坡度是

14464
10:16:07,040 --> 10:16:12,756
零，如果它……如果它……如果它更大

14465
10:16:09,756 --> 10:16:15,116
如果它大于零，那么

14466
10:16:12,756 --> 10:16:16,400
呃，我们要把那个设为一，对吧

14467
10:16:15,116 --> 10:16:17,880
因为如果它真的会……

14468
10:16:16,400 --> 10:16:20,320
如果它在上面，就让它保持不变。

14469
10:16:17,880 --> 10:16:23,520
零

14470
10:16:20,320 --> 10:16:23,520
嗯，好的

14471
10:16:24,596 --> 10:16:29,680
太棒了，现在让我们来谈谈，嗯，某种程度上的…… 

14472
10:16:28,040 --> 10:16:32,596
我们所拥有的这个 Python 脚本

14473
10:16:29,680 --> 10:16:34,116
在这里奔跑，呃，只是剖析

14474
10:16:32,596 --> 10:16:37,116
正在发生的一切，这样我们就可以

14475
10:16:34,116 --> 10:16:39,116
就把它和呃这张图片联系起来



14476
10:16:37,116 --> 10:16:40,560
我们，就是我刚在Excal Draw里写的那个（这里“that that”表述不太符合常见语法规范，可能原文存在错误，但按照要求直接翻译） 

14477
10:16:39,116 --> 10:16:42,720
这样一来，一切似乎都说得通了。

14478
10:16:40,560 --> 10:16:43,560
在代码上，在一个概念层面上以及一个

14479
10:16:42,720 --> 10:16:45,680
代码

14480
10:16:43,560 --> 10:16:48,160
水平 好吧，所以就有点要……

14481
10:16:45,680 --> 10:16:51,000
通过，呃，这个 NumPy 脚本，现在，呃，我们

14482
10:16:48,160 --> 10:16:52,040
正常情况下导入 numpy 嗯 我是说我

14483
10:16:51,000 --> 10:16:54,000
实际上已经过了这部分了

14484
10:16:52,040 --> 10:16:55,800
我不打算再回顾这个了，嗯

14485
10:16:54,000 --> 10:16:56,960
但如果我们下去，你可以看到一堆

14486
10:16:55,800 --> 10:16:58,360
这里的函数，对吧，而且这些全都是

14487
10:16:56,960 --> 10:17:00,720
这些都是非常有用的功能。

14488
10:16:58,360 --> 10:17:02,800
我们基本上要用来……的（这里句子不完整，可能语义表达不准确） 

14489
10:17:00,720 --> 10:17:04,400
呃，训练一个单层单隐藏层（的模型）

14490
10:17:02,800 --> 10:17:06,560
多层感知机层来自

14491
10:17:04,400 --> 10:17:08,200
从零开始 嗯 运用我们的直觉

14492
10:17:06,560 --> 10:17:12,116
之前在那基础上构建，你知道的

14493
10:17:08,200 --> 10:17:14,116
微型电网 等等，所以我们往下滚动页面

14494
10:17:12,116 --> 10:17:16,276
并且在这个主函数中，我们声明

14495
10:17:14,116 --> 10:17:19,040
这里有一些变量，比如隐藏变量

14496
10:17:16,276 --> 10:17:21,840
尺寸，我将其设置为比如 256 英寸

14497
10:17:19,040 --> 10:17:23,916
这种情况，呃，输出大小是 10，对吧，所以

14498
10:17:21,840 --> 10:17:26,360
10个不同的数字，从0到9，以及我们的

14499
10:17:23,916 --> 10:17:28,596
输入尺寸是 28x28 像素的扁平化形式

14500
10:17:26,360 --> 10:17:30,960
呃，然后我们要把我们的……

14501
10:17:28,596 --> 10:17:34,080
批量大小 我就在这里填个 8，这样我们

14502
10:17:30,960 --> 10:17:40,040
可以获取……的速度，嗯，学习率

14503
10:17:34,080 --> 10:17:42,560
0.1 或者，嗯，换个说法是 1×10⁻³ 以及

14504
10:17:40,040 --> 10:17:44,040
然后是环氧乙烷，我们要处理五个（单位等，需结合具体语境），所以是环氧乙烷

14505
10:17:42,560 --> 10:17:45,520
是你经历这件事的次数有多少

14506
10:17:44,040 --> 10:17:47,240
整个训练集，所以你接着进行

14507
10:17:45,520 --> 10:17:49,200
从头到尾过一遍，那是肯定的

14508
10:17:47,240 --> 10:17:50,680
迭代次数 特定数量的

14509
10:17:49,200 --> 10:17:52,240
就像前向和反向传播一样，它是

14510
10:17:50,680 --> 10:17:54,800
就像进行一次迭代，然后你接着做

14511
10:17:52,240 --> 10:17:56,520
多个轮次，也就是你知道的“次数”

14512
10:17:54,800 --> 10:17:59,436
你从火车上跨过去

不过原句 “that you go over the train” 单独看表意不是特别清晰，可能在特定语境中有更合适的理解。 

14513
10:17:56,520 --> 10:18:01,596
数据，所以在这里面我们声明这个

14514
10:17:59,436 --> 10:18:03,436
模型 神经网络 正确 输入 隐藏

14515
10:18:01,596 --> 10:18:04,720
以及输出大小，然后我们就有

14516
10:18:03,436 --> 10:18:06,756
这个列车功能即将……

14517
10:18:04,720 --> 10:18:09,436
实际上为我们做那件事，所以在……里面

14518
10:18:06,756 --> 10:18:10,916
这里我们有我们要进行的训练轮数（epoch数），而我们…… 

14519
10:18:09,436 --> 10:18:12,436
打算做什么，在每个……里面（原文“eoch”可能是拼写错误，推测为“each” ） 

14520
10:18:10,916 --> 10:18:13,960
我们要做的是
我们要去训练

14521
10:18:12,436 --> 10:18:15,480
分批进行，对吧？所以我们有了这一批。

14522
10:18:13,960 --> 10:18:18,756
调整一批所有的图像的大小

14523
10:18:15,480 --> 10:18:20,596
将其展平，这样就变成了B×7 784，并且

14524
10:18:18,756 --> 10:18:22,880
我们只是要逐步了解一下，嗯，某种类型

14525
10:18:20,596 --> 10:18:24,960
在这里逐一查看，所以在……

14526
10:18:22,880 --> 10:18:27,000
这个模型。向前推进，我的意思是我们只是

14527
10:18:24,960 --> 10:18:30,040
我们参与了这件事，我们只是在承担（后果等，需结合语境确定准确含义） 

14528
10:18:27,000 --> 10:18:31,800
嗯，X 列车（这里可能表述有误，推测可能是某个特定算法或系统，可结合上下文理解）只是输入图像，并且

14529
10:18:30,040 --> 10:18:34,840
那么这就是输出标签，对吧

14530
10:18:31,800 --> 10:18:37,680
这是……这是那一批，所以在……（原文表述不太完整和清晰，可能存在信息缺失） 

14531
10:18:34,840 --> 10:18:39,840
模型前向传播 嗯，我们输入一个批次，然后我们

14532
10:18:37,680 --> 10:18:41,800
获取一个输出缓存，然后我们得到一个，我们得到

14533
10:18:39,840 --> 10:18:44,436
y 对了，y 预测 （注：原英文表述可能不太符合常规语法逻辑）

14534
10:18:41,800 --> 10:18:46,720
一批中的概率分布在 （此译文感觉原英文句子不完整，但按要求进行了逐词翻译） 

14535
10:18:44,436 --> 10:18:49,480
一批；一组；一群；批量

14536
10:18:46,720 --> 10:18:51,520
对，呃，在我们进行模型前向传播之后，我们就……

14537
10:18:49,480 --> 10:18:54,960
打算采用 Y 的损失函数

14538
10:18:51,520 --> 10:18:58,276
公关以及我们从……处获得的 Y 批次产品

14539
10:18:54,960 --> 10:19:01,160
就在这里，然后我们要出发了，要穿过去，穿过去

14540
10:18:58,276 --> 10:19:04,000
熵损失计算损失，并且

14541
10:19:01,160 --> 10:19:06,040
然后，我们将分别处理那个。

14542
10:19:04,000 --> 10:19:09,240
再次输出，要记住这是

14543
10:19:06,040 --> 10:19:11,800
对数几率，所以不是实际的，嗯，概率

14544
10:19:09,240 --> 10:19:14,680
分布，呃，这是交叉熵损失

14545
10:19:11,800 --> 10:19:17,040
将要对那些进行softmax处理

14546
10:19:14,680 --> 10:19:18,840
嗯，然后它将返回一个损失值。

14547
10:19:17,040 --> 10:19:20,640
对，所以它在这里面进行了软最大值运算。

14548
10:19:18,840 --> 10:19:22,436
所以当我们实际上在获取，呃

14549
10:19:20,640 --> 10:19:23,756
我们的交叉熵损失函数的导数

14550
10:19:22,436 --> 10:19:25,080
得单独去做那件事，对吧

14551
10:19:23,756 --> 10:19:27,480
我们必须得出我们的概率

14552
10:19:25,080 --> 10:19:30,000
分销，然后我们必须……

14553
10:19:27,480 --> 10:19:32,680
基本上就是，嗯，就像我走着那样

14554
10:19:30,000 --> 10:19:33,960
在我们实际做……之前是怎样的

14555
10:19:32,680 --> 10:19:35,436
我们如何进行交叉熵损失的计算

14556
10:19:33,960 --> 10:19:37,800
导数 我曾深入探究过这个

14557
10:19:35,436 --> 10:19:40,080
之前理解了，呃，这是

14558
10:19:37,800 --> 10:19:41,240
实际上我们所做的一切，所以，呃，你懂的，感觉

14559
10:19:40,080 --> 10:19:42,560
可以把这个打印出来，但这个

14560
10:19:41,240 --> 10:19:45,596
如果你去做的话，应该相当直观。

14561
10:19:42,560 --> 10:19:47,480
之前用过 Python 和 PyTorch 嗯 还有

14562
10:19:45,596 --> 10:19:49,560
然后我们就，你懂的，做那个做那个

14563
10:19:47,480 --> 10:19:51,240
减去我们的产出，然后我们

14564
10:19:49,560 --> 10:19:52,880
从那里进行反向传播，对吧，所以我们

14565
10:19:51,240 --> 10:19:55,240
取我们的梯度输出，然后我们使用这个

14566
10:19:52,880 --> 10:19:58,680
缓存这个；把……缓存起来

注：“cache the”并非完整表达，“the”后通常需接名词，这里按字面给出较宽泛的翻译。 

14567
10:19:55,240 --> 10:20:01,360
缓存 嗯，所以当我们做的时候要记住

14568
10:19:58,680 --> 10:20:03,720
模型。向前，我们有偏航角、俯仰角和横滚角（YPR），它们是

14569
10:20:01,360 --> 10:20:06,276
对数几率（logits），然后我们有缓存，它…… 

14570
10:20:03,720 --> 10:20:07,880
实际上仅仅是，嗯，输入，对吧，所以

14571
10:20:06,276 --> 10:20:09,320
图层的所有不同部分

14572
10:20:07,880 --> 10:20:11,916
我们接下来会需要类似……用于……的东西

14573
10:20:09,320 --> 10:20:16,000
例如，我们的 dx²，它是……的导数

14574
10:20:11,916 --> 10:20:18,080
第二，嗯，第二个 x 值，或者，嗯，用于…… 

14575
10:20:16,000 --> 10:20:19,596
示例 这条街输出得对，就那样吧 

14576
10:20:18,080 --> 10:20:21,840
像这样的东西，我们会需要的

14577
10:20:19,596 --> 10:20:23,560
通过所有层进行反向传播

14578
10:20:21,840 --> 10:20:25,080
而且不只是像单一的重量或者

14579
10:20:23,560 --> 10:20:26,400
单个砝码，这里我们会需要用到

14580
10:20:25,080 --> 10:20:28,756
那一整批类似贯穿……（这里文本不太完整，语义不太清晰）

14581
10:20:26,400 --> 10:20:31,000
向前传球，没错，嗯，所以就是这样就是这样

14582
10:20:28,756 --> 10:20:33,400
所有这一切 只不过是……一对（两个，这里“coule”可能是“couple”拼写错误 ） 

14583
10:20:31,000 --> 10:20:35,276
那些，然后当然还有那个输出的

14584
10:20:33,400 --> 10:20:36,640
好的，那么只是为了澄清一下，就像

14585
10:20:35,276 --> 10:20:40,000
我知道那里“缓存”到底是什么意思。

14586
10:20:36,640 --> 10:20:42,680
有时候那可能会有点误导人，嗯

14587
10:20:40,000 --> 10:20:44,880
所以我们进行模型反向传播，然后我们

14588
10:20:42,680 --> 10:20:48,640
只需进行模型更新权重操作，然后我们就能通过了。

14589
10:20:44,880 --> 10:20:51,000
你知道权重、偏差，嗯，权重以及

14590
10:20:48,640 --> 10:20:53,240
再次产生偏见

14591
10:20:51,000 --> 10:20:56,200
那么让我们来梳理一下正在发生的事情。

14592
10:20:53,240 --> 10:20:57,960
在接下来的这部分，我有点假设……

注：原文 “in forward” 表述有误，可能想表达 “in the following”  。 

14593
10:20:56,200 --> 10:21:00,000
这很合理，我们会深入探讨的

14594
10:20:57,960 --> 10:21:01,680
模型反向传播，然后更新权重

14595
10:21:00,000 --> 10:21:05,640
所以在

14596
10:21:01,680 --> 10:21:08,840
向前，呃，模型。向前到这边来，所以

14597
10:21:05,640 --> 10:21:11,160
在这里面，我们将批量大小设置为

14598
10:21:08,840 --> 10:21:12,560
x 在位置零处的形状，所以它将……

14599
10:21:11,160 --> 10:21:16,276
它将会列出这个形状，它是……（原英文表述不太符合正常语法，此为尽量通顺的翻译） 

14600
10:21:12,560 --> 10:21:18,916
到784会变成B，或者抱歉，B是…… 

14601
10:21:16,276 --> 10:21:20,880
会是，嗯，我们拿到的那一批，所以

14602
10:21:18,916 --> 10:21:23,276
当我们 当我们拿下这部分时 我们就……

14603
10:21:20,880 --> 10:21:25,040
拿到一批真货，所以我然后去…… 

14604
10:21:23,276 --> 10:21:28,080
我加上批量大小，所以它变得有点……

14605
10:21:25,040 --> 10:21:29,480
大约八张图片的片段 嗯

14606
10:21:28,080 --> 10:21:32,080
在这里面，我们要拿取…… 

14607
10:21:29,480 --> 10:21:34,200
第一个 那 那 领先维度

14608
10:21:32,080 --> 10:21:36,916
其中涉及到的是批量大小，并且我们设置

14609
10:21:34,200 --> 10:21:42,840
这里设置批量大小，然后我们进行重塑操作

14610
10:21:36,916 --> 10:21:45,160
我们按照微米来确定批量大小，然后那个

14611
10:21:42,840 --> 10:21:47,960
本质上就只是 只是最后 最后

14612
10:21:45,160 --> 10:21:49,240
其一，它将被重塑为

14613
10:21:47,960 --> 10:21:52,756
批量大小

14614
10:21:49,240 --> 10:21:56,000
嗯，这只是一种简便的做法。

14615
10:21:52,756 --> 10:21:58,040
28乘以28，所以是784，这就是接下来要得到的结果

14616
10:21:56,000 --> 10:22:00,480
重塑为
然后我们继续进行 

14617
10:21:58,040 --> 10:22:02,560
做我们的直线前推动作，这些就是（动作内容）

14618
10:22:00,480 --> 10:22:06,000
这些应该是非常有道理的。

14619
10:22:02,560 --> 10:22:09,520
对，所以在我们的线性远期合约中

14620
10:22:06,000 --> 10:22:11,960
嗯，我们接收一份重物，抱歉，我们接收…… 

14621
10:22:09,520 --> 10:22:17,360
一个 x、一个权重和一个偏置，对吧，所以我们这样做

14622
10:22:11,960 --> 10:22:21,320
用 X 乘以 w 再加 B，而不是 w 乘以 WX 再加 b

14623
10:22:17,360 --> 10:22:25,116
它是 xw 加上 b 嗯，所以就是这样，它是 I

14624
10:22:21,320 --> 10:22:30,560
意思是，是B选项，编号784，我们回到…… 

14625
10:22:25,116 --> 10:22:34,680
这样，我们进入这里，B 乘以 784 再乘以 784 乘以…… （这里原文“by”结尾表述不太完整和清晰，可能有信息缺失） 

14626
10:22:30,560 --> 10:22:36,436
256，然后我们得到B除以256，对吧，嗯

14627
10:22:34,680 --> 10:22:38,596
应该相当……

14628
10:22:36,436 --> 10:22:40,080
直观的，然后我们添加，我们添加……

14629
10:22:38,596 --> 10:22:41,596
偏差，这也是我提到的另一个术语

14630
10:22:40,080 --> 10:22:43,320
实际上这个里面没包含，但你

14631
10:22:41,596 --> 10:22:45,400
我们有点可以就那样，有点可以就那样

14632
10:22:43,320 --> 10:22:50,116
把偏差想象成一种额外的附加因素

14633
10:22:45,400 --> 10:22:50,116
它所增添的东西，嗯

14634
10:22:50,480 --> 10:22:56,840
现在向下滚动到 ReLU，对，就是 ReLU，我

14635
10:22:55,160 --> 10:22:59,080
意思是，这不言而喻，它仅仅是

14636
10:22:56,840 --> 10:23:01,116
要确定一个点 R，它将会是

14637
10:22:59,080 --> 10:23:03,880
数字。最大值 它将把那个应用到……

14638
10:23:01,116 --> 10:23:07,116
里面的每一个数值都在成就着你

14639
10:23:03,880 --> 10:23:08,756
知道它是否，呃，是否这个数值是像……

14640
10:23:07,116 --> 10:23:10,880
负 1，然后 0 将是……

14641
10:23:08,756 --> 10:23:12,800
最多也就是，就好像哪个更高，Z

14642
10:23:10,880 --> 10:23:14,800
或者是 -1，那么它将会选择

14643
10:23:12,800 --> 10:23:16,000
零，如果它像一，那么它就是

14644
10:23:14,800 --> 10:23:17,436
会像是哦，有一个比……更高

14645
10:23:16,000 --> 10:23:20,200
零，对，所以它有点像是那个…… 

14646
10:23:17,436 --> 10:23:21,800
重读，然后真正的导数是你

注：从文本内容来看，“relue”可能是拼写错误，推测可能想表达“re - read（重读）” ，“derivative”在数学语境里是“导数”，但结合整体文本语义不太明确，可能存在其他理解。 

14647
10:23:20,200 --> 10:23:24,436
正如我们之前所解释的，你如何拥有

14648
10:23:21,800 --> 10:23:26,800
喜欢这个图表，然后就像这样 D

14649
10:23:24,436 --> 10:23:28,880
导数的梯度为零，那么它就是

14650
10:23:26,800 --> 10:23:31,240
在那之后要进行渐变一

14651
10:23:28,880 --> 10:23:33,640
零，对，嗯，所以就是这样，就是这么回事。

14652
10:23:31,240 --> 10:23:37,320
这在这儿做，嗯，因为我们想

14653
10:23:33,640 --> 10:23:40,240
你是想说“Are you derivative right?” 吧，如果是这样，翻译为：你是对的，是衍生的吗？

如果按照你提供的原文 “ra you derivative right” ，它并不是一个正确的英文表达，无法准确进行有意义的翻译。 

14654
10:23:37,320 --> 10:23:44,720
嗯

14655
10:23:40,240 --> 10:23:47,040
现在再沿着线性方向往前回溯，我们

14656
10:23:44,720 --> 10:23:48,520
走吕埃出口，所以那是新的（路线等，此处需结合语境确定确切含义） 

14657
10:23:47,040 --> 10:23:50,880
输入到下一行你的

14658
10:23:48,520 --> 10:23:53,000
前向层 这些 权重 这些 

不过你提供的内容似乎不太符合正常的语法逻辑，可能存在表述不完整或有误的情况。 

14659
10:23:50,880 --> 10:23:54,680
权重 2，然后是偏置 2，对吧

14660
10:23:53,000 --> 10:23:56,276
所以那也应该说得通，并且

14661
10:23:54,680 --> 10:23:58,160
然后我们就返回那个，所以这就是前向传播

14662
10:23:56,276 --> 10:23:59,480
实际上并没有太复杂，我们可以

14663
10:23:58,160 --> 10:24:01,320
有点只是走过然后去理解

14664
10:23:59,480 --> 10:24:02,840
这些形状是如何变化的，这更…… 

14665
10:24:01,320 --> 10:24:05,320
一个关于如何理解的模板示例

14666
10:24:02,840 --> 10:24:07,880
这是从零开始的
现在我们往下移到

14667
10:24:05,320 --> 10:24:13,720
向后，这有点难，嗯，开始吧

14668
10:24:07,880 --> 10:24:15,916
在这里进行反向传播，我们有 W1、B1、W2、B2

14669
10:24:13,720 --> 10:24:17,800
好的，那么我们把梯度输出放进去，所以

14670
10:24:15,916 --> 10:24:19,800
起点，无论我们从何处开始

14671
10:24:17,800 --> 10:24:21,840
在适当的后面，然后向前走，再向前走

不过你提供的内容 “in back proper ation” 可能有误，推测可能是 “in back proportion” 等表达，你可以检查确认下。 

14672
10:24:19,800 --> 10:24:23,840
反向通过各层，然后

14673
10:24:21,840 --> 10:24:25,756
缓存也是，也就是那个……那个

14674
10:24:23,840 --> 10:24:28,560
前向传播，就像中间缓存

14675
10:24:25,756 --> 10:24:31,756
存储的值，对，嗯，所以我们进入……

14676
10:24:28,560 --> 10:24:34,480
往这边往后看，然后我们看到

14677
10:24:31,756 --> 10:24:37,276
嗯，我们得到了这个梯度输出，并且

14678
10:24:34,480 --> 10:24:40,800
正如我们所预期的那样缓存，嗯，然后我们就……

14679
10:24:37,276 --> 10:24:43,800
展开那个元组，这样 fc1 就可以输入了，所以我们

14680
10:24:40,800 --> 10:24:43,800
仅仅；只是；正好；刚才

14681
10:24:44,080 --> 10:24:52,916
嗯，FC1输入
FC1输出
呃，数值输出

14682
10:24:49,116 --> 10:24:56,320
对，嗯，所以就是稍微展开来讲一下

14683
10:24:52,916 --> 10:24:58,720
又是这个 嗯 现在我们到这里，然后它是

14684
10:24:56,320 --> 10:25:02,756
线性反向传播，所以如果我们回顾一下到

14685
10:24:58,720 --> 10:25:04,276
这个线性反向的将会，嗯……

14686
10:25:02,756 --> 10:25:06,436
它将对这两者进行计算。

14687
10:25:04,276 --> 10:25:10,720
对，所以线性反向传播稍微复杂一些 （注：这里 “bigger” 根据上下文可能有不同理解，若在线性代数、机器学习等语境中，也可能有 “更复杂、更庞大” 等含义，仅从文本看“更大”较字面，结合专业领域知识可能有更合适译法）

如果是在专业领域相关场景，“right so linear backward is a bit bigger” 更准确的可能是“没错，所以线性反向传播的计算量稍大一些” 等类似表达，你可根据实际情况选用。  

14688
10:25:06,436 --> 10:25:13,200
实际上，嗯，我们来这里是为了拿个学位。 

14689
10:25:10,720 --> 10:25:14,520
输出
选择输出项
输入

14690
10:25:13,200 --> 10:25:17,840
然后是权重，对吧，这样我们就可以

14691
10:25:14,520 --> 10:25:20,840
计算……呃……梯度

注：原文“uh the the”表述存在重复和口语化的停顿词“uh”，可能是不太准确或口语状态下的表达。 

14692
10:25:17,840 --> 10:25:25,360
X值和W值的属性

14693
10:25:20,840 --> 10:25:28,000
对，所以在这里我们要做呃梯度权重的操作。

14694
10:25:25,360 --> 10:25:30,840
嗯，是 X 等于 X 的转置乘以梯度。 

14695
10:25:28,000 --> 10:25:33,360
输出 所以如果我们到这里，我们可以

14696
10:25:30,840 --> 10:25:34,916
看，呃，X的转置，然后乘以……（这里“the”后面似乎内容不完整）

14697
10:25:33,360 --> 10:25:38,000
梯度输出，在这种情况下以及那个

14698
10:25:34,916 --> 10:25:40,960
第一层是损失函数的导数

14699
10:25:38,000 --> 10:25:43,400
嗯，然后比如说在这个DX2里我们

14700
10:25:40,960 --> 10:25:44,800
查看梯度输出乘以转置的结果

14701
10:25:43,400 --> 10:25:47,480
重量2

14702
10:25:44,800 --> 10:25:50,756
好的，那么 gr 输出时间的转置

14703
10:25:47,480 --> 10:25:53,320
权重二，然后是偏置

14704
10:25:50,756 --> 10:25:56,640
嗯，我会在……里再详细解释一下。 

14705
10:25:53,320 --> 10:25:59,800
剖腹产手术，但是，嗯，这就是，这就是

14706
10:25:56,640 --> 10:26:02,596
梯度偏差，对吧，所以嗯，实际上我可以

14707
10:25:59,800 --> 10:26:05,320
就把那个打印出来，咱们来弄一下

14708
10:26:02,596 --> 10:26:08,840
快速进入这里然后直接退出

14709
10:26:05,320 --> 10:26:15,360
那个，嗯，那么这事儿流程又是怎样的呢，我们要怎么做

14710
10:26:08,840 --> 10:26:20,116
猪蛔虫（这里推测“np. suum”可能是“Nematodirus suum” 猪蛔虫的意思）。所以我就只做，嗯，猪蛔虫，就做我…… （注：原文表述可能不太完整和准确，翻译尽量贴合原文） 

14711
10:26:15,360 --> 10:26:23,640
Python 导入 NumPy

14712
10:26:20,116 --> 10:26:27,720
当 n 为 p 时，然后我们取 x

14713
10:26:23,640 --> 10:26:31,160
等于，只需使用 torch。嗯，我们将使用 3

14714
10:26:27,720 --> 10:26:36,436
比如说，我们就说 2 乘 4 吧，对，我们来打印

14715
10:26:31,160 --> 10:26:38,880
退出
导入
导入 torch
然后返回上一级

14716
10:26:36,436 --> 10:26:45,596
打印出 X，然后我们就得到这个结果了，所以如果

14717
10:26:38,880 --> 10:26:50,276
我们，嗯，我们打印出 X 的 torch.sum（这里 torch.sum 应该是指 PyTorch 库中的求和函数，在实际场景里一般会表述为更符合专业语境的说法，但按字面直译如此）

14718
10:26:45,596 --> 10:26:53,640
我们将坐标轴比例设置为相等（这里“axis equal 0”表述可能有误，推测是“axis equal” 表示设置坐标轴比例相等 ），然后继续操作

14719
10:26:50,276 --> 10:26:55,480
暗淡 我觉得是保持 是保持暗淡吗

14720
10:26:53,640 --> 10:26:59,200
它怎么样

14721
10:26:55,480 --> 10:27:01,560
继续 保持尺寸 等于

14722
10:26:59,200 --> 10:27:04,160
的确，我们可以看到，实际上所有这些

14723
10:27:01,560 --> 10:27:07,320
它是不是把这些混在一起了？

14724
10:27:04,160 --> 10:27:11,240
所以它会变成 2 加 1，然后

14725
10:27:07,320 --> 10:27:13,080
这就像 21 加上那个数，所以结果是 3.23 

14726
10:27:11,240 --> 10:27:15,160
然后，基本上就像搅和在一起那样

14727
10:27:13,080 --> 10:27:17,240
膝盖晃动 膝盖挤压 膝盖没问题

14728
10:27:15,160 --> 10:27:20,160
对，嗯，它接下来要做这个。

14729
10:27:17,240 --> 10:27:22,160
像这样横过……横过……这个…… 

14730
10:27:20,160 --> 10:27:25,560
水平向右，所以它会变得一团糟 

14731
10:27:22,160 --> 10:27:27,916
十字 或 竖条 抱歉，因为那是

14732
10:27:25,560 --> 10:27:29,720
那就是零轴，对吧，那……

14733
10:27:27,916 --> 10:27:31,916
这里的领先维度，所以就是这样就是这样

14734
10:27:29,720 --> 10:27:33,436
这个垂直部分，所以它会变得稀软。

14735
10:27:31,916 --> 10:27:37,116
垂直地

14736
10:27:33,436 --> 10:27:39,800
嗯，所以实际上就这么多了。

14737
10:27:37,116 --> 10:27:41,756
嗯，所以我们只是在全面地整合各种事物。

14738
10:27:39,800 --> 10:27:44,800
整批都是这样，但你会看到的

14739
10:27:41,756 --> 10:27:47,720
在 C 语言里这更直观些

14740
10:27:44,800 --> 10:27:49,480
版本 现在我们来做 你知道这个的 就像我

14741
10:27:47,720 --> 10:27:50,960
正如我之前提到的，而且我们刚刚

14742
10:27:49,480 --> 10:27:53,596
本质上是为了……归还那些权利

（注：原句不完整，“for the”后面似乎缺少内容） 

14743
10:27:50,960 --> 10:27:56,116
线性反向传播

14744
10:27:53,596 --> 10:27:58,800
我们返还我们所有的 我们所有的……

注：原英文表述似乎不太完整或存在重复表意，译文根据字面直译。 

14745
10:27:56,116 --> 10:28:01,000
梯度，然后我们进行一次

14746
10:27:58,800 --> 10:28:03,240
优化步骤，所以我们来处理这个模型。

14747
10:28:01,000 --> 10:28:05,960
反向传播，然后我们进行模型更新权重操作

14748
10:28:03,240 --> 10:28:08,520
并且我们也经过了 1、2、3、4 以及那个（此处“the”后缺少内容，翻译可能不准确）

14749
10:28:05,960 --> 10:28:10,596
更新过程中的学习率

14750
10:28:08,520 --> 10:28:12,840
我们马上就会在这里看到权重，我们

14751
10:28:10,596 --> 10:28:15,720
实际上，只需要进行自我调节、自我权衡。

注：原文 “self. weights self” 表述不太常规，这里根据常见语义理解进行翻译，可能和原文确切含义有偏差。 

14752
10:28:12,840 --> 10:28:19,680
多比亚斯权重和偏置，然后我们做减法

14753
10:28:15,720 --> 10:28:21,596
等于学习率乘以……（这里原文没写完，后面内容缺失） 

14754
10:28:19,680 --> 10:28:23,840
渐变，没错，就像我刚才说的那样

14755
10:28:21,596 --> 10:28:27,240
在你试图减少你（这里原文“you're”可能有误，推测可能是“your” ）的……之前

14756
10:28:23,840 --> 10:28:29,360
实际上是在尝试做梯度，嗯

14757
10:28:27,240 --> 10:28:30,916
梯度下降，这就是它的本质

14758
10:28:29,360 --> 10:28:32,680
只是随机梯度

14759
10:28:30,916 --> 10:28:35,840
下降，因为它正在这么做

14760
10:28:32,680 --> 10:28:37,520
每一次都是这样，呃，是的

14761
10:28:35,840 --> 10:28:40,880
那 那就是我们更新网络的方式

14762
10:28:37,520 --> 10:28:42,960
所以你知道，如果……如果梯度是……如果

14763
10:28:40,880 --> 10:28:45,040
坡度非常大，这意味着

14764
10:28:42,960 --> 10:28:47,040
有很多错误，对吧，所以如果我们这样做

14765
10:28:45,040 --> 10:28:49,400
嗯，学习率乘以某个真正的……

14766
10:28:47,040 --> 10:28:52,400
嗨，那么一个正数乘以一个正数以及

14767
10:28:49,400 --> 10:28:54,276
然后从这里减去那个，嗯，那是

14768
10:28:52,400 --> 10:28:56,080
这意味着它贡献很大。

14769
10:28:54,276 --> 10:28:58,320
然后这将意味着它是……它是……

14770
10:28:56,080 --> 10:29:00,800
最初你知道，贡献了很多

14771
10:28:58,320 --> 10:29:02,080
误差，并且我们想要减少这种误差，我们希望

14772
10:29:00,800 --> 10:29:04,520
去改变它

14773
10:29:02,080 --> 10:29:06,040
值得注意的是，嗯，然后如果是像……

14774
10:29:04,520 --> 10:29:07,560
说小声点
我们不 我们不 我们不

14775
10:29:06,040 --> 10:29:09,040
想尽可能地调整一下，对吧，所以

14776
10:29:07,560 --> 10:29:10,520
这有点像是要达到一种平衡

14777
10:29:09,040 --> 10:29:13,840
在……之间
在中间
无论哪一个

14778
10:29:10,520 --> 10:29:16,680
给我们带来了最多的误差，对吧

14779
10:29:13,840 --> 10:29:18,400
嗯，我们这么做，我们秉持同样的理念。

14780
10:29:16,680 --> 10:29:21,000
对于所有这些，而我们只是去做

14781
10:29:18,400 --> 10:29:23,000
本质上，这个标量值

14782
10:29:21,000 --> 10:29:25,756
乘以整体中的每一项

14783
10:29:23,000 --> 10:29:28,000
权重和偏置矩阵，我们来做这件事

14784
10:29:25,756 --> 10:29:30,080
到处都是，差不多就是这样，你

14785
10:29:28,000 --> 10:29:33,560
我们为每一个，每一个都这样做

14786
10:29:30,080 --> 10:29:35,320
每一次迭代，我们做一件事，我们做一件事，我们得到，我们得到

14787
10:29:33,560 --> 10:29:37,160
无论输入和输出，呃

14788
10:29:35,320 --> 10:29:39,000
我们需要预测结果，我们进行一次前向传播

14789
10:29:37,160 --> 10:29:42,160
我们对……求损失函数的导数

14790
10:29:39,000 --> 10:29:44,200
损失模型。反向传播，也就是反向传递

14791
10:29:42,160 --> 10:29:45,596
更新权重，然后如果有需要我们就……

14792
10:29:44,200 --> 10:29:47,800
就像打印出整个进度一样

14793
10:29:45,596 --> 10:29:49,960
时间到了，那么如果我们继续运行

14794
10:29:47,800 --> 10:29:49,960
这；这个

14795
10:29:50,080 --> 10:29:56,756
嗯，Python对C语言很友好，我们可以去了解一下。 

14796
10:29:54,200 --> 10:29:59,000
实际上，这训练得相当不错，所以

14797
10:29:56,756 --> 10:30:01,360
我们 这训练速度也相当快呢

14798
10:29:59,000 --> 10:30:03,520
你知道NumPy是基于C语言的，而C语言是……

（注：原英文句子表述可能有误，“bed to” 可能是 “built on” 之误） 

14799
10:30:01,360 --> 10:30:05,680
真的很快，我们能看出来，你知道的

14800
10:30:03,520 --> 10:30:09,560
超过第一个
超过最初的7500

14801
10:30:05,680 --> 10:30:11,800
经过多次迭代，我们得到了 93% 的准确率，所以仅仅…… 

14802
10:30:09,560 --> 10:30:15,160
关于这个问题再详细阐述一下

14803
10:30:11,800 --> 10:30:18,116
整个线性反向，嗯，np. 总和交叉

14804
10:30:15,160 --> 10:30:20,116
轴零，在这种情况下你会选取每一列，并且

14805
10:30:18,116 --> 10:30:24,360
你把它挤压在一起，我们这么做的原因是……（这里文本似乎不完整） 

14806
10:30:20,116 --> 10:30:26,320
这么做是因为其中每一个都像是

14807
10:30:24,360 --> 10:30:30,520
在整批中，对吧，所以这个

14808
10:30:26,320 --> 10:30:33,560
就像是一个，呃，一个单独的

14809
10:30:30,520 --> 10:30:35,040
右侧层 一束又一束的

14810
10:30:33,560 --> 10:30:37,840
所有神经元的偏差，或者

14811
10:30:35,040 --> 10:30:39,756
无论你想说什么，还有我们……

14812
10:30:37,840 --> 10:30:42,800
我们在这里所做的是选取一个单一的

14813
10:30:39,756 --> 10:30:44,916
神经元，而且我们正在压缩一切

14814
10:30:42,800 --> 10:30:48,000
一起，因为想象一下，要是你有一个……

14815
10:30:44,916 --> 10:30:49,840
非常大，嗯，就像非常稀疏的那种

14816
10:30:48,000 --> 10:30:51,800
对于单个（情况/事物等，需结合语境）来说是非常大的奖励信号

14817
10:30:49,840 --> 10:30:53,276
举个例子，然后就像你再做另外二十个那样

14818
10:30:51,800 --> 10:30:54,880
一类人，而且他们有着完全相反的（情况/特点等，需结合语境明确） 

14819
10:30:53,276 --> 10:30:56,800
对，这个想法是有点像……

14820
10:30:54,880 --> 10:30:58,240
把它们全部平均一下，你不是（这样的）。 

14821
10:30:56,800 --> 10:31:00,116
你不像在做除法
你也不是在做加法

14822
10:30:58,240 --> 10:31:02,276
把它们全部加起来，然后再进行除法运算，但是

14823
10:31:00,116 --> 10:31:03,680
你 你只是在积累所有

14824
10:31:02,276 --> 10:31:05,520
把它们放在一起，这样你最终会得到

14825
10:31:03,680 --> 10:31:07,160
那种类似靠近并推动的东西

14826
10:31:05,520 --> 10:31:09,276
朝着类似哪里的方向

14827
10:31:07,160 --> 10:31:11,080
应该进行归纳总结，我知道这一点。

14828
10:31:09,276 --> 10:31:14,160
听起来在概念上真的很先进

14829
10:31:11,080 --> 10:31:16,360
但不是这样的，你只是在试图……

14830
10:31:14,160 --> 10:31:18,400
以无论何种有利于大众的方式推动

14831
10:31:16,360 --> 10:31:20,680
所以这就是你这么做的原因，交流电穿越

14832
10:31:18,400 --> 10:31:22,520
实际批次本身，中控单元（CU），要是你刚刚…… 

14833
10:31:20,680 --> 10:31:24,360
这个向量展开后，我的意思是你可以这样做

14834
10:31:22,520 --> 10:31:26,360
但训练可能不会像（此处文本不完整，原句意思未表达完整）

14835
10:31:24,360 --> 10:31:28,040
顺畅地，然而如果你只是要

14836
10:31:26,360 --> 10:31:30,240
积累一切，这样你就能继续前进了 

14837
10:31:28,040 --> 10:31:31,596
一般来说，最好的移动方式是什么

14838
10:31:30,240 --> 10:31:33,276
消除那种偏见的最佳方法是什么？

14839
10:31:31,596 --> 10:31:35,720
价值，然后呢，它会有一点点帮助。

14840
10:31:33,276 --> 10:31:38,080
更重要的是，这就是我们这么做的原因，嗯，但现在

14841
10:31:35,720 --> 10:31:41,520
让我们来学习 C 语言，这基本上是一门…… 

14842
10:31:38,080 --> 10:31:44,116
仅我们运行的最后一个脚本的端口

14843
10:31:41,520 --> 10:31:45,880
所以这个V1C，你会在……里找到它

14844
10:31:44,116 --> 10:31:47,240
天真的 CPU，因为这很天真

14845
10:31:45,880 --> 10:31:49,080
算法，这些并非真的……

14846
10:31:47,240 --> 10:31:51,720
真的很快，简直是最容易的

14847
10:31:49,080 --> 10:31:54,080
书写它们的方式，嗯，非常直观。

14848
10:31:51,720 --> 10:31:56,040
去理解，嗯，但这给了我们一个基础

14849
10:31:54,080 --> 10:32:00,560
关于我们如何能够修改这个并转变转变 

14850
10:31:56,040 --> 10:32:01,640
把它放到 CUDA 里，对吧，嗯，所以在这儿里面我们

14851
10:32:00,560 --> 10:32:05,720
做同样的事

14852
10:32:01,640 --> 10:32:05,720
想法 我们有一个小型神经网络

14853
10:32:06,160 --> 10:32:10,640
顶部的东西，我的意思是它应该

14854
10:32:08,000 --> 10:32:13,240
可能会从上到下进行，但是

14855
10:32:10,640 --> 10:32:15,040
呃，是的，所以在这里面是学习率

14856
10:32:13,240 --> 10:32:17,080
相同的学习率，我们有十六进制的 10，即 

14857
10:32:15,040 --> 10:32:18,916
有点不同，我将批量大小改为

14858
10:32:17,080 --> 10:32:20,960
四个，因为把它设为 8 个或 16 个

注：原英文表述不太符合常规语法，推测可能想表达“选择四个，因为选择 8 个或 16 个会怎样（可能存在其他情况）”这样的意思，但由于文本不完整，只能按字面翻译。 

14859
10:32:18,916 --> 10:32:22,840
或者32刚刚消耗了多得离谱的（东西）

14860
10:32:20,960 --> 10:32:25,000
逐层计算所需的时间

14861
10:32:22,840 --> 10:32:26,960
所以我把这个稍微调低到四

14862
10:32:25,000 --> 10:32:29,756
输入大小保持不变
它必须
嗨

14863
10:32:26,960 --> 10:32:31,596
并且大小为256，输出大小为10，训练

14864
10:32:29,756 --> 10:32:35,160
样本量10000，测试样本量，我们不会…… 

14865
10:32:31,596 --> 10:32:36,400
真的很需要这个，但要一千（单位），嗯

14866
10:32:35,160 --> 10:32:38,116
然后我们有了这个神经网络

14867
10:32:36,400 --> 10:32:39,960
结构体，没错，所以实际上我们没法进行一次……（此处原文不完整） 

14868
10:32:38,116 --> 10:32:41,560
CL 我们不能用 C 语言创建一个类，但我们可以

14869
10:32:39,960 --> 10:32:44,480
确实构成，我们没有，我们没有像……这样的（内容不完整，句子表意不太明确） 

14870
10:32:41,560 --> 10:32:46,880
这个英文文本存在重复用词和表意不完整的问题，大致翻译为：
类以及面向对象作为…… 

14871
10:32:44,480 --> 10:32:49,200
在 C++ 里我们所做的这方面，没错，这是一个

14872
10:32:46,880 --> 10:32:51,080
函数式 函数式语言 所以我们在

14873
10:32:49,200 --> 10:32:52,916
只允许使用 strs 以及其内部的（内容）

14874
10:32:51,080 --> 10:32:54,400
在这里我们只是存储了一堆数组，所以

14875
10:32:52,916 --> 10:32:56,680
所有的权重和偏置，然后是

14876
10:32:54,400 --> 10:32:59,080
那些的梯度，对，呃，只是为了

14877
10:32:56,680 --> 10:33:02,200
可以轻松地把所有东西都记录下来，而且

14878
10:32:59,080 --> 10:33:06,320
并且使用这个非常简单的，呃，结构体

14879
10:33:02,200 --> 10:33:08,116
现在我们有一些关于……的功能

14880
10:33:06,320 --> 10:33:09,436
为了实际加载数据，现在我

14881
10:33:08,116 --> 10:33:12,276
不想让你太过担心……（这里原文句子未完整，推测可能后面还有内容）

14882
10:33:09,436 --> 10:33:13,960
加载数据这方面，嗯，这部分它

14883
10:33:12,276 --> 10:33:16,520
这有点取决于具体是哪种用途。

14884
10:33:13,960 --> 10:33:19,160
万一你有，但在这种情况下，嗯，我，我

14885
10:33:16,520 --> 10:33:21,436
运行呃，下载器脚本，所以

14886
10:33:19,160 --> 10:33:26,160
这个下载器脚本，呃，只是保存

14887
10:33:21,436 --> 10:33:29,160
将所有内容保存到一个二进制文件，嗯，然后

14888
10:33:26,160 --> 10:33:31,560
在 C 语言里，我们只需把它们写回去

14889
10:33:29,160 --> 10:33:33,840
再次，那么，或者，抱歉，我们，我们，我们读了它们，我们

14890
10:33:31,560 --> 10:33:36,240
从二进制文件中读取，所以注意我们是怎么做的

14891
10:33:33,840 --> 10:33:38,520
比如文件打开，然后输入文件名

14892
10:33:36,240 --> 10:33:41,200
然后读取二进制文件，嗯，然后它

14893
10:33:38,520 --> 10:33:45,276
只是将其转化为一种有用的格式

14894
10:33:41,200 --> 10:33:48,840
对，所以，呃，是的，它并非完全如此。

14895
10:33:45,276 --> 10:33:51,756
呃，太疯狂了，嗯，实际上我们只是

14896
10:33:48,840 --> 10:33:54,276
就直接把这个读进，嗯，读进……

14897
10:33:51,756 --> 10:33:56,080
字节，然后我们根据需要对其进行修改

14898
10:33:54,276 --> 10:33:58,756
稍后我们对标签做同样的事情

14899
10:33:56,080 --> 10:34:00,916
非常简单，呃，数据加载函数

14900
10:33:58,756 --> 10:34:02,800
嗯，和大多数情况相比不算太疯狂。

14901
10:34:00,916 --> 10:34:05,240
但这是用 C 语言写的，对吧，所以它是

14902
10:34:02,800 --> 10:34:08,040
显然会有点不一样

14903
10:34:05,240 --> 10:34:09,436
现在我们这儿有件有趣的事儿。

14904
10:34:08,040 --> 10:34:12,880
名为初始化工资，我可能

14905
10:34:09,436 --> 10:34:15,320
本应该带你到我们这儿的后面看看的

14906
10:34:12,880 --> 10:34:18,480
嗯，在我们这个对C友好的环境里它去哪儿了

14907
10:34:15,320 --> 10:34:20,436
脚本，所以注意在这里我们是如何拥有……

14908
10:34:18,480 --> 10:34:21,756
多个函数，对吧，我们有 r r

14909
10:34:20,436 --> 10:34:23,160
导数初始化权重

14910
10:34:21,756 --> 10:34:25,960
初始化偏差，然后是其他这些

14911
10:34:23,160 --> 10:34:28,560
那些我已经讲过的，嗯

14912
10:34:25,960 --> 10:34:31,436
初始化
正在初始化权重以及

14913
10:34:28,560 --> 10:34:33,880
偏见其实挺简单的，好吧，它们

14914
10:34:31,436 --> 10:34:36,000
只需遵循特定的指南，所以如果我们这样做

14915
10:34:33,880 --> 10:34:38,640
从初始化偏差开始，它是

14916
10:34:36,000 --> 10:34:40,040
实际上就只是，呃，仅仅是一个

14917
10:34:38,640 --> 10:34:41,480
一堆零，没错，这就是它的走向 

14918
10:34:40,040 --> 10:34:42,960
要做到公正，仅仅有偏见是远远不够的（由于原句表述不太完整和清晰，此翻译仅供参考）。
需要说明的是，原句 “to be just need the bias is a bunch of” 存在语法错误，可能正确的表述会有不同意思。 

14919
10:34:41,480 --> 10:34:45,840
零，没关系，我们可以开始了，然后我们

14920
10:34:42,960 --> 10:34:48,200
可以从那里上下移动

14921
10:34:45,840 --> 10:34:50,480
嗯，但是那些砝码，因为

14922
10:34:48,200 --> 10:34:51,916
所以，偏见就是偏见，飘忽不定、四处流散

14923
10:34:50,480 --> 10:34:53,116
来自上一层，所以将其作为

14924
10:34:51,916 --> 10:34:55,400
一个零实际上并不重要，它

14925
10:34:53,116 --> 10:34:57,800
这对任何事情都没有影响，那个偏差，那个…… 

注：原文“the the”可能存在表述错误，影响了整体语义的清晰性。 

14926
10:34:55,400 --> 10:34:59,520
偏置梯度正在直接流动

14927
10:34:57,800 --> 10:35:02,680
来自上一层的那些未被修改的（部分）

14928
10:34:59,520 --> 10:35:04,960
相同的梯度，嗯，但（还有）权重

14929
10:35:02,680 --> 10:35:07,360
它们本身有点不同，那么如何……

14930
10:35:04,960 --> 10:35:09,720
我们初始化权重，实际上我是…… （注：原英文句子似乎表述不太完整或存在一定的口语化随意性，这里尽量按原文逐词翻译并结合语境尝试表达通顺） 

14931
10:35:07,360 --> 10:35:14,640
打算到这边来，我们打算…… 

14932
10:35:09,720 --> 10:35:16,436
搜索 P torch 计时

14933
10:35:14,640 --> 10:35:19,360
初始化，这就是你（做某事）的方式

14934
10:35:16,436 --> 10:35:23,640
实际上进行初始化 嗯 我就直接做 我会

14935
10:35:19,360 --> 10:35:26,596
就做，呃，火炬，做，呃，神经网络。

14936
10:35:23,640 --> 10:35:28,276
线性的，嗯，我们将前往…… 

14937
10:35:26,596 --> 10:35:34,400
线性的

14938
10:35:28,276 --> 10:35:34,400
所以在 PyTorch 里我们这样做

14939
10:35:34,596 --> 10:35:39,040
嗯，哪里是……

注：原英文“um where is”表述不完整，通常“where is”后面还会接具体询问的事物。 

14940
10:35:36,640 --> 10:35:43,756
是的

14941
10:35:39,040 --> 10:35:45,840
所以偏差在这当中被初始化，嗯

14942
10:35:43,756 --> 10:35:47,436
分布，我们……我们可以……我们可以

14943
10:35:45,840 --> 10:35:51,720
我们不完全需要担心……

注：原英文句子本身不太符合常见表达习惯，这里按字面意思进行了翻译。 

14944
10:35:47,436 --> 10:35:54,000
这没什么大不了的，嗯，但后来那个

14945
10:35:51,720 --> 10:35:56,756
那么权重本身，这些是

14946
10:35:54,000 --> 10:35:59,520
而且这些在这方面也没有被初始化，呃。 

14947
10:35:56,756 --> 10:36:02,276
基础，对，所以我们有……某种形状

14948
10:35:59,520 --> 10:36:06,800
按输入输出特征

14949
10:36:02,276 --> 10:36:09,800
特点，而且我们是从，呃，从……制作这个的

14950
10:36:06,800 --> 10:36:15,200
从 K 的负平方根到正的（这里“Ro TK”可能是拼写错误，推测是“root” ）

14951
10:36:09,800 --> 10:36:19,436
K的平方根，其中K是

14952
10:36:15,200 --> 10:36:22,640
嗯，K 是输入特征的倒数，所以

14953
10:36:19,436 --> 10:36:25,960
如果我们回到这里，我们正在进行一项

14954
10:36:22,640 --> 10:36:27,840
随机正态分布，对吧

14955
10:36:25,960 --> 10:36:29,436
对于这些数字中的每一个，我们都必须……我们

14956
10:36:27,840 --> 10:36:31,480
必须把它们归到这个范围，对吧

14957
10:36:29,436 --> 10:36:33,960
所以这些数值 这些数值在……里

14958
10:36:31,480 --> 10:36:38,680
一些呈正态分布的范围等等

14959
10:36:33,960 --> 10:36:38,680
我们必须要做的是

14960
10:36:39,000 --> 10:36:47,480
嗯，我们要这么做，我们将其初始化为这个，对吧？

14961
10:36:42,960 --> 10:36:47,480
所以在这种情况下，K

14962
10:36:49,040 --> 10:36:54,960
好的，那么如果我们真的去 H（这里不太明确 H 具体指代什么，需结合上下文）

14963
10:36:51,640 --> 10:36:56,596
ination 可能并不是一个正确的单词，推测可能有拼写错误。当前内容“ination paper he init”无法准确连贯地翻译。你可以检查并提供正确的英文文本。 

14964
10:36:54,960 --> 10:36:59,400
纸；纸张；报纸；文件；论文

14965
10:36:56,596 --> 10:37:02,520
嗯，我想这是……这是……

14966
10:36:59,400 --> 10:37:04,240
它在攀爬 嘿 所以在攀爬 还有干草

（注：原句可能存在拼写错误，正确的也许是“it's climbing hey so climbing and hay” ） 

14967
10:37:02,520 --> 10:37:07,520
你提供的文本似乎存在拼写错误且语义不太清晰，推测可能正确的表达及翻译如下：

如果是 “Climbing and they are...”
翻译为：攀爬，并且他们是……

由于原始文本问题较多，若以上不是你想要的内容，请检查并提供更准确的英文文本。 

14968
10:37:04,240 --> 10:37:10,840
同样的事情，嗯，但如果我们进入这里

14969
10:37:07,520 --> 10:37:14,840
我们从两方面考虑，或许并非如此。

注：原英文 “two ided” 可能存在拼写错误，推测正确的是 “two - sided” 。 

14970
10:37:10,840 --> 10:37:19,436
他们的公式就在这附近。（注：原文“there”可能有误，推测应为“their” ）

14971
10:37:14,840 --> 10:37:19,436
嗯，它去哪儿了？

14972
10:37:27,720 --> 10:37:33,276
我向上搜索

14973
10:37:30,276 --> 10:37:33,276
嗯

14974
10:37:44,596 --> 10:37:51,080
Rue初始化

14975
10:37:47,720 --> 10:37:51,080
也许这是一个更合适的术语值得去研究

14976
10:38:02,720 --> 10:38:07,040
为了；因为；对于；至于；适合于

14977
10:38:05,040 --> 10:38:11,040
是的，这是对的。

14978
10:38:07,040 --> 10:38:13,720
这里，所以这导致了一个零均值的 G CH

14979
10:38:11,040 --> 10:38:16,880
标准差为……的分布

14980
10:38:13,720 --> 10:38:21,400
平方 < 二的平方根除以嗯，除以这个 

14981
10:38:16,880 --> 10:38:22,640
术语，而这个术语是，嗯，我想不起来了。 

14982
10:38:21,400 --> 10:38:24,720
确切记得这是什么，但我

14983
10:38:22,640 --> 10:38:27,560
认为这就是长度

14984
10:38:24,720 --> 10:38:29,040
所以我们这里有一个输入大小，你……

14985
10:38:27,560 --> 10:38:31,560
可以说至于长度，我不知道是否……

14986
10:38:29,040 --> 10:38:33,320
那正是 L 所关联的具体内容，但

14987
10:38:31,560 --> 10:38:35,160
我们现在先保留那个假设。

14988
10:38:33,320 --> 10:38:37,960
那，那就是那个想法，有你

14989
10:38:35,160 --> 10:38:41,276
本来会；本应该

14990
10:38:37,960 --> 10:38:45,160
嗯，标准差是

14991
10:38:41,276 --> 10:38:46,960
这个，嗯，如果我们继续前进

14992
10:38:45,160 --> 10:38:48,436
也许我们在这里能找到其他东西。

14993
10:38:46,960 --> 10:38:51,040
也；太；很；非常

14994
10:38:48,436 --> 10:38:51,040
嗯，如果我们

14995
10:38:51,916 --> 10:38:57,160
继续 是的，所以一些

14996
10:38:54,640 --> 10:39:00,116
其他解决方案的层级是小因素。

14997
10:38:57,160 --> 10:39:00,116
在砝码上；在重物上；在重量方面（需结合具体语境确定最准确含义） 

14998
10:39:00,436 --> 10:39:03,436
对；正确；是的；好吧

14999
10:39:03,720 --> 10:39:06,720
不管怎样；无论如何

15000
10:39:09,160 --> 10:39:14,520
呃，对，这差不多就是那个……

15001
10:39:12,160 --> 10:39:17,916
从中获取灵感，所以只是看着

15002
10:39:14,520 --> 10:39:20,880
就有点像这个的目的，嗯

15003
10:39:17,916 --> 10:39:24,360
这种特定的初始化方式为

15004
10:39:20,880 --> 10:39:25,436
和那个 P 火炬款相比，嗯，那个我……

15005
10:39:24,360 --> 10:39:27,680
或许本应该深入调查一下

15006
10:39:25,436 --> 10:39:31,360
事先说明，那个 PyTorch 的（东西）有点…… 

15007
10:39:27,680 --> 10:39:33,520
不同的，嗯，但干草初始化

15008
10:39:31,360 --> 10:39:38,960
设计用于与 railu 配合良好，所以

15009
10:39:33,520 --> 10:39:41,840
它使用“两个输入的平方根（< TK 可能是特定缩写暂按原样保留） / 嗯，输入” 

15010
10:39:38,960 --> 10:39:43,560
将其大小作为……的标准差

15011
10:39:41,840 --> 10:39:45,320
它所基于生成的分布

15012
10:39:43,560 --> 10:39:47,680
对；正确；好的；行

15013
10:39:45,320 --> 10:39:50,200
嗯，它本质上是为……计数的

15014
10:39:47,680 --> 10:39:52,480
暂停激活以消除负值

15015
10:39:50,200 --> 10:39:54,720
价值观，所以你可能会有这些，嗯

15016
10:39:52,480 --> 10:39:56,320
所谓的死亡神经元，它们会在……时出现

15017
10:39:54,720 --> 10:39:58,240
你有那种就像全是零的街道（这里Rue可能结合语境指街道，但不太明确，你可根据实际情况调整） 

15018
10:39:56,320 --> 10:40:00,080
拿出某样东西，然后当你试图去……

15019
10:39:58,240 --> 10:40:01,680
呃，就像用某个东西去乘它

15020
10:40:00,080 --> 10:40:03,480
最终就像将其归零一样，而你

15021
10:40:01,680 --> 10:40:05,480
可能会喜欢通过训练而达成的结果

15022
10:40:03,480 --> 10:40:06,880
用一排那样的零来处理

15023
10:40:05,480 --> 10:40:08,560
什么都别做，然后他们就会说

15024
10:40:06,880 --> 10:40:10,596
没用的，所以实际上你并非……

15025
10:40:08,560 --> 10:40:12,680
将信息压缩成那些

15026
10:40:10,596 --> 10:40:13,880
因为它们都为零，所以这很有帮助。

15027
10:40:12,680 --> 10:40:18,400
处理；应对；对付；与……打交道；涉及；关于

15028
10:40:13,880 --> 10:40:19,960
现在跳回到 C

15029
10:40:18,400 --> 10:40:22,640
剧本；脚本；手稿；笔迹；字体；药单；处方；书写的字母（或单词、句子）；按照事先准备好的讲稿（或方案）做的事
（计算机）脚本程序；（为使某一程序自动运行而编制的）代码
写……的脚本；为……写剧本
把……改编为剧本；把……改写成电影剧本；把……录制成磁带；把……写下来；按照事先准备好的讲稿（或方案）说（或做）

由于“script”在不同语境中有不同含义，你可以给我提供更具体的使用场景，以便我更准确地翻译。 

15030
10:40:19,960 --> 10:40:24,560
嗯，这就是我们在这里正在做的事情，所以我们

15031
10:40:22,640 --> 10:40:26,200
本质上我们有这个，我们只是

15032
10:40:24,560 --> 10:40:28,960
我们只需要利用像我们所拥有的……之类的东西 （原句表述不太清晰完整） 

15033
10:40:26,200 --> 10:40:31,320
我们默认在使用 C 语言时会得到这个结果

15034
10:40:28,960 --> 10:40:34,080
带有其所处规格的重量，在我们这里 

15035
10:40:31,320 --> 10:40:36,116
制作这个比例，使其成为平方根函数

15036
10:40:34,080 --> 10:40:38,320
你知道的，就像我们之前在做的那样，嗯

15037
10:40:36,116 --> 10:40:43,320
二的平方根除以英寸尺寸

15038
10:40:38,320 --> 10:40:45,436
这个箱子，嗯，你想要什么尺寸的呢，嗯，你……（原文表述不太完整和流畅） 

15039
10:40:43,320 --> 10:40:46,720
知道尺寸可能不合适 我只是

15040
10:40:45,436 --> 10:40:49,080
有点发现这样做是可行的，而且 

15041
10:40:46,720 --> 10:40:51,560
因此，用这个进行训练效果格外好。

15042
10:40:49,080 --> 10:40:53,960
我们打算坚持那样做，嗯，但是

15043
10:40:51,560 --> 10:40:55,916
我们要遍历的大小

15044
10:40:53,960 --> 10:40:57,840
这个，并且本质上是针对每一个权重

15045
10:40:55,916 --> 10:41:00,200
数值 我们要生成一个数值

15046
10:40:57,840 --> 10:41:03,480
在兰德之间，所以兰德将会是

15047
10:41:00,200 --> 10:41:06,520
介于零和随机数最大值之间的任意值，所以

15048
10:41:03,480 --> 10:41:09,160
二、一，不管这是什么，所以从本质上来说

15049
10:41:06,520 --> 10:41:10,720
这里面的这个将会是零

15050
10:41:09,160 --> 10:41:12,200
在那个最大数值之间，它将会……

15051
10:41:10,720 --> 10:41:14,520
这将简化为介于一个……之间

15052
10:41:12,200 --> 10:41:17,320
值介于 0 和一位小数浮点数之间

15053
10:41:14,520 --> 10:41:19,040
第32点：0到1之间的数字，我们…… 

15054
10:41:17,320 --> 10:41:22,116
打算用这个乘以……（这里原文没完整，推测后面还有内容）

15055
10:41:19,040 --> 10:41:25,400
规模，嗯，它将会是……

15056
10:41:22,116 --> 10:41:29,680
然后我们要减去它

15057
10:41:25,400 --> 10:41:31,276
通过，嗯，通过……除以……的比例

15058
10:41:29,680 --> 10:41:33,880
除以

15059
10:41:31,276 --> 10:41:36,756
二，而这只会给我们一个

15060
10:41:33,880 --> 10:41:38,360
对于我们的……来说是不错的正态分布

15061
10:41:36,756 --> 10:41:39,520
砝码 没错 接下来要这么做

15062
10:41:38,360 --> 10:41:41,160
本质上和我们之前做的是同一份工作

15063
10:41:39,520 --> 10:41:43,960
正在做；从事；进行

15064
10:41:41,160 --> 10:41:46,880
在初始化偏差之前，将所有这些都设为零

15065
10:41:43,960 --> 10:41:47,880
就像我们之前做的那样，Ru也非常……

15066
10:41:46,880 --> 10:41:49,560
简单的

15067
10:41:47,880 --> 10:41:52,916
嗯，那个Softmax函数，我是说，我觉得我展示过了。

15068
10:41:49,560 --> 10:41:55,240
所以你在Triton部分提到了softmax

15069
10:41:52,916 --> 10:41:57,000
嗯，这是，没错，这应该相当……

15070
10:41:55,240 --> 10:41:59,720
直观地说，我们，我们明白这个，你知道的，我们明白

15071
10:41:57,000 --> 10:42:01,560
这个最大值，对吧，然后当我们……

15072
10:41:59,720 --> 10:42:03,800
实际上进行指数运算，我们……我们

15073
10:42:01,560 --> 10:42:06,320
减去最大值，这样我们仍然能得到

15074
10:42:03,800 --> 10:42:07,720
保持数值稳定性 嗯 不

15075
10:42:06,320 --> 10:42:10,000
拥有那个就好像会给这些

15076
10:42:07,720 --> 10:42:12,320
疯了吧，你知道的，e的任意次方，超…… 

15077
10:42:10,000 --> 10:42:15,000
疯狂的数据，当我们有……呃，荒谬的情况时 

15078
10:42:12,320 --> 10:42:16,680
数组，嗯，就像你知道的，还有负数方面的（情况） 

15079
10:42:15,000 --> 10:42:18,756
一个000阴性10，就是，就是

15080
10:42:16,680 --> 10:42:20,840
失去控制了，对吧，所以我们想，我们

15081
10:42:18,756 --> 10:42:22,560
想让麦克斯对其进行规范化处理，然后只需得到

15082
10:42:20,840 --> 10:42:24,160
摆脱其中任何一个；去掉其中任何一个 

15083
10:42:22,560 --> 10:42:26,800
不稳定；不稳固；动荡；不安定

15084
10:42:24,160 --> 10:42:28,756
嗯，然后我们，对，我们只是计算这个

15085
10:42:26,800 --> 10:42:31,560
软最大值，没错，这……这也不算太……

15086
10:42:28,756 --> 10:42:33,436
糟糕，和我们之前看过的是同一个函数

注：原英文文本在语法上似乎不太准确和完整，但已按照要求进行翻译。 

15087
10:42:31,560 --> 10:42:35,200
有一颗磨砂质感的痣，所以我特地

15088
10:42:33,436 --> 10:42:37,116
这样措辞以便它能够……（原文“make make”可能有误，译文按原文直译，语义可能不通顺） 

15089
10:42:35,200 --> 10:42:39,160
最有道理了，所以它是一只地图鼹鼠，但是

15090
10:42:37,116 --> 10:42:41,640
这就把它当作你正在摄入的东西来对待

15091
10:42:39,160 --> 10:42:45,960
一个数组 a，然后你进行矩阵乘法运算 

15092
10:42:41,640 --> 10:42:48,400
那么假设 B ，比如说 2 乘以 4 是一个

15093
10:42:45,960 --> 10:42:50,276
还有 4 乘以 3，这样你最终会得到一个

15094
10:42:48,400 --> 10:42:52,276
2乘以3，它会按行来排列那个结果 

15095
10:42:50,276 --> 10:42:54,520
主要指令，没错，把这些做得简单些

15096
10:42:52,276 --> 10:42:56,200
尽可能地，嗯，你可以剖析这些，但是

15097
10:42:54,520 --> 10:42:57,960
我们已经在金属方面做了很多事情了。

15098
10:42:56,200 --> 10:43:02,000
所以，我不会再详细讲这个了。

15099
10:42:57,960 --> 10:43:05,436
大概是第20次了，嗯，然后我们有一个

15100
10:43:02,000 --> 10:43:08,560
a 乘以 B 的转置，所以这将会花费（这里“take”根据语境推测可能是“花费（时间、精力等）”的意思，需要结合完整文本确定更准确含义）

15101
10:43:05,436 --> 10:43:13,276
在 B 里就好像是说，就好像 A 是 2 乘以 4 并且

15102
10:43:08,560 --> 10:43:14,840
那么 B 是一个，嗯，3 行 4 列的矩阵，所以它会…… 

15103
10:43:13,276 --> 10:43:17,640
呃，进行这个操作，就好像它是……

15104
10:43:14,840 --> 10:43:21,400
将 B 转置为一个 4×3 的矩阵，所以最终得到一个

15105
10:43:17,640 --> 10:43:24,160
2乘以3，对，嗯，然后这个也是同样的思路。

15106
10:43:21,400 --> 10:43:29,960
如果你最终得到一个4X二，然后

15107
10:43:24,160 --> 10:43:33,040
一个 4×4 的，还有一个 4×2 的，然后是 4 乘以…… 

15108
10:43:29,960 --> 10:43:34,560
呃，3 作为 B，它将对 A 进行转置。

15109
10:43:33,040 --> 10:43:35,560
它将把它做成一个2×4的规格，而且它们是

15110
10:43:34,560 --> 10:43:37,520
去匹配 你会得到

15111
10:43:35,560 --> 10:43:41,880
二和三，没错，所以那只是……

15112
10:43:37,520 --> 10:43:45,680
大概就是那个意思，然后我们会，嗯

15113
10:43:41,880 --> 10:43:48,116
这里“the the ru”表述有误，可能存在拼写错误。若忽略错误按字面大致翻译如下：
往前我可能写了一个

15114
10:43:45,680 --> 10:43:50,400
另外，嗯，可能有

15115
10:43:48,116 --> 10:43:53,520
写道 是的，所以这就像是为……而设计的

15116
10:43:50,400 --> 10:43:55,200
分批进行工作 嗯，我可能……

15117
10:43:53,520 --> 10:43:59,800
又写了一篇和（前文提到的事物）一样的

15118
10:43:55,200 --> 10:43:59,800
不小心弄的，我可能会把它删掉

15119
10:44:04,320 --> 10:44:12,240
嗯，哦，你在吗？
是的，所以我应该

15120
10:44:09,160 --> 10:44:13,680
实际上可能要把这个去掉，不过呢

15121
10:44:12,240 --> 10:44:14,880
嗯，我稍后再操心那个吧。

15122
10:44:13,680 --> 10:44:17,080
并且到时候这将会被更新。

15123
10:44:14,880 --> 10:44:18,596
你正在处理这件事，嗯，然后我们就……

15124
10:44:17,080 --> 10:44:22,080
只需将偏差转发，该偏差是

15125
10:44:18,596 --> 10:44:23,720
你知道的，要加上偏差值，嗯，所以

15126
10:44:22,080 --> 10:44:26,320
实际上，这正在做的事情是它在…… 

15127
10:44:23,720 --> 10:44:29,200
遍历呃 它 它正在进行

15128
10:44:26,320 --> 10:44:31,640
通过批量大小，对吧，然后我们

15129
10:44:29,200 --> 10:44:33,840
遍历实际大小本身

15130
10:44:31,640 --> 10:44:37,680
这是；哪个是

15131
10:44:33,840 --> 10:44:39,756
嗯，哪个才是真正的，呃，就像那个……

15132
10:44:37,680 --> 10:44:41,680
行长度，所以它会跳过

15133
10:44:39,756 --> 10:44:43,000
在尽可能多的批量元素上，就像它（所涉及的情况）一样 

15134
10:44:41,680 --> 10:44:44,276
需要这样做，所以它打算跳过它的……

注：原英文文本“needs to so it's going to skip it's”表述不太符合正常语法规范，翻译只能尽量按字面理解。 

15135
10:44:43,000 --> 10:44:46,520
准备大步前行

15136
10:44:44,276 --> 10:44:48,756
然后它会添加这个“ey”

15137
10:44:46,520 --> 10:44:52,596
对它进行偏移，然后只需进行相加操作

15138
10:44:48,756 --> 10:44:54,160
等于在那个值处的偏差，对吧，所以

15139
10:44:52,596 --> 10:44:59,040
我们实际上就只有这个这个

15140
10:44:54,160 --> 10:45:02,560
一排偏置项，而且它会，嗯，只是

15141
10:44:59,040 --> 10:45:04,160
本质上是把每一个（东西）加起来，这就是它的用途。 

15142
10:45:02,560 --> 10:45:07,400
对于比如给定的一批元素，对于比如

15143
10:45:04,160 --> 10:45:09,200
批次元素一，嗯，它将会仅仅

15144
10:45:07,400 --> 10:45:10,400
另外，你知道的，比如说有大概10个数值

15145
10:45:09,200 --> 10:45:12,080
在这里它将把所有的 10 都加到……（原文句子不完整）

15146
10:45:10,400 --> 10:45:13,240
偏差值，而且它会下降

15147
10:45:12,080 --> 10:45:14,800
它将添加那些相同的值

15148
10:45:13,240 --> 10:45:16,480
再一次，这只是在应用同样的偏见。

15149
10:45:14,800 --> 10:45:18,916
对每一个 对每一行 没错 就是这样

15150
10:45:16,480 --> 10:45:18,916
这正在进行中。

15151
10:45:19,240 --> 10:45:22,040
再往下滚动，我不会（继续这样做）了。

15152
10:45:20,560 --> 10:45:24,756
先不深入探讨这些，因为有……

15153
10:45:22,040 --> 10:45:27,840
希望有更多事情发生，但请往下滚动

15154
10:45:24,756 --> 10:45:31,596
呃，那个……

15155
10:45:27,840 --> 10:45:33,080
实际的，呃，列车功能以及……在哪里

15156
10:45:31,596 --> 10:45:36,680
是

15157
10:45:33,080 --> 10:45:40,320
这是在主函数里，所以在这里我们

15158
10:45:36,680 --> 10:45:42,640
有一个伪随机数生成器

15159
10:45:40,320 --> 10:45:44,160
嗯，这些是伪随机的，它们不是

15160
10:45:42,640 --> 10:45:46,240
实际上，你可以拥有完全随机的

15161
10:45:44,160 --> 10:45:47,640
数字，那是非常难的，呃，你

15162
10:45:46,240 --> 10:45:49,520
了解密码学中的格雷克问题以及

15163
10:45:47,640 --> 10:45:51,596
一切与我所不是的样子类似的事物

15164
10:45:49,520 --> 10:45:54,880
打算深入探讨，嗯，你知道的，在这个方面

15165
10:45:51,596 --> 10:45:56,880
万一我们正在使用 srand 来 来 来生成

15166
10:45:54,880 --> 10:45:58,840
随机数，但在CUDA中你可以使用Q

15167
10:45:56,880 --> 10:46:00,436
兰德 所以它将生成随机数

15168
10:45:58,840 --> 10:46:01,880
数字并行处理得非常快，所以你

15169
10:46:00,436 --> 10:46:03,560
不必非得等着 CPU 去（做某事）
（由于原句不完整，“to”后面内容缺失，翻译可能不太精准，但已按要求处理） 

15170
10:46:01,880 --> 10:46:05,640
做这个，再做这个，然后做这个

15171
10:46:03,560 --> 10:46:07,040
对，这有点快了，嗯，我们

15172
10:46:05,640 --> 10:46:10,520
初始化这个神经网络类

15173
10:46:07,040 --> 10:46:12,960
和神经网络（NN）或者抱歉，结构体，结构体必须…… 

15174
10:46:10,520 --> 10:46:15,720
使用政治上正确的术语，我们

15175
10:46:12,960 --> 10:46:18,240
初始化神经网络，所以我们到这里来

15176
10:46:15,720 --> 10:46:21,480
然后我们就有了这个神经网络，接着是那个

15177
10:46:18,240 --> 10:46:24,080
权重属性 对 呃 等于 然后我们

15178
10:46:21,480 --> 10:46:26,040
做马利克，就做个普通的马利克，所以

15179
10:46:24,080 --> 10:46:28,960
权重 其中一个将会 嗯 被隐藏起来

15180
10:46:26,040 --> 10:46:30,800
按输入大小调整大小，对吧，所以那就是…… 

15181
10:46:28,960 --> 10:46:33,840
256 乘以

15182
10:46:30,800 --> 10:46:36,880
784，然后是权重二，即

15183
10:46:33,840 --> 10:46:39,200
输出大小乘以隐藏大小，所以，嗯，这是

15184
10:46:36,880 --> 10:46:42,880
将要成为；将会是

15185
10:46:39,200 --> 10:46:47,360
嗯，它叫什么来着，256乘以10，所以它是

15186
10:46:42,880 --> 10:46:48,480
打算乘坐BX 256路车，然后换乘26X路车

15187
10:46:47,360 --> 10:46:50,116
10 然后它将把这些数相乘，并且

15188
10:46:48,480 --> 10:46:53,160
它会在10次输出后得到一个B，对吧

15189
10:46:50,116 --> 10:46:56,160
对于那些砝码之后的情况，嗯，你知道的

15190
10:46:53,160 --> 10:46:58,080
偏差，偏差一是隐藏层大小，只是在添加（过程中涉及） 

15191
10:46:56,160 --> 10:47:01,400
再次回到所有这些的那个输出上

15192
10:46:58,080 --> 10:47:02,880
那些神经元，每个神经元各自的值

15193
10:47:01,400 --> 10:47:06,320
IUS 2 一样

15194
10:47:02,880 --> 10:47:09,000
想法，梯度权重，所以就只是这个，但是

15195
10:47:06,320 --> 10:47:10,436
这只是不同的，呃，这只是一个…… 

15196
10:47:09,000 --> 10:47:13,160
不同的变量，对吧，所以我们在

15197
10:47:10,436 --> 10:47:14,560
存储那些误差的梯度

15198
10:47:13,160 --> 10:47:17,320
嗯，而且它们会是一样的。

15199
10:47:14,560 --> 10:47:19,116
形状合适；调整到位（注：“shape right”较口语化，准确含义需结合具体语境，此处为较常见理解）

15200
10:47:17,320 --> 10:47:21,080
嗯，然后我们进行初始化，这样我们就有了

15201
10:47:19,116 --> 10:47:23,640
初始化权重和初始化偏置

15202
10:47:21,080 --> 10:47:25,320
现在这要回到，嗯，那个……

15203
10:47:23,640 --> 10:47:27,640
你提供的英文文本“climing init that we did the the hay”存在拼写错误，可能正确的表达不太清晰。如果猜测性地进行修正和翻译，也许是 “climbing, it's neat that we did the hay”，可译为：
爬山，我们去弄干草这件事真不错。 

15204
10:47:25,320 --> 10:47:30,116
初始化与已初始化的偏差

15205
10:47:27,640 --> 10:47:33,320
我们之前所做的

15206
10:47:30,116 --> 10:47:36,800
嗯，现在，既然我们已经初始化了那些

15207
10:47:33,320 --> 10:47:40,116
我们带着随机值进入这里，所以

15208
10:47:36,800 --> 10:47:43,596
我们的X列车将成为那列关键列车（注：这里“the train”结合语境可能有“关键列车”等更合适意译，若缺乏更多背景信息，也可直译为“那列列车” ）

若不考虑潜在语境，纯字面翻译为：
我们的X列车将是那列列车

15209
10:47:40,116 --> 10:47:46,916
大小，所以在这种情况下训练集的大小是，呃

15210
10:47:43,596 --> 10:47:46,916
你知道一万（这个数量）

注：这里“10,000”如果结合具体语境可能有更合适的译法，比如“你知道一万美元”“你知道一万次”等，仅根据现有文本只能给出较宽泛的翻译。 

15211
10:47:48,000 --> 10:47:53,080
让我再往下面一点，火车

15212
10:47:49,916 --> 10:47:55,960
尺寸乘以输入尺寸，所以一幅图像是

15213
10:47:53,080 --> 10:47:57,360
784 嗯，你知道的，把它压平，然后我们

15214
10:47:55,960 --> 10:47:58,116
在这种情况下有火车的尺寸（此处表述不太符合常见语境，推测原文可能表述不太准确，但按照要求进行了逐字翻译）

15215
10:47:57,360 --> 10:48:01,040
是

15216
10:47:58,116 --> 10:48:04,160
一万……呃，Y 线列车就要……

15217
10:48:01,040 --> 10:48:05,960
是一组那样的整数

15218
10:48:04,160 --> 10:48:08,560
扩展这个，这样我们实际上就不会……不会（这里原文语义不太完整） 

15219
10:48:05,960 --> 10:48:11,916
需要784 只有一个整数值

15220
10:48:08,560 --> 10:48:13,756
每个样本，嗯，也就是标签，以及

15221
10:48:11,916 --> 10:48:15,720
然后我们对于……也有相同的情况（由于原文“for for the for”表述有误，可能影响完整准确理解，但按现有内容只能大致这样翻译） 

15222
10:48:13,756 --> 10:48:18,276
测试集

15223
10:48:15,720 --> 10:48:20,756
好的，我们用……把这些装进去

15224
10:48:18,276 --> 10:48:24,000
之前，嗯，正在加载脚本，那个…… 

15225
10:48:20,756 --> 10:48:25,840
我之前给你展示过，在……之前我们可以打印（此处原英文句子似乎不完整）

15226
10:48:24,000 --> 10:48:27,116
终端里的第一张图片，所以这个

15227
10:48:25,840 --> 10:48:30,916
只是打算把东西打印出来

15228
10:48:27,116 --> 10:48:32,160
使用那个X东西，对，嗯，所以如果我……我是

15229
10:48:30,916 --> 10:48:33,400
稍后会把这个整理出来，然后你会……

15230
10:48:32,160 --> 10:48:36,880
有点明白我的意思了吧，但这只是……

15231
10:48:33,400 --> 10:48:38,960
向我们展示了，嗯，就像我们的……有多棒

15232
10:48:36,880 --> 10:48:40,520
实际的预测将会是，嗯，所以

15233
10:48:38,960 --> 10:48:42,520
实际上，我们可以去看看一个…… 

15234
10:48:40,520 --> 10:48:44,160
终端里的图像，然后看看，好的，什么

15235
10:48:42,520 --> 10:48:45,436
它以为这就是……这是什么？

注：原英文文本 “did it think this was what was the” 并不是一个符合语法规则的完整句子，翻译是基于字面尽量理解其可能表达的意思。 

15236
10:48:44,160 --> 10:48:46,960
实际标签，没错，所以我们在某种程度上可以

15237
10:48:45,436 --> 10:48:48,880
就像看看，然后把东西大致配对起来在……里

15238
10:48:46,960 --> 10:48:50,960
我们自己的脑袋 我不想像这样使用

15239
10:48:48,880 --> 10:48:52,596
OpenCV（开源计算机视觉库）或者一个自定义扩展来放置一个

15240
10:48:50,960 --> 10:48:54,360
窗户，因为那只是一堆额外的东西

15241
10:48:52,596 --> 10:48:56,480
工作  在……里做这件事更容易些

15242
10:48:54,360 --> 10:48:58,640
终端，嗯，然后就是训练

15243
10:48:56,480 --> 10:49:00,640
那些也需要标签，对吧，然后

15244
10:48:58,640 --> 10:49:02,480
我们继续前行，然后去坐火车。

15245
10:49:00,640 --> 10:49:04,596
全面的函数，然后

15246
10:49:02,480 --> 10:49:07,200
我们释放了所有资源，我们不使用CUDA

15247
10:49:04,596 --> 10:49:10,520
免费的，这只是C，我们就做免费的，然后它

15248
10:49:07,200 --> 10:49:12,840
去除权重，呃，偏差

15249
10:49:10,520 --> 10:49:14,960
那些用于训练的所有梯度

15250
10:49:12,840 --> 10:49:18,200
训练集和测试集（注：原文可能少了“training”，一般常见表达是“training set and the test set” ）

15251
10:49:14,960 --> 10:49:19,436
现在我们进入这里面的TR区域

15252
10:49:18,200 --> 10:49:22,000
有一堆事情正在发生，所有的……（原句似乎不完整） 

15253
10:49:19,436 --> 10:49:23,040
对，所以如果我点击这个，能看到哪里

15254
10:49:22,000 --> 10:49:26,596
结束；结尾；终点

注：“the end”常见有以上这些含义，具体需结合语境来精准理解。这里如果它用于影视、故事等结尾处，通常可译为“完”“剧终” 。 

如果你提供更多上下文，我可以为你提供更合适的翻译。若你希望我仅单纯翻译这句话，那么就是“结束” 。 

15255
10:49:23,040 --> 10:49:28,680
是我们有这个，我们有这个，嗯，这个

15256
10:49:26,596 --> 10:49:32,800
就藏在这里，所以那将会是

15257
10:49:28,680 --> 10:49:36,480
你知道我们之前看过的那个 B 除以 256（这里原句表述不太完整和准确，“B by 256”推测是“B divided by 256” ） 

15258
10:49:32,800 --> 10:49:38,756
嗯，那个B

15259
10:49:36,480 --> 10:49:42,596
在……旁边  在哪里  是（过去式）

15260
10:49:38,756 --> 10:49:44,200
它按隐藏大小划分批次大小，所以那是

15261
10:49:42,596 --> 10:49:47,080
就好像会成为真正的隐藏层

15262
10:49:44,200 --> 10:49:49,560
输出，没错，所以在这里我们得到一个 B 乘以……（原句似乎不太完整） 

15263
10:49:47,080 --> 10:49:51,436
256 那是隐藏层，它是

15264
10:49:49,560 --> 10:49:53,400
那是你所知道的第一个 MMAL 输出。

15265
10:49:51,436 --> 10:49:55,840
本质上，然后我们得到输出结果

15266
10:49:53,400 --> 10:49:58,680
这是按输出大小划分的批次大小，哪个……

注：原英文文本似乎不太完整或表述不太准确，但按照要求进行了翻译。 

15267
10:49:55,840 --> 10:50:01,400
在这种情况下是 p

15268
10:49:58,680 --> 10:50:02,480
乘以10，然后我们计算批次数量，所以这个

15269
10:50:01,400 --> 10:50:04,880
我们实际要进行的批次数量

15270
10:50:02,480 --> 10:50:07,680
要做的是训练集大小除以批次

15271
10:50:04,880 --> 10:50:09,360
大小，而我们这样做的原因是

15272
10:50:07,680 --> 10:50:10,800
因为我们不想仅仅是像……

15273
10:50:09,360 --> 10:50:12,916
每次我们都不想给予时进行抵消

15274
10:50:10,800 --> 10:50:15,200
每个样本的数据都是相同的，所以如果我们

15275
10:50:12,916 --> 10:50:17,840
取那总共的60,000，然后进行除法运算

15276
10:50:15,200 --> 10:50:19,756
按批量大小来说，比如四个

15277
10:50:17,840 --> 10:50:21,680
呃，或者抱歉，列车规模是一万，并且

15278
10:50:19,756 --> 10:50:26,560
那么批量大小是四，我们打算

15279
10:50:21,680 --> 10:50:28,756
总共获得2500个，嗯，每个（批次）总共2500个批次

注：原英文表述“total batches each”不太符合常规表达逻辑，这里按字面逐词翻译。 

15280
10:50:26,560 --> 10:50:30,960
里面有四张图片，所以我们要去（做某事）

15281
10:50:28,756 --> 10:50:32,160
做四个，然后再做四个，接着再做四个

15282
10:50:30,960 --> 10:50:35,116
然后这边有四个，我们不喜欢

15283
10:50:32,160 --> 10:50:37,200
重叠右侧，包含相同的图像

15284
10:50:35,116 --> 10:50:40,276
在相邻的批次中，我们只是有点儿给予 

15285
10:50:37,200 --> 10:50:42,200
每次都会有新数据，而且我们会进行轮次训练 

15286
10:50:40,276 --> 10:50:44,400
在那之上，没错，所以我们要做所有的…… （这里原句可能不完整） 

15287
10:50:42,200 --> 10:50:45,680
分批处理，然后我们再进行一个轮次

15288
10:50:44,400 --> 10:50:47,200
说完那个，那么接下来会发生什么呢，它是……

15289
10:50:45,680 --> 10:50:49,840
它要……它要像这样往上走

15290
10:50:47,200 --> 10:50:52,040
在第一个训练周期（Epoch）中达到 50% 或其他情况 

15291
10:50:49,840 --> 10:50:54,560
像 50% 这样的数字，然后它是

15292
10:50:52,040 --> 10:50:55,880
准备开启下一个轮次，而且它是

15293
10:50:54,560 --> 10:50:56,960
要从所有的例子中学习

15294
10:50:55,880 --> 10:50:58,960
它之前是那样的，而且它将会……

15295
10:50:56,960 --> 10:51:00,116
就好像在说“哦，我们又看到那些了，我们知道”

15296
10:50:58,960 --> 10:51:02,160
确切地知道在那里要做什么，所以一切都在进行中

15297
10:51:00,116 --> 10:51:04,116
这会让你明白准确性的重要性（注：原英文表述不太符合常规语法，此为根据大概意思的翻译）

15298
10:51:02,160 --> 10:51:05,840
会喜欢的，就好像损失要来了

15299
10:51:04,116 --> 10:51:07,840
要看起来像这样，这是会有结果的

注：原句 “it's going to figure” 表述不太常见或准确，更常见的可能是 “it's going to work out” 等表达，这里按字面大致翻译。 

15300
10:51:05,840 --> 10:51:09,080
开始把一切都弄清楚并进行调整

15301
10:51:07,840 --> 10:51:10,400
无论它能拿到什么，并且

15302
10:51:09,080 --> 10:51:12,436
它会下降，因为有迹可循

15303
10:51:10,400 --> 10:51:14,840
弄清楚要优化什么，然后它将

注：原英文句子似乎不完整。 

15304
10:51:12,436 --> 10:51:16,880
在那个时代达到稳定状态，它将会……

15305
10:51:14,840 --> 10:51:18,840
有点趋于平稳，然后接下来

15306
10:51:16,880 --> 10:51:20,880
下一个纪元开始了，它将要……它（此处文本可能不完整）

15307
10:51:18,840 --> 10:51:22,320
又要下降了，因为这是由于（此处表述似乎不太完整通顺，“because it's because”语义重复且表意不明） 

15308
10:51:20,880 --> 10:51:25,320
它又看到那些了，而且它能

15309
10:51:22,320 --> 10:51:27,080
为更多情况进行优化，它就能压缩得更多。

15310
10:51:25,320 --> 10:51:28,916
将功能融入其中，因为它被视为…… 

15311
10:51:27,080 --> 10:51:30,800
那已经……嗯，所以它会给你

15312
10:51:28,916 --> 10:51:32,276
知道（情况）继续再次下降，然后

15313
10:51:30,800 --> 10:51:35,080
它会有点趋于平稳，然后

15314
10:51:32,276 --> 10:51:36,480
它又要下降了，然后……

15315
10:51:35,080 --> 10:51:38,560
我们最终只会到某个地方去

15316
10:51:36,480 --> 10:51:41,000
当 无论何时 所有的时代都已终结

15317
10:51:38,560 --> 10:51:42,840
好的，现在我们开始按轮次进行迭代。

15318
10:51:41,000 --> 10:51:46,200
这是

15319
10:51:42,840 --> 10:51:49,240
嗯，如果我实际看一下这个，嗯，这个

15320
10:51:46,200 --> 10:51:50,960
终点就在这里，所以在单一的（情境/范围等，需结合上下文确定）之中

15321
10:51:49,240 --> 10:51:52,720
时代，这就是大部分工作所在之处

15322
10:51:50,960 --> 10:51:54,400
做得对的话，我们就只做免费隐藏的（事情）

15323
10:51:52,720 --> 10:51:56,720
以及输出，所以大部分工作是

15324
10:51:54,400 --> 10:51:59,040
实际上是在……内部的环氧回路中完成的

15325
10:51:56,720 --> 10:52:01,520
在这里我们遭遇了一次彻底的损失，而我们……

15326
10:51:59,040 --> 10:52:03,596
将正确的数量初始化为零

15327
10:52:01,520 --> 10:52:05,436
答案，所以我们也把它设为零，这个

15328
10:52:03,596 --> 10:52:07,756
只是用于追踪准确性，所以我们

15329
10:52:05,436 --> 10:52:10,276
能看到损失相对于什么在下降

15330
10:52:07,756 --> 10:52:12,520
准确率百分比已经超出预期

注：原英文 “the percent accuracy is over the over” 表述不太符合常规英语表达习惯，“over the over” 可能有误，推测想表达 “超出预期” 之类的意思，以上是根据常见语境给出的翻译。 

15331
10:52:10,276 --> 10:52:14,756
训练样本上的 U

15332
10:52:12,520 --> 10:52:18,840
对，所以在每一个训练步骤中我们都能看到

15333
10:52:14,756 --> 10:52:21,840
哪个 或者 每一个 抱歉 每一个 嗯 每一个

15334
10:52:18,840 --> 10:52:24,560
每一千，或者每一百

15335
10:52:21,840 --> 10:52:27,276
训练步骤 我们可以看到什么

15336
10:52:24,560 --> 10:52:29,640
准确率超过了（这里文本不完整，“over the”后面应该还有内容）

15337
10:52:27,276 --> 10:52:33,480
批次，然后在这里面我们进行迭代

15338
10:52:29,640 --> 10:52:38,960
在多个批次上以嗯，以……的幅度增加

15339
10:52:33,480 --> 10:52:38,960
每次都是这样，嗯，一批一批的

15340
10:52:40,880 --> 10:52:46,200
加 + 以及

15341
10:52:43,000 --> 10:52:49,916
然后我们使用起始索引，这将用于……（原文句子不完整）

15342
10:52:46,200 --> 10:52:52,040
是批次次数乘以批次次数再乘以批次大小，我们

15343
10:52:49,916 --> 10:52:55,080
让我们继续推进，这样我们基本上就能得到

15344
10:52:52,040 --> 10:52:56,480
在这里面，我们传入我们的神经网络

15345
10:52:55,080 --> 10:53:00,160
我们像传递我们的神经网络一样传递我们的（此处原句“our like”可能有误，推测可能影响语义准确传达） 

15346
10:52:56,480 --> 10:53:02,240
结构体指针用于输入，所以那是…… 

15347
10:53:00,160 --> 10:53:05,040
要去坐火车了，而且将会是……

15348
10:53:02,240 --> 10:53:08,720
呃，开始

15349
10:53:05,040 --> 10:53:12,080
索引，所以不管这是哪一个，嗯

15350
10:53:08,720 --> 10:53:15,000
不管它是哪一批次 嗯 乘以

15351
10:53:12,080 --> 10:53:17,400
乘以批量大小，所以它即将…… 

15352
10:53:15,000 --> 10:53:19,840
以批量大小为增量进行跳过，对吧

15353
10:53:17,400 --> 10:53:19,840
所以事情正在进展

15354
10:53:22,360 --> 10:53:27,916
它将……而不是呃跳过

15355
10:53:26,116 --> 10:53:31,040
就好像这实际上不会像…… 

15356
10:53:27,916 --> 10:53:33,040
加等于，嗯，就像批次本身，这是

15357
10:53:31,040 --> 10:53:34,520
每次添加一个，所以这是

15358
10:53:33,040 --> 10:53:37,160
只是要表现得像一个增量一样

15359
10:53:34,520 --> 10:53:38,160
所以我们直接跳过，就是这样

15360
10:53:37,160 --> 10:53:39,840
这就是它正在做的事情，它正在进行着

15361
10:53:38,160 --> 10:53:41,680
一次跳四个，而不是仅仅……（这里原句似乎不完整） 

15362
10:53:39,840 --> 10:53:44,360
一个，我们只是加上

15363
10:53:41,680 --> 10:53:47,320
另外，呃，还有

15364
10:53:44,360 --> 10:53:50,200
然后我们传入隐藏层

15365
10:53:47,320 --> 10:53:52,756
我们传入输出，然后传入批次

15366
10:53:50,200 --> 10:53:57,360
尺寸也一样，对吧，所以所有的输入

15367
10:53:52,756 --> 10:53:58,800
嗯，隐藏输出大小，对，嗯，还有这个

15368
10:53:57,360 --> 10:54:01,080
只是要完成我们所有的前向传播过程

15369
10:53:58,800 --> 10:54:03,276
从，呃，你知道的，采取这个（做法）的方式

15370
10:54:01,080 --> 10:54:04,640
我们已经处理好的扁平化图像

15371
10:54:03,276 --> 10:54:07,000
我只是因为它就这么摆在了……（原句似乎不完整） 

15372
10:54:04,640 --> 10:54:09,000
二进制，它就那样存在着，就像你一样 

15373
10:54:07,000 --> 10:54:10,756
可以对其进行重新格式化并将其解读为

15374
10:54:09,000 --> 10:54:13,400
无论你想要什么，但我只能在回忆里看到

15375
10:54:10,756 --> 10:54:15,840
实际上它确实是按照一个（的形式）来布置的

15376
10:54:13,400 --> 10:54:17,880
从 0 开始，你知道从 Z 到 784 或者

15377
10:54:15,840 --> 10:54:21,040
不管怎样，嗯，所以这也没那么难。

15378
10:54:17,880 --> 10:54:21,040
实际上喜欢瞎折腾

15379
10:54:21,276 --> 10:54:29,040
当我们进行前向传播时，我们计算

15380
10:54:24,916 --> 10:54:31,000
我们的交叉熵损失，没错，使用这个…… 

15381
10:54:29,040 --> 10:54:32,640
呃，和我们之前一样的交叉熵损失概念

15382
10:54:31,000 --> 10:54:36,276
在 C 语言友好的脚本中完成的，所以我们现在

15383
10:54:32,640 --> 10:54:38,000
只是把那个移植到 C 语言上，呃，如果

15384
10:54:36,276 --> 10:54:39,276
就好像，如果，如果，如果这样不行的话…… 

15385
10:54:38,000 --> 10:54:40,596
有道理，然后你实际上就可以进去了

15386
10:54:39,276 --> 10:54:42,360
你可以看到，好吧，那么我们是什么呢

15387
10:54:40,596 --> 10:54:44,320
在这里做（某事）和在这里做（某事）对比，对吧，你有……

15388
10:54:42,360 --> 10:54:45,880
像语言模型之类的工具以及……（原文“and and”可能有误，这里按原文格式呈现翻译）

15389
10:54:44,320 --> 10:54:47,240
互联网，你可以通过它来调查这些事情

15390
10:54:45,880 --> 10:54:50,880
把事情彻彻底底地做完，而且你可以做到友善待人 

15391
10:54:47,240 --> 10:54:56,276
看看正在发生什么 嗯 是的 所以我们

15392
10:54:50,880 --> 10:54:58,240
计算我们的损失，我们要加上，嗯，我们要加上…… 

15393
10:54:56,276 --> 10:55:01,240
呃，我们把那部分损失加到总损失里，所以

15394
10:54:58,240 --> 10:55:03,040
在那个实际的纪元里，我们看到，好的

15395
10:55:01,240 --> 10:55:05,560
嗯，那个……那个是什么来着

15396
10:55:03,040 --> 10:55:08,240
平均损失，对，嗯，你知道在这儿

15397
10:55:05,560 --> 10:55:10,320
我们用总损失除以，你懂的

15398
10:55:08,240 --> 10:55:12,916
麻木的批次，所以我们有点，我们有点

15399
10:55:10,320 --> 10:55:12,916
将其平均；算出……的平均值

注：由于“average that”表述较简短且缺乏具体语境，以上为常见释义，可能需要根据具体情况灵活理解。 

15400
10:55:13,960 --> 10:55:19,640
呃，嗯

15401
10:55:17,520 --> 10:55:20,880
我们每个时代都这样做，然后

15402
10:55:19,640 --> 10:55:24,116
在……里面；在……内部

15403
10:55:20,880 --> 10:55:27,080
在这里，我们仅仅是，这仅仅起到……的作用

15404
10:55:24,116 --> 10:55:30,436
给正确计数器的小增量

15405
10:55:27,080 --> 10:55:34,800
所以这只是要看看，好吧，嗯

15406
10:55:30,436 --> 10:55:34,800
嗯，我们关系亲密吗，还是不亲密呢，嗯

15407
10:55:35,680 --> 10:55:41,200
所以这应该是不言而喻的，嗯

15408
10:55:39,116 --> 10:55:42,520
这也不一定就是这样。 

15409
10:55:41,200 --> 10:55:44,160
训练跑步的一部分，但就像

15410
10:55:42,520 --> 10:55:46,320
你可以用来使用的一个额外功能

15411
10:55:44,160 --> 10:55:48,520
打印出，呃，在……之上的准确率是多少

15412
10:55:46,320 --> 10:55:49,880
时间，嗯，不是损失，而是实际情况

15413
10:55:48,520 --> 10:55:52,800
百分之；百分比；百分数

15414
10:55:49,880 --> 10:55:56,320
准确性，反向传播函数，所以这

15415
10:55:52,800 --> 10:56:00,080
吸收你知道的氮（NN 可能是 nitrogen 的缩写，这里根据语境推测），而且它会吸收呃…… 

15416
10:55:56,320 --> 10:56:02,560
指向，呃，指向输入的指针，对吧，所以这个

15417
10:56:00,080 --> 10:56:06,160
这是指向此处的内存地址吗？

15418
10:56:02,560 --> 10:56:09,200
这个指数，它将会是，嗯

15419
10:56:06,160 --> 10:56:11,160
起始索引乘以输入大小，对吗

15420
10:56:09,200 --> 10:56:14,680
然后在这个里面我们传入几个

15421
10:56:11,160 --> 10:56:16,000
事物的意义被隐藏起来了 嗯 你懂这个的

15422
10:56:14,680 --> 10:56:17,560
神经网络将包含所有的

15423
10:56:16,000 --> 10:56:19,320
我们所有的重物之类的东西 所以

15424
10:56:17,560 --> 10:56:23,276
别这样，这就好像所有的一切都被包含在……里了。 

15425
10:56:19,320 --> 10:56:27,276
那个，呃，输入本身

15426
10:56:23,276 --> 10:56:28,916
嗯，隐藏输出标签和批量大小

15427
10:56:27,276 --> 10:56:31,916
所以其结构与前锋的结构非常相似

15428
10:56:28,916 --> 10:56:34,880
通过，除了我们还包括，呃，我们还

15429
10:56:31,916 --> 10:56:38,080
包含标签

15430
10:56:34,880 --> 10:56:40,520
好的，更新权重，现在一切都……（此处英文句子似乎不完整，翻译根据现有内容给出） 

15431
10:56:38,080 --> 10:56:43,480
之后进行更新，然后我们就可以打印了。

15432
10:56:40,520 --> 10:56:44,560
找出一些有用的东西，好的，就是这样

15433
10:56:43,480 --> 10:56:45,840
在这件事里几乎所有发生的情况

15434
10:56:44,560 --> 10:56:49,360
训练循环，其中很多就像

15435
10:56:45,840 --> 10:56:52,436
打印并记录相关内容 嗯 但是

15436
10:56:49,360 --> 10:56:56,160
是的，那么继续

（这里“going”的准确含义需要结合更多上下文来确定更合适的表达，“继续”只是一个比较常见符合语境推测的翻译） 

15437
10:56:52,436 --> 10:56:57,840
实际上，如果我们看看我们的，呃，如果我们

15438
10:56:56,160 --> 10:57:00,436
实际上，看看

15439
10:56:57,840 --> 10:57:02,880
让我跳到前面的道路上去

15440
10:57:00,436 --> 10:57:06,436
这是从哪儿来的（因缺少更多语境，此处根据一般理解翻译，“this”含义可根据实际情境调整）；这是怎么回事（同样结合一般语境推测）；这个……从哪儿来的呢 

如果完整表述可能是 “Where did this come from?” 之类的，由于英文未完整给出，只能宽泛理解并给出可能的译法。你可以补充完整英文内容以便得到更准确的翻译。 

15441
10:57:02,880 --> 10:57:09,800
好的，太棒了，那么在前锋区里面，嗯……

15442
10:57:06,436 --> 10:57:14,596
我们，这很简单，对吧，1、2、3、4

15443
10:57:09,800 --> 10:57:16,916
五，六，嗯，现在里面情况还不算太糟

15444
10:57:14,596 --> 10:57:18,160
在这里我只额外添加了软件 Max 。 

15445
10:57:16,916 --> 10:57:19,756
因为我不想显得多余

15446
10:57:18,160 --> 10:57:21,400
并且包含在像整体训练这样的内容中

15447
10:57:19,756 --> 10:57:23,240
循环那件事，当时有很多事情在发生

15448
10:57:21,400 --> 10:57:24,916
就在那儿，那儿很安静，只有你

15449
10:57:23,240 --> 10:57:27,116
整理起来很复杂

15450
10:57:24,916 --> 10:57:28,320
所有事情，不过，是的，它真的……

15451
10:57:27,116 --> 10:57:30,680
当你把事情分解成……时会很有帮助

15452
10:57:28,320 --> 10:57:31,916
小块的内容
这超级容易处理

15453
10:57:30,680 --> 10:57:34,360
我想向前推进并且…… 

15454
10:57:31,916 --> 10:57:35,596
反向传播尽可能模块化

15455
10:57:34,360 --> 10:57:37,240
这样你们真的可以

（需要注意的是，你提供的句子不完整，若有更多内容可以继续向我提供以获取更准确的翻译。） 

15456
10:57:35,596 --> 10:57:40,436
如果你想的话，可以对性能进行优化。

15457
10:57:37,240 --> 10:57:42,916
就像在边上，嗯，但这就像是

15458
10:57:40,436 --> 10:57:44,720
实际上和我们在“or”（或；或者）中所做的完全一样

15459
10:57:42,916 --> 10:57:46,320
几乎和我们在C语言里所做的完全一样

15460
10:57:44,720 --> 10:57:48,200
友好的函数或对C友好的（表述） 

15461
10:57:46,320 --> 10:57:50,080
台词 那么在那里我们有这个

15462
10:57:48,200 --> 10:57:54,360
就像线性前向方法，这种方法会

15463
10:57:50,080 --> 10:57:56,200
进行M摩尔和偏置，嗯，然后

15464
10:57:54,360 --> 10:57:59,436
线性反向传播，这对你有什么作用呢（原句表述不太符合常见英语语法，此翻译结合常见语境推测）

注：如果原文存在拼写或表述错误，可进一步核实准确内容后再让我翻译。 

15465
10:57:56,200 --> 10:58:02,160
知道两毫摩尔，还有，呃，还有一个 

15466
10:57:59,436 --> 10:58:03,520
偏置反向传播 嗯，但在这个里面我们某种程度上

15467
10:58:02,160 --> 10:58:05,840
只是把它拆分成更简单、更多的（部分）

15468
10:58:03,520 --> 10:58:08,276
可处理的部分，所以一只地图鼹鼠

15469
10:58:05,840 --> 10:58:10,360
具体来说，呃，就像一次行动

15470
10:58:08,276 --> 10:58:12,200
你可以自行对其进行优化，所以

15471
10:58:10,360 --> 10:58:14,240
就像优化一个线性前向过程或者……

15472
10:58:12,200 --> 10:58:15,436
更一般地说，线性反向它是

15473
10:58:14,240 --> 10:58:16,560
你知道吗，要做到那样有点难呢

15474
10:58:15,436 --> 10:58:18,596
里面有好几样东西，你有

15475
10:58:16,560 --> 10:58:21,116
把内核融合在一起，这更……

15476
10:58:18,596 --> 10:58:23,560
太复杂了，所以我决定保留这个。

15477
10:58:21,116 --> 10:58:25,960
尽可能易于管理，超级（这里“超级”表述较模糊，需结合更完整语境准确理解）

15478
10:58:23,560 --> 10:58:31,560
可被破解的 嗯，你懂的

15479
10:58:25,960 --> 10:58:33,436
模块化的，但在地图里鼹鼠的（这里文本似乎表意不完整或有语病）

15480
10:58:31,560 --> 10:58:35,916
AB；AB血型；抗体（antibody）

注：“ab”是个多义词，具体含义需结合语境确定，以上列举了一些常见解释。若有具体语境，请补充以便更精准翻译。 

15481
10:58:33,436 --> 10:58:38,560
嗯，是的，这个

15482
10:58:35,916 --> 10:58:41,916
这实际上和 C 是一样的吗？

15483
10:58:38,560 --> 10:58:43,680
很友好，所以如果我把这个放在这儿，嗯

15484
10:58:41,916 --> 10:58:46,680
实际上，也许我真的会带上它。实际上

15485
10:58:43,680 --> 10:58:50,360
向下 嗯

15486
10:58:46,680 --> 10:58:55,436
但在这里，线性向前，对吧，我们只是

15487
10:58:50,360 --> 10:58:57,116
计算 x * W
这就是 x * W
我们不是……呃，x *

15488
10:58:55,436 --> 10:59:00,680
W A和B是同一回事，我们不是（这种情况） 

15489
10:58:57,116 --> 10:59:02,320
转置任何东西以及其中的内容

15490
10:59:00,680 --> 10:59:04,240
而且我已经讲过这个功能了

15491
10:59:02,320 --> 10:59:08,400
但你，你大概能明白我们只是……

15492
10:59:04,240 --> 10:59:11,640
在 A 和 B 之间做一个“枫木（这里‘maple’可能结合上下文有特定含义，此处直译为枫木）”操作，然后嗯…… 

15493
10:59:08,400 --> 10:59:14,640
我们进行了双向偏差前向处理，所以那也是…… 

15494
10:59:11,640 --> 10:59:16,436
我们要去那边，是啊，我

15495
10:59:14,640 --> 10:59:19,276
已经也复习过了
不需要再复习了

15496
10:59:16,436 --> 10:59:21,756
再讲一遍，鲁，转发一下，只是……

15497
10:59:19,276 --> 10:59:24,960
要非常（这里“very”单独出现表意不完整，推测可能文本不完整）对每个元素应用那个（方法、规则等，需结合上文确定“that”指代内容） 

15498
10:59:21,756 --> 10:59:26,560
简单的M、Mo、A和B，所以还是同样的情况

15499
10:59:24,960 --> 10:59:28,360
除了它是隐藏的 它是 它是

15500
10:59:26,560 --> 10:59:30,400
实际上，输出的秘诀

注：原英文文本 “the the” 可能存在重复用词的错误，以上翻译是在尽量贴合原文基础上完成的。 

15501
10:59:28,360 --> 10:59:32,840
而不是将输出设置为隐藏，所以接下来

15502
10:59:30,400 --> 10:59:35,040
首先，然后我们进行偏置前向传播

15503
10:59:32,840 --> 10:59:36,916
再次，然后进行softmax操作，对吧，所以

15504
10:59:35,040 --> 10:59:39,000
显然，像这样是非常非常简单的。

15505
10:59:36,916 --> 10:59:40,480
要遵循，嗯，这更像是……更像是那种……

15506
10:59:39,000 --> 10:59:43,400
复杂性存在于现实之中

15507
10:59:40,480 --> 10:59:48,200
函数，所以就像这样，这有很多

15508
10:59:43,400 --> 10:59:50,520
比……比……比……更难应对

15509
10:59:48,200 --> 10:59:55,756
仅仅是为了传递函数本身

15510
10:59:50,520 --> 11:00:00,800
好的，所以我在那一步退出，然后

15511
10:59:55,756 --> 11:00:03,040
嗯，然后往下说，比如倒着说

15512
11:00:00,800 --> 11:00:06,320
函数，它有点……

15513
11:00:03,040 --> 11:00:10,596
说实话，更糟的是一直到这里

15514
11:00:06,320 --> 11:00:13,756
反向函数，所以在这儿里面

15515
11:00:10,596 --> 11:00:16,960
嗯，我们要对所有内容进行零梯度操作。

15516
11:00:13,756 --> 11:00:20,276
所以这意味着在此之前

15517
11:00:16,960 --> 11:00:23,756
我们的梯度 我们正在累积各项内容

15518
11:00:20,276 --> 11:00:25,080
好的，那么我们的梯度，嗯，我们的梯度偏差以及

15519
11:00:23,756 --> 11:00:29,000
我们的梯度权重实际上是

15520
11:00:25,080 --> 11:00:30,680
积累东西，所以我们只是想

15521
11:00:29,000 --> 11:00:32,756
马上把那些清零，这就是那个

15522
11:00:30,680 --> 11:00:34,840
当……时零梯度和P torch的等效情况

15523
11:00:32,756 --> 11:00:38,640
我们去这里

15524
11:00:34,840 --> 11:00:40,320
嗯，我们让优化器执行更新步骤，所以就是这样

15525
11:00:38,640 --> 11:00:41,960
就像实际更新的权重，所以你……你

15526
11:00:40,320 --> 11:00:43,800
知道的话就做前向（动作），然后你…… 

15527
11:00:41,960 --> 11:00:45,080
计算损失，然后进行反向传播

15528
11:00:43,800 --> 11:00:46,480
然后你用以下方式更新权重

15529
11:00:45,080 --> 11:00:48,320
梯度下降，然后你归零

15530
11:00:46,480 --> 11:00:52,680
毕业生，所以你只是把每一个（数据、数值等，需结合上下文确定）都归零了

15531
11:00:48,320 --> 11:00:54,040
整个网络中的单个梯度 嗯

15532
11:00:52,680 --> 11:00:56,640
然后你要重新计算

15533
11:00:54,040 --> 11:01:00,160
那些当你进行下一次优化器操作时要做的事情 

15534
11:00:56,640 --> 11:01:02,640
向右迈步，否则抱歉，无损失。向后退

15535
11:01:00,160 --> 11:01:03,916
相反，当你计算梯度时

15536
11:01:02,640 --> 11:01:05,436
再次强调，它们不会累积。

15537
11:01:03,916 --> 11:01:07,116
此外，他们只是打算安置它们。

15538
11:01:05,436 --> 11:01:08,800
最初，并且你要进行更新

15539
11:01:07,116 --> 11:01:11,840
基于那些梯度，然后以及

15540
11:01:08,800 --> 11:01:14,596
然后再把它们归零

15541
11:01:11,840 --> 11:01:16,276
嗯，所以这就是我们在这里所做的一切，我们归零。

15542
11:01:14,596 --> 11:01:19,200
梯度，实际上有一个关于……的函数（这里“for”后面内容缺失，只能大致翻译到这） 

15543
11:01:16,276 --> 11:01:26,000
这个所谓的内存设置实际上就只是一个 C（语言相关，这里信息不足不太明确 C 具体所指） 

15544
11:01:19,200 --> 11:01:27,320
函数 um 将 s 的 n 个字节设置为 C，所以

15545
11:01:26,000 --> 11:01:32,916
设定；放置；设置；使处于；规定；树立；凝固；一套；集合；布景；装置；一组；凝结；凝固的；规定的；固定的；坚决的

由于“Set”含义较多，具体意思需结合上下文确定。若你能提供更多相关内容，我会给出更准确的翻译。 

15546
11:01:27,320 --> 11:01:34,640
嗯，设置，设置，嗯，所以 s 的元素是，这是……

注：你提供的英文似乎存在一些表述不完整或不太清晰准确的地方，以上是根据字面进行的大致翻译。 

15547
11:01:32,916 --> 11:01:37,960
第一个，所以

15548
11:01:34,640 --> 11:01:41,360
梯度，然后 C 就是我们想要的值。

15549
11:01:37,960 --> 11:01:44,960
把它设置为零，然后是 N 和……（这里“the N the”表述似乎不完整） 

15550
11:01:41,360 --> 11:01:46,400
它的长度刚好是梯度的大小

15551
11:01:44,960 --> 11:01:49,400
好的，那么尺寸

15552
11:01:46,400 --> 11:01:51,400
是数字的数量，然后是一个

15553
11:01:49,400 --> 11:01:53,200
float 就像字节的数量

15554
11:01:51,400 --> 11:01:55,960
本质上，所以……的字节数

15555
11:01:53,200 --> 11:01:59,436
梯度在内存中占据，我们打算

15556
11:01:55,960 --> 11:02:01,200
从那个……的开头开始，然后

15557
11:01:59,436 --> 11:02:03,480
我们要初始化所有那些。

15558
11:02:01,200 --> 11:02:05,000
那些顺序内存处的值

15559
11:02:03,480 --> 11:02:07,200
地址，我们打算把它们设置为

15560
11:02:05,000 --> 11:02:08,756
零，这就是零抓取在……上的作用（此处“on a”后面内容缺失，译文意思可能不够完整） 

15561
11:02:07,200 --> 11:02:11,960
非常低

15562
11:02:08,756 --> 11:02:12,916
水平 嗯，所以我们用我们的哑铃来做那个

15563
11:02:11,960 --> 11:02:15,320
以及我们的

15564
11:02:12,916 --> 11:02:17,916
偏差，现在我们进行梯度输出，所以这个

15565
11:02:15,320 --> 11:02:22,320
只是要到一个恶意的批量大小时间

注：原英文 “malic” 可能拼写有误，推测正确的词是 “malicious” 。若按 “malicious” 翻译，句子意思为 “只是要到一个恶意的批量大小时间” ，但整体句子表述可能不够自然流畅，需结合更多上下文来准确理解。 

15566
11:02:17,916 --> 11:02:24,480
输出大小，所以是 B * 10，对吧，是 B 乘以 10，它们

15567
11:02:22,320 --> 11:02:26,200
计算输出梯度，所以我们进入到

15568
11:02:24,480 --> 11:02:27,840
这个拉利，所有这些所做的只是……

15569
11:02:26,200 --> 11:02:29,916
利用这个，这个巨大的产出，而我们…… 

15570
11:02:27,840 --> 11:02:32,320
初始化，一切都如同归零，并且

15571
11:02:29,916 --> 11:02:34,480
我们有这样的输出，也就是那个，呃

15572
11:02:32,320 --> 11:02:36,240
从正向传播中记住的是

15573
11:02:34,480 --> 11:02:37,596
softmax的输出，即

15574
11:02:36,240 --> 11:02:40,320
实际上是一个概率分布，它

15575
11:02:37,596 --> 11:02:41,680
不是低级的小混混，也不是之前那样

15576
11:02:40,320 --> 11:02:43,720
求幂运算，它实际上是一种

15577
11:02:41,680 --> 11:02:46,116
每个值的概率分布

15578
11:02:43,720 --> 11:02:48,720
在 0 和 1 之间，那么我们有这个

15579
11:02:46,116 --> 11:02:50,720
标签，实际上我们在这里所做的一切就是

15580
11:02:48,720 --> 11:02:53,640
我们只是逐元素地设置梯度

15581
11:02:50,720 --> 11:02:55,360
输出到，嗯，实际的输出值，所以

15582
11:02:53,640 --> 11:02:58,200
哪……哪……呃，哪个浮点数

15583
11:02:55,360 --> 11:03:01,756
数字，它对吗，然后我们进行减法运算

15584
11:02:58,200 --> 11:03:03,840
一个基于它的实际标签，所以

15585
11:03:01,756 --> 11:03:06,640
注意在之前，在“C友好”中我们是如何…… 

15586
11:03:03,840 --> 11:03:09,000
呃，我们的梯度输出等于

15587
11:03:06,640 --> 11:03:10,520
softmax概率减去真实标签y，我们正在做的是

15588
11:03:09,000 --> 11:03:12,240
这里情况也一样，只是我们不能仅仅……

15589
11:03:10,520 --> 11:03:14,560
进行一个简单的NumPy逐元素操作

15590
11:03:12,240 --> 11:03:16,240
行动方面，我们不能傻里傻气的，而且

15591
11:03:14,560 --> 11:03:18,400
要说对这件事，我们实际上得

15592
11:03:16,240 --> 11:03:20,040
我们必须明确表达，而且我们可以成为一个…… 

15593
11:03:18,400 --> 11:03:25,116
只是做了减法就有点小聪明了

15594
11:03:20,040 --> 11:03:26,276
等于 1 呃，在那里，所以呃，就是这样

15595
11:03:25,116 --> 11:03:28,276
实际上我们正在做同样的事情

15596
11:03:26,276 --> 11:03:30,756
只是使用了一种不同的

15597
11:03:28,276 --> 11:03:32,680
诀窍在于如果我们只是继续坚持下去

15598
11:03:30,756 --> 11:03:34,116
我们现在刚刚计算出了输出梯度。

15599
11:03:32,680 --> 11:03:36,320
我们现在实际上可以使用那些了。

15600
11:03:34,116 --> 11:03:38,916
梯度并开始像使用矩阵那样使用它们 （注：原句“like Matrix”这里可能表述不太完整，推测意思是像使用矩阵那样，若有更准确背景信息可进一步优化翻译） 

15601
11:03:36,320 --> 11:03:41,480
多次高潮，偏向后方，还有“Ru” 

15602
11:03:38,916 --> 11:03:44,916
倒退以及诸如此类的事情，对吧，所以

15603
11:03:41,480 --> 11:03:48,436
第一个是马特·莫，嗯，我们开始吧

15604
11:03:44,916 --> 11:03:52,720
现在，呃，我们来计算 w2 的梯度。

15605
11:03:48,436 --> 11:03:54,436
w2. 梯度就在这里，所以是 x2 的转置乘以 

15606
11:03:52,720 --> 11:03:57,560
损失的导数，也就是梯度

15607
11:03:54,436 --> 11:04:03,320
输出 所以在这里我们进行一个隐藏操作，即

15608
11:03:57,560 --> 11:04:03,320
在这种情况下，这里是X2，嗯，或者

15609
11:04:03,360 --> 11:04:14,320
抱歉，是的，重复两次，所以呢，本质上这个…… 

15610
11:04:10,320 --> 11:04:16,800
进入那个的输入，嗯，然后

15611
11:04:14,320 --> 11:04:19,160
乘以，所以这是乘以B，对吧，所以B是

15612
11:04:16,800 --> 11:04:21,680
在这种情况下是梯度输出，所以我们正在

15613
11:04:19,160 --> 11:04:23,200
把这个和这里的这个 a 进行转置，并且

15614
11:04:21,680 --> 11:04:25,520
然后将这个相乘，然后那就会……

15615
11:04:23,200 --> 11:04:29,840
等于 C 或者梯度权重为 2，对吧，所以

15616
11:04:25,520 --> 11:04:32,360
梯度权重数量 W2 对的

15617
11:04:29,840 --> 11:04:33,520
嗯，是的，所以那……那应该是

15618
11:04:32,360 --> 11:04:36,000
相当地；公平地；公正地；相当程度上

15619
11:04:33,520 --> 11:04:38,360
直观的
现在我们更进一步
我们前往

15620
11:04:36,000 --> 11:04:40,080
偏置反向 偏置反向不是

15621
11:04:38,360 --> 11:04:43,960
实际上，太糟糕了，如此偏袒。

15622
11:04:40,080 --> 11:04:46,276
向后呢，呃，实际上就是要去……

15623
11:04:43,960 --> 11:04:47,880
我们要遍历……这个

15624
11:04:46,276 --> 11:04:49,000
尺寸，我的意思是要记住我们有批量的（货物/产品等，需结合具体语境）

15625
11:04:47,880 --> 11:04:52,000
尺寸合适，所以我们要进行迭代

15626
11:04:49,000 --> 11:04:54,640
贯穿它的整个规模 呃 你

15627
11:04:52,000 --> 11:04:58,276
知道对每个“我”（I）进行迭代和递增

15628
11:04:54,640 --> 11:05:03,320
时间到了，我们要去……商店……一个

15629
11:04:58,276 --> 11:05:05,680
偏置值 一个梯度 偏置梯度 这个

15630
11:05:03,320 --> 11:05:08,720
索引为；作为……索引

15631
11:05:05,680 --> 11:05:11,360
零，然后我们要遍历一遍

15632
11:05:08,720 --> 11:05:13,520
整个批量大小，而且我们

15633
11:05:11,360 --> 11:05:16,116
真的就打算那样设定了

15634
11:05:13,520 --> 11:05:17,320
我们要迭代的具体值

15635
11:05:16,116 --> 11:05:18,840
记住，我们正在遍历这个

15636
11:05:17,320 --> 11:05:20,480
整个批量大小，就像我们之前在做的那样

15637
11:05:18,840 --> 11:05:23,596
之前我们就像在挤压那个…… 

15638
11:05:20,480 --> 11:05:27,960
数字，我们接下来要详细探讨一下这些数字。（这里原文“that”指代前面提到的“numbers”，结合合理推测做了稍微润色，若严格逐字翻译为“数字，我们接下来要过一遍那个”，会稍显生硬）

15639
11:05:23,596 --> 11:05:29,680
我们基本上要去做 B 了。

15640
11:05:27,960 --> 11:05:33,400
时代；次数；倍数；乘以

15641
11:05:29,680 --> 11:05:37,520
尺寸，所以整个，呃，整个长度

15642
11:05:33,400 --> 11:05:39,040
关于那个，整个……的长度，嗯，……的

15643
11:05:37,520 --> 11:05:42,276
像一个……像一个……

注：原英文文本“like a of like a” 可能表述有误，不太符合正常英文表达逻辑，以上是按照字面进行的翻译。 

15644
11:05:39,040 --> 11:05:46,160
行，然后加

15645
11:05:42,276 --> 11:05:47,680
我，而且我们只是打算设置，嗯，嗯

15646
11:05:46,160 --> 11:05:49,436
因为这将使每一个（事物）都增加 

15647
11:05:47,680 --> 11:05:52,320
时间，所以本质上我们只是要去……

15648
11:05:49,436 --> 11:05:53,880
一次向下移动一行，对吧，并且

15649
11:05:52,320 --> 11:05:55,680
我们 我们把它压到一起了

15650
11:05:53,880 --> 11:05:58,840
因为我们正处于累加状态

15651
11:05:55,680 --> 11:06:01,080
这里的值，所以我们的梯度偏置是 

15652
11:05:58,840 --> 11:06:03,640
这相当于在……上进行 np.sum 操作 

15653
11:06:01,080 --> 11:06:07,560
轴零，保持维度为真

15654
11:06:03,640 --> 11:06:10,276
对，呃，然后我们回去

15655
11:06:07,560 --> 11:06:13,116
要去哪里是

注：原英文“to where is”并不是一个符合常见语法规则的完整正确表达，可能存在信息缺失或表述错误。 

15656
11:06:10,276 --> 11:06:15,320
如果我们回到反向传播函数

15657
11:06:13,116 --> 11:06:18,800
太棒了，所以现在我们要计算偏置的反向传播了。

15658
11:06:15,320 --> 11:06:21,080
传入呃梯度偏差，对吧，所以我们现在…… （原句不完整，“we're”后面内容缺失，这里根据已有信息尽量通顺翻译） 

15659
11:06:18,800 --> 11:06:23,756
计算梯度偏差，并且我们

15660
11:06:21,080 --> 11:06:25,800
传入梯度，这样在这个（情况）中就会……

注：原英文句子不太完整或表意不太清晰，以上翻译是根据现有内容尽量给出通顺的译文。 

15661
11:06:23,756 --> 11:06:29,040
这种情况会是梯度输出，然后

15662
11:06:25,800 --> 11:06:30,436
批量大小和尺寸，所以应该

15663
11:06:29,040 --> 11:06:31,960
相当直观，它只是那个

15664
11:06:30,436 --> 11:06:34,720
梯度正在直接流动，而且我们

15665
11:06:31,960 --> 11:06:36,360
只需进行一次跨……的累加操作

15666
11:06:34,720 --> 11:06:38,000
这批（数据/样本等，需结合具体语境），因为我们想进行泛化。

15667
11:06:36,360 --> 11:06:40,720
在一批数据上操作，没错，这样做更有用的是

15668
11:06:38,000 --> 11:06:43,756
这样做，嗯，然后我们就接着做，因为…… 

15669
11:06:40,720 --> 11:06:47,640
我们已经完成了W2表格，现在我们实际上要开始下一步了 

15670
11:06:43,756 --> 11:06:49,720
接下来，呃，是DX X2，对吧，那么

15671
11:06:47,640 --> 11:06:52,800
dx2 呃，是对的

15672
11:06:49,720 --> 11:06:54,040
嘿，我们这儿，马利克，因为记住这是…… （原句表述不太完整和规范，此为尽量贴合原意的翻译） 

15673
11:06:52,800 --> 11:06:55,640
只是暂时的，我们不，我们不

15674
11:06:54,040 --> 11:06:57,240
实际上需要把这个存起来 这个不行

15675
11:06:55,640 --> 11:06:58,640
需要在任何地方进行更新，我们只是

15676
11:06:57,240 --> 11:07:01,840
正在计算这个，因为它是一个

15677
11:06:58,640 --> 11:07:03,480
计算W1的先决条件，所以我们 我们

15678
11:07:01,840 --> 11:07:06,640
在我们不需要存储之后可以释放它

15679
11:07:03,480 --> 11:07:09,320
这段记忆就像是高效的，嗯

15680
11:07:06,640 --> 11:07:12,840
而在这里面，我们实际上就直接进去

15681
11:07:09,320 --> 11:07:17,560
呃，梯度输出时间，W2的转置，对吧

15682
11:07:12,840 --> 11:07:20,880
所以我们得到梯度输出为 W2 转置乘以 T

15683
11:07:17,560 --> 11:07:24,916
然后我们把它存储在 dx2 里，对吧，接着进行

15684
11:07:20,880 --> 11:07:29,520
再往下，D 出口，就是这部分

15685
11:07:24,916 --> 11:07:33,160
这里 $\mathrm{d}\mathbf{r}$ 对 $x_2$ 的导数是 $\mathrm{d}\mathbf{r}$ 关于……（原句“d r of”表述不太完整清晰，这里只能按字面直译） 

15686
11:07:29,520 --> 11:07:35,480
X 我们为这个分配内存，然后继续

15687
11:07:33,160 --> 11:07:40,436
嗯，我们会经历整个……

15688
11:07:35,480 --> 11:07:42,160
批量处理，实际上我们只需要做 dx2，所以就是 dx2

15689
11:07:40,436 --> 11:07:43,916
时间

15690
11:07:42,160 --> 11:07:47,080
D（由于“D”可能是人名首字母、缩写、某个特定概念的代称等，仅这一个字母较难准确判断其具体含义，这里只能直接照字面处理） 

15691
11:07:43,916 --> 11:07:49,916
嗯，不管是什么，不管那个什么

15692
11:07:47,080 --> 11:07:53,436
价值只是在经历它的过程中体现

15693
11:07:49,916 --> 11:07:58,240
对，然后如果是这样的话，这将会是……嗯

15694
11:07:53,436 --> 11:08:02,160
这会被判定为真吗？ 

15695
11:07:58,240 --> 11:08:05,800
所以，或者本质上是一个 1，如果这个，如果这个

15696
11:08:02,160 --> 11:08:08,520
如果这个值嗯……本质上只是

15697
11:08:05,800 --> 11:08:11,240
左导数 右导数

15698
11:08:08,520 --> 11:08:12,800
这就是全部了，嗯，我们也许不会

15699
11:08:11,240 --> 11:08:14,160
实际上甚至需要求鲁伊导数

15700
11:08:12,800 --> 11:08:16,116
在这整件事上是倒退的，但是

15701
11:08:14,160 --> 11:08:19,436
不管怎样，我们还是要留着它。嗯，这个

15702
11:08:16,116 --> 11:08:23,276
不过这确实有用，所以这存储了……（原句似乎未完整）

15703
11:08:19,436 --> 11:08:27,840
D出，那就是我们想要的，对吧，D出是

15704
11:08:23,276 --> 11:08:31,200
好的，然后我们使用……使用……来更新

15705
11:08:27,840 --> 11:08:34,276
嗯，它叫什么来着，我们来计算 D 出值。

15706
11:08:31,200 --> 11:08:36,520
从我们在这里用完的那个 dx2 （注：这里 “dx2” 可能是特定领域术语，由于缺乏背景信息，按原文保留）

15707
11:08:34,276 --> 11:08:38,240
好，我们存储了那个，存储了梯度

15708
11:08:36,520 --> 11:08:39,916
因为那里有临时的坡度

注：你提供的文本不太完整，这是结合字面意思进行的翻译。 

15709
11:08:38,240 --> 11:08:42,400
之后不需要它，我们现在就需要它。

15710
11:08:39,916 --> 11:08:45,640
目前根据那个计算输出尺寸（dout），并且

15711
11:08:42,400 --> 11:08:49,840
然后我们使用 D 输出 d

15712
11:08:45,640 --> 11:08:55,720
鲁出去呃，过会儿，然后我们基本上就走

15713
11:08:49,840 --> 11:08:58,480
为了计算 W1，我们进行 x1。t 乘以 d r 得出结果 

15714
11:08:55,720 --> 11:09:00,360
好的，那么进行转置，所以 A 转置成 B，那就是

15715
11:08:58,480 --> 11:09:06,080
这将会变成什么样

注：原英文句子表述不太完整规范，通常可能想说 “What this is going to be” 之类的，但按照要求直接翻译原内容呈现如上结果。 

15716
11:09:00,360 --> 11:09:10,720
你提供的内容 “be a tore B we go input” 可能并不是一个正确、有意义的英文表达，可能存在拼写错误。不过按照原文翻译为：
成为一个撕裂的 B 我们去输入 

15717
11:09:06,080 --> 11:09:13,000
那么，呃，输入 X1，将其转置，然后乘以 D

15718
11:09:10,720 --> 11:09:15,560
将数值输出并把它存储在……我们（这里表述不太完整通顺，原文可能存在语病） 

15719
11:09:13,000 --> 11:09:18,720
太棒了一个
注：这里“one awesome”表述不太常见和规范，“awesome”常见作形容词“棒的、令人惊叹的”，若“one”指数量“一个”，这样的搭配表意不太清晰，推测可能想表达“一个很棒的……” ，但根据指令仅按原文进行了翻译。 

15720
11:09:15,560 --> 11:09:23,960
像往常一样进行偏置反向传播，所以我们只是

15721
11:09:18,720 --> 11:09:27,040
有呃，偏差本身，嗯，然后

15722
11:09:23,960 --> 11:09:30,720
那个，那个正在流动的，呃，流动着的

15723
11:09:27,040 --> 11:09:33,320
从右边开始，所以不管怎样，就是不管什么……

15724
11:09:30,720 --> 11:09:35,000
嗯，不管前一层的梯度是什么

15725
11:09:33,320 --> 11:09:38,200
那只是会直接流动吗

15726
11:09:35,000 --> 11:09:40,720
陷入偏见，对吧，因为，嗯，你知道的

15727
11:09:38,200 --> 11:09:42,436
添加 添加 并不会 呃 改变这个

15728
11:09:40,720 --> 11:09:44,520
某事物的梯度，它只是在变化

15729
11:09:42,436 --> 11:09:47,360
类似的位置，它的偏移量，但是

15730
11:09:44,520 --> 11:09:48,596
坡度保持不变，嗯，但没错

15731
11:09:47,360 --> 11:09:51,080
那 那简直就是倒退

15732
11:09:48,596 --> 11:09:53,080
还不算太糟，本来可能会更糟的 

15733
11:09:51,080 --> 11:09:54,916
有点难以跟上我的……我的（这里原文“my my”表述不太准确，可能存在信息缺失）

15734
11:09:53,080 --> 11:09:58,560
你不断出局，这或许会……

注：你提供的英文原句可能存在拼写错误，正常应该是 “If you're out constantly it might have...” 之类的表述，以上翻译是基于现有内容进行的处理。 

15735
11:09:54,916 --> 11:10:01,960
把你弄糊涂了，但呃，对，就是这样。

15736
11:09:58,560 --> 11:10:05,040
差不多就是这样，然后在，嗯，里面

15737
11:10:01,960 --> 11:10:08,560
是的，里面，所以那是反的。

15738
11:10:05,040 --> 11:10:10,160
然后在这之后进行反向操作，接着我们做……

15739
11:10:08,560 --> 11:10:11,960
更新权重，然后我们打印一些内容

15740
11:10:10,160 --> 11:10:13,200
出去，所以让我们只关注…… 

15741
11:10:11,960 --> 11:10:14,640
在这里更新权重
别 别担心

15742
11:10:13,200 --> 11:10:16,240
关于其余部分，你可以进行解析。

15743
11:10:14,640 --> 11:10:17,840
这得靠你自己 我们真正在乎的是……
（原句似乎不太完整表意不太明确，以上按现有内容翻译） 

15744
11:10:16,240 --> 11:10:19,720
关于的是实际的学习机制

15745
11:10:17,840 --> 11:10:22,320
没错，你可以把任何东西打印出来。

15746
11:10:19,720 --> 11:10:24,040
你想在哪天做都很容易，嗯，但是

15747
11:10:22,320 --> 11:10:25,640
我们关心的是实际的机制是什么

15748
11:10:24,040 --> 11:10:28,756
是

15749
11:10:25,640 --> 11:10:31,000
在这里，所以如果我去更新权重，我们

15750
11:10:28,756 --> 11:10:34,276
传入神经网络结构体，对吧

15751
11:10:31,000 --> 11:10:37,436
指向我们访问的那个（对象），我们要经过（它）

15752
11:10:34,276 --> 11:10:39,480
这里的每一个人，而且说真的，我们只是

15753
11:10:37,436 --> 11:10:41,000
嗯，我们只是做着同样的事情，如此隐秘

15754
11:10:39,480 --> 11:10:45,436
大小乘以输入大小，所以那将会是

15755
11:10:41,000 --> 11:10:48,880
呃，你知道的，784 乘以 256，那就是…… 

15756
11:10:45,436 --> 11:10:50,160
权重一 我们 我们遍历每个

15757
11:10:48,880 --> 11:10:51,640
索引 记住，这是安排好的

15758
11:10:50,160 --> 11:10:54,560
在内存中依次排列，所以这就要开始…… 

15759
11:10:51,640 --> 11:10:56,360
计算 784 除以 256 的结果是多少

15760
11:10:54,560 --> 11:10:57,400
那是一个很大的值，马上就要…… 

15761
11:10:56,360 --> 11:10:59,916
在内存中对其进行迭代，它是

15762
11:10:57,400 --> 11:11:03,596
要把这些台词过一遍，还是就这个（台词情况继续） 

15763
11:10:59,916 --> 11:11:05,320
直的东西，而且它就会去做

15764
11:11:03,596 --> 11:11:06,916
学习率乘以任意梯度值

15765
11:11:05,320 --> 11:11:09,916
曾经，然后它将进行减法运算等于

15766
11:11:06,916 --> 11:11:11,436
把那个累积成，嗯，权重，一是它是

15767
11:11:09,916 --> 11:11:14,116
要对重量做同样的事

15768
11:11:11,436 --> 11:11:16,400
两个要记住的权重，两个是，嗯，输出

15769
11:11:14,116 --> 11:11:21,200
尺寸乘以隐藏尺寸，所以是隐藏尺寸

15770
11:11:16,400 --> 11:11:24,560
256输出尺寸为10微米，偏置隐藏

15771
11:11:21,200 --> 11:11:27,520
二号尺码售罄

15772
11:11:24,560 --> 11:11:29,520
尺寸非常

15773
11:11:27,520 --> 11:11:31,200
直截了当，差不多就是这样

15774
11:11:29,520 --> 11:11:34,360
它；这；那；这个；那个；其

15775
11:11:31,200 --> 11:11:36,800
嗯，让我们继续来训练这个。

15776
11:11:34,360 --> 11:11:39,160
事情，所以回到上面，让我来做一下

15777
11:11:36,800 --> 11:11:42,680
当然，这些都已安排妥当。

15778
11:11:39,160 --> 11:11:44,720
没错，我们会做256个，当然，我们会做的

15779
11:11:42,680 --> 11:11:46,040
批量大小为四，这对学习来说没问题

15780
11:11:44,720 --> 11:11:49,436
比率；速率；等级；价格；费用；评估；估价；给……定级；值得；被评价

注：“rate”含义丰富，需结合具体语境准确理解，以上为常见释义。 

15781
11:11:46,040 --> 11:11:50,480
0.01，这也没关系，我们来设置 theox（此处“theox”可能是特定术语，若有更准确信息可替换更合适译法）

15782
11:11:49,436 --> 11:11:54,160
到；向；朝

15783
11:11:50,480 --> 11:11:54,160
只要五个就更少了

15784
11:11:54,240 --> 11:11:59,436
多余的，或者我们实际上把它设置为…… 

15785
11:11:56,800 --> 11:12:04,400
把它调到三，为什么不呢，现在我们开始吧

15786
11:11:59,436 --> 11:12:05,640
进入这里，GCC Das o V1，然后是 V1 文档

15787
11:12:04,400 --> 11:12:08,320
我们要编译的是哪个文件

15788
11:12:05,640 --> 11:12:10,436
而且我们是为了链接数学做语言模型（LM），对吧，所以

15789
11:12:08,320 --> 11:12:12,916
在这里面我们处理 math.h 文件，我们

15790
11:12:10,436 --> 11:12:17,000
要让这个起作用，需要关联数学知识。

15791
11:12:12,916 --> 11:12:18,520
因为如果我们不马上（做这件事），嗯

15792
11:12:17,000 --> 11:12:19,960
未识别的对这些的引用是

注：原英文句子似乎表述不太完整或准确，以上翻译是按照字面内容进行的。 

15793
11:12:18,520 --> 11:12:21,400
所有的数学函数都是正确的，但如果我们

15794
11:12:19,960 --> 11:12:24,720
做；干；从事；执行；完成；算出；解答；制作；扮演；行；合适；愿意；要；需要；应该；足够；进展；发生；废寝忘食地工作；引起；使整洁；学习；研究；参观；游览；处理；惩罚；痛打；欺骗；说；写；创作；翻译；整理；烹调；算出；解答；走过；行驶；度过；从事；干；做；进行；执行；完成；算出；解答；制作；扮演；行；合适；愿意；要；需要；应该；足够；进展；发生；废寝忘食地工作；引起；使整洁；学习；研究；参观；游览；处理；惩罚；痛打；欺骗；说；写；创作；翻译；整理；烹调；算出；解答；走过；行驶；度过

（“do”在不同语境有不同含义，以上列出了常见释义，你可结合具体语境选择合适的释义。若它在完整句子中，翻译会更准确恰当。） 

15795
11:12:21,400 --> 11:12:26,640
LM，这会行得通的，我们可以去实施这个计划了，所以……

15796
11:12:24,720 --> 11:12:28,840
我们拿到了第一个，这是一份五份装的印刷品（这里“five printed”表述不太常规，可能需要结合具体语境确定更准确含义） 

15797
11:12:26,640 --> 11:12:33,240
我们的第一个趋势训练标签是五个

注：原文中“out”可能是“our”的拼写错误。 

15798
11:12:28,840 --> 11:12:34,916
正如我们在这里看到的，然后是 04 1 9 2 1 31 4

15799
11:12:33,240 --> 11:12:37,916
我们可以看到准确率开始时 

15800
11:12:34,916 --> 11:12:41,276
嗯，损失大约是2.3。

15801
11:12:37,916 --> 11:12:44,640
这呃，就像我们所预期的那样随意。

15802
11:12:41,276 --> 11:12:46,840
所以 2.3 对应的准确率约为 10%

15803
11:12:44,640 --> 11:12:49,960
并且我们可以通过第一个看到这一点

15804
11:12:46,840 --> 11:12:51,520
它经历了2个200个隐藏状态（HS）的轮次，并且我们

15805
11:12:49,960 --> 11:12:54,200
可以看到那个

15806
11:12:51,520 --> 11:12:56,240
准确率可达约 60%，这是

15807
11:12:54,200 --> 11:12:58,720
实实在在的右侧亏损正在出现

15808
11:12:56,240 --> 11:13:00,360
向下，然后在接下来的那个里它看到，哦

15809
11:12:58,720 --> 11:13:01,916
天哪，等等，我们已经看过这些样品了。

15810
11:13:00,360 --> 11:13:04,000
之前，而且它甚至还会下降

15811
11:13:01,916 --> 11:13:06,720
此外，它将降至088，并且

15812
11:13:04,000 --> 11:13:08,680
准确率会大幅提升，你知道的，会提升15%

15813
11:13:06,720 --> 11:13:10,840
因为它已经见过这些样本了

15814
11:13:08,680 --> 11:13:12,640
在，嗯，然后它会那样做。

15815
11:13:10,840 --> 11:13:16,480
再次，它将上升到

15816
11:13:12,640 --> 11:13:20,916
86%，最后我们得到大约88 8.6%

15817
11:13:16,480 --> 11:13:25,200
嗯，这里，呃，是的，我是说你可以

15818
11:13:20,916 --> 11:13:28,916
始终打印出结尾样本

15819
11:13:25,200 --> 11:13:30,480
如果你真的想的话，嗯，你可以的

15820
11:13:28,916 --> 11:13:33,116
总是多打印出一些样本来

15821
11:13:30,480 --> 11:13:35,840
就像它，嗯，它是如何匹配的那样

15822
11:13:33,116 --> 11:13:39,960
那些……嗯，但我们会注意到

15823
11:13:35,840 --> 11:13:42,116
在我们的，呃，在我们的 CUDA 文件里，所以，呃

15824
11:13:39,960 --> 11:13:43,840
不管怎样，要理解这些内容可真不容易啊。 

15825
11:13:42,116 --> 11:13:46,276
那里，但那就是那个C文件，就是这样

15826
11:13:43,840 --> 11:13:47,640
我们从NumPy进行转换，看看情况并非如此

15827
11:13:46,276 --> 11:13:49,436
实际上，那样疯狂的一跳它是…… 

15828
11:13:47,640 --> 11:13:52,160
主要只是在编写算法，你呢

15829
11:13:49,436 --> 11:13:53,640
通过艰难的方式才明白 嗯 而且有点

15830
11:13:52,160 --> 11:13:55,756
对事物更加留意，对吧，这是…… 

15831
11:13:53,640 --> 11:13:57,436
很容易遇到问题，但只要

15832
11:13:55,756 --> 11:13:59,436
由于我们对事情很谨慎，它 

15833
11:13:57,436 --> 11:14:02,000
应该不会太糟
咱们去跳吧

15834
11:13:59,436 --> 11:14:03,720
现在进入CUDA 好了 好了 各位 那么这个

15835
11:14:02,000 --> 11:14:05,720
是这门课程的最后几个部分之一

15836
11:14:03,720 --> 11:14:07,960
实际上，这部分，这一部分是

15837
11:14:05,720 --> 11:14:09,960
旨在成为 旨在成为一个

15838
11:14:07,960 --> 11:14:11,800
稍微短一点，所以这是为了……而设计的（这里原句不完整，“designed to”后面应该还有内容）

15839
11:14:09,960 --> 11:14:14,200
给你某种类型的一个模板用于

15840
11:14:11,800 --> 11:14:16,240
接着说，这是最终项目

15841
11:14:14,200 --> 11:14:18,200
好吧，呃，我不会给你

15842
11:14:16,240 --> 11:14:19,840
立刻得到所有答案，这是……的一部分

15843
11:14:18,200 --> 11:14:21,680
你的工作是独自把这件事弄清楚。

15844
11:14:19,840 --> 11:14:23,720
拥有并使用我们所开发的成果

15845
11:14:21,680 --> 11:14:29,400
事先进行持续和优化

15846
11:14:23,720 --> 11:14:34,480
性能再往右调，所以我有这个

15847
11:14:29,400 --> 11:14:37,000
嗯，我这儿正好有个简单的GPU文件。

15848
11:14:34,480 --> 11:14:39,160
呃，或者抱歉，是在Cuda里的文件夹，所以我们

15849
11:14:37,000 --> 11:14:39,160
走；去；出发

注：“go”常见释义有“走；去；出发；变得；发出…声音；（时间）过去；（事情）进展”等，具体含义需结合语境确定。此处按照一般常见意思翻译。 

15850
11:14:39,276 --> 11:14:45,596
我们去，嗯，去 Cuda 目录

15851
11:14:43,640 --> 11:14:49,160
然后我们切换到 n 目录

15852
11:14:45,596 --> 11:14:50,880
看看这里的内部，嗯，你要去…… 

15853
11:14:49,160 --> 11:14:52,596
要找到这个文件，这个视图中的这一个，对，我…… 

15854
11:14:50,880 --> 11:14:54,436
就把这个当作不同版本，这样你就…… 

15855
11:14:52,596 --> 11:14:57,160
我之后能更新更多版本吗？

15856
11:14:54,436 --> 11:14:59,916
如果在未来的CUDA中出现了某些故障，呃

15857
11:14:57,160 --> 11:15:01,680
发布之类的，但嗯，是的，所以这个

15858
11:14:59,916 --> 11:15:05,520
本质上只是一个直接的移植自……的版本 

15859
11:15:01,680 --> 11:15:08,680
我们的 C 文件，所以实际上我们所做的一切

15860
11:15:05,520 --> 11:15:10,080
在这里，我们加载同样的东西，嗯

15861
11:15:08,680 --> 11:15:12,360
我们以同样的方式进行初始化，一切皆如此。

15862
11:15:10,080 --> 11:15:14,276
如你所见，这些都是在中央处理器（CPU）上完成的

15863
11:15:12,360 --> 11:15:17,720
我们实际改变的只有



15864
11:15:14,276 --> 11:15:19,200
凯尔说得对，这样我们就能看到那口井了。

15865
11:15:17,720 --> 11:15:22,756
但不仅仅只有马帕尔果仁



15866
11:15:19,200 --> 11:15:25,400
你可以看到，所以我们有这个MMAL A和B

15867
11:15:22,756 --> 11:15:27,480
嗯，所以这……这不是

15868
11:15:25,400 --> 11:15:30,200
转置了，呃，然后这是 B

15869
11:15:27,480 --> 11:15:31,596
转置，然后这是一个转置后的（矩阵等，结合具体语境确定所指事物） 

15870
11:15:30,200 --> 11:15:33,680
好的，那么当我们进行反向操作时

15871
11:15:31,596 --> 11:15:35,800
通过，并且我们需要转置某些（东西）

15872
11:15:33,680 --> 11:15:37,160
价值观 呃，那就是我们要用它来做的事

15873
11:15:35,800 --> 11:15:39,116
好的，所以我们有某些内核，它们…… （这里原文似乎不完整） 

15874
11:15:37,160 --> 11:15:41,840
专门为此（设立、准备等，需结合上下文确定准确含义），而且实际上我们可以

15875
11:15:39,116 --> 11:15:44,520
看，基于这里的索引方案

15876
11:15:41,840 --> 11:15:47,080
嗯，就像注意到我们是如何对 N 进行迭代的那样

15877
11:15:44,520 --> 11:15:48,116
每一次，除了这一次

15878
11:15:47,080 --> 11:15:49,640
这一个有点不同，这一个

15879
11:15:48,116 --> 11:15:53,680
是 M

15880
11:15:49,640 --> 11:15:55,640
但是，如果我们走进这里，我们可以看到一个

15881
11:15:53,680 --> 11:15:57,080
这只是普通的那种，对吧，那么开始排（行/列等，需结合具体语境确定“row”意思） 

15882
11:15:55,640 --> 11:16:01,960
*

15883
11:15:57,080 --> 11:16:05,596
n u 加上 I，然后如果我们看这个

15884
11:16:01,960 --> 11:16:07,880
B 它是 I * k + 列 右侧，并且这是

15885
11:16:05,596 --> 11:16:10,436
不同，所以注意这个字母 a 是如何保持……（原英文句子似乎不完整） 

15886
11:16:07,880 --> 11:16:12,160
同样的情况，但因为我们正在改变 B 以及

15887
11:16:10,436 --> 11:16:14,560
让它转置这部分，这个

15888
11:16:12,160 --> 11:16:20,960
索引更改，对吧，然后还是一样的情况

15889
11:16:14,560 --> 11:16:24,400
这里的想法是，呃，我们只是对矩阵 A 进行转置，所以

15890
11:16:20,960 --> 11:16:27,880
这部分我用 I K，然后是第 i k 列，以及

15891
11:16:24,400 --> 11:16:30,360
然后是列，嗯，这部分将……

15892
11:16:27,880 --> 11:16:33,436
有所不同，对吧。所以，我不用第N行，而是…… 

15893
11:16:30,360 --> 11:16:33,436
是 I N

15894
11:16:33,560 --> 11:16:40,000
划船以及

15895
11:16:36,520 --> 11:16:41,720
呃，是的，那些基本上就是……

15896
11:16:40,000 --> 11:16:43,116
重大改变
我们这样做的原因

15897
11:16:41,720 --> 11:16:46,400
为了；因为；对于；至于；适合于

15898
11:16:43,116 --> 11:16:49,596
嗯，我们这样做是因为 A 是……

15899
11:16:46,400 --> 11:16:51,080
转置的 um 以及 并且 m 是 m 是一个

15900
11:16:49,596 --> 11:16:52,596
有点不同，但这些是，这些是

15901
11:16:51,080 --> 11:16:55,720
简单的内核，我期望你能够（做到）

15902
11:16:52,596 --> 11:16:58,960
剖析这些，但如果我们继续深入下去

15903
11:16:55,720 --> 11:17:00,596
我们有……我们有我们的偏见，呃，我们

15904
11:16:58,960 --> 11:17:04,200
有一个Softmax核，所以这就要开始了

15905
11:17:00,596 --> 11:17:05,720
进行一次softmax（归一化指数函数）输出，呃，也就是一个…… 

15906
11:17:04,200 --> 11:17:07,276
每一批次的分配情况

15907
11:17:05,720 --> 11:17:09,680
元素，所以它将垂直移动

15908
11:17:07,276 --> 11:17:12,640
向下，每一根线都将…… 

15909
11:17:09,680 --> 11:17:12,640
做一个 一个（原文“do a a”表述有误，推测可能是有拼写错误，但按要求进行了字面翻译）

15910
11:17:13,080 --> 11:17:16,756
现在我们用……来校准我们的大梯度

注：原文“row”可能是“now”的拼写错误，此翻译是按照修正推测后的理解进行的。 

15911
11:17:15,276 --> 11:17:18,560
这个简单的内核，所以它只会

 

15912
11:17:16,756 --> 11:17:20,080
走吧，你知道它会成功的（这里 “go through” 可根据具体语境理解为“成功、顺利通过”等意思 ，需结合上下文确定更准确含义 ） 

15913
11:17:18,560 --> 11:17:23,756
每一个值，然后将其设置为

15914
11:17:20,080 --> 11:17:26,916
零 嗯 可能比内存设置函数（memset）更快 我是说

15915
11:17:23,756 --> 11:17:29,400
不确定，但然后我们有我们的 D

15916
11:17:26,916 --> 11:17:35,000
核，所以这仅仅是……的导数

15917
11:17:29,400 --> 11:17:37,956
你逐元素地将梯度相乘。

注：原文中 “Ru” 可能是 “You” 的拼写错误。 

15918
11:17:35,000 --> 11:17:39,276
梯度的乘法，我们可以

15919
11:17:37,956 --> 11:17:42,916
见是；看是

注：“see is”这样的表述不太符合常见的英语表达习惯，可能是不完整的内容。 

15920
11:17:39,276 --> 11:17:46,720
在这里用于乘法运算

15921
11:17:42,916 --> 11:17:46,720
梯度和这个函数

15922
11:17:47,240 --> 11:17:52,560
在这里被使用，呃，在这里被使用，所以当……

15923
11:17:49,560 --> 11:17:55,436
当我们在做我们的“吕”（Rue可能是人名、特定事物名等，需结合上下文准确理解）相关事情时，我们在尽自己所能。

注：由于“Rue”含义不明，这里翻译只能根据字面推测，你可补充更多背景信息让翻译更精准。 

15924
11:17:52,560 --> 11:17:59,480
嗯，当我们在进行我们实际的，呃

15925
11:17:55,436 --> 11:18:01,436
我们正在经过 D 区，而且我们需要，嗯

15926
11:17:59,480 --> 11:18:04,720
将那些数值相乘，这有点像是在

注：此英文句子不完整，翻译可能无法完全准确表达其确切含义。 

15927
11:18:01,436 --> 11:18:05,756
明白我们为什么要把那个放在那里 嗯

15928
11:18:04,720 --> 11:18:08,276
回去；返回

请注意，“going back”单独成句表意不太完整，更可能是“正在回去、正在返回”这样的意思，若它处于具体语境中意思可能会有不同。 

15929
11:18:05,756 --> 11:18:12,560
好了，我们只有前锋了，所以 

15930
11:18:08,276 --> 11:18:15,560
典型的 A * B 我不知道为什么这是 T

15931
11:18:12,560 --> 11:18:15,560
嗯

15932
11:18:16,720 --> 11:18:22,956
好的

15933
11:18:18,436 --> 11:18:22,956
嗯，宾（Bim 可能是名字，也可能是某个特定事物）完全不工作了。 

15934
11:18:25,400 --> 11:18:32,800
对，然后我们只进行一次机器学习操作，再加上偏差项

15935
11:18:28,916 --> 11:18:34,956
然后添加一个偏置项，接着进行softmax操作，对，非常……

（注：原英文句子似乎表述不太完整和规范，以上翻译是尽量按字面进行的） 

15936
11:18:32,800 --> 11:18:37,640
简单的交叉熵损失将是

15937
11:18:34,956 --> 11:18:40,240
在主机上完成，我们将进行计算

15938
11:18:37,640 --> 11:18:41,840
我们在 GPU 上的输出梯度，因为

15939
11:18:40,240 --> 11:18:43,640
实际上将会有一个

15940
11:18:41,840 --> 11:18:45,720
当你……的时候，你们很多人都得考虑

注：原英文句子不完整，此翻译是基于现有内容进行的。 

15941
11:18:43,640 --> 11:18:47,560
实际上在写，凯尔，你就像在问“是什么”

15942
11:18:45,720 --> 11:18:50,916
实际上，它到底有多有用呢？

15943
11:18:47,560 --> 11:18:54,160
去写你自己的，呃，实际上，去……

15944
11:18:50,916 --> 11:18:56,520
写下你自己的内容，比如像这样

15945
11:18:54,160 --> 11:18:59,040
其一，我们或许能把这个转化为中央处理器（CPU）。

15946
11:18:56,520 --> 11:19:01,000
而且它可能会更快，但谁知道呢，嗯

15947
11:18:59,040 --> 11:19:02,680
这里的这种想法就像是如果你

15948
11:19:01,000 --> 11:19:04,800
如果有重大更新，就来个大的（更新）吧 

15949
11:19:02,680 --> 11:19:07,400
去做类似更新为渐变效果的事，而且你

15950
11:19:04,800 --> 11:19:09,596
有这些巨大的，嗯，你有这些

15951
11:19:07,400 --> 11:19:11,956
你试图处理的巨大的 W 矩阵

注：原英文句子未完整，这里根据一般理解进行了“补充性”的翻译处理，以让句子更通顺。若有上下文，请提供以便更精准翻译。 

15952
11:19:09,596 --> 11:19:14,116
更改和修改，然后开启一个线程

15953
11:19:11,956 --> 11:19:16,320
去做每一件小事 呃 去做每一件小事

15954
11:19:14,116 --> 11:19:18,400
像点更新将有助于加快那件事

15955
11:19:16,320 --> 11:19:20,400
向上，但如果你只是想达到一个 B 的水平

15956
11:19:18,400 --> 11:19:21,520
例如乘以 10，这就是这里所做的事情

15957
11:19:20,400 --> 11:19:23,240
你或许只靠……就能侥幸成功

15958
11:19:21,520 --> 11:19:25,080
在CPU上以极快的速度进行这项操作，并且你会

15959
11:19:23,240 --> 11:19:26,680
你会没事的，呃，因为就像……

15960
11:19:25,080 --> 11:19:28,560
当你必须……时的内核启动开销

15961
11:19:26,680 --> 11:19:30,320
真的，必须要启动这个。

15962
11:19:28,560 --> 11:19:32,436
告诉图形处理器（GPU）要做什么，然后它会

（注：原句不完整，根据现有内容只能翻译到这里） 

15963
11:19:30,320 --> 11:19:35,320
触发一堆线程去…… 

15964
11:19:32,436 --> 11:19:37,520
正确执行那个，嗯，然后在我们的……（这里“in our”后面似乎内容不完整）

15965
11:19:35,320 --> 11:19:38,360
反向传播时，我们将梯度置零

15966
11:19:37,520 --> 11:19:40,240
以确保他们不是

15967
11:19:38,360 --> 11:19:42,916
积累并给我们，你知道的，各种组合

15968
11:19:40,240 --> 11:19:45,200
信号

15969
11:19:42,916 --> 11:19:47,276
嗯，我们有我们的

15970
11:19:45,200 --> 11:19:49,520
呃，计算，计算输出梯度，所以

15971
11:19:47,276 --> 11:19:52,360
那基本上将会是那个……（此处原文不完整，句子表意未明确） 

15972
11:19:49,520 --> 11:19:54,080
这些是输出概率减去……（这里文本不完整）

15973
11:19:52,360 --> 11:19:57,596
真实标签

15974
11:19:54,080 --> 11:20:02,800
对，然后我们有我们的……一个……

15975
11:19:57,596 --> 11:20:05,160
转置乘以 B，所以我们回到这里

15976
11:20:02,800 --> 11:20:09,640
嗯，这个，这个

15977
11:20:05,160 --> 11:20:11,640
dw2 对，我们更新，嗯，我们更新

15978
11:20:09,640 --> 11:20:13,756
偏置 2 的梯度，所以有特定的

15979
11:20:11,640 --> 11:20:15,360
现在回想一下，当我们……的时候，其核心是

15980
11:20:13,756 --> 11:20:17,276
发射这些，就是它了，看起来好像

15981
11:20:15,360 --> 11:20:20,080
有很多事情需要梳理，但实际上

15982
11:20:17,276 --> 11:20:21,840
所有这些不过是在回顾之前的情况

15983
11:20:20,080 --> 11:20:25,880
我们采用的那种技巧，就好像是你……你…… 

15984
11:20:21,840 --> 11:20:28,320
得启动，嗯，这么说吧，要是你有1.25 

15985
11:20:25,880 --> 11:20:29,520
元素，而且通常情况下你只会做

15986
11:20:28,320 --> 11:20:32,640
嗯，就像

15987
11:20:29,520 --> 11:20:35,160
1024 呃，线程，所以你要做的是

15988
11:20:32,640 --> 11:20:38,200
你再添加一个额外的方块，对吧

15989
11:20:35,160 --> 11:20:39,880
用一个 用一个嗯 用一个

15990
11:20:38,200 --> 11:20:42,680
它里面的线程，或者，或者仅仅是，或者

15991
11:20:39,880 --> 11:20:45,400
通常来说，你可以说还有另一部分 

15992
11:20:42,680 --> 11:20:47,000
而且既然你有了那些界限之类的东西

15993
11:20:45,400 --> 11:20:49,276
那个用于检查是否……的小 if 语句

15994
11:20:47,000 --> 11:20:51,080
一切都是值得的，以至于它又不值得了。 

15995
11:20:49,276 --> 11:20:53,200
就像从那些矩阵中出来那样

15996
11:20:51,080 --> 11:20:55,720
你正在和类似外部的事物打交道

15997
11:20:53,200 --> 11:20:56,880
在那段记忆之外，嗯，然后你可以

15998
11:20:55,720 --> 11:20:58,160
那 这本质上就是这么回事

15999
11:20:56,880 --> 11:21:01,436
没错，所以我们只是在小心处理关于……的事情 

16000
11:20:58,160 --> 11:21:02,880
我们该如何推出这些东西，嗯，没错。

16001
11:21:01,436 --> 11:21:05,436
这这要追溯到你知道的（某个情况）

16002
11:21:02,880 --> 11:21:08,560
第五章，关于核，对吧

16003
11:21:05,436 --> 11:21:10,160
那么，呃，这些启动配置可以

16004
11:21:08,560 --> 11:21:12,436
真的会把你搞得一团糟，让事情变得…… 

16005
11:21:10,160 --> 11:21:13,596
看起来比实际情况更复杂，但是

16006
11:21:12,436 --> 11:21:17,200
如果你能大致看一下这个

16007
11:21:13,596 --> 11:21:19,116
一次处理一位，你有，呃，你

16008
11:21:17,200 --> 11:21:21,596
有点喜欢这种网格大小，抱歉，那个…… 

16009
11:21:19,116 --> 11:21:23,520
网格维度和块维度，对吧，还有……

16010
11:21:21,596 --> 11:21:25,680
这就是你真正要处理的全部内容了

16011
11:21:23,520 --> 11:21:28,560
然后，当然，那些支持……的论据（此处文本不完整，“for”后面应有内容） 

16012
11:21:25,680 --> 11:21:28,560
内核启动

16013
11:21:32,480 --> 11:21:41,200
它本身更多的是毫摩尔，对吧，回到……

16014
11:21:36,200 --> 11:21:44,640
这里，这次，所以它是一个 * B

16015
11:21:41,200 --> 11:21:46,276
转置 a 乘以 B 的转置

16016
11:21:44,640 --> 11:21:47,916
呃，然后在这里面我们只需要做我们的…… 

16017
11:21:46,276 --> 11:21:49,756
我们只需沿着我们的……往后走

注：原英文 “our ra” 可能存在拼写错误，正常应该有完整词汇，这里按原文逐词直译。 

16018
11:21:47,916 --> 11:21:51,436
功能，这一切都非常接近…… （这里“function”在原句中的表意不太明确，要结合更完整的语境准确理解它可能代表的含义） 

16019
11:21:49,756 --> 11:21:55,916
我们的 C 文件，就好像它只是在运行而已。

16020
11:21:51,436 --> 11:21:57,720
同时，对吧，嗯，这里也是同样的思路，我……

16021
11:21:55,916 --> 11:22:00,320
只是打算再往下去一点

16022
11:21:57,720 --> 11:22:02,520
更新我们的权重，嗯，你知道的，这是

16023
11:22:00,320 --> 11:22:02,520
善良的；友好的；和蔼的；宽容的；客气请求或命令
种类；类型

16024
11:22:12,360 --> 11:22:16,596
我想我有两个这样的东西

16025
11:22:15,320 --> 11:22:18,956
我们正在使用……吗？

注：原英文句子不完整，这里按常规语境给出大致翻译。 

16026
11:22:16,596 --> 11:22:23,360
这让我

16027
11:22:18,956 --> 11:22:26,520
看，是的，我们在用那个，但是

16028
11:22:23,360 --> 11:22:28,956
这一次更新

16029
11:22:26,520 --> 11:22:31,000
渐变 是的 那也没问题 所以 所以

16030
11:22:28,956 --> 11:22:33,000
这些是不同的事情，对吧？是的，所以

16031
11:22:31,000 --> 11:22:35,480
更新梯度，那是为了……

16032
11:22:33,000 --> 11:22:37,200
偏差以及用于此的更新权重

16033
11:22:35,480 --> 11:22:40,080
嗯，实际上那就是梯度所在之处

16034
11:22:37,200 --> 11:22:44,880
下降本身就会发生

16035
11:22:40,080 --> 11:22:44,880
嗯，然后在这个循环里面

16036
11:22:46,400 --> 11:22:50,320
我们要进行呃初始化我们的…… 

16037
11:22:48,640 --> 11:22:53,040
设备训练集，所以当你有……

16038
11:22:50,320 --> 11:22:55,080
这个 D 前缀，记住，它代表设备。

16039
11:22:53,040 --> 11:22:58,480
嗯，你知道的，Y是标签，训练是…… 

16040
11:22:55,080 --> 11:23:00,240
训练集 我们 可以 称呼 所有那些 我们 记忆中的（这里原文可能存在拼写错误，推测“C AAL”可能是“can call” ，“mem”可能是“remember”等词的不完整形式 ）

16041
11:22:58,480 --> 11:23:02,276
把它们复制到设备上，因为它们是

16042
11:23:00,240 --> 11:23:04,200
在主机上初始化为指针，并且

16043
11:23:02,276 --> 11:23:07,640
我们必须带着敬意把那些复制过来。

16044
11:23:04,200 --> 11:23:09,520
将它们的内存地址传送到设备

16045
11:23:07,640 --> 11:23:11,000
嗯，然后在这边我们只是

16046
11:23:09,520 --> 11:23:12,640
遍历我们所需的所有轮次

16047
11:23:11,000 --> 11:23:16,160
在这种情况下要做的事是在……处进行定义

16048
11:23:12,640 --> 11:23:18,320
顶部，然后是批次数量，对吧，并且

16049
11:23:16,160 --> 11:23:20,560
然后我们设定一个起始索引，我们来做

16050
11:23:18,320 --> 11:23:22,116
肯定会有点喜欢大步走的，所以我们

16051
11:23:20,560 --> 11:23:23,720
所以，不管我们现在处理的是哪一批（东西）

注：由于原文句子不太完整，这种翻译是根据有限内容尽量通顺表意。 

16052
11:23:22,116 --> 11:23:25,040
整个事物中的批次数量

16053
11:23:23,720 --> 11:23:27,320
我们实际上是通过进行（某种操作）来计算它的。

注：这里原文未完整，“doing”后面应该还有内容，“进行（某种操作）”是根据不完整原文的大致补充表述。 

16054
11:23:25,040 --> 11:23:30,000
训练集大小 除以批次的数量

16055
11:23:27,320 --> 11:23:32,560
规模，所以如果你有一万个训练样本…… 

注：原英文“a th 10,000”表述有误，推测可能是想表达“a 10,000” 。 

16056
11:23:30,000 --> 11:23:35,240
呃，示例以及批量大小为四

16057
11:23:32,560 --> 11:23:38,240
你将会有，呃，2500 批。

16058
11:23:35,240 --> 11:23:39,640
对，所以当你做的时候，嗯，无论做哪件事

16059
11:23:38,240 --> 11:23:41,200
一批，你在的地方，它即将前往（此处英文原句可能表述不太准确和完整，翻译可能不太符合常规逻辑）

16060
11:23:39,640 --> 11:23:45,080
尽管你知道它本质上正在发展

16061
11:23:41,200 --> 11:23:50,276
前往零，呃，三

16062
11:23:45,080 --> 11:23:50,276
嗯 0 3

16063
11:23:51,000 --> 11:23:59,080
7 11 它将每隔四个跳过

16064
11:23:56,160 --> 11:24:01,756
好的，我们进行前向传播，所以要保持

16065
11:23:59,080 --> 11:24:04,480
这个，呃，这个很简单，这个挺不错的小…… 

16066
11:24:01,756 --> 11:24:09,320
简洁的神经网络结构，正好与我们所有的……（原句不完整，此翻译仅供参考）

16067
11:24:04,480 --> 11:24:13,436
我们的梯度和我们的权重

16068
11:24:09,320 --> 11:24:17,000
好的，我们来计算……呃，我们算 C

16069
11:24:13,436 --> 11:24:19,640
本质上，这部分所做的是

16070
11:24:17,000 --> 11:24:22,956
我们正在计算损失
我们正在累加损失 

16071
11:24:19,640 --> 11:24:26,200
将其计入总运营亏损

16072
11:24:22,956 --> 11:24:26,200
……在哪里是
（注：此英文表述不符合正常语法，可能原文有误）

16073
11:24:27,436 --> 11:24:32,400
在这个层面上，我们有，我们进行初始化

16074
11:24:30,436 --> 11:24:34,080
轮次循环内的总损失

16075
11:24:32,400 --> 11:24:35,116
对，所以这是针对整个纪元的。

16076
11:24:34,080 --> 11:24:37,040
这就是为什么我们……这就是我们善良的原因

16077
11:24:35,116 --> 11:24:39,040
当我们加上损失的时候就是这么做的

16078
11:24:37,040 --> 11:24:40,640
我们只是在添加它，然后

16079
11:24:39,040 --> 11:24:42,116
我们，你知道的，会相应地进行划分。

16080
11:24:40,640 --> 11:24:45,116
所以我们只是在取平均值

16081
11:24:42,116 --> 11:24:49,756
整个轮次的损失

16082
11:24:45,116 --> 11:24:51,520
嗯，在这种情况下，我们实际上只是

16083
11:24:49,756 --> 11:24:55,116
就像我们在 C 文件里所做的那样，我们正在

16084
11:24:51,520 --> 11:24:56,640
只是，呃，加到正确的计数器里，所以

16085
11:24:55,116 --> 11:24:58,200
无论我们正确处理了多少个样本

16086
11:24:56,640 --> 11:25:01,360
就是那个百分比

16087
11:24:58,200 --> 11:25:03,240
进入反向传播时的准确率 我

16088
11:25:01,360 --> 11:25:05,000
已经经历过这个了，他们（原文“there”可能有误，推测为“they”）的意思是

16089
11:25:03,240 --> 11:25:06,320
你可以在某种程度上对所有这些进行筛选整理。

16090
11:25:05,000 --> 11:25:09,240
不同的

16091
11:25:06,320 --> 11:25:11,116
争论 呃 我们进行更新，我们做一次更新

16092
11:25:09,240 --> 11:25:14,436
我们每个人的权重

16093
11:25:11,116 --> 11:25:15,800
权重矩阵，嗯，所以它只是会……

16094
11:25:14,436 --> 11:25:19,200
本质元素

16095
11:25:15,800 --> 11:25:21,276
逐元素的 呃，它将是逐元素的

16096
11:25:19,200 --> 11:25:22,756
乘以，嗯，梯度乘以这个

16097
11:25:21,276 --> 11:25:25,840
学习率，而且它将会

16098
11:25:22,756 --> 11:25:27,756
将其累积到正上方的重量中

16099
11:25:25,840 --> 11:25:30,720
设备，然后在这里我们只是打印

16100
11:25:27,756 --> 11:25:33,040
一些有用的东西，就在这儿往下找

16101
11:25:30,720 --> 11:25:36,276
确保我们释放训练集

16102
11:25:33,040 --> 11:25:38,400
呃，我们得到的隐藏层输出和 D 输出

16103
11:25:36,276 --> 11:25:41,480
已初始化

16104
11:25:38,400 --> 11:25:43,720
在我们对……进行初始化之前

16105
11:25:41,480 --> 11:25:45,360
整个神经网络，所以基本上就是

16106
11:25:43,720 --> 11:25:47,800
做我们的

16107
11:25:45,360 --> 11:25:49,200
恶意初始化那些，以便每个

16108
11:25:47,800 --> 11:25:50,840
这些将被设置为类似随机的状态

16109
11:25:49,200 --> 11:25:53,116
价值观，或者在这种情况下，偏见正在……

16110
11:25:50,840 --> 11:25:56,160
将其设置为零，然后我们进行我们的

16111
11:25:53,116 --> 11:25:59,400
库达·马利克，所以我们，所以我们在……上分配

16112
11:25:56,160 --> 11:26:02,080
CPU 我们在 CPU 上初始化所有东西，我们

16113
11:25:59,400 --> 11:26:04,360
在我们要将所有东西移至的设备上进行分配

16114
11:26:02,080 --> 11:26:06,840
设备，嗯，然后我们就可以运行了。

16115
11:26:04,360 --> 11:26:11,276
对，然后在这种情况下，我们所需要做的就是……（这里句子未完整，按照意思应该还有下文）

16116
11:26:06,840 --> 11:26:15,360
要做的是，嗯，初始化这个神经网络（此处原文“neural”后可能缺失“network”之类的词） 

16117
11:26:11,276 --> 11:26:18,240
接下来我们用……用……用它来初始化它

16118
11:26:15,360 --> 11:26:22,640
带有随机数据的随机数据

16119
11:26:18,240 --> 11:26:27,756
数值 呃 然后我们加载我们整个的 呃

16120
11:26:22,640 --> 11:26:30,640
将训练集输入到，嗯，输入到主机中

16121
11:26:27,756 --> 11:26:32,680
记忆中，我们去训练一切，并且

16122
11:26:30,640 --> 11:26:34,800
等我们做完后，我们可以释放任何我们……（原文似乎不完整） 

16123
11:26:32,680 --> 11:26:37,240
需要在 CPU 上运行并释放我们所需的任何资源

16124
11:26:34,800 --> 11:26:39,800
在设备上进行，所以如果我继续并且

16125
11:26:37,240 --> 11:26:39,800
试运行一下这个

16126
11:26:42,276 --> 11:26:48,080
这里，B1

16127
11:26:45,080 --> 11:26:48,080
和好人一起可不太好跑（注：此英文表述不太符合常见表达习惯，这是按照字面的勉强翻译）

若原句可能是 “not going to run with the good” 之类更规范的表达，也可理解为 “不会和好人混在一起” 。具体需结合更多语境判断。如果后续还有疑问，你可以补充更多信息。 

16128
11:26:48,200 --> 11:26:52,560
老板如此反复无常，我曾是其成员。 

16129
11:26:50,880 --> 11:26:55,320
参考 别担心那个 一

16130
11:26:52,560 --> 11:26:59,680
警告
然后我们去运行这个，我们可以

16131
11:26:55,320 --> 11:27:02,040
看，呃，这列火车快得离谱，呃，我们

16132
11:26:59,680 --> 11:27:04,436
从呃，第一阶段开始，我们有三个

16133
11:27:02,040 --> 11:27:07,520
这里的轮次总数，每一轮做 2500 次

16134
11:27:04,436 --> 11:27:09,640
HS，我们得到的损失约为 2.3，这（此处句子不完整，可能还有后续内容来进一步说明“这”的情况）

16135
11:27:07,520 --> 11:27:12,560
正如我们所预期的，然后我们看到了

16136
11:27:09,640 --> 11:27:16,080
准确率提高至60%，然后它

16137
11:27:12,560 --> 11:27:18,560
变得更糟，它突然跳跃，径直上升到……去

16138
11:27:16,080 --> 11:27:23,040
高达约87%，然后甚至还会跃升

16139
11:27:18,560 --> 11:27:25,480
更高一些，最后我们能达到大约90%，对吧

16140
11:27:23,040 --> 11:27:27,480
所以那相当不错，而且我们可以，呃，我们

16141
11:27:25,480 --> 11:27:30,560
实际上可以和更大的海伊一起运行这个（这里“海伊”不确定“ Hye ”的准确所指，可根据实际情况调整） 

16142
11:27:27,480 --> 11:27:33,720
参数，这样我就可以继续代入计算了

16143
11:27:30,560 --> 11:27:36,436
10.24 在那里并使用更大的批量大小

16144
11:27:33,720 --> 11:27:39,840
也许大概八个，然后环氧乙烷是……

16145
11:27:36,436 --> 11:27:45,436
五，我们进来这里，整理好，然后出发

16146
11:27:39,840 --> 11:27:48,040
然后运行它，我们可以看到，嗯

16147
11:27:45,436 --> 11:27:51,276
嗯，这样就能获得更高的准确性，对吧？

16148
11:27:48,040 --> 11:27:52,640
现在甚至高达92%，所以这有点是怎么回事呢

16149
11:27:51,276 --> 11:27:54,480
这部分是什么呢，它叫做

16150
11:27:52,640 --> 11:27:56,720
理解一下，所以你明白了第一部分，在那里……（这里“grocking”疑似拼写错误，可能想表达“grasping” ） 

16151
11:27:54,480 --> 11:27:58,400
就是那种刚开始的感觉 

16152
11:27:56,720 --> 11:28:00,160
它的训练步骤，而且它有点……

16153
11:27:58,400 --> 11:28:01,480
弄清楚该推动哪些权重

16154
11:28:00,160 --> 11:28:02,840
正确的方向，然后你和

16155
11:28:01,480 --> 11:28:05,916
然后它把那个弄清楚了，接着它

16156
11:28:02,840 --> 11:28:08,436
暴跌，损失下降得非常快

16157
11:28:05,916 --> 11:28:10,080
这就是我们现在在这里所看到的情况。

16158
11:28:08,436 --> 11:28:13,560
损失大约是2.3，然后它是

16159
11:28:10,080 --> 11:28:17,436
1.72，然后轰地一下变成0.5，接着一直这样 

16160
11:28:13,560 --> 11:28:20,320
低至大约2.9，0.3嘛，然后

16161
11:28:17,436 --> 11:28:22,436
这里发生了什么
现在是吗
不，不是

16162
11:28:20,320 --> 11:28:24,160
现在再也不能使用那些简单的模式了

16163
11:28:22,436 --> 11:28:25,720
它已经识别出来了，现在它得…… 

16164
11:28:24,160 --> 11:28:27,240
寻找更多更难的内容

16165
11:28:25,720 --> 11:28:28,756
属性 可能会有某些图像

16166
11:28:27,240 --> 11:28:31,756
它真的很艰难

16167
11:28:28,756 --> 11:28:33,436
识别，而且必须，而且必须

16168
11:28:31,756 --> 11:28:35,880
你知道学习额外的东西，这（东西）…… 

16169
11:28:33,436 --> 11:28:37,596
需要更多的训练步骤来在……里做嗯

16170
11:28:35,880 --> 11:28:39,720
深入理解……的过程

16171
11:28:37,596 --> 11:28:42,756
数据集，或者对其进行泛化

16172
11:28:39,720 --> 11:28:45,360
那被称为深度理解，对吧

16173
11:28:42,756 --> 11:28:46,240
嗯，因此就有了格罗克语言模型，我当时…… 

16174
11:28:45,360 --> 11:28:50,276
使用；利用；运用；使用……的；以……作为手段

16175
11:28:46,240 --> 11:28:54,320
在……嗯，不过没错，所以如果我们走出……

16176
11:28:50,276 --> 11:28:56,756
这个，然后到，嗯，到这个这边来

16177
11:28:54,320 --> 11:28:58,276
这个 v 文件，我把它命名为 V 是因为它是

16178
11:28:56,756 --> 11:29:02,276
应该很快的，就是这一个

16179
11:28:58,276 --> 11:29:05,116
你之后应该要编辑的内容，前往

16180
11:29:02,276 --> 11:29:08,116
房间里，我正在做一些比较

16181
11:29:05,116 --> 11:29:10,000
在这里，但要把那些移除

16182
11:29:08,116 --> 11:29:12,400
比较和

16183
11:29:10,000 --> 11:29:13,840
比较一下，然后我们还有另一次比较

16184
11:29:12,400 --> 11:29:17,360
那个文件是试验性的，但我会

16185
11:29:13,840 --> 11:29:21,160
可能很快就会把那个移除，嗯，然后我们

16186
11:29:17,360 --> 11:29:23,680
进入另一个 v1c 里面的（这个表述在完整语义上可能不太清晰，需结合更多语境来准确理解）

16187
11:29:21,160 --> 11:29:25,956
房间文件以及这个

16188
11:29:23,680 --> 11:29:27,640
有一个和我们之前有的那个很接近

16189
11:29:25,956 --> 11:29:31,200
直到现在，我们实际上唯一的事情是……（此处原文似乎不完整） 

16190
11:29:27,640 --> 11:29:32,880
这里的改变是，不使用呃，而是在……

16191
11:29:31,200 --> 11:29:35,080
实际上，我们让这对你来说变得更容易了，所以

16192
11:29:32,880 --> 11:29:37,360
在过去的那个（情况）中，我们有点把它简化了。

16193
11:29:35,080 --> 11:29:39,080
并且拥有了所有的，并且有过，并且像那样做了

16194
11:29:37,360 --> 11:29:41,520
地图的呈现方式有点不同，在我们（所处）的地方 

16195
11:29:39,080 --> 11:29:43,436
在内核内部进行了转置，但在

16196
11:29:41,520 --> 11:29:45,240
这个例子，嗯，我们想把它做出来。

16197
11:29:43,436 --> 11:29:48,480
对你来说，直接插入你自己的代码会更容易些。

注：原句“easier for to”表述有误，推测完整表述可能是“easier for you to” 。 

16198
11:29:45,240 --> 11:29:50,756
进入这里并让它起作用，嗯，所以使用

16199
11:29:48,480 --> 11:29:52,240
你提供的内容中“sjem”可能并不是正确的英文单词，推测存在拼写错误，以下是按照原文呈现的翻译：
像sjem 那个 sjem Cuda

16200
11:29:50,756 --> 11:29:54,040
我们之前所做的优化



16201
11:29:52,240 --> 11:29:56,200
更快的MMAL章节，就像那就是你想要的（这里“mmal”可能是特定领域术语，需结合具体语境确定准确含义） 

16202
11:29:54,040 --> 11:29:57,480
会插在这里，对吧，嗯，你会有

16203
11:29:56,200 --> 11:30:01,080
你自己的内核，而且你会

16204
11:29:57,480 --> 11:30:03,240
启动它，然后从这里，嗯，接着

16205
11:30:01,080 --> 11:30:06,240
里面；内部

16206
11:30:03,240 --> 11:30:06,240
属于；关于；由……组成；因为；来自；在……之中

如果“of”是处于某个具体句子语境中，请你提供完整句子，以便我能更准确翻译。 

16207
11:30:07,680 --> 11:30:14,480
嗯，然后如果我进入里面的话

16208
11:30:11,840 --> 11:30:16,640
下方我们可以看到一个转置内核，上方

16209
11:30:14,480 --> 11:30:18,000
在那里，但如果我们进行反向传播

16210
11:30:16,640 --> 11:30:19,756
转发内容没有任何修改。

16211
11:30:18,000 --> 11:30:22,640
因为那里没有移调，但是

16212
11:30:19,756 --> 11:30:24,480
在反向传播过程中，我们可以看到

16213
11:30:22,640 --> 11:30:26,080
只有转置矩阵函数

16214
11:30:24,480 --> 11:30:27,520
右 转置 转置 转置

16215
11:30:26,080 --> 11:30:29,800
因为我们得做三次这个

16216
11:30:27,520 --> 11:30:32,160
我们得计算一下，呃，就是这个，这个

16217
11:30:29,800 --> 11:30:33,436
一个，还有这个，这里没有dx1，对吧，我们（此处原文表述不太符合常规完整句子语法逻辑，翻译尽量贴近原文表意） 

16218
11:30:32,160 --> 11:30:35,276
我们没必要这么做，那是多余的。

16219
11:30:33,436 --> 11:30:37,956
因为在它之前我们没有一层（结构/层面等，需结合上下文确定准确含义）。 

16220
11:30:35,276 --> 11:30:40,000
嗯，所以我们做三个，那种的三个

16221
11:30:37,956 --> 11:30:42,800
转位哺乳动物

16222
11:30:40,000 --> 11:30:45,840
操作等等，在这里，这简直是…… 

16223
11:30:42,800 --> 11:30:48,560
只是将其从列主序切换为

16224
11:30:45,840 --> 11:30:50,520
按行优先，它就做这么多，呃，它是

16225
11:30:48,560 --> 11:30:52,000
这里有一个很酷的小技巧

16226
11:30:50,520 --> 11:30:55,596
适用于它的自定义内核，你可以查看

16227
11:30:52,000 --> 11:30:55,596
如果你想

16228
11:30:56,800 --> 11:31:03,520
嗯，我们……它在哪里呢？

16229
11:31:00,480 --> 11:31:05,480
到这里来，所以有个转置操作

16230
11:31:03,520 --> 11:31:07,520
我们所说的矩阵函数，我们将其传入（这里表述似乎不太完整，原句表意可能不太明确）

16231
11:31:05,480 --> 11:31:08,720
这些设备将数据输入到它里面，然后

16232
11:31:07,520 --> 11:31:10,880
在这里面我们实际上会进行……（原文不完整，句子意思可能表述不全）

16233
11:31:08,720 --> 11:31:13,400
转置发射，并且我们确保

16234
11:31:10,880 --> 11:31:16,560
没有错误发生，并且我们进行同步

16235
11:31:13,400 --> 11:31:19,360
嗯，GPU 上的所有线程

16236
11:31:16,560 --> 11:31:21,520
没错，这就是真正的，呃，这……

16237
11:31:19,360 --> 11:31:24,240
是实际的跨（此处“trans”表意不明，可根据具体语境补充准确含义）呃 跨……的地方

16238
11:31:21,520 --> 11:31:27,320
转置会发生，嗯，这倒也不是太……

16239
11:31:24,240 --> 11:31:29,200
从概念上讲是糟糕的，嗯，但别……别

16240
11:31:27,320 --> 11:31:30,956
别太担心这个，更重要的是…… （由于原句不太完整，这里按合理逻辑稍作补充以表意通顺）

若原句没有上下文，也可直译为：
太担心这个了，更是如此 

16241
11:31:29,200 --> 11:31:32,160
担心你如何加快这个的速度

16242
11:31:30,956 --> 11:31:34,560
事物；东西；事情；事件

16243
11:31:32,160 --> 11:31:38,040
起来，这样我就可以去阿哈德那儿把这事办了

16244
11:31:34,560 --> 11:31:40,680
实际上，呃，就像我会在这里做出改变

16245
11:31:38,040 --> 11:31:43,240
实际上仅仅就是那个转置

16246
11:31:40,680 --> 11:31:46,720
哦，我……我在最上面有一些堪萨斯大学（KU）的东西，让…… 

16247
11:31:43,240 --> 11:31:46,720
我移除；我删除

（注：“me remove”单独看不是特别符合常见规范表达，可能有特定语境，若这是句子一部分可补充完整后重新让我翻译。） 

16248
11:31:50,720 --> 11:31:53,720
那个；那

16249
11:31:54,520 --> 11:31:58,320
布洛斯，我会把那个加进去的。

16250
11:31:59,956 --> 11:32:04,520
暂时我们只是

16251
11:32:02,240 --> 11:32:06,320
编译 我当时在和科斯瞎折腾

16252
11:32:04,520 --> 11:32:07,880
就像这是一个完全用于实验的文件

16253
11:32:06,320 --> 11:32:10,800
所以别好像觉得我就是那种……

16254
11:32:07,880 --> 11:32:15,360
和这个瞎折腾呢，呃，但我们

16255
11:32:10,800 --> 11:32:17,080
就像做科氏（Koss）的链接那样

16256
11:32:15,360 --> 11:32:20,000
像；喜欢

16257
11:32:17,080 --> 11:32:23,680
然后去运行这个，这样我们就能看到了

16258
11:32:20,000 --> 11:32:26,000
它 它也挺快的 嗯 是的

16259
11:32:23,680 --> 11:32:28,436
所以它进行训练，它在250这个条件下以相同方式进行训练

16260
11:32:26,000 --> 11:32:33,000
在隐藏层大小为 256 的情况下，这就是我们所采用的设置

16261
11:32:28,436 --> 11:32:34,520
或者实际上这是 1024 嗯 所以是 1024 以及

16262
11:32:33,000 --> 11:32:37,480
我们只给它设置了八的批量大小。

16263
11:32:34,520 --> 11:32:39,040
三个时代去学习，虽然嗯，这需要…… 

16264
11:32:37,480 --> 11:32:42,400
你知道它能达到大约90%

16265
11:32:39,040 --> 11:32:44,400
准确率，这仍然不错，嗯，但没错

16266
11:32:42,400 --> 11:32:46,080
在减少……在减少……嗯……在一个……

16267
11:32:44,400 --> 11:32:48,400
训练样本数量减少，所以我们

16268
11:32:46,080 --> 11:32:50,520
把批量大小设为八而不是四，所以

16269
11:32:48,400 --> 11:32:52,040
它变得 它变得更像 它变成了两倍

16270
11:32:50,520 --> 11:32:54,040
泛化的程度，因为它

16271
11:32:52,040 --> 11:32:56,596
批量大小翻倍了，但数量…… 

16272
11:32:54,040 --> 11:32:58,756
训练样本数量减半了，对吧

16273
11:32:56,596 --> 11:33:00,276
所以实际上也没那么糟糕，嗯

16274
11:32:58,756 --> 11:33:03,040
当你仔细想想，所以我们可以像

16275
11:33:00,276 --> 11:33:06,756
将这个环氧数提高到

16276
11:33:03,040 --> 11:33:09,320
六，然后你就会明白有多少…… 

16277
11:33:06,756 --> 11:33:12,320
这实际上有多大的差别

16278
11:33:09,320 --> 11:33:12,320
制作；使；让；使得；迫使；造就；使成为；使产生；引起；作出；做；假装；把…当作；使看上去像；整理；准备；制造；使变得；使处于某种状态

具体含义需结合具体语境确定。

16279
11:33:17,720 --> 11:33:22,320
所以我们可以看到它有点在上升

16280
11:33:19,436 --> 11:33:23,916
到 92，你知道这是最后一个阶段了

16281
11:33:22,320 --> 11:33:26,880
就是这样，当时就是顿悟了，就是这么回事

16282
11:33:23,916 --> 11:33:30,560
在那里做什么呢，嗯，但没错，所以我们进展到了……

16283
11:33:26,880 --> 11:33:33,160
大约92%，嗯，在某些方面接近90%到93% 

16284
11:33:30,560 --> 11:33:35,080
案例 嗯 但没错，那还不错 嗯

16285
11:33:33,160 --> 11:33:37,040
那是，你知道的，我知道大多数人类都是……

16286
11:33:35,080 --> 11:33:39,436
比那更好，但只有10秒钟的……

16287
11:33:37,040 --> 11:33:40,880
训练 我觉得这对……来说相当不错了

16288
11:33:39,436 --> 11:33:44,480
对世界一无所知于……（这里“at”后面似乎缺少内容）

16289
11:33:40,880 --> 11:33:46,276
这个神经网络表现不错

16290
11:33:44,480 --> 11:33:48,436
随着时间的推移，我打算添加

16291
11:33:46,276 --> 11:33:50,276
对此进行的优化，但既然你是

16292
11:33:48,436 --> 11:33:52,640
现在正在看这个，这可不……

16293
11:33:50,276 --> 11:33:54,240
当前仓库中存在……的版本

16294
11:33:52,640 --> 11:33:55,640
你现在正在观看的这门课程

16295
11:33:54,240 --> 11:33:57,956
无论那是从它出现之时起的五年之后

16296
11:33:55,640 --> 11:34:00,880
发布了，不管是两个月还是一个（此处“one”表意不明，可根据具体语境补充完整） 

16297
11:33:57,956 --> 11:34:03,436
哎呀，这就是当前的版本，那个…… （这里原句似乎没说完） 

16298
11:34:00,880 --> 11:34:05,800
你现在所看到的，所以这个

16299
11:34:03,436 --> 11:34:08,040
等我……的时候可能就不一样了

16300
11:34:05,800 --> 11:34:10,680
未来更新了 GitHub 仓库 呃

16301
11:34:08,040 --> 11:34:12,596
我确实打算维护这个并添加（内容）

16302
11:34:10,680 --> 11:34:14,116
你知道，另外可能有一个 V2 版本，带有…… 

16303
11:34:12,596 --> 11:34:16,840
就像你知道的，我会确保有个合适的名字（由于原英文表述不太符合常规语法，此翻译是根据大致语义推测） 

16304
11:34:14,116 --> 11:34:18,360
当然是所有东西，但呃，只是为了，仅仅是

16305
11:34:16,840 --> 11:34:20,800
进去然后再添加一些额外的东西

16306
11:34:18,360 --> 11:34:23,320
例如一些特征，就像我可能……我

16307
11:34:20,800 --> 11:34:27,160
可能会加上那种特别快的，呃

16308
11:34:23,320 --> 11:34:29,480
就像自定义的呃按行优先的内核，在那里我们

16309
11:34:27,160 --> 11:34:31,956
确实喜欢张量核心运算，所以 

16310
11:34:29,480 --> 11:34:35,916
warp 呃 扭曲矩阵乘法

16311
11:34:31,956 --> 11:34:39,160
以TF32精度累加W MMA

16312
11:34:35,916 --> 11:34:41,000
那东西真的很快，呃，然后随着…… 

16313
11:34:39,160 --> 11:34:44,000
嗯，你还可以进行另一项优化

16314
11:34:41,000 --> 11:34:46,200
结束了，正在使用 CUDA 流，所以记住

16315
11:34:44,000 --> 11:34:49,116
在……呃……在并发章节里，并且

16316
11:34:46,200 --> 11:34:50,840
而且在第五章里并没有

16317
11:34:49,116 --> 11:34:52,240
我们去了哪里，你知道的，越来越深入了

16318
11:34:50,840 --> 11:34:55,436
分解为内核以及整个CUDA

16319
11:34:52,240 --> 11:34:57,000
架构方面，你可以使用流来，呃

16320
11:34:55,436 --> 11:34:59,240
让事情并发运行，对，所以

16321
11:34:57,000 --> 11:35:02,276
你可能正在加载一些数据，呃，并且

16322
11:34:59,240 --> 11:35:04,840
然后你知道做那种类似向前的动作

16323
11:35:02,276 --> 11:35:08,720
你可以做个前滚翻之类的动作

16324
11:35:04,840 --> 11:35:10,480
嗯，一次前向传播和一次反向传播，以及

16325
11:35:08,720 --> 11:35:12,680
然后，在那件事发生的时候，你可以是

16326
11:35:10,480 --> 11:35:14,480
马上加载下一段数据

16327
11:35:12,680 --> 11:35:16,400
所以我是说，显然这就像一个

16328
11:35:14,480 --> 11:35:17,640
数字 数字分类 而你正在

16329
11:35:16,400 --> 11:35:19,720
不会有超棒的表现

16330
11:35:17,640 --> 11:35:21,680
在这里受到限制，没必要像……这样

16331
11:35:19,720 --> 11:35:23,800
拥有超高吞吐量的计算单元（CU）

16332
11:35:21,680 --> 11:35:26,680
你可以把这个东西弄到……（此处“up to”后内容缺失，原句表意不完整）

16333
11:35:23,800 --> 11:35:28,240
如果你……如果你做……能达到99%的准确率

16334
11:35:26,680 --> 11:35:30,800
了解更深层次的内容，你就会提升

16335
11:35:28,240 --> 11:35:32,240
隐藏尺寸并调整所有这些东西

16336
11:35:30,800 --> 11:35:34,116
让这个东西……是相当容易的

16337
11:35:32,240 --> 11:35:35,880
表现出色，但这是那种……

16338
11:35:34,116 --> 11:35:39,596
你想要练习的事情，这样当……的时候

16339
11:35:35,880 --> 11:35:41,520
你编写更复杂的内核

注：原文“more more comp complex”表述有误，推测正确表述可能是“more complex” 。 

16340
11:35:39,596 --> 11:35:43,880
一开始并没有那么难。

16341
11:35:41,520 --> 11:35:46,320
对，所以你知道有很多…… 

16342
11:35:43,880 --> 11:35:50,040
你可以进行的优化，你可以添加进去

16343
11:35:46,320 --> 11:35:50,040
呃，在这儿，哪儿是……

16344
11:35:50,916 --> 11:35:59,116
它在这个呃矩阵乘法内核中

16345
11:35:56,240 --> 11:36:00,720
在这里你可以用其他东西替换这个。

16346
11:35:59,116 --> 11:36:03,080
我现在不打算把它换掉。

16347
11:36:00,720 --> 11:36:04,436
因为那是你这类人会做的事（这里“kind”语义不太完整，可能需要更多上下文来精准翻译，按字面大致是这个意思） 

16348
11:36:03,080 --> 11:36:05,596
作为决赛的一部分想要做的事

16349
11:36:04,436 --> 11:36:07,756
规划你想做的事情

16350
11:36:05,596 --> 11:36:09,800
自主引导，然后可以深入其中

16351
11:36:07,756 --> 11:36:11,840
靠你自己，所以我的意思是你可以用这个

16352
11:36:09,800 --> 11:36:14,400
不过要是你想找点乐子的话

16353
11:36:11,840 --> 11:36:16,000
这里只是一个简单的哺乳动物内核

16354
11:36:14,400 --> 11:36:19,080
这里没有移项之类的操作

16355
11:36:16,000 --> 11:36:21,400
是R大调，你可以尽情享受它带来的乐趣。

16356
11:36:19,080 --> 11:36:23,880
呃，所以就是这样，随时可以更改。

16357
11:36:21,400 --> 11:36:28,240
这个内核可能会用张量进行实验。

16358
11:36:23,880 --> 11:36:29,916
核心业务
Windows媒体音频（WMA）相关内容
嗯，然后

16359
11:36:28,240 --> 11:36:33,080
你知道CUDA流之类的东西吗

16360
11:36:29,916 --> 11:36:36,400
那么可以随意使用呃，国立中央大学（这里推测“ncu”可能是“National Central University” ，需根据具体语境确定） 

16361
11:36:33,080 --> 11:36:39,276
侧写师 嗯，希望这能让（此处文本不完整，可能后面还有内容）

16362
11:36:36,400 --> 11:36:42,360
让你更好地了解如何去……

注：原文“you a better Insight”表述有误，可能想说“give you a better insight” 。这里按照合理推测来呈现大致意思。 

16363
11:36:39,276 --> 11:36:44,000
建立项目，以及呃，如何……以及如何

16364
11:36:42,360 --> 11:36:46,000
虽然他们……他们可能看起来像莱克斯在……（注：原英文文本可能存在表述不完整或有误的情况）

16365
11:36:44,000 --> 11:36:47,436
在外面，你可以稍微深入探究一下，然后

16366
11:36:46,000 --> 11:36:49,840
弄清楚正在发生什么

16367
11:36:47,436 --> 11:36:51,276
现在马上快速把所有的都过一遍

16368
11:36:49,840 --> 11:36:52,880
这些同样只是为了让一切都……

16369
11:36:51,276 --> 11:36:55,560
非常清楚，这些正在发挥作用

16370
11:36:52,880 --> 11:37:00,560
同样，嗯，我们会继续逐一进行编辑。

16371
11:36:55,560 --> 11:37:05,160
把它们追溯到你所知道的56（不太明确“56”具体所指），所以我们会这么做

16372
11:37:00,560 --> 11:37:09,640
256 那里有环氧树脂，我们会做大概三个，我们会

16373
11:37:05,160 --> 11:37:14,116
批量大小为四，学习率是 1 *

16374
11:37:09,640 --> 11:37:17,240
103，然后在这里我们将进行……

16375
11:37:14,116 --> 11:37:17,240
256 作为

16376
11:37:17,880 --> 11:37:24,160
嗯，呃，我们会降低批量大小。

16377
11:37:20,916 --> 11:37:25,956
在我们的……里面之前把那个放低一些

16378
11:37:24,160 --> 11:37:29,956
CPU 我们

16379
11:37:25,956 --> 11:37:29,956
呃，会把这个调到……

16380
11:37:31,916 --> 11:37:39,200
2506批量大小，四个轮次，第三个轮次

16381
11:37:35,000 --> 11:37:43,160
那挺好的，然后我们进入我们的 Python 环境

16382
11:37:39,200 --> 11:37:45,160
在这里设置呃火炬参考脚本

16383
11:37:43,160 --> 11:37:50,640
到 到

16384
11:37:45,160 --> 11:37:53,680
嗯，这已经是 256 了，呃，1×10⁻³批次

16385
11:37:50,640 --> 11:37:56,560
四号尺寸，我们看起来状态不错，然后我们出发

16386
11:37:53,680 --> 11:38:00,680
对C语言友好

16387
11:37:56,560 --> 11:38:04,640
剧本 我翻得有点过头了 26

16388
11:38:00,680 --> 11:38:07,640
不错的球棒，四号尺寸，太棒了，所以

16389
11:38:04,640 --> 11:38:12,080
现在，现在我们进入 Python 了，我来运行一下

16390
11:38:07,640 --> 11:38:12,080
Python 呃  PyTorch 参考资料

16391
11:38:17,040 --> 11:38:20,880
等一下，数据正在加载

16392
11:38:19,160 --> 11:38:24,560
在 Python 里有时候会花点时间

16393
11:38:20,880 --> 11:38:27,480
这并不是有史以来最优化的东西

16394
11:38:24,560 --> 11:38:30,800
所以；那么；因此

16395
11:38:27,480 --> 11:38:33,880
呃，太棒了，所以我们最终达到了大约 90%

16396
11:38:30,800 --> 11:38:37,436
最后准确率能达到90%，你知道的

16397
11:38:33,880 --> 11:38:40,040
89 这里在这种情况下我们有 87，所以我们

16398
11:38:37,436 --> 11:38:42,756
最后最终会得到大约90个，咱们（接着看情况之类，这里原文不完整推测大概语义） 

16399
11:38:40,040 --> 11:38:45,916
记住那个数字 90，然后我们就出发

16400
11:38:42,756 --> 11:38:49,240
到 Python，到 C

16401
11:38:45,916 --> 11:38:51,520
友好且我们

16402
11:38:49,240 --> 11:38:54,080
得到；获得；拿到

16403
11:38:51,520 --> 11:38:57,840
百分之八十七

16404
11:38:54,080 --> 11:39:04,040
89%，大约90%
我有……我有五把斧头在……

16405
11:38:57,840 --> 11:39:08,640
呃，是的，也大约有 90%。

16406
11:39:04,040 --> 11:39:11,160
91%，然后我们转到光盘界面

16407
11:39:08,640 --> 11:39:15,640
变得天真

注：“into naive”这样的表达不太符合常见用法，“into”通常是介词，后面一般接名词，而“naive”是形容词，常见可能是“become naive” 。不过按照你提供的内容，就直接逐词对应如上翻译。 

16408
11:39:11,160 --> 11:39:16,596
CPU，我们用GCC编译，涉及数学运算时我们会这样做

16409
11:39:15,640 --> 11:39:19,240
然后跑

16410
11:39:16,596 --> 11:39:21,436
这个在……（这里“this in”单独看表意不完整，可能是文本截取不完整或特定语境下表述）

16411
11:39:19,240 --> 11:39:23,276
这 这会需要（时间、精力等，因缺乏语境无法精准确定）

需要说明的是，原英文表述“the this”存在语法错误，可能会影响对句子确切含义的理解。 

16412
11:39:21,436 --> 11:39:25,680
一个；某一；任一；每一；用于前有形容词或后有短语的不可数名词前

注：“a”在不同语境中有不同含义，这里列出常见释义供参考。如果它在具体句子中，需结合上下文来更准确翻译。若有更完整内容，请提供以便我精准翻译。 

16413
11:39:23,276 --> 11:39:27,436
其次，嗯，它不习惯这样做。

16414
11:39:25,680 --> 11:39:29,480
很快 我知道NumPy可能有更多

16415
11:39:27,436 --> 11:39:33,040
专门的铣削程序，所以有很多的…… 

16416
11:39:29,480 --> 11:39:33,040
这仅仅是

16417
11:39:33,880 --> 11:39:39,880
呃，或者抱歉，嗯，对，对，NumPy 它

16418
11:39:38,276 --> 11:39:42,596
可能有更多专门的程序

16419
11:39:39,880 --> 11:39:47,160
所以在这里就像用原生 C 语言来做这件事一样

16420
11:39:42,596 --> 11:39:47,160
天真地认为这会花上一段时间

16421
11:39:48,596 --> 11:39:52,480
嗯，是的，所以我们可以看到

16422
11:39:52,720 --> 11:39:57,720
我们最终到了……（这里原英文表述不太完整准确，正常语境下这样的表达可能表意不明，但按要求进行了翻译） 

16423
11:39:58,756 --> 11:40:03,880
关于 试一试

注：“give it a” 一般后面会接 “try” 等词构成 “give it a try”（试一试），这里原文未完整表述，仅按字面逐词进行了翻译。 

16424
11:40:00,880 --> 11:40:07,596
第二，也非常接近 90%，所以

16425
11:40:03,880 --> 11:40:09,880
88.5，稍微差了点，嗯，但也就这样了

16426
11:40:07,596 --> 11:40:09,880
几乎；差不多

16427
11:40:10,800 --> 11:40:14,800
现在可以忽略不计

16428
11:40:18,040 --> 11:40:26,320
这句话存在语法错误，正确表达可能有偏差，勉强翻译为：
我们得……我要把光盘放进英伟达CUDA里做什么？ 

16429
11:40:21,756 --> 11:40:27,840
斜杠 GPU，然后我们将进行 nvcc 编译

16430
11:40:26,320 --> 11:40:31,160
没有；无；不用；不带有

16431
11:40:27,840 --> 11:40:33,596
科斯，看那个，它快了好多啊（注：原文“Coss onun”可能有误，推测可能是人名“科斯”相关表述） 

16432
11:40:31,160 --> 11:40:35,840
是

16433
11:40:33,596 --> 11:40:38,160
好了，现在总共是三个纪元，而且我们

16434
11:40:35,840 --> 11:40:39,596
最终以 90% 的繁荣收场 哦 怎么会 怎么会

16435
11:40:38,160 --> 11:40:42,116
方便之处在于

16436
11:40:39,596 --> 11:40:44,160
嘿，然后我们就出发，我们会走的

16437
11:40:42,116 --> 11:40:48,400
嗯……

16438
11:40:44,160 --> 11:40:50,436
房间文件

16439
11:40:48,400 --> 11:40:54,480
房间

16440
11:40:50,436 --> 11:40:55,800
和科斯（Koss）堆在一起，我刚刚加了这个（这里“the”后面内容缺失，翻译可能不太准确达意）

16441
11:40:54,480 --> 11:40:58,240
库布罗斯的东西，因为你可以添加你的（内容）

注：“kublos”可能是一个特定的名称，由于缺乏更多背景信息，这里直接保留未做处理；原英文句子表述不太完整和清晰，翻译尽量贴合原意。 

16442
11:40:55,800 --> 11:41:02,240
你提供的内容“own kublos sjam or like the LT matol in” 似乎并不是有明确意义的英文表达，可能存在拼写错误等问题，以下是按照字面直接翻译：
拥有库布罗斯·沙姆 或者 像 LT 马托尔在……里 

16443
11:40:58,240 --> 11:41:04,480
然后就玩玩那个，嗯，你来操作这个

16444
11:41:02,240 --> 11:41:06,720
速度大致相同，然后我们得到

16445
11:41:04,480 --> 11:41:09,360
大约也有90%，所以一切都……

16446
11:41:06,720 --> 11:41:11,116
达到了约90%，这很不错，表明

16447
11:41:09,360 --> 11:41:15,160
结果有点一致，就像

16448
11:41:11,116 --> 11:41:16,560
确保那一切都已解决。

16449
11:41:15,160 --> 11:41:17,916
如果你……就给自己一个鼓励吧

16450
11:41:16,560 --> 11:41:21,040
走到这一步，基本上就是……

16451
11:41:17,916 --> 11:41:22,916
课程结束啦，你做到了，干得好

16452
11:41:21,040 --> 11:41:25,560
嗯，我只是要快速回顾一些内容

16453
11:41:22,916 --> 11:41:26,916
小小的提示指向正确的方向

16454
11:41:25,560 --> 11:41:29,360
说明：如果你想继续进行……（原文似乎不完整）

16455
11:41:26,916 --> 11:41:31,596
这东西，嗯，你知道的，它可能

16456
11:41:29,360 --> 11:41:34,680
很难理解所有内容，所以我

16457
11:41:31,596 --> 11:41:37,436
如果你不愿意理解也没关系，但要是你愿意的话，呃

16458
11:41:34,680 --> 11:41:40,200
我为你准备了一些额外的资源，所以

16459
11:41:37,436 --> 11:41:42,240
在这边的 readme 文件里面我

16460
11:41:40,200 --> 11:41:44,360
有一个关于，你知道的，类似“什么是……”的板块

16461
11:41:42,240 --> 11:41:45,560
统一内存 内存架构

16462
11:41:44,360 --> 11:41:47,756
我原以为会是那种你知道的类型

16463
11:41:45,560 --> 11:41:49,200
有用的，而且你可能会感兴趣的

16464
11:41:47,756 --> 11:41:51,720
但主要是我想涵盖的内容

16465
11:41:49,200 --> 11:41:52,956
现在我要往这个里面添加东西了。

16466
11:41:51,720 --> 11:41:55,520
我打算在这个自述文件中添加内容，因为

16467
11:41:52,956 --> 11:41:57,320
嗯，在未来，呃，但有……

16468
11:41:55,520 --> 11:41:58,436
有一个“深入探究”板块，并且

16469
11:41:57,320 --> 11:42:00,400
这就好像如果你想拿走那个

16470
11:41:58,436 --> 11:42:03,400
多走一步，真正弄清楚你该如何

16471
11:42:00,400 --> 11:42:05,200
可以应用很深很深的，嗯，很深的…… 

16472
11:42:03,400 --> 11:42:06,880
优化与进步以及

16473
11:42:05,200 --> 11:42:09,160
无论你想在CUDA里怎么称呼它

16474
11:42:06,880 --> 11:42:10,560
还有 GPU 编程，呃，尤其是在……

16475
11:42:09,160 --> 11:42:12,840
深度学习 这就是 这就是你……（原英文文本不太完整和通顺，翻译只能尽量处理） 

16476
11:42:10,560 --> 11:42:14,360
可以这么做，有个东西叫做

16477
11:42:12,840 --> 11:42:17,880
量化，我即将开始讲解（这里原句“start”后面缺少内容，可能表述不太完整，但按要求翻译）

16478
11:42:14,360 --> 11:42:20,880
使用量化时就是你……就是……的情况

注：原英文文本表述不太符合常见语法规则，可能存在信息缺失或表达错误，此翻译仅基于字面内容进行。 

16479
11:42:17,880 --> 11:42:24,560
你从，呃，比如说……开始

16480
11:42:20,880 --> 11:42:26,916
FP32，然后你可以降至比如FP16或整数类型

16481
11:42:24,560 --> 11:42:28,680
8 你实际上可以下去，你

16482
11:42:26,916 --> 11:42:30,800
实际上可以从32位浮点数（FP32）转换为8位整数（INT 8），并且

16483
11:42:28,680 --> 11:42:32,916
你仍然可以拥有非常非常好的东西（此处根据语境可灵活调整“好的”具体所指） 

16484
11:42:30,800 --> 11:42:35,640
性能以及……的质量 （原文“and and”“of the of”表述有误，推测可能存在重复使用介词和连词的情况，这影响了正常语义表达，但按要求进行了翻译） 

16485
11:42:32,916 --> 11:42:37,200
模型的精度，没错，所以在那里

16486
11:42:35,640 --> 11:42:39,400
有一些你可以采取的具体方法。

16487
11:42:37,200 --> 11:42:42,720
围绕这个有一些窍门，但其中很多都……（原句不完整） 

16488
11:42:39,400 --> 11:42:44,480
与……有关，呃，你知道的，如果你的，如果你的

16489
11:42:42,720 --> 11:42:46,480
射程是有限的，所以如果你……如果你可以

16490
11:42:44,480 --> 11:42:50,880
像最多那样击打，比如说，我不想（这样）

16491
11:42:46,480 --> 11:42:52,116
知道10以及最小值为 - 10，然后你

16492
11:42:50,880 --> 11:42:53,956
实际上不必担心太多

16493
11:42:52,116 --> 11:42:56,000
那些指数值，对吧，如果你的

16494
11:42:53,956 --> 11:42:57,436
权重已初始化，并且你的

16495
11:42:56,000 --> 11:42:59,200
训练很稳定，一切正常（此处根据语境意译，原英文“nothing's going”表述不太完整准确，推测可能表达“没出什么问题”等意思） 

16496
11:42:57,436 --> 11:43:01,320
是高于还是低于 10，你不会（这么做）

注：由于原英文句子不太完整或表意不太清晰，此翻译是根据字面意思尽量连贯表达。 

16497
11:42:59,200 --> 11:43:02,360
得担心这件事 嗯 你可以

16498
11:43:01,320 --> 11:43:03,520
真的就把那个截下来当作你的……

16499
11:43:02,360 --> 11:43:06,520
精准无误，那将会是那个（此处表述不完整，可结合上下文理解准确意思） 

16500
11:43:03,520 --> 11:43:09,360
它最多能达到，嗯，那些大概会是这样

16501
11:43:06,520 --> 11:43:11,276
越稀疏的值，对吧，呃，所以

16502
11:43:09,360 --> 11:43:12,720
量化几乎就是一门艺术

16503
11:43:11,276 --> 11:43:14,640
做那件事，那就像是在进行…… 

16504
11:43:12,720 --> 11:43:16,160
精度非常高的数字

16505
11:43:14,640 --> 11:43:17,880
然后将它们向下移动到更低的位置

16506
11:43:16,160 --> 11:43:19,436
以极快的速度精准行事

16507
11:43:17,880 --> 11:43:21,916
和那些（事物）进行的操作，因为我能看出来

16508
11:43:19,436 --> 11:43:25,240
事实上，int 8 要快得多

16509
11:43:21,916 --> 11:43:27,400
比FP32（单精度浮点格式）好，而且不止好四倍

16510
11:43:25,240 --> 11:43:30,080
差距还挺大的，嗯，而且我们也看到了这点。

16511
11:43:27,400 --> 11:43:32,756
在郭诉库博斯 LT 案的部分，那里…… 

16512
11:43:30,080 --> 11:43:35,360
我们比较了 32 位和 16 位，然后

16513
11:43:32,756 --> 11:43:36,756
表现相当出色，所以

16514
11:43:35,360 --> 11:43:38,000
你可以想象 in8 会是什么样子

16515
11:43:36,756 --> 11:43:40,756
因为那里只有整数，没有 

16516
11:43:38,000 --> 11:43:43,400
需要担心的浮点数

16517
11:43:40,756 --> 11:43:46,436
没有小数点，对吧，只是

16518
11:43:43,400 --> 11:43:49,080
所以量化相当酷

16519
11:43:46,436 --> 11:43:52,240
它在当前的很多车型中都有大量应用，比如

16520
11:43:49,080 --> 11:43:54,840
呃，你知道的，比如说 GP4 或者像羊驼这类的（注：“llama”在人工智能领域可能也代指大语言模型“Llama” ）呃

16521
11:43:52,240 --> 11:43:57,000
羊驼 4050 亿参数模型，如果你听说过这个的话

16522
11:43:54,840 --> 11:43:59,720
呃，实际上很多这些都用到了呃

16523
11:43:57,000 --> 11:44:02,680
量化，没错，所以很有可能就像

16524
11:43:59,720 --> 11:44:04,436
bf16 或者像 fp8 之类的东西

16525
11:44:02,680 --> 11:44:06,640
其中一些甚至使用float 4，这是

16526
11:44:04,436 --> 11:44:08,200
酷，嗯，然后还有张量核心，它……

16527
11:44:06,640 --> 11:44:09,756
我已经说过了，但我做不到，我（这里原文表述可能不太完整和准确） 

16528
11:44:08,200 --> 11:44:11,880
不能忽略它，张量核心是

16529
11:44:09,756 --> 11:44:13,360
太好了，嗯，我只是没把它涵盖进去。 

16530
11:44:11,880 --> 11:44:15,956
这是因为这有点像

16531
11:44:13,360 --> 11:44:17,680
这有点像是一门入门课程，所以

16532
11:44:15,956 --> 11:44:20,520
这句话存在拼写错误，正确的可能是 “I try to pack as much as possible”，翻译为：
我尽量多打包一些东西。

16533
11:44:17,680 --> 11:44:22,596
换算成一定的小时数

16534
11:44:20,520 --> 11:44:24,160
你知道的，你可以消化并且

16535
11:44:22,596 --> 11:44:26,800
那么，如果你想继续那样做

16536
11:44:24,160 --> 11:44:30,116
显然也有张量课程，嗯

16537
11:44:26,800 --> 11:44:32,360
稀疏性是个不错的概念，所以稀疏性就是…… 

16538
11:44:30,116 --> 11:44:33,640
你可以把稀疏性理解为，嗯，如果我

16539
11:44:32,360 --> 11:44:35,320
有像一个……

（由于文本不完整，此翻译可能无法准确传达完整意思） 

16540
11:44:33,640 --> 11:44:41,436
数组；一系列；大批；排列；部署

16541
11:44:35,320 --> 11:44:43,756
嗯，比如说，会像是 0 0 0 0o 嗯

16542
11:44:41,436 --> 11:44:48,436
像7

16543
11:44:43,756 --> 11:44:51,560
0 0 z0 0，然后说在这边我们会

16544
11:44:48,436 --> 11:44:53,520
有，就像有个六，对，这是

16545
11:44:51,560 --> 11:44:57,756
这就是“稀疏”的含义，所以有一个…… 

16546
11:44:53,520 --> 11:44:59,640
一串零，偶尔还会有一个（什么，此处原句不完整表意不明）

16547
11:44:57,756 --> 11:45:01,956
就像代表一个的非常大的数字

16548
11:44:59,640 --> 11:45:03,680
很多，对吧，也许是基于它的位置

16549
11:45:01,956 --> 11:45:07,276
基于它相对于其他事物的位置

16550
11:45:03,680 --> 11:45:09,200
数字 嗯 但这里的想法是你

16551
11:45:07,276 --> 11:45:10,956
实际上可以把这些存储在小得多的（空间里）

16552
11:45:09,200 --> 11:45:13,276
记忆 所以这更像是一段记忆

16553
11:45:10,956 --> 11:45:15,200
并且不仅仅是像……那样去计算事物 

16554
11:45:13,276 --> 11:45:17,880
这就像你能从中获得什么样的品质呢

16555
11:45:15,200 --> 11:45:20,880
这真的是一场表演，那么我们……

16556
11:45:17,880 --> 11:45:22,276
实际上能做的是，我们可以说，嗯，你

16557
11:45:20,880 --> 11:45:23,800
要知道我们将有两个矩阵

16558
11:45:22,276 --> 11:45:26,480
一个带有数值，一个带有……（原文此处不完整）

16559
11:45:23,800 --> 11:45:30,160
坐标，所以我们出发

16560
11:45:26,480 --> 11:45:36,400
-7 和 6，然后是另一个矩阵

16561
11:45:30,160 --> 11:45:42,596
会是，嗯，你知道的，0、1、2、3、4，所以这个

16562
11:45:36,400 --> 11:45:45,160
会是，嗯，4，然后是5、6、7、8、9、10、11

16563
11:45:42,596 --> 11:45:48,916
12 12 13 14 15

16564
11:45:45,160 --> 11:45:52,000
16 没错，所以最终你会进行存储

16565
11:45:48,916 --> 11:45:54,360
只有四个整数，而不是，而不是

16566
11:45:52,000 --> 11:45:56,360
16个整数，然后你将所有数都进行缩减处理，缩减的幅度为 

16567
11:45:54,360 --> 11:45:58,640
现在有很多了，想象一下，当你扩大规模的时候

16568
11:45:56,360 --> 11:46:00,480
要了解二维或三维结构，你是……

（不过原英文句子“to you know 2D or 3D structures you're”表述有误，可能正确的表达是“To know 2D or 3D structures, you're...” ） 

16569
11:45:58,640 --> 11:46:02,000
节省了相当于……数量级的…… 

16570
11:46:00,480 --> 11:46:04,116
记忆，而且它真的真的……

16571
11:46:02,000 --> 11:46:05,916
效率很高，对吧。所以这是关于……的事情。 

16572
11:46:04,116 --> 11:46:07,276
想想当你使用Divi的时候，呃，当你……

16573
11:46:05,916 --> 11:46:09,956
你知道，设计高性能的

16574
11:46:07,276 --> 11:46:12,116
神经网络，呃，我们要大写吗？

16575
11:46:09,956 --> 11:46:13,720
在诸如稀疏性之类的事情上，没错，这可能会……

16576
11:46:12,116 --> 11:46:15,480
受到那些你认识的人的鼓舞

16577
11:46:13,720 --> 11:46:17,080
谁在外面编写神经网络？

16578
11:46:15,480 --> 11:46:19,400
所以当他们只是在写像字母 P 这样的内容时

16579
11:46:17,080 --> 11:46:20,596
如果它倾向于稀疏性，那么就是torch架构

16580
11:46:19,400 --> 11:46:22,840
如果它在那方面真的表现出色，并且

16581
11:46:20,596 --> 11:46:24,200
那就是它所依赖运行的东西，然后这是

16582
11:46:22,840 --> 11:46:25,956
这对你真的有好处，这成就了你的工作

16583
11:46:24,200 --> 11:46:28,240
简单，嗯，但稀疏性只是一个

16584
11:46:25,956 --> 11:46:29,640
绩效技巧 呃 你 你懂的 接受它吧

16585
11:46:28,240 --> 11:46:32,200
当你可以的时候

16586
11:46:29,640 --> 11:46:34,400
那么，有一本名为《库达》的书，作者是

16587
11:46:32,200 --> 11:46:38,520
例子；范例；榜样；楷模；典型；样品；样本；实例

16588
11:46:34,400 --> 11:46:40,160
所以，嗯，这实际上就是一本……书而已。 

16589
11:46:38,520 --> 11:46:42,436
通用目的 GPU 编程（第一部分） 

16590
11:46:40,160 --> 11:46:45,160
这是我通过谷歌搜索找到的，所以

16591
11:46:42,436 --> 11:46:47,276
这就像那些江户时代风格的网站之一

16592
11:46:45,160 --> 11:46:50,640
嗯，是的，它有……它有一堆

16593
11:46:47,276 --> 11:46:52,720
里面的东西，比如中央处理器（CPU）、图形处理器（GPU）的崛起

16594
11:46:50,640 --> 11:46:57,160
计算方面，我讲了很多内容。 

16595
11:46:52,720 --> 11:46:57,160
嗯，那么，C 语言与架构有什么关系呢？ 

16596
11:46:58,080 --> 11:47:02,800
嗯，很多很多我……（这里文本不完整，语义不太明确） 

16597
11:47:01,200 --> 11:47:04,400
说过，或者很多很多的很多的 

16598
11:47:02,800 --> 11:47:06,116
这里面重要的部分是

16599
11:47:04,400 --> 11:47:07,596
被压缩进这门课程里，对吧，所以

16600
11:47:06,116 --> 11:47:10,436
显然并非所有都是这样，而且我也没（做/是这样等，需结合上下文确定didn't后的内容）

16601
11:47:07,596 --> 11:47:14,040
我也没读过这本书，嗯，300

16602
11:47:10,436 --> 11:47:16,040
页数 所以我还没读过这本书

16603
11:47:14,040 --> 11:47:17,916
但你接下来会发现的很多内容

16604
11:47:16,040 --> 11:47:20,800
这里面将会，呃，被压缩。

16605
11:47:17,916 --> 11:47:20,800
深入到这个之中

16606
11:47:21,360 --> 11:47:26,520
课程；科目；过程；进程；一道菜；航向；航线

16607
11:47:23,560 --> 11:47:29,436
现在有西蒙写的另一篇文章

16608
11:47:26,520 --> 11:47:30,916
在人工智能公司“Anthropic”负责数据工作的人

16609
11:47:29,436 --> 11:47:33,276
深度的并行分布式训练

16610
11:47:30,916 --> 11:47:35,200
学习模型，以便其他……其他……

16611
11:47:33,276 --> 11:47:39,116
我们正在谈论的章节

16612
11:47:35,200 --> 11:47:41,240
呃……在处理……处理大型算法

16613
11:47:39,116 --> 11:47:44,436
在多个方面进行训练

16614
11:47:41,240 --> 11:47:46,680
这种情况

注：“instances this”并非一个常见的标准短语表达，从字面看推测可能想表达“this instances”这种“情况” ，如果结合上下文可能有更准确的译法。 

16615
11:47:44,436 --> 11:47:48,520
这就是它的一个很好的例子，所以

16616
11:47:46,680 --> 11:47:50,596
分布式训练是一个大问题

16617
11:47:48,520 --> 11:47:52,720
现在变得有点像数据中心了

16618
11:47:50,596 --> 11:47:54,520
将研究集中到一个紧凑的地方

注：原文语义可能不太完整，推测可能是想说把研究整合到一个集中的地方之类的意思，若有更准确的背景信息，翻译会更精准。 

16619
11:47:52,720 --> 11:47:56,320
围绕着它，并帮助减少那个你（此处原英文语义不太清晰完整）

16620
11:47:54,520 --> 11:48:00,956
知道 分散的 分布式的

16621
11:47:56,320 --> 11:48:03,200
方面，但当你拥有了你（此句英文可能表述有误，译文不太通顺） 

16622
11:48:00,956 --> 11:48:04,520
当你拥有一个大型数据中心时

16623
11:48:03,200 --> 11:48:06,756
一堆模型，而且你必须得到

16624
11:48:04,520 --> 11:48:08,040
让他们和一群一群的图形处理器交谈

16625
11:48:06,756 --> 11:48:09,640
抱歉，你得让他们进行管理员对话。

16626
11:48:08,040 --> 11:48:12,276
以某种方式对待彼此，这很难

16627
11:48:09,640 --> 11:48:13,680
对，所以这多少涉及到那个，嗯

16628
11:48:12,276 --> 11:48:15,596
我不打算把这整件事都过一遍

16629
11:48:13,680 --> 11:48:17,756
事情，但这确实会经历更多

16630
11:48:15,596 --> 11:48:21,040
性能优化，诸如此类的事情

16631
11:48:17,756 --> 11:48:24,240
全部规约，它们用于，嗯，那个…… 

16632
11:48:21,040 --> 11:48:26,360
实际的，呃，优化过程，所以你会

16633
11:48:24,240 --> 11:48:28,596
就像一个原子，W 会减少或者

16634
11:48:26,360 --> 11:48:31,680
嗯，有件事……

注：由于原文本身表述不太完整，这种翻译是在一定推测基础上尽量符合可能的语义。 

16635
11:48:28,596 --> 11:48:33,840
啊，是的，那里有很多…… 

16636
11:48:31,680 --> 11:48:35,436
考虑这里，但我甚至连一个（什么东西这里未明确）都没有

16637
11:48:33,840 --> 11:48:36,640
用于在上面进行训练的集群，所以我没办法（做这件事）

16638
11:48:35,436 --> 11:48:38,756
真的要教这个

16639
11:48:36,640 --> 11:48:41,520
部分；零件；角色；片段

注：“part”有多种释义，具体需结合上下文来确定最合适的意思。若你能提供更多相关内容，我可以给出更精准的翻译。 

16640
11:48:38,756 --> 11:48:43,360
嗯，我们回去，有几个项目。

16641
11:48:41,520 --> 11:48:46,360
我发现的是那些真的很酷

16642
11:48:43,360 --> 11:48:50,400
其中一个是MNUS Cuda或者CNN，抱歉，我

16643
11:48:46,360 --> 11:48:54,160
是米米斯·库达（这里不太明确“memis Cuda”具体是什么，可能是特定名称有误），就是这个，然后…… 

16644
11:48:50,400 --> 11:48:56,480
这就是真正的QNN，呃，QNN和库布罗斯

16645
11:48:54,160 --> 11:48:58,640
为了在nness数据集上进行此训练

16646
11:48:56,480 --> 11:49:01,276
我相信的用途

16647
11:48:58,640 --> 11:49:04,040
卷积，所以如果我们想要继续的话

16648
11:49:01,276 --> 11:49:06,400
没错，看呐，它就像个 V，视觉上的 V

16649
11:49:04,040 --> 11:49:10,116
工作室代码项目之类的，所以这个

16650
11:49:06,400 --> 11:49:13,436
如果你用的是 Windows 系统，可能会更容易些，但

16651
11:49:10,116 --> 11:49:18,200
比如，如果你进入，例如那个那个

16652
11:49:13,436 --> 11:49:18,200
网络 C++ 文件

16653
11:49:19,480 --> 11:49:24,116
嗯，是的，我不会去翻找了。

16654
11:49:22,680 --> 11:49:26,956
这个，但这是个很酷的小项目

16655
11:49:24,116 --> 11:49:28,720
我发现了嗯，你知道的，随便去做

16656
11:49:26,956 --> 11:49:30,200
无论你想用它做什么，但它会

16657
11:49:28,720 --> 11:49:33,720
它出现在了 GitHub 的搜索结果中

16658
11:49:30,200 --> 11:49:36,916
当我搜索“mist Cuda”时，那该怎么做呢？

16659
11:49:33,720 --> 11:49:39,160
你会那样做的。

16660
11:49:36,916 --> 11:49:40,200
嗯，我不打算开启CUDA模式，对吧

16661
11:49:39,160 --> 11:49:45,040
现在，我要留着最好的部分（暂不展示等，需结合语境理解）

16662
11:49:40,200 --> 11:49:48,160
对于上一个微广告而言，CUDA（英伟达推出的一种并行计算平台和编程模型）与……非常相似

16663
11:49:45,040 --> 11:49:49,360
嗯，由kpoy制作的微广告，所以这是个东西

16664
11:49:48,160 --> 11:49:51,880
我之前稍微提到过，而这就是…… 

16665
11:49:49,360 --> 11:49:54,000
你应该重点复习的内容

16666
11:49:51,880 --> 11:49:57,080
理解，呃，像……这样的事情是如何……的

16667
11:49:54,000 --> 11:50:00,200
反向传播起作用了，所以这相当……

16668
11:49:57,080 --> 11:50:02,560
很像一个像一个像一个派火炬

16669
11:50:00,200 --> 11:50:04,160
自动求导，但数值非常非常小，所以如果我们

16670
11:50:02,560 --> 11:50:07,160
实际上，进入它的文件，进入

16671
11:50:04,160 --> 11:50:10,240
在微电网文件本身中，有一个

16672
11:50:07,160 --> 11:50:12,320
它的引擎，所以那里的数值有点像

16673
11:50:10,240 --> 11:50:13,916
对它来说像是一种价值之类的东西，那么像什么呢

16674
11:50:12,320 --> 11:50:16,160
你可以进行的操作，比如点赞之类的操作

16675
11:50:13,916 --> 11:50:17,436
一个幂，所以当你输入双星号时

16676
11:50:16,160 --> 11:50:20,756
它将调用这个下划线

16677
11:50:17,436 --> 11:50:22,200
非核心功耗作为一种方法，对吧，嗯，然后

16678
11:50:20,756 --> 11:50:24,400
这个广告和你有的东西一模一样。

16679
11:50:22,200 --> 11:50:27,240
加号，并且那将涉及到所有的……（此英文表述不太符合常规语法，译文可能存在表意不精准的情况） 

16680
11:50:24,400 --> 11:50:29,756
添加方法，然后在引擎外部，你

16681
11:50:27,240 --> 11:50:31,320
有实际的神经网络代码文件 neural net.py，它是

16682
11:50:29,756 --> 11:50:32,956
这勾起了所有关于……的抽象概念

（注：原英文句子似乎不完整，“of”后面缺少内容。） 

16683
11:50:31,320 --> 11:50:34,680
就像从神经元过渡到神经层，所以你

16684
11:50:32,956 --> 11:50:36,200
有一个带有一组……的单个神经元

16685
11:50:34,680 --> 11:50:37,756
里面的砝码，你知道的，所有的砝码

16686
11:50:36,200 --> 11:50:39,680
不同的 X 值，然后点

16687
11:50:37,756 --> 11:50:43,360
产品，然后输出一个是……的（这里原文似乎不完整）

16688
11:50:39,680 --> 11:50:44,956
神经元 对，所以你就像在做……（原英文文本表述不太符合正常语法逻辑，翻译可能存在表意不精准情况） 

16689
11:50:43,360 --> 11:50:47,756
产品 在这里我们可以很清楚地看到

16690
11:50:44,956 --> 11:50:50,956
显然，然后呢，呃，你知道的

16691
11:50:47,756 --> 11:50:54,720
就像一个层面，在那里它会进行一系列的……

16692
11:50:50,956 --> 11:50:57,000
神经元，嗯，然后它会，接着



16693
11:50:54,720 --> 11:50:59,800
它就像一层神经元而已

16694
11:50:57,000 --> 11:51:01,720
就像那样，对，一堆长棍堆叠在一起

16695
11:50:59,800 --> 11:51:03,200
彼此叠加，然后是多层感知机

16696
11:51:01,720 --> 11:51:05,240
这就像那一层，但有……

16697
11:51:03,200 --> 11:51:09,080
……的倍数

16698
11:51:05,240 --> 11:51:11,800
那些，嗯，然后微核仁组织区（Micro Cuda 可能表述有误，推测是 Micro CUDAs，CUDAs 可能指 NVIDIA 的 CUDA 技术，但这里不太明确，暂时直译）仅仅是

16699
11:51:09,080 --> 11:51:15,276
但就在那里用 CUDA 实现了那个

16700
11:51:11,800 --> 11:51:17,000
肯定得有一个，所以，呃，没错，随便用。

16701
11:51:15,276 --> 11:51:18,880
尽情享受其中的乐趣，并且

16702
11:51:17,000 --> 11:51:20,400
一切都如它本该的样子。

16703
11:51:18,880 --> 11:51:23,400
更快些，这样你就可以有点像只……

16704
11:51:20,400 --> 11:51:25,680
在某种程度上理解事物，呃

16705
11:51:23,400 --> 11:51:28,320
计算统一设备

16706
11:51:25,680 --> 11:51:30,596
架构 这里有 你喜欢的操作

16707
11:51:28,320 --> 11:51:33,520
所有的CUDA操作，因此都转移到GPU上

16708
11:51:30,596 --> 11:51:34,756
就像马利克和梅姆复制一样，嗯，你懂的

16709
11:51:33,520 --> 11:51:37,880
它的界面非常简单，你可以

16710
11:51:34,756 --> 11:51:40,200
想象一下，PyTorch和这个类似，嗯

16711
11:51:37,880 --> 11:51:43,000
可能在性能上更优

16712
11:51:40,200 --> 11:51:45,000
但是，呃，你不想做像……这样的事

16713
11:51:43,000 --> 11:51:46,916
每次你进行Cuda M复制和恶意操作（注：原文“malic”可能拼写错误，推测可能是“malicious”相关意思）

不过原文句子表述不太符合正常语法逻辑，可能会影响准确理解和翻译。 

16714
11:51:45,000 --> 11:51:49,080
想移动某物或使用一件……

16715
11:51:46,916 --> 11:51:52,000
数据 你知道你有那种天真的想法

16716
11:51:49,080 --> 11:51:55,040
当然是核函数啦，嗯，双曲正切核函数

16717
11:51:52,000 --> 11:51:57,520
没错，所有这些，呃，但没错，所以有一堆…… 

16718
11:51:55,040 --> 11:51:58,840
人们正在做的酷炫项目，然后

16719
11:51:57,520 --> 11:52:01,916
还有另一个有趣的，我

16720
11:51:58,840 --> 11:52:05,360
找到了第二，第二好的那个，呃，显卡

16721
11:52:01,916 --> 11:52:07,940
谜题，这样你就可以使用qy库了

16722
11:52:05,360 --> 11:52:09,436
你提供的“go qy”可能并不是一个准确的英文表达，“qy”不是常见的英文单词，推测可能存在拼写错误。不过按字面勉强翻译为：去qy

16723
11:52:07,940 --> 11:52:13,000
[音乐]

16724
11:52:09,436 --> 11:52:14,880
Python 如此快速且开源，支持 GPU 加速

16725
11:52:13,000 --> 11:52:17,400
用 Python 进行计算，所以它是

16726
11:52:14,880 --> 11:52:19,400
本质上就是CUDA，但你可以使用它

16727
11:52:17,400 --> 11:52:23,480
通过一个 Python 接口，该接口是

16728
11:52:19,400 --> 11:52:26,480
太棒了 嗯 我们去 GitHub 找……（这里“for”后面内容缺失，句子不完整，但按照现有内容翻译）

16729
11:52:23,480 --> 11:52:26,480
这；这个

16730
11:52:27,200 --> 11:52:31,560
赛伊；赛（人名简称）；网络（Cyber 的缩写） 

16731
11:52:29,360 --> 11:52:33,956
没错，上面有很多很酷的东西。

16732
11:52:31,560 --> 11:52:35,596
你知道的，你只需导入它，然后

16733
11:52:33,956 --> 11:52:38,240
然后你可以，你可以做出类似的形状

16734
11:52:35,596 --> 11:52:41,080
之类的事情，然后用那个做点事情，嗯

16735
11:52:38,240 --> 11:52:43,000
类似于像P T或者nump这样的东西

16736
11:52:41,080 --> 11:52:44,916
没错，但是

16737
11:52:43,000 --> 11:52:47,956
是的，所以这些 GPU 谜题就像

16738
11:52:44,916 --> 11:52:50,080
经历着 嗯 你知道的 像在解决……之类的事情 

16739
11:52:47,956 --> 11:52:52,040
本质上是那些逻辑问题，在这些问题中我们

16740
11:52:50,080 --> 11:52:53,956
曾让一个克雷尔人帮我们解决了一个问题，但是

16741
11:52:52,040 --> 11:52:55,880
为一群不同的……做那件事

16742
11:52:53,956 --> 11:52:57,320
示例，所以不要只用矩阵

16743
11:52:55,880 --> 11:52:58,956
乘法，有很多种情况呢

16744
11:52:57,320 --> 11:53:01,560
这里面还有其他你可能……

16745
11:52:58,956 --> 11:53:04,560
找到……的乐趣

16746
11:53:01,560 --> 11:53:04,560
练习；实践；惯例；业务；诊所
从事（职业）；练习；实习
经常做；养成……的习惯；练习；实习；执业 

16747
11:53:04,720 --> 11:53:11,640
嗯，然后是我选定的最后一个

16748
11:53:07,400 --> 11:53:13,276
最后要提到的是CUDA模式，所以他们

16749
11:53:11,640 --> 11:53:16,480
他们有一个 他们有一个 G Hub 他们有一个

16750
11:53:13,276 --> 11:53:20,080
YouTube 频道，他们有一个 Discord（社交平台）。 

16751
11:53:16,480 --> 11:53:21,916
服务器，以及差不多一堆这样的东西

16752
11:53:20,080 --> 11:53:24,400
它实际上是不是包含了很多……

16753
11:53:21,916 --> 11:53:26,560
材料以及超出我在我的……中所涵盖的内容

16754
11:53:24,400 --> 11:53:29,400
当然，嗯，这一个更像是……（这里“course”可能有误，正确的可能是“of course” ，根据正常语义进行了补充性理解） 

16755
11:53:26,560 --> 11:53:31,480
视频辅助，但背后的社区

16756
11:53:29,400 --> 11:53:33,000
CUDA模式太惊人了，他们真的……

16757
11:53:31,480 --> 11:53:35,276
非常优秀的工程师和研究人员

16758
11:53:33,000 --> 11:53:36,840
嗯，在这里就是制作一些很酷的东西

16759
11:53:35,276 --> 11:53:40,080
人们一直都在超级积极地参与到（此处原文未完整，可能缺少内容）

16760
11:53:36,840 --> 11:53:41,480
这个社区是个很棒的地方，所以，呃

16761
11:53:40,080 --> 11:53:43,640
这是我绝对会做的事（这里原句不完整，推测可能是“这是我绝对会做的事”之类的意思） 

16762
11:53:41,480 --> 11:53:45,916
推荐你去看看

16763
11:53:43,640 --> 11:53:47,880
嗯，呃，是的，有很多……

16764
11:53:45,916 --> 11:53:50,080
像你看到的那样，章节一闪而过。 

16765
11:53:47,880 --> 11:53:55,436
注意，没错，他们拥有一切

16766
11:53:50,080 --> 11:53:59,880
无切割器的特里同（Triton） 嗯 融合内核数据

16767
11:53:55,436 --> 11:54:02,276
处理，嗯，张量核心，对吧，所以一个

16768
11:53:59,880 --> 11:54:04,080
一堆很酷的东西 嗯 我会推荐的

16769
11:54:02,276 --> 11:54:07,596
你加入他们的 Discord 服务器，你

16770
11:54:04,080 --> 11:54:09,596
能找到他们的 Discord 在哪里。

16771
11:54:07,596 --> 11:54:14,320
服务器

16772
11:54:09,596 --> 11:54:14,320
这儿 呃 对 有一堆

16773
11:54:15,400 --> 11:54:19,400
本质上是一堆很酷的呃 一堆

16774
11:54:18,000 --> 11:54:21,720
酷炫的团体之类的，感觉就像

16775
11:54:19,400 --> 11:54:25,560
初学者；新手

16776
11:54:21,720 --> 11:54:27,916
右侧区域 像今天这样超级活跃

16777
11:54:25,560 --> 11:54:31,520
最后一条消息就是最后一条消息

16778
11:54:27,916 --> 11:54:34,080
就好像连几个小时都不到

16779
11:54:31,520 --> 11:54:36,200
之前，而且那仅仅是一个频道，对吧，所以

16780
11:54:34,080 --> 11:54:37,880
你到这儿看看，最后一条消息是

16781
11:54:36,200 --> 11:54:41,276
比如1小时

16782
11:54:37,880 --> 11:54:43,080
之前，所以如果你喜欢这门课程，嗯，你

16783
11:54:41,276 --> 11:54:45,480
完全可以在其他平台上找到我

16784
11:54:43,080 --> 11:54:47,756
你可以在 YouTube 上找到我，你可以找到

16785
11:54:45,480 --> 11:54:49,560
在X（原推特）上能找到我
你可以在 

16786
11:54:47,756 --> 11:54:51,720
Discord（ Discord是一款通讯软件 ） 我有一个满是……的Discord服务器

16787
11:54:49,560 --> 11:54:53,160
很多人，呃，你知道有CUDA

16788
11:54:51,720 --> 11:54:54,680
也有这种模式，但我还有一台服务器

16789
11:54:53,160 --> 11:54:56,116
和一群人在一起，而且我们，你知道的

16790
11:54:54,680 --> 11:54:59,720
喜欢学习知识并与人合作，并且

16791
11:54:56,116 --> 11:55:01,480
所有那些，嗯，是的，在YouTube上找到我，找到

16792
11:54:59,720 --> 11:55:03,360
在领英上找我
在X平台（原推特）上找我
在……上找我

16793
11:55:01,480 --> 11:55:04,680
迪斯科，那些都将是要么……（此句不完整，可能导致语义不太清晰） 

16794
11:55:03,360 --> 11:55:06,040
描述中的链接，或者如果它们是……

16795
11:55:04,680 --> 11:55:09,756
描述里没有，它们会在……（这里文本未完整）

16796
11:55:06,040 --> 11:55:12,720
GitHub 仓库，嗯，在下面的描述里

16797
11:55:09,756 --> 11:55:12,720
感谢观看